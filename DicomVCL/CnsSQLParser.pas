// Generated by ParserBuilder @ 2012-5-19 ÉÏÎç 09:46:38

unit CnsSQLParser;

(* NOTE: Any changes made to this file may be overwritten when it gets regenerated
  from within ParserBuilder - unless you run the Delphi Import command*)


interface

uses
  Windows, Messages, SysUtils, Classes,CnsSQLData,db, CnsSQLScanner;


const
  maxT = 124;
  minErrDist = 2;  (* minimal distance (good tokens) between two errors *)
  setsize = 16;  (* sets are stored in 16 bits *)

type
  BITSET = set of 0..15;
  TSymbolSet = array [0..maxT div  setsize] of BITSET;

{PBGLOBAL}

{ENDPBGLOBAL}




type
  TCnsSQLParser = class(TCnsSQLScanner)
  private
    FSuccessful: boolean;
    {PBPRIVATE}
    fOutputStream : TStringStream;
 fCollectStart : Integer;
 fCollectLength : Integer;
 procedure Init;
 procedure Final;
 Function CalcLength : Integer;
 procedure SetStart;
 function CopySourceToCurrent : String;
 procedure WriteStr(S : string);
 Function GetLexString : String;
 procedure GetNumber (VAR Int : INTEGER);
 procedure ReportError(nr, line, col, pos: integer);
 procedure AddUserGroup(AName:string);
 function GetCnsString: string;

    {ENDPBPRIVATE}
    procedure PerformGet;
    procedure SynError(errNo: integer);
    procedure SemError(errNo: integer);
    function _In(var s: TSymbolSet; x: integer): boolean;
    procedure Expect(n: integer);
    procedure ExpectWeak(n, follow: integer);
    function WeakSeparator(n, syFol, repFol: integer): boolean;
    function GetSuccessful: boolean;
    Procedure SetSourceString(const Value : String);
        Procedure _FieldType (var k1:Integer;VAR s1: string);
    Procedure _FieldItem (AParent:TCnsCollect;VAR f1: TCnsFieldGroup);
    Procedure _UserItem (tu1: TCnsTableUser);
    Procedure _ColumnDefine (var mode1:Integer;var FieldName1:String);
    Procedure _AnalyzeItem (t1:TCnsTable);
    Procedure _QueryItem (t1:TCnsTable);
    Procedure _FieldCollection (AParent:TCnsCollect;var AFG:TCnsFieldGroup);
    Procedure _ReportItem (t1:TCnsTable);
    Procedure _UserGroup (t1:TCnsTable);
    Procedure _TableProfileItem (ts1 : TCnsProfileGroup);
    Procedure _TableStateItem (ts1 : TCnsStateGroup);
    Procedure _ViewItem;
    Procedure _TaskItem;
    Procedure _TableItem (AParent:TCnsCollect;var t1:TCnsTable);
    Procedure _ViewGroup;
    Procedure _TaskGroup;
    Procedure _TableGroup;
    Procedure _CnsSQL;


  protected
    {PBPROTECTED}
     
    {ENDPBPROTECTED}
  public
    {PBPUBLIC}
    GroupName:string;
SQLData:TCnsSQLData;
procedure SetSQLData(AValue:TCnsSQLData);

    {ENDPBPUBLIC}
    constructor Create;
    destructor Destroy; override;
    procedure Parse;
    procedure LexString(var Lex: string);
    procedure LexName(var Lex: string);
    procedure LookAheadString(var Lex: string);
    procedure LookAheadName(var Lex: string);
  published
    property Successful: boolean read GetSuccessful;
    Property SourceString : String write SetSourceString;
    {PBPUBLISHED}
    
    {ENDPBPUBLISHED}
  end;

implementation

var
  symSet: array [0..2] of TSymbolSet;
  errDist: integer;
  sym: integer;

{  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
   + For ParserBuilder's Delphi import function to work,        -
   + you must place your code in this Arbitrary Source section. -
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- }

{PBARBITRARYSOURCE}


Procedure TCnsSQLParser.SetStart;
Begin
 fCollectStart := nextPos+1;
End;

procedure TCnsSQLParser.Init;
begin
 fOutputStream.Size := 0;
 fCollectStart := 0;
 fCollectLength := 0;
 lst.Size := 0;
 if not assigned(SQLData) then
   Raise Exception.Create('SQLDData is Not assigned!' );
end;

procedure TCnsSQLParser.SetSQLData(AValue:TCnsSQLData);
begin
  SQLData := AValue;
end;

Function TCnsSQLParser.CopySourceToCurrent : String;
Begin
 CalcLength;
 Result := Copy(src.DataString, FCollectStart, fCollectLength);
End;

Function TCnsSQLParser.CalcLength : Integer;
Begin
 Result := nextPos - fCollectStart+1;
 fCollectLength := Result;
End;

procedure TCnsSQLParser.Final;
begin
 if Errors>0 then
  lst.WriteString('*** Errors ***' );
 lst.WriteString(fOutputStream.DataString);
 fOutputStream.Size := 0;
end;

procedure TCnsSQLParser.WriteStr(S : string);
begin
 fOutputStream.WriteBuffer(S[1],length(S));
end;

Function TCnsSQLParser.GetLexString : String;
Begin
 LexString(Result);
end;

Function TCnsSQLParser.GetCnsString : String;
Begin
 LexString(Result);
 Result := Copy(Result,2,Length(Result)-2);
end;

procedure TCnsSQLParser.ReportError(nr, line, col, pos: integer);
Var
 S, S1 : String;
 SL : TStringList;
begin
 Case nr of
 {$I  CnsSQL.err}
 End; // Case
 S := CRLF +S+CRLF + 'Line ' +IntToStr(line)+CRLF+'Column ' +
   IntToStr(col)+CRLF+'................................' +CRLF;
 SL := TStringList.Create;
 SL.Text := src.DataString;
 if Line<SL.Count then
   S1 := SL[Line-1]
  else S1 := '[End Of Source File]' ;
 SL.Free;
 Insert(' ERROR->' ,S1,Col-1);
 Inc(fErrors);
 WriteStr(S+S1+CRLF);
end;

PROCEDURE TCnsSQLParser.GetNumber (VAR Int : INTEGER);
VAR
  Error : INTEGER;
  S : STRING;
BEGIN
  GetString(pos, len, S);
  Int := 0;
  Val(S, Int, Error);
END;

procedure TCnsSQLParser.AddUserGroup(AName:string);
var
  i:Integer;
begin
  for i:=0 to SQLData.UserGroups.Count-1 do
  begin
    if AName=SQLData.UserGroups[i] then
      exit;
  end;
  SQLData.UserGroups.Add(AName);
end;




{ENDPBARBITRARYSOURCE}

 { TCnsSQLParser - Generated Methods below}
procedure TCnsSQLParser.SemError(errNo: integer);
begin
  if errDist >= minErrDist then
  begin
     Error(errNo, line, col, pos);
  end;
  errDist := 0;
end;

procedure TCnsSQLParser.SynError(errNo: integer);
begin
  if errDist >= minErrDist then
  begin
     Error(errNo, nextLine, nextCol, nextPos);
  end;
  errDist := 0;
end;

procedure TCnsSQLParser.PerformGet;
//var
//  s: string;
begin
  repeat
    Get(sym);
    if sym <= maxT then
      INC(errDist)
    else
    begin
     
    end;
  until sym <= maxT
  end;

function TCnsSQLParser._In(var s: TSymbolSet; x: integer): boolean;
begin
  _In := x mod setsize in s[x div setsize];
end;

function TCnsSQLParser.GetSuccessful: boolean;
begin
  FSuccessful := errors = 0;
  Result := FSuccessful;
end;

procedure TCnsSQLParser.Expect(n: integer);
begin
  if Sym = n then PerformGet
  else
    SynError(n);
end;

procedure TCnsSQLParser.ExpectWeak(n, follow: integer);
begin
  if Sym = n then PerformGet
  else
  begin
    SynError(n);
    while not _In(symSet[follow], Sym) do PerformGet;
  end
end;

function TCnsSQLParser.WeakSeparator(n, syFol, repFol: integer): boolean;
var
  s: TSymbolSet;
  i: integer;
begin
  if sym = n then
  begin
    PerformGet;
    WeakSeparator := True;
    EXIT;
  end
  else if _In(symSet[repFol], sym) then
  begin
    WeakSeparator := False;
    exit
  end
  else
  begin
    i := 0;
    while i <= maxT div setsize do
    begin
      s[i] := symSet[0, i] + symSet[syFol, i] + symSet[repFol, i];
      INC(i)
    end;
    SynError(n);
    while not _In(s, sym) do PerformGet;
    WeakSeparator := _In(symSet[syFol], sym)
  end
end;

procedure TCnsSQLParser.LexName(var Lex: string);
begin
    GetName(pos, len, Lex)
end;

procedure TCnsSQLParser.LexString(var Lex: string);
begin
   GetString(pos, len, Lex)
end;

procedure TCnsSQLParser.LookAheadName(var Lex: string);
begin
  GetName(nextPos, nextLen, Lex);
end;

procedure TCnsSQLParser.LookAheadString(var Lex: string);
begin
  GetString(nextPos, nextLen, Lex)
end;

Procedure TCnsSQLParser.SetSourceString(const Value : String);
Begin
  if (src<> NIL) then
    src.Free;
  src := TStringStream.Create(Value);
End;

Procedure TCnsSQLParser._FieldType (var k1:Integer;VAR s1: string);
  BEGIN
    CASE sym OF
      105 : BEGIN
        PerformGet;
        k1 := ord(ftSmallint) ;
        END;
      106 : BEGIN
        PerformGet;
        k1 := ord(ftInteger) ;
        END;
      107 : BEGIN
        PerformGet;
        k1 := ord(ftInteger) ;
        END;
      108 : BEGIN
        PerformGet;
        k1 := ord(ftInteger) ;
        END;
      109 : BEGIN
        PerformGet;
        k1 := ord(ftDate) ;
        END;
      110 : BEGIN
        PerformGet;
        k1 := ord(ftBoolean) ;
        END;
      111 : BEGIN
        PerformGet;
        k1 := ord(ftTime) ;
        END;
      112 : BEGIN
        PerformGet;
        k1 := ord(ftDateTime) ;
        END;
      113 : BEGIN
        PerformGet;
        k1 := ord(ftCurrency) ;
        END;
      114 : BEGIN
        PerformGet;
        k1 := ord(ftAutoInc) ;
        END;
      115 : BEGIN
        PerformGet;
        k1 := ord(ftBlob) ;
        IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(2);
          s1 := GetLexString ;
          IF (sym = 24) THEN BEGIN
            PerformGet;
            Expect(2);
            s1 := s1+ ',' +GetLexString ;
          END;
          Expect(17);
        END;
        END;
      116 : BEGIN
        PerformGet;
        k1 := ord(ftMemo) ;
        IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(2);
          s1 := GetLexString ;
          IF (sym = 24) THEN BEGIN
            PerformGet;
            Expect(2);
            s1 := s1+ ',' +GetLexString ;
          END;
          Expect(17);
        END;
        END;
      117 : BEGIN
        PerformGet;
        Expect(16);
        Expect(2);
        k1 := ord(ftString) ;
        s1 := GetLexString ;
        Expect(17);
        END;
      118 : BEGIN
        PerformGet;
        Expect(16);
        Expect(2);
        k1 := ord(ftString) ;
        s1 := GetLexString ;
        Expect(17);
        END;
      119 : BEGIN
        PerformGet;
        Expect(16);
        Expect(2);
        k1 := ord(ftString) ;
        s1 := GetLexString ;
        Expect(17);
        END;
      120 : BEGIN
        PerformGet;
        k1:=ord(ftFloat) ;
        IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(2);
          s1 := GetLexString ;
          IF (sym = 24) THEN BEGIN
            PerformGet;
            Expect(2);
            s1 := s1+ ',' +GetLexString ;
          END;
          Expect(17);
        END;
        END;
      121 : BEGIN
        PerformGet;
        k1:=ord(ftFloat) ;
        IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(2);
          s1 := GetLexString ;
          IF (sym = 24) THEN BEGIN
            PerformGet;
            Expect(2);
            s1 := s1+ ',' +GetLexString ;
          END;
          Expect(17);
        END;
        END;
      122 : BEGIN
        PerformGet;
        k1:=ord(ftFloat) ;
        IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(2);
          s1 := GetLexString ;
          IF (sym = 24) THEN BEGIN
            PerformGet;
            Expect(2);
            s1 := s1+ ',' +GetLexString ;
          END;
          Expect(17);
        END;
        END;
      123 : BEGIN
        PerformGet;
        k1 := ord(ftBytes) ;
        IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(2);
          s1 := GetLexString ;
          Expect(17);
        END;
        END;
    ELSE BEGIN SynError(125);
        END;
    END;
  END;

Procedure TCnsSQLParser._FieldItem (AParent:TCnsCollect;VAR f1: TCnsFieldGroup);
  var t2:TCnsTable ;
  BEGIN
    Expect(1);
    f1 := TCnsFieldGroup.Create(AParent,Uppercase(GetLexString)) ;
    f1.IsField := true ;
    _FieldType(f1.FieldType,f1.FieldLength);
    WHILE _In(symSet[1], sym) DO BEGIN
      CASE sym OF
        63 : BEGIN
          PerformGet;
          Expect(3);
          f1.DefaultValue := GetCnsString ;
          IF (sym = 73) THEN BEGIN
            PerformGet;
            Expect(36);
            Expect(1);
            f1.SetProfileRelate( 'DEFAULT' ,getCnsString,f1.DefaultValue)
          END;
          END;
        79 : BEGIN
          PerformGet;
          Expect(3);
          f1.Prompt1 := getCnsString ;
          END;
        80 : BEGIN
          PerformGet;
          Expect(3);
          f1.Prompt2 := getCnsString ;
          END;
        81 : BEGIN
          PerformGet;
          Expect(3);
          f1.Prompt3 := getCnsString ;
          END;
        82 : BEGIN
          PerformGet;
          Expect(3);
          f1.Prompt4 := getCnsString ;
          END;
        83 : BEGIN
          PerformGet;
          Expect(3);
          f1.Prompt5 := getCnsString ;
          END;
        84 : BEGIN
          PerformGet;
          Expect(3);
          f1.Prompt := getCnsString ;
          IF (sym = 73) THEN BEGIN
            PerformGet;
            Expect(36);
            Expect(1);
            f1.SetProfileRelate( 'PROMPT' ,getLexString,f1.Prompt)
          END;
          END;
        85 : BEGIN
          PerformGet;
          Expect(16);
          Expect(3);
          f1.SelectList.Add(GetCnsString) ;
          WHILE (sym = 24) DO BEGIN
            PerformGet;
            Expect(3);
            f1.SelectList.Add(GetCnsString) ;
          END;
          Expect(17);
          END;
        46 : BEGIN
          PerformGet;
          Expect(3);
          f1.Hint := getCnsString ;
          IF (sym = 73) THEN BEGIN
            PerformGet;
            Expect(36);
            Expect(1);
            f1.SetProfileRelate( 'HINT' ,getLexString,f1.Hint)
          END;
          END;
        86 : BEGIN
          PerformGet;
          Expect(87);
          f1.IsNull := false ;
          END;
        88, 89 : BEGIN
          IF (sym = 88) THEN BEGIN
            PerformGet;
          END ELSE IF (sym = 89) THEN BEGIN
            PerformGet;
          END ELSE BEGIN SynError(126);
          END;
          Expect(2);
          f1.MinString := GetLexString ;
          END;
        90, 91 : BEGIN
          IF (sym = 90) THEN BEGIN
            PerformGet;
          END ELSE IF (sym = 91) THEN BEGIN
            PerformGet;
          END ELSE BEGIN SynError(127);
          END;
          Expect(2);
          f1.MaxString := GetLexString ;
          END;
        92, 93, 94, 95 : BEGIN
          IF (sym = 92) THEN BEGIN
            PerformGet;
          END ELSE IF (sym = 93) THEN BEGIN
            PerformGet;
          END ELSE IF (sym = 94) THEN BEGIN
            PerformGet;
          END ELSE IF (sym = 95) THEN BEGIN
            PerformGet;
          END ELSE BEGIN SynError(128);
          END;
          f1.OrderString := GetLexString ;
          END;
        61 : BEGIN
          PerformGet;
          f1.ReadOnly := true ;
          END;
        96 : BEGIN
          PerformGet;
          Expect(1);
          f1.ControlType := getLexString ;
          END;
        97 : BEGIN
          PerformGet;
          Expect(3);
          f1.PictureMask := getCnsString ;
          END;
        98 : BEGIN
          PerformGet;
          Expect(48);
          f1.CanQuery := True ;
          END;
        99 : BEGIN
          PerformGet;
          Expect(100);
          f1.AutoRemmber := True ;
          END;
        101 : BEGIN
          PerformGet;
          f1.IsTreeField := True ;
          END;
        66 : BEGIN
          PerformGet;
          Expect(25);
          Expect(16);
          Expect(3);
          f1.ColorValues.Add(GetCnsString) ;
          Expect(15);
          Expect(1);
          f1.ColorStrings.Add(GetLexString) ;
          WHILE (sym = 24) DO BEGIN
            PerformGet;
            Expect(3);
            f1.ColorValues.Add(GetCnsString) ;
            Expect(15);
            Expect(1);
            f1.ColorStrings.Add(GetLexString) ;
          END;
          Expect(17);
          END;
        102 : BEGIN
          PerformGet;
          Expect(2);
          GetNumber(f1.WidthInGrid) ;
          END;
        103 : BEGIN
          PerformGet;
          Expect(2);
          GetNumber(f1.WidthInDialog) ;
          END;
        76 : BEGIN
          PerformGet;
          Expect(1);
          f1.LookupFieldName := UpperCase(GetLexString) ;
          Expect(77);
          IF (sym = 1) THEN BEGIN
            PerformGet;
            f1.LookupTable := GetLexString ;
          END ELSE IF (sym = 25) THEN BEGIN
            _TableItem(f1, t2);
            f1.LookupTable := t2.Name ;
            f1.LookupTableDefine := t2 ;
            t2.TableMode := cnsIsLookupTable ;
          END ELSE BEGIN SynError(129);
          END;
          IF (sym = 19) THEN BEGIN
            PerformGet;
            IF (sym = 78) THEN BEGIN
              PerformGet;
              f1.LookupWhere := 'PROFILE' ;
            END ELSE IF (sym = 3) THEN BEGIN
              PerformGet;
              f1.LookupWhere := GetCnsString ;
            END ELSE BEGIN SynError(130);
            END;
          END;
          Expect(23);
          Expect(3);
          f1.LookupBy := GetCnsString ;
          IF (sym = 104) THEN BEGIN
            PerformGet;
            Expect(3);
            f1.LookupDisplay := GetCnsString ;
          END;
          END;
      END;
    END;
  END;

Procedure TCnsSQLParser._UserItem (tu1: TCnsTableUser);
  var tup1:TCnsTableUserProfileState ;
  BEGIN
    IF (sym = 45) THEN BEGIN
      PerformGet;
    END ELSE IF (sym = 1) THEN BEGIN
      PerformGet;
    END ELSE BEGIN SynError(131);
    END;
    tup1 := TCnsTableUserProfileState.Create(tu1,GetLexString) ;
     tu1.Add(tup1) ;
    IF (sym = 16) THEN BEGIN
      PerformGet;
      Expect(1);
      tup1.AddState(GetLexString) ;
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        tup1.AddState(GetLexString) ;
      END;
      Expect(17);
    END;
  END;

Procedure TCnsSQLParser._ColumnDefine (var mode1:Integer;var FieldName1:String);
  BEGIN
    IF (sym = 71) THEN BEGIN
      PerformGet;
      Expect(23);
      Expect(1);
      mode1 := 0 ;
      FieldName1 := getLexString
    END ELSE IF (sym = 72) THEN BEGIN
      PerformGet;
      Expect(73);
      Expect(1);
      mode1 := 1 ;
      FieldName1 := getLexString
    END ELSE BEGIN SynError(132);
    END;
  END;

Procedure TCnsSQLParser._AnalyzeItem (t1:TCnsTable);
  var ca1:TCnsAnalyze ;
  BEGIN
    Expect(50);
    Expect(1);
    ca1 := TCnsAnalyze.Create(t1.Analyzes,getLexString) ;
    t1.Analyzes.Add(ca1) ;
    IF (sym = 44) THEN BEGIN
      PerformGet;
      IF (sym = 45) THEN BEGIN
        PerformGet;
      END ELSE IF (sym = 16) THEN BEGIN
        PerformGet;
        Expect(1);
        ca1.AddProfile(GetLexString) ;
        WHILE (sym = 24) DO BEGIN
          PerformGet;
          Expect(1);
          ca1.AddProfile(GetLexString) ;
        END;
        Expect(17);
      END ELSE BEGIN SynError(133);
      END;
    END;
    IF (sym = 51) THEN BEGIN
      PerformGet;
      _ColumnDefine(ca1.RowMode,ca1.RowField);
    END;
    IF (sym = 52) THEN BEGIN
      PerformGet;
      _ColumnDefine(ca1.ColMode,ca1.ColField);
    END;
    IF (sym = 53) OR (sym = 54) OR (sym = 55) THEN BEGIN
      IF (sym = 53) THEN BEGIN
        PerformGet;
        Expect(16);
        Expect(1);
        ca1.SumMode:=0 ;
        ca1.SumField:=GetLexString ;
        Expect(17);
      END ELSE IF (sym = 54) THEN BEGIN
        PerformGet;
        Expect(16);
        Expect(1);
        ca1.SumMode:=1 ;
        ca1.SumField:=GetLexString ;
        Expect(17);
      END ELSE BEGIN
        PerformGet;
        Expect(16);
        Expect(1);
        ca1.SumMode:=2 ;
        ca1.SumField:=GetLexString ;
        Expect(17);
      END;
    END;
    IF (sym = 56) THEN BEGIN
      PerformGet;
      Expect(23);
      Expect(16);
      Expect(1);
      ca1.RangeFields.Add(GetLexString) ;
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        ca1.RangeFields.Add(GetLexString) ;
      END;
      Expect(17);
    END;
  END;

Procedure TCnsSQLParser._QueryItem (t1:TCnsTable);
  var
   cq1:TCnsQuery ;
  BEGIN
    Expect(48);
    Expect(49);
    Expect(1);
    cq1 := TCnsQuery.Create(t1.Querys,getLexString) ;
    t1.Querys.Add(cq1) ;
    IF (sym = 44) THEN BEGIN
      PerformGet;
      IF (sym = 45) THEN BEGIN
        PerformGet;
      END ELSE IF (sym = 16) THEN BEGIN
        PerformGet;
        Expect(1);
        cq1.AddProfile(GetLexString) ;
        WHILE (sym = 24) DO BEGIN
          PerformGet;
          Expect(1);
          cq1.AddProfile(GetLexString) ;
        END;
        Expect(17);
      END ELSE BEGIN SynError(134);
      END;
    END;
    Expect(16);
    Expect(1);
    cq1.FieldNames.Add(getLexString) ;
    WHILE (sym = 24) DO BEGIN
      PerformGet;
      Expect(1);
      cq1.FieldNames.Add(getLexString) ;
    END;
    Expect(17);
  END;

Procedure TCnsSQLParser._FieldCollection (AParent:TCnsCollect;var AFG:TCnsFieldGroup);
  var f1:TCnsFieldGroup ;
   t2:TCnsTable ;
   td1:TCnsDetailTable ;
   tx1:TCnsCollect ;
  BEGIN
    Expect(71);
    Expect(1);
    AFG := TCnsFieldGroup.Create(AParent,GetLexString) ;
    afg.StartPos := line ;
    Expect(6);
    IF (sym = 1) THEN BEGIN
      _FieldItem(afg, f1);
      AFG.Add(f1) ;
    END ELSE IF (sym = 71) THEN BEGIN
      _FieldCollection(afg, f1);
      AFG.Add(f1) ;
    END ELSE BEGIN SynError(135);
    END;
    WHILE (sym = 24) DO BEGIN
      PerformGet;
      IF (sym = 1) THEN BEGIN
        _FieldItem(afg,f1);
        AFG.Add(f1) ;
      END ELSE IF (sym = 71) THEN BEGIN
        _FieldCollection(afg,f1);
        AFG.Add(f1) ;
      END ELSE BEGIN SynError(136);
      END;
    END;
    Expect(7);
    IF (sym = 74) THEN BEGIN
      PerformGet;
      Expect(58);
      Expect(1);
      afg.IsDetail := true ;
      afg.DetailTable := GetLexString ;
      afg.LookupTableDefine := SQLData.TableGroup.ItemByName[GetLexString] ;
      if assigned(afg.LookupTableDefine) then
      begin
      afg.LookupTableDefine.Clear ;
      afg.LookupTableDefine.Parent :=  afg ;
      end
      else
      begin
      afg.LookupTableDefine := TCnsTable.Create(afg,GetLexString) ;
      SQLData.TableGroup.Add(afg.LookupTableDefine) ;
      end;
      afg.LookupTableDefine.StartPos := afg.StartPos ;
      afg.LookupTableDefine.TableMode := cnsIsDetailTable ;
      tx1 := AParent ;
      while not(tx1 is TCnsTable) do tx1 := tx1.Parent ;
      td1 := TCnsDetailTable.Create(afg.LookupTableDefine,GetLexString) ;
      (tx1 as TCnsTable).Details.Add(td1) ;
      afg.LookupTableDefine.DatabaseName := (tx1 as TCnsTable).DatabaseName ;
      afg.LookupTableDefine.PluginName := (tx1 as TCnsTable).PluginName ;
      afg.LookupTableDefine.AutoCreate:= (tx1 as TCnsTable).AutoCreate ;
      afg.LookupTableDefine.GroupName := (tx1 as TCnsTable).GroupName ;
      afg.LookupTableDefine.FetchCount := 300 ;
      afg.MasterDetailLink := td1 ;
      Expect(16);
      Expect(1);
      afg.LookupTableDefine.TableName := GetLexString ;
      Expect(17);
      IF (sym = 44) THEN BEGIN
        PerformGet;
        IF (sym = 45) THEN BEGIN
          PerformGet;
        END ELSE IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(1);
          td1.AddProfile(GetLexString) ;
          WHILE (sym = 24) DO BEGIN
            PerformGet;
            Expect(1);
            td1.AddProfile(GetLexString) ;
          END;
          Expect(17);
        END ELSE BEGIN SynError(137);
        END;
      END;
      Expect(40);
      Expect(12);
      Expect(16);
      Expect(1);
      afg.LookupTableDefine.PrimaryKey.Add(UpperCase(GetLexString)) ;
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        afg.LookupTableDefine.PrimaryKey.Add(UpperCase(GetLexString)) ;
      END;
      Expect(17);
      IF (sym = 61) THEN BEGIN
        PerformGet;
        Expect(75);
        Expect(2);
        GetNumber(afg.LookupTableDefine.ReadOnlyState) ;
      END;
      Expect(60);
    END;
    IF (sym = 76) THEN BEGIN
      PerformGet;
      Expect(1);
      afg.LookupFieldName := UpperCase(GetLexString) ;
      Expect(15);
      Expect(1);
      afg.LookupFieldName := afg.LookupFieldName+ '=' +UpperCase(GetLexString) ;
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        afg.LookupFieldName := afg.LookupFieldName + ',' + UpperCase( GetLexString ) ;
        Expect(15);
        Expect(1);
        afg.LookupFieldName := afg.LookupFieldName+ '=' +UpperCase(GetLexString) ;
      END;
      Expect(77);
      IF (sym = 1) THEN BEGIN
        PerformGet;
        afg.LookupTable := GetLexString ;
      END ELSE IF (sym = 25) THEN BEGIN
        _TableItem(afg,t2);
        afg.LookupTable := t2.Name ;
        afg.LookupTableDefine := t2 ;
        t2.TableMode := cnsIsLookupTable ;
      END ELSE BEGIN SynError(138);
      END;
      IF (sym = 19) THEN BEGIN
        PerformGet;
        IF (sym = 78) THEN BEGIN
          PerformGet;
          afg.LookupWhere := 'PROFILE' ;
        END ELSE IF (sym = 3) THEN BEGIN
          PerformGet;
          afg.LookupWhere := GetLexString ;
        END ELSE BEGIN SynError(139);
        END;
      END;
    END;
  END;

Procedure TCnsSQLParser._ReportItem (t1:TCnsTable);
  var cr1:TCnsReport ;
  BEGIN
    Expect(1);
    cr1:=TCnsReport.Create(t1.Reports,GetLexString) ;
    t1.Reports.Add(cr1) ;
    IF (sym = 44) THEN BEGIN
      PerformGet;
      IF (sym = 45) THEN BEGIN
        PerformGet;
      END ELSE IF (sym = 16) THEN BEGIN
        PerformGet;
        Expect(1);
        cr1.AddProfile(GetLexString) ;
        WHILE (sym = 24) DO BEGIN
          PerformGet;
          Expect(1);
          cr1.AddProfile(GetLexString) ;
        END;
        Expect(17);
      END ELSE BEGIN SynError(140);
      END;
    END;
  END;

Procedure TCnsSQLParser._UserGroup (t1:TCnsTable);
  var tu1:TCnsTableUser ;
  BEGIN
    Expect(1);
    tu1 := TCnsTableUser.Create(t1.UserPermits,GetLexString) ;
    t1.UserPermits.Add(tu1) ;
    AddUserGroup(GetLexString) ;
    Expect(44);
    _UserItem(tu1);
    WHILE (sym = 24) DO BEGIN
      PerformGet;
      _UserItem(tu1);
    END;
    Expect(57);
  END;

Procedure TCnsSQLParser._TableProfileItem (ts1 : TCnsProfileGroup);
  var sg1:TCnsProfile ;
  BEGIN
    Expect(1);
    sg1:=TCnsprofile.Create(ts1,GetLexString) ;
    ts1.Add(sg1) ;
    IF (sym = 58) THEN BEGIN
      PerformGet;
      Expect(59);
      Expect(15);
      Expect(2);
      sg1.Value := StrToIntDef(GetLexString,1) ;
      Expect(60);
    END;
  END;

Procedure TCnsSQLParser._TableStateItem (ts1 : TCnsStateGroup);
  var sg1:TCnsState ;
  BEGIN
    Expect(1);
    sg1:=TCnsState.Create(ts1,GetLexString) ;
    ts1.Add(sg1) ;
    Expect(15);
    Expect(2);
    sg1.Value := StrToIntDef(GetLexString,1) ;
    IF (sym = 61) OR (sym = 62) THEN BEGIN
      IF (sym = 61) THEN BEGIN
        PerformGet;
      END ELSE BEGIN
        PerformGet;
        sg1.IsReadOnly := false ;
      END;
      IF (sym = 45) THEN BEGIN
        PerformGet;
        sg1.ReadOnlyFields.Add(Uppercase(GetLexString)) ;
      END ELSE IF (sym = 16) THEN BEGIN
        PerformGet;
        Expect(1);
        sg1.ReadOnlyFields.Add(Uppercase(GetLexString)) ;
        WHILE (sym = 24) DO BEGIN
          PerformGet;
          Expect(1);
          sg1.ReadOnlyFields.Add(UpperCase(GetLexString)) ;
        END;
        Expect(17);
      END ELSE BEGIN SynError(141);
      END;
    END;
    IF (sym = 63) THEN BEGIN
      PerformGet;
      Expect(16);
      Expect(1);
      Expect(15);
      Expect(3);
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        Expect(15);
        Expect(3);
      END;
      Expect(17);
    END;
    IF (sym = 64) OR (sym = 65) THEN BEGIN
      IF (sym = 64) THEN BEGIN
        PerformGet;
      END ELSE BEGIN
        PerformGet;
        sg1.IsDisableFunction := false ;
      END;
      IF (sym = 45) THEN BEGIN
        PerformGet;
        sg1.DisableFunctions.Add(Uppercase(GetLexString)) ;
      END ELSE IF (sym = 16) THEN BEGIN
        PerformGet;
        Expect(1);
        sg1.DisableFunctions.Add(GetLexString) ;
        WHILE (sym = 24) DO BEGIN
          PerformGet;
          Expect(1);
          sg1.DisableFunctions.Add(GetLexString) ;
        END;
        Expect(17);
      END ELSE BEGIN SynError(142);
      END;
    END;
    Expect(66);
    Expect(1);
    sg1.ColorString := GetLexString ;
    IF (sym = 67) THEN BEGIN
      PerformGet;
      IF (sym = 32) THEN BEGIN
        PerformGet;
        sg1.UserMode := 0 ;
        Expect(16);
        Expect(1);
        sg1.UserField := GetLexString ;
        Expect(17);
      END ELSE IF (sym = 68) THEN BEGIN
        PerformGet;
        sg1.UserMode := 1 ;
        Expect(16);
        Expect(1);
        sg1.UserField := GetLexString ;
        Expect(17);
      END ELSE IF (sym = 45) THEN BEGIN
        PerformGet;
        sg1.UserMode := 2 ;
      END ELSE BEGIN SynError(143);
      END;
    END;
    IF (sym = 69) THEN BEGIN
      PerformGet;
      Expect(23);
      Expect(1);
      sg1.OrderField := GetLexString ;
    END;
    IF (sym = 70) THEN BEGIN
      PerformGet;
      Expect(23);
      Expect(3);
      sg1.ClassByField := getCnsString ;
    END;
  END;

Procedure TCnsSQLParser._ViewItem;
  var v1:TCnsView ;
 //  str1:string ;
  BEGIN
    Expect(10);
    Expect(1);
    v1 := SQLData.ViewGroup.ItemByName[GetLexString] ;
    if assigned(v1) then
    begin
    v1.Clear ;
    end else
    begin
    v1 := TCnsView.Create(SQLData.ViewGroup,GetLexString) ;
    SQLData.ViewGroup.Add(v1) ;
    v1.GroupName := GroupName ;
    end;
    v1.StartPos := Line ;
    Expect(6);
    Expect(11);
    Expect(12);
    Expect(1);
    v1.PluginName := GetLexString ;
    Expect(13);
    Expect(12);
    Expect(1);
    v1.DatabaseName := GetLexString ;
    IF (sym = 14) THEN BEGIN
      PerformGet;
      Expect(15);
      Expect(2);
      v1.FetchCount := StrToIntDef(GetLexString,0) ;
    END;
    WHILE (sym = 1) DO BEGIN
      PerformGet;
      v1.FieldList.Add(GetLexString) ;
      Expect(16);
      Expect(1);
      v1.PromptList.Add(getLexString) ;
      Expect(17);
    END;
    Expect(18);
    Expect(3);
    v1.FromSQL := getCnsString ;
    Expect(19);
    Expect(3);
    v1.WhereSQL := GetCnsString ;
    Expect(7);
  END;

Procedure TCnsSQLParser._TaskItem;
  var task1:TCnsTask ;
   detail1:TCnsDetailTable ;
   str1:string ;
  BEGIN
    Expect(20);
    Expect(1);
    task1 := SQLData.TaskGroup.ItemByName[GetLexString] ;
    if assigned(task1) then
    task1.Clear
    else
    begin
    task1 := TCnsTask.Create(SQLData.TaskGroup,GetLexString) ;
    SQLData.taskGroup.Add(task1) ;
    task1.GroupName := GroupName ;
    end;
    task1.StartPos := Line ;
    Expect(6);
    Expect(11);
    Expect(12);
    Expect(1);
    task1.PluginName := GetLexString ;
    Expect(21);
    Expect(12);
    Expect(1);
    task1.DatasetName := getLexString ;
    WHILE (sym = 22) DO BEGIN
      PerformGet;
      Expect(16);
      Expect(1);
      detail1 := task1.AddDetailTable(GetLexString) ;
      Expect(23);
      Expect(1);
      str1:=GetLexString ;
      Expect(15);
      Expect(1);
      detail1.DetailLink.Add(str1+ '=' +GetLexString) ;
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        str1:=GetLexString ;
        Expect(15);
        Expect(1);
        detail1.DetailLink.Add(str1+ '=' +GetLexString) ;
      END;
      Expect(17);
    END;
    Expect(7);
  END;

Procedure TCnsSQLParser._TableItem (AParent:TCnsCollect;var t1:TCnsTable);
  var f1:TCnsFieldGroup ;
 //  cs1:TCnsState ;
   cp1:TCnsProgram ;
   temp1,temp2:string ;
  BEGIN
    Expect(25);
    Expect(1);
    t1 := SQLData.TableGroup.ItemByName[GetLexString] ;
    if assigned(t1) then
    begin
    t1.Clear ;
    t1.Parent := AParent ;
    end
    else
    begin
    t1 := TCnsTable.Create(AParent,GetLexString) ;
    SQLData.TableGroup.Add(t1) ;
    t1.GroupName := GroupName ;
    end;
    t1.StartPos := Line ;
    Expect(16);
    Expect(1);
    t1.TableName := UpperCase(GetLexString) ;
    Expect(17);
    Expect(6);
    Expect(11);
    Expect(12);
    Expect(1);
    t1.PluginName := GetLexString ;
    IF (sym = 26) THEN BEGIN
      PerformGet;
      t1.AutoCreate := true ;
    END;
    IF (sym = 27) THEN BEGIN
      PerformGet;
      t1.LogExec := true ;
    END;
    IF (sym = 28) THEN BEGIN
      PerformGet;
      t1.LogTime := true ;
    END;
    IF (sym = 29) THEN BEGIN
      PerformGet;
      t1.CountFirst := true ;
    END;
    IF (sym = 30) THEN BEGIN
      PerformGet;
      t1.NeedLock := true ;
    END;
    IF (sym = 31) THEN BEGIN
      PerformGet;
      t1.MultiDatabase:= true ;
    END;
    IF (sym = 32) THEN BEGIN
      PerformGet;
      Expect(12);
      Expect(1);
      t1.TableOwner := GetLexString ;
    END;
    Expect(13);
    Expect(12);
    Expect(1);
    t1.DatabaseName := GetLexString ;
    IF (sym = 14) THEN BEGIN
      PerformGet;
      Expect(15);
      Expect(2);
      t1.FetchCount := StrToIntDef(GetLexString,0) ;
    END;
    IF (sym = 33) THEN BEGIN
      PerformGet;
      Expect(1);
      t1.UserField := GetLexString ;
    END;
    IF (sym = 34) THEN BEGIN
      PerformGet;
      Expect(35);
      Expect(1);
      t1.States := TCnsStateGroup.Create(t1,UpperCase(getLexString)) ;
      Expect(6);
      _TableStateItem(t1.States);
      WHILE (sym = 1) DO BEGIN
        _TableStateItem(t1.States);
      END;
      Expect(7);
    END;
    IF (sym = 36) THEN BEGIN
      PerformGet;
      Expect(35);
      Expect(1);
      t1.ProfileFieldName := UpperCase(GetLexString) ;
      Expect(16);
      _TableProfileItem(t1.Profiles);
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        _TableProfileItem(t1.Profiles);
      END;
      Expect(17);
    END;
    Expect(37);
    Expect(6);
    WHILE (sym = 1) DO BEGIN
      _UserGroup(t1);
    END;
    Expect(7);
    Expect(38);
    Expect(6);
    WHILE (sym = 1) DO BEGIN
      _ReportItem(t1);
    END;
    Expect(7);
    _FieldCollection(t1, f1);
    t1.Add(f1) ;
    WHILE (sym = 71) DO BEGIN
      _FieldCollection(t1, f1);
      t1.Add(f1) ;
    END;
    Expect(39);
    Expect(40);
    Expect(16);
    Expect(1);
    t1.AddPrimaryKey(UpperCase(GetLexString)) ;
    WHILE (sym = 24) DO BEGIN
      PerformGet;
      Expect(1);
      t1.AddPrimaryKey(UpperCase(GetLexString)) ;
    END;
    Expect(17);
    WHILE (sym = 48) DO BEGIN
      _QueryItem(t1);
    END;
    IF (sym = 41) THEN BEGIN
      PerformGet;
      Expect(6);
      Expect(1);
      temp1 := GetLexString ;
      temp2 := 'NONE' ;
      Expect(16);
      IF (sym = 1) THEN BEGIN
        PerformGet;
        temp2 := GetLexString ;
      END;
      Expect(17);
      t1.AnalyzeFields.Values[temp1] := Temp2 ;
      WHILE (sym = 24) DO BEGIN
        PerformGet;
        Expect(1);
        temp1 := GetLexString ;
        temp2 := 'NONE' ;
        Expect(16);
        IF (sym = 1) THEN BEGIN
          PerformGet;
          temp2 := GetLexString ;
        END;
        Expect(17);
        t1.AnalyzeFields.Values[temp1] := Temp2 ;
      END;
      Expect(7);
    END;
    WHILE (sym = 50) DO BEGIN
      _AnalyzeItem(t1);
    END;
    IF (sym = 42) THEN BEGIN
      PerformGet;
      Expect(6);
      SetStart ;
      WHILE _In(symSet[2], sym) DO BEGIN
        PerformGet;
      END;
      t1.Trigger := CopySourceToCurrent ;
      Expect(7);
    END;
    WHILE (sym = 43) DO BEGIN
      PerformGet;
      Expect(1);
      cp1 := TCnsProgram.Create(t1.Scripts,getLexString) ;
      t1.Scripts.Add(cp1) ;
      IF (sym = 44) THEN BEGIN
        PerformGet;
        IF (sym = 45) THEN BEGIN
          PerformGet;
        END ELSE IF (sym = 16) THEN BEGIN
          PerformGet;
          Expect(1);
          cp1.AddProfile(GetLexString) ;
          WHILE (sym = 24) DO BEGIN
            PerformGet;
            Expect(1);
            cp1.AddProfile(GetLexString) ;
          END;
          Expect(17);
        END ELSE BEGIN SynError(144);
        END;
      END;
      Expect(6);
      Expect(40);
      Expect(12);
      Expect(3);
      cp1.ShortCut := GetCnsString ;
      Expect(46);
      Expect(12);
      Expect(3);
      cp1.Hint := GetCnsString ;
      IF (sym = 47) THEN BEGIN
        PerformGet;
        Expect(15);
        Expect(2);
        GetNumber(cp1.ImageIndex) ;
      END;
      Expect(7);
    END;
    Expect(7);
  END;

Procedure TCnsSQLParser._ViewGroup;
  BEGIN
    Expect(9);
    Expect(1);
    GroupName := getLexString ;
    Expect(6);
    WHILE (sym = 10) DO BEGIN
      _ViewItem;
    END;
    Expect(7);
  END;

Procedure TCnsSQLParser._TaskGroup;
  BEGIN
    Expect(8);
    Expect(1);
    GroupName := getLexString ;
    Expect(6);
    WHILE (sym = 20) DO BEGIN
      _TaskItem;
    END;
    Expect(7);
  END;

Procedure TCnsSQLParser._TableGroup;
  var t1:TCnsTable ;
  BEGIN
    Expect(5);
    Expect(1);
    GroupName := getLexString ;
    Expect(6);
    WHILE (sym = 25) DO BEGIN
      _TableItem(SQLData.TableGroup, t1);
    END;
    Expect(7);
  END;

Procedure TCnsSQLParser._CnsSQL;
  BEGIN
    Init ;
                                             SetStart ;
    WHILE (sym = 5) OR (sym = 8) OR (sym = 9) DO BEGIN
      IF (sym = 5) THEN BEGIN
        _TableGroup;
      END ELSE IF (sym = 8) THEN BEGIN
        _TaskGroup;
      END ELSE BEGIN
        _ViewGroup;
      END;
    END;
    Expect(0);
    Final ;
  END;



procedure TCnsSQLParser.Parse;
begin
  if (src.DataString = '') then 
    lst.WriteString('Empty Source')
    Else Begin    
   _Reset; PerformGet;
   _CnsSQL;

    End;
end;

destructor TCnsSQLParser.Destroy;
Begin
{PBDESTROY}
  fOutputStream.Free;

{ENDPBDESTROY}
  inherited;
End;

constructor TCnsSQLParser.Create;
begin
  inherited;
{PBCREATE}
  fOutputStream := TStringStream.Create('' );
 Error := ReportError;
 SQLData := nil;

{ENDPBCREATE}
  errDist := minErrDist;
   symSet[0, 0] := [0];
  symSet[0, 1] := [];
  symSet[0, 2] := [];
  symSet[0, 3] := [];
  symSet[0, 4] := [];
  symSet[0, 5] := [];
  symSet[0, 6] := [];
  symSet[0, 7] := [];
  symSet[1, 0] := [];
  symSet[1, 1] := [];
  symSet[1, 2] := [14];
  symSet[1, 3] := [13, 15];
  symSet[1, 4] := [2, 12, 15];
  symSet[1, 5] := [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[1, 6] := [0, 1, 2, 3, 5, 6, 7];
  symSet[1, 7] := [];
  symSet[2, 0] := [1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 1] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 2] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 3] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 4] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 5] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 6] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
  symSet[2, 7] := [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
end;


end.   (* CnsSQLParser *)
