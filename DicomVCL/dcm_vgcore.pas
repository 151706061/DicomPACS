unit dcm_vgcore;

{$I dcm_define.inc}
{$H+}
{$ALIGN ON}
{$MINENUMSIZE 4}
{.$DEFINE DARWINBUFFER}
{.$DEFINE UPDATERECT}
{.$DEFINE BOUNDS}
{.$DEFINE DRAWFOCUSED}

interface

uses
  {$IFDEF LINUX}
  cairo, cairoXlib, xlib, x, xutil, gtk2def, gtk2proc, gtk2, gdk2, gdk2x, gdk2pixbuf, glib2,
  pango,
  {$ENDIF}
  {$IFDEF DARWIN}
  MacOSAll,
  CarbonDef, CarbonPrivate, carboncanvas, CarbonProc, Maps,
  {$ENDIF}
  {$IFDEF WINDOWS}
  Windows, Messages, Registry, ShellAPI, ActiveX, CommCtrl, MultiMon,
  {$ENDIF}
  {$IFDEF FPC}
  LCLProc, LCLIntf, LCLType, LMessages, LResources,
  {$ELSE}
  Imm,
  {$ENDIF}
  Classes, Variants, SysUtils, Contnrs, Forms, Controls, Dialogs, Graphics,
  StdCtrls, DB, DBCtrls, ExtCtrls, Menus, Clipbrd, ActnList, ImgList;

{$HPPEMIT '#include <shldisp.h>'}
{!============================================================================!}

const

  GripSize = 3;
  RotSize = 10;

const
  InvalideCanvasState = $FFFFFFFF;

  { Global Settings }

var
  GlobalDisableFocusEffect: boolean = false;

  { *** }

  {$IFDEF NOVCL}
type
  TCloseAction = (caNone, caHide, caFree, caMinimize);
  TMouseButton = (mbLeft, mbRight, mbMiddle);
  TCursor = -32768..32767;
  TTabOrder = -1..32767;
  TModalResult = Low(Integer)..High(Integer);
  THelpContext = -MaxLongint..MaxLongint;
  THelpType = (htKeyword, htContext);

const
  crDefault = TCursor(0);
  crNone = TCursor(-1);
  crArrow = TCursor(-2);
  crCross = TCursor(-3);
  crIBeam = TCursor(-4);
  crSize = TCursor(-22);
  crSizeNESW = TCursor(-6);
  crSizeNS = TCursor(-7);
  crSizeNWSE = TCursor(-8);
  crSizeWE = TCursor(-9);
  crUpArrow = TCursor(-10);
  crHourGlass = TCursor(-11);
  crDrag = TCursor(-12);
  crNoDrop = TCursor(-13);
  crHSplit = TCursor(-14);
  crVSplit = TCursor(-15);
  crMultiDrag = TCursor(-16);
  crSQLWait = TCursor(-17);
  crNo = TCursor(-18);
  crAppStart = TCursor(-19);
  crHelp = TCursor(-20);
  crHandPoint = TCursor(-21);
  crSizeAll = TCursor(-22);

const
  mrNone = 0;
  mrOk = 1;
  mrCancel = 2;
  mrAbort = 3;
  mrRetry = 4;
  mrIgnore = 5;
  mrYes = 6;
  mrNo = 7;
  mrAll = 8;
  mrNoToAll = 9;
  mrYesToAll = 10;
  mrClose = 11;

const
  { Virtual Keys, Standard Set }
  {$EXTERNALSYM VK_LBUTTON}
  VK_LBUTTON = 1;
  {$EXTERNALSYM VK_RBUTTON}
  VK_RBUTTON = 2;
  {$EXTERNALSYM VK_CANCEL}
  VK_CANCEL = 3;
  {$EXTERNALSYM VK_MBUTTON}
  VK_MBUTTON = 4; { NOT contiguous with L & RBUTTON }
  {$EXTERNALSYM VK_BACK}
  VK_BACK = 8;
  {$EXTERNALSYM VK_TAB}
  VK_TAB = 9;
  {$EXTERNALSYM VK_CLEAR}
  VK_CLEAR = 12;
  {$EXTERNALSYM VK_RETURN}
  VK_RETURN = 13;
  {$EXTERNALSYM VK_SHIFT}
  VK_SHIFT = $10;
  {$EXTERNALSYM VK_CONTROL}
  VK_CONTROL = 17;
  {$EXTERNALSYM VK_MENU}
  VK_MENU = 18;
  {$EXTERNALSYM VK_PAUSE}
  VK_PAUSE = 19;
  {$EXTERNALSYM VK_CAPITAL}
  VK_CAPITAL = 20;
  {$EXTERNALSYM VK_KANA }
  VK_KANA = 21;
  {$EXTERNALSYM VK_HANGUL }
  VK_HANGUL = 21;
  {$EXTERNALSYM VK_JUNJA }
  VK_JUNJA = 23;
  {$EXTERNALSYM VK_FINAL }
  VK_FINAL = 24;
  {$EXTERNALSYM VK_HANJA }
  VK_HANJA = 25;
  {$EXTERNALSYM VK_KANJI }
  VK_KANJI = 25;
  {$EXTERNALSYM VK_CONVERT }
  VK_CONVERT = 28;
  {$EXTERNALSYM VK_NONCONVERT }
  VK_NONCONVERT = 29;
  {$EXTERNALSYM VK_ACCEPT }
  VK_ACCEPT = 30;
  {$EXTERNALSYM VK_MODECHANGE }
  VK_MODECHANGE = 31;
  {$EXTERNALSYM VK_ESCAPE}
  VK_ESCAPE = 27;
  {$EXTERNALSYM VK_SPACE}
  VK_SPACE = $20;
  {$EXTERNALSYM VK_PRIOR}
  VK_PRIOR = 33;
  {$EXTERNALSYM VK_NEXT}
  VK_NEXT = 34;
  {$EXTERNALSYM VK_END}
  VK_END = 35;
  {$EXTERNALSYM VK_HOME}
  VK_HOME = 36;
  {$EXTERNALSYM VK_LEFT}
  VK_LEFT = 37;
  {$EXTERNALSYM VK_UP}
  VK_UP = 38;
  {$EXTERNALSYM VK_RIGHT}
  VK_RIGHT = 39;
  {$EXTERNALSYM VK_DOWN}
  VK_DOWN = 40;
  {$EXTERNALSYM VK_SELECT}
  VK_SELECT = 41;
  {$EXTERNALSYM VK_PRINT}
  VK_PRINT = 42;
  {$EXTERNALSYM VK_EXECUTE}
  VK_EXECUTE = 43;
  {$EXTERNALSYM VK_SNAPSHOT}
  VK_SNAPSHOT = 44;
  {$EXTERNALSYM VK_INSERT}
  VK_INSERT = 45;
  {$EXTERNALSYM VK_DELETE}
  VK_DELETE = 46;
  {$EXTERNALSYM VK_HELP}
  VK_HELP = 47;
  { VK_0 thru VK_9 are the same as ASCII '0' thru '9' ($30 - $39) }
  { VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' ($41 - $5A) }
  {$EXTERNALSYM VK_LWIN}
  VK_LWIN = 91;
  {$EXTERNALSYM VK_RWIN}
  VK_RWIN = 92;
  {$EXTERNALSYM VK_APPS}
  VK_APPS = 93;
  {$EXTERNALSYM VK_NUMPAD0}
  VK_NUMPAD0 = 96;
  {$EXTERNALSYM VK_NUMPAD1}
  VK_NUMPAD1 = 97;
  {$EXTERNALSYM VK_NUMPAD2}
  VK_NUMPAD2 = 98;
  {$EXTERNALSYM VK_NUMPAD3}
  VK_NUMPAD3 = 99;
  {$EXTERNALSYM VK_NUMPAD4}
  VK_NUMPAD4 = 100;
  {$EXTERNALSYM VK_NUMPAD5}
  VK_NUMPAD5 = 101;
  {$EXTERNALSYM VK_NUMPAD6}
  VK_NUMPAD6 = 102;
  {$EXTERNALSYM VK_NUMPAD7}
  VK_NUMPAD7 = 103;
  {$EXTERNALSYM VK_NUMPAD8}
  VK_NUMPAD8 = 104;
  {$EXTERNALSYM VK_NUMPAD9}
  VK_NUMPAD9 = 105;
  {$EXTERNALSYM VK_MULTIPLY}
  VK_MULTIPLY = 106;
  {$EXTERNALSYM VK_ADD}
  VK_ADD = 107;
  {$EXTERNALSYM VK_SEPARATOR}
  VK_SEPARATOR = 108;
  {$EXTERNALSYM VK_SUBTRACT}
  VK_SUBTRACT = 109;
  {$EXTERNALSYM VK_DECIMAL}
  VK_DECIMAL = 110;
  {$EXTERNALSYM VK_DIVIDE}
  VK_DIVIDE = 111;
  {$EXTERNALSYM VK_F1}
  VK_F1 = 112;
  {$EXTERNALSYM VK_F2}
  VK_F2 = 113;
  {$EXTERNALSYM VK_F3}
  VK_F3 = 114;
  {$EXTERNALSYM VK_F4}
  VK_F4 = 115;
  {$EXTERNALSYM VK_F5}
  VK_F5 = 116;
  {$EXTERNALSYM VK_F6}
  VK_F6 = 117;
  {$EXTERNALSYM VK_F7}
  VK_F7 = 118;
  {$EXTERNALSYM VK_F8}
  VK_F8 = 119;
  {$EXTERNALSYM VK_F9}
  VK_F9 = 120;
  {$EXTERNALSYM VK_F10}
  VK_F10 = 121;
  {$EXTERNALSYM VK_F11}
  VK_F11 = 122;
  {$EXTERNALSYM VK_F12}
  VK_F12 = 123;
  {$EXTERNALSYM VK_F13}
  VK_F13 = 124;
  {$EXTERNALSYM VK_F14}
  VK_F14 = 125;
  {$EXTERNALSYM VK_F15}
  VK_F15 = 126;
  {$EXTERNALSYM VK_F16}
  VK_F16 = 127;
  {$EXTERNALSYM VK_F17}
  VK_F17 = 128;
  {$EXTERNALSYM VK_F18}
  VK_F18 = 129;
  {$EXTERNALSYM VK_F19}
  VK_F19 = 130;
  {$EXTERNALSYM VK_F20}
  VK_F20 = 131;
  {$EXTERNALSYM VK_F21}
  VK_F21 = 132;
  {$EXTERNALSYM VK_F22}
  VK_F22 = 133;
  {$EXTERNALSYM VK_F23}
  VK_F23 = 134;
  {$EXTERNALSYM VK_F24}
  VK_F24 = 135;
  {$EXTERNALSYM VK_NUMLOCK}
  VK_NUMLOCK = 144;
  {$EXTERNALSYM VK_SCROLL}
  VK_SCROLL = 145;
  { VK_L & VK_R - left and right Alt, Ctrl and Shift virtual keys.
    Used only as parameters to GetAsyncKeyState() and GetKeyState().
    No other API or message will distinguish left and right keys in this way. }
  {$EXTERNALSYM VK_LSHIFT}
  VK_LSHIFT = 160;
  {$EXTERNALSYM VK_RSHIFT}
  VK_RSHIFT = 161;
  {$EXTERNALSYM VK_LCONTROL}
  VK_LCONTROL = 162;
  {$EXTERNALSYM VK_RCONTROL}
  VK_RCONTROL = 163;
  {$EXTERNALSYM VK_LMENU}
  VK_LMENU = 164;
  {$EXTERNALSYM VK_RMENU}
  VK_RMENU = 165;
  {$EXTERNALSYM VK_PROCESSKEY}
  VK_PROCESSKEY = 229;
  {$EXTERNALSYM VK_ATTN}
  VK_ATTN = 246;
  {$EXTERNALSYM VK_CRSEL}
  VK_CRSEL = 247;
  {$EXTERNALSYM VK_EXSEL}
  VK_EXSEL = 248;
  {$EXTERNALSYM VK_EREOF}
  VK_EREOF = 249;
  {$EXTERNALSYM VK_PLAY}
  VK_PLAY = 250;
  {$EXTERNALSYM VK_ZOOM}
  VK_ZOOM = 251;
  {$EXTERNALSYM VK_NONAME}
  VK_NONAME = 252;
  {$EXTERNALSYM VK_PA1}
  VK_PA1 = 253;
  {$EXTERNALSYM VK_OEM_CLEAR}
  VK_OEM_CLEAR = 254;

  {$ENDIF}

  {$IFDEF WINDOWS}
const
  WM_ADDUPDATERECT = WM_USER + 123;
  {$ENDIF}

const

  vcAliceblue = '#FFF0F8FF';
  vcAntiquewhite = '#FFFAEBD7';
  vcAqua = '#FF00FFFF';
  vcAquamarine = '#FF7FFFD4';
  vcAzure = '#FFF0FFFF';
  vcBeige = '#FFF5F5DC';
  vcBisque = '#FFFFE4C4';
  vcBlack = '#FF000000';
  vcBlanchedalmond = '#FFFFEBCD';
  vcBlue = '#FF0000FF';
  vcBlueviolet = '#FF8A2BE2';
  vcBrown = '#FFA52A2A';
  vcBurlywood = '#FFDEB887';
  vcCadetblue = '#FF5F9EA0';
  vcChartreuse = '#FF7FFF00';
  vcChocolate = '#FFD2691E';
  vcCoral = '#FFFF7F50';
  vcCornflowerblue = '#FF6495ED';
  vcCornsilk = '#FFFFF8DC';
  vcCrimson = '#FFDC143C';
  vcCyan = '#FF00FFFF';
  vcDarkblue = '#FF00008B';
  vcDarkcyan = '#FF008B8B';
  vcDarkgoldenrod = '#FFB8860B';
  vcDarkgray = '#FFA9A9A9';
  vcDarkgreen = '#FF006400';
  vcDarkgrey = '#FFA9A9A9';
  vcDarkkhaki = '#FFBDB76B';
  vcDarkmagenta = '#FF8B008B';
  vcDarkolivegreen = '#FF556B2F';
  vcDarkorange = '#FFFF8C00';
  vcDarkorchid = '#FF9932CC';
  vcDarkred = '#FF8B0000';
  vcDarksalmon = '#FFE9967A';
  vcDarkseagreen = '#FF8FBC8F';
  vcDarkslateblue = '#FF483D8B';
  vcDarkslategray = '#FF2F4F4F';
  vcDarkslategrey = '#FF2F4F4F';
  vcDarkturquoise = '#FF00CED1';
  vcDarkviolet = '#FF9400D3';
  vcDeeppink = '#FFFF1493';
  vcDeepskyblue = '#FF00BFFF';
  vcDimgray = '#FF696969';
  vcDimgrey = '#FF696969';
  vcDodgerblue = '#FF1E90FF';
  vcFirebrick = '#FFB22222';
  vcFloralwhite = '#FFFFFAF0';
  vcForestgreen = '#FF228B22';
  vcFuchsia = '#FFFF00FF';
  vcGainsboro = '#FFDCDCDC';
  vcGhostwhite = '#FFF8F8FF';
  vcGold = '#FFFFD700';
  vcGoldenrod = '#FFDAA520';
  vcGray = '#FF808080';
  vcGreen = '#FF008000';
  vcGreenyellow = '#FFADFF2F';
  vcGrey = '#FF808080';
  vcHoneydew = '#FFF0FFF0';
  vcHotpink = '#FFFF69B4';
  vcIndianred = '#FFCD5C5C';
  vcIndigo = '#FF4B0082';
  vcIvory = '#FFFFFFF0';
  vcKhaki = '#FFF0E68C';
  vcLavender = '#FFE6E6FA';
  vcLavenderblush = '#FFFFF0F5';
  vcLawngreen = '#FF7CFC00';
  vcLemonchiffon = '#FFFFFACD';
  vcLightblue = '#FFADD8E6';
  vcLightcoral = '#FFF08080';
  vcLightcyan = '#FFE0FFFF';
  vcLightgoldenrodyellow = '#FFFAFAD2';
  vcLightgray = '#FFD3D3D3';
  vcLightgreen = '#FF90EE90';
  vcLightgrey = '#FFD3D3D3';
  vcLightpink = '#FFFFB6C1';
  vcLightsalmon = '#FFFFA07A';
  vcLightseagreen = '#FF20B2AA';
  vcLightskyblue = '#FF87CEFA';
  vcLightslategray = '#FF778899';
  vcLightslategrey = '#FF778899';
  vcLightsteelblue = '#FFB0C4DE';
  vcLightyellow = '#FFFFFFE0';
  vcLime = '#FF00FF00';
  vcLimegreen = '#FF32CD32';
  vcLinen = '#FFFAF0E6';
  vcMagenta = '#FFFF00FF';
  vcMaroon = '#FF800000';
  vcMediumaquamarine = '#FF66CDAA';
  vcMediumblue = '#FF0000CD';
  vcMediumorchid = '#FFBA55D3';
  vcMediumpurple = '#FF9370DB';
  vcMediumseagreen = '#FF3CB371';
  vcMediumslateblue = '#FF7B68EE';
  vcMediumspringgreen = '#FF00FA9A';
  vcMediumturquoise = '#FF48D1CC';
  vcMediumvioletred = '#FFC71585';
  vcMidnightblue = '#FF191970';
  vcMintcream = '#FFF5FFFA';
  vcMistyrose = '#FFFFE4E1';
  vcMoccasin = '#FFFFE4B5';
  vcNavajowhite = '#FFFFDEAD';
  vcNavy = '#FF000080';
  vcOldlace = '#FFFDF5E6';
  vcOlive = '#FF808000';
  vcOlivedrab = '#FF6B8E23';
  vcOrange = '#FFFFA500';
  vcOrangered = '#FFFF4500';
  vcOrchid = '#FFDA70D6';
  vcPalegoldenrod = '#FFEEE8AA';
  vcPalegreen = '#FF98FB98';
  vcPaleturquoise = '#FFAFEEEE';
  vcPalevioletred = '#FFDB7093';
  vcPapayawhip = '#FFFFEFD5';
  vcPeachpuff = '#FFFFDAB9';
  vcPeru = '#FFCD853F';
  vcPink = '#FFFFC0CB';
  vcPlum = '#FFDDA0DD';
  vcPowderblue = '#FFB0E0E6';
  vcPurple = '#FF800080';
  vcRed = '#FFFF0000';
  vcRosybrown = '#FFBC8F8F';
  vcRoyalblue = '#FF4169E1';
  vcSaddlebrown = '#FF8B4513';
  vcSalmon = '#FFFA8072';
  vcSandybrown = '#FFF4A460';
  vcSeagreen = '#FF2E8B57';
  vcSeashell = '#FFFFF5EE';
  vcSienna = '#FFA0522D';
  vcSilver = '#FFC0C0C0';
  vcSkyblue = '#FF87CEEB';
  vcSlateblue = '#FF6A5ACD';
  vcSlategray = '#FF708090';
  vcSlategrey = '#FF708090';
  vcSnow = '#FFFFFAFA';
  vcSpringgreen = '#FF00FF7F';
  vcSteelblue = '#FF4682B4';
  vcTan = '#FFD2B48C';
  vcTeal = '#FF008080';
  vcThistle = '#FFD8BFD8';
  vcTomato = '#FFFF6347';
  vcTurquoise = '#FF40E0D0';
  vcViolet = '#FFEE82EE';
  vcWheat = '#FFF5DEB3';
  vcWhite = '#FFFFFFFF';
  vcWhitesmoke = '#FFF5F5F5';
  vcYellow = '#FFFFFF00';
  vcYellowgreen = '#FF9ACD32';

type

  TvxColorIdent = record
    Name: string;
    Value: string;
  end;

const

  vgColorIdents: array[0..146] of TvxColorIdent = (
    (Name: 'Aliceblue'; Value: '#FFF0F8FF'),
    (Name: 'Antiquewhite'; Value: '#FFFAEBD7'),
    (Name: 'Aqua'; Value: '#FF00FFFF'),
    (Name: 'Aquamarine'; Value: '#FF7FFFD4'),
    (Name: 'Azure'; Value: '#FFF0FFFF'),
    (Name: 'Beige'; Value: '#FFF5F5DC'),
    (Name: 'Bisque'; Value: '#FFFFE4C4'),
    (Name: 'Black'; Value: '#FF000000'),
    (Name: 'Blanchedalmond'; Value: '#FFFFEBCD'),
    (Name: 'Blue'; Value: '#FF0000FF'),
    (Name: 'Blueviolet'; Value: '#FF8A2BE2'),
    (Name: 'Brown'; Value: '#FFA52A2A'),
    (Name: 'Burlywood'; Value: '#FFDEB887'),
    (Name: 'Cadetblue'; Value: '#FF5F9EA0'),
    (Name: 'Chartreuse'; Value: '#FF7FFF00'),
    (Name: 'Chocolate'; Value: '#FFD2691E'),
    (Name: 'Coral'; Value: '#FFFF7F50'),
    (Name: 'Cornflowerblue'; Value: '#FF6495ED'),
    (Name: 'Cornsilk'; Value: '#FFFFF8DC'),
    (Name: 'Crimson'; Value: '#FFDC143C'),
    (Name: 'Cyan'; Value: '#FF00FFFF'),
    (Name: 'Darkblue'; Value: '#FF00008B'),
    (Name: 'Darkcyan'; Value: '#FF008B8B'),
    (Name: 'Darkgoldenrod'; Value: '#FFB8860B'),
    (Name: 'Darkgray'; Value: '#FFA9A9A9'),
    (Name: 'Darkgreen'; Value: '#FF006400'),
    (Name: 'Darkgrey'; Value: '#FFA9A9A9'),
    (Name: 'Darkkhaki'; Value: '#FFBDB76B'),
    (Name: 'Darkmagenta'; Value: '#FF8B008B'),
    (Name: 'Darkolivegreen'; Value: '#FF556B2F'),
    (Name: 'Darkorange'; Value: '#FFFF8C00'),
    (Name: 'Darkorchid'; Value: '#FF9932CC'),
    (Name: 'Darkred'; Value: '#FF8B0000'),
    (Name: 'Darksalmon'; Value: '#FFE9967A'),
    (Name: 'Darkseagreen'; Value: '#FF8FBC8F'),
    (Name: 'Darkslateblue'; Value: '#FF483D8B'),
    (Name: 'Darkslategray'; Value: '#FF2F4F4F'),
    (Name: 'Darkslategrey'; Value: '#FF2F4F4F'),
    (Name: 'Darkturquoise'; Value: '#FF00CED1'),
    (Name: 'Darkviolet'; Value: '#FF9400D3'),
    (Name: 'Deeppink'; Value: '#FFFF1493'),
    (Name: 'Deepskyblue'; Value: '#FF00BFFF'),
    (Name: 'Dimgray'; Value: '#FF696969'),
    (Name: 'Dimgrey'; Value: '#FF696969'),
    (Name: 'Dodgerblue'; Value: '#FF1E90FF'),
    (Name: 'Firebrick'; Value: '#FFB22222'),
    (Name: 'Floralwhite'; Value: '#FFFFFAF0'),
    (Name: 'Forestgreen'; Value: '#FF228B22'),
    (Name: 'Fuchsia'; Value: '#FFFF00FF'),
    (Name: 'Gainsboro'; Value: '#FFDCDCDC'),
    (Name: 'Ghostwhite'; Value: '#FFF8F8FF'),
    (Name: 'Gold'; Value: '#FFFFD700'),
    (Name: 'Goldenrod'; Value: '#FFDAA520'),
    (Name: 'Gray'; Value: '#FF808080'),
    (Name: 'Green'; Value: '#FF008000'),
    (Name: 'Greenyellow'; Value: '#FFADFF2F'),
    (Name: 'Grey'; Value: '#FF808080'),
    (Name: 'Honeydew'; Value: '#FFF0FFF0'),
    (Name: 'Hotpink'; Value: '#FFFF69B4'),
    (Name: 'Indianred'; Value: '#FFCD5C5C'),
    (Name: 'Indigo'; Value: '#FF4B0082'),
    (Name: 'Ivory'; Value: '#FFFFFFF0'),
    (Name: 'Khaki'; Value: '#FFF0E68C'),
    (Name: 'Lavender'; Value: '#FFE6E6FA'),
    (Name: 'Lavenderblush'; Value: '#FFFFF0F5'),
    (Name: 'Lawngreen'; Value: '#FF7CFC00'),
    (Name: 'Lemonchiffon'; Value: '#FFFFFACD'),
    (Name: 'Lightblue'; Value: '#FFADD8E6'),
    (Name: 'Lightcoral'; Value: '#FFF08080'),
    (Name: 'Lightcyan'; Value: '#FFE0FFFF'),
    (Name: 'Lightgoldenrodyellow'; Value: '#FFFAFAD2'),
    (Name: 'Lightgray'; Value: '#FFD3D3D3'),
    (Name: 'Lightgreen'; Value: '#FF90EE90'),
    (Name: 'Lightgrey'; Value: '#FFD3D3D3'),
    (Name: 'Lightpink'; Value: '#FFFFB6C1'),
    (Name: 'Lightsalmon'; Value: '#FFFFA07A'),
    (Name: 'Lightseagreen'; Value: '#FF20B2AA'),
    (Name: 'Lightskyblue'; Value: '#FF87CEFA'),
    (Name: 'Lightslategray'; Value: '#FF778899'),
    (Name: 'Lightslategrey'; Value: '#FF778899'),
    (Name: 'Lightsteelblue'; Value: '#FFB0C4DE'),
    (Name: 'Lightyellow'; Value: '#FFFFFFE0'),
    (Name: 'Lime'; Value: '#FF00FF00'),
    (Name: 'Limegreen'; Value: '#FF32CD32'),
    (Name: 'Linen'; Value: '#FFFAF0E6'),
    (Name: 'Magenta'; Value: '#FFFF00FF'),
    (Name: 'Maroon'; Value: '#FF800000'),
    (Name: 'Mediumaquamarine'; Value: '#FF66CDAA'),
    (Name: 'Mediumblue'; Value: '#FF0000CD'),
    (Name: 'Mediumorchid'; Value: '#FFBA55D3'),
    (Name: 'Mediumpurple'; Value: '#FF9370DB'),
    (Name: 'Mediumseagreen'; Value: '#FF3CB371'),
    (Name: 'Mediumslateblue'; Value: '#FF7B68EE'),
    (Name: 'Mediumspringgreen'; Value: '#FF00FA9A'),
    (Name: 'Mediumturquoise'; Value: '#FF48D1CC'),
    (Name: 'Mediumvioletred'; Value: '#FFC71585'),
    (Name: 'Midnightblue'; Value: '#FF191970'),
    (Name: 'Mintcream'; Value: '#FFF5FFFA'),
    (Name: 'Mistyrose'; Value: '#FFFFE4E1'),
    (Name: 'Moccasin'; Value: '#FFFFE4B5'),
    (Name: 'Navajowhite'; Value: '#FFFFDEAD'),
    (Name: 'Navy'; Value: '#FF000080'),
    (Name: 'Oldlace'; Value: '#FFFDF5E6'),
    (Name: 'Olive'; Value: '#FF808000'),
    (Name: 'Olivedrab'; Value: '#FF6B8E23'),
    (Name: 'Orange'; Value: '#FFFFA500'),
    (Name: 'Orangered'; Value: '#FFFF4500'),
    (Name: 'Orchid'; Value: '#FFDA70D6'),
    (Name: 'Palegoldenrod'; Value: '#FFEEE8AA'),
    (Name: 'Palegreen'; Value: '#FF98FB98'),
    (Name: 'Paleturquoise'; Value: '#FFAFEEEE'),
    (Name: 'Palevioletred'; Value: '#FFDB7093'),
    (Name: 'Papayawhip'; Value: '#FFFFEFD5'),
    (Name: 'Peachpuff'; Value: '#FFFFDAB9'),
    (Name: 'Peru'; Value: '#FFCD853F'),
    (Name: 'Pink'; Value: '#FFFFC0CB'),
    (Name: 'Plum'; Value: '#FFDDA0DD'),
    (Name: 'Powderblue'; Value: '#FFB0E0E6'),
    (Name: 'Purple'; Value: '#FF800080'),
    (Name: 'Red'; Value: '#FFFF0000'),
    (Name: 'Rosybrown'; Value: '#FFBC8F8F'),
    (Name: 'Royalblue'; Value: '#FF4169E1'),
    (Name: 'Saddlebrown'; Value: '#FF8B4513'),
    (Name: 'Salmon'; Value: '#FFFA8072'),
    (Name: 'Sandybrown'; Value: '#FFF4A460'),
    (Name: 'Seagreen'; Value: '#FF2E8B57'),
    (Name: 'Seashell'; Value: '#FFFFF5EE'),
    (Name: 'Sienna'; Value: '#FFA0522D'),
    (Name: 'Silver'; Value: '#FFC0C0C0'),
    (Name: 'Skyblue'; Value: '#FF87CEEB'),
    (Name: 'Slateblue'; Value: '#FF6A5ACD'),
    (Name: 'Slategray'; Value: '#FF708090'),
    (Name: 'Slategrey'; Value: '#FF708090'),
    (Name: 'Snow'; Value: '#FFFFFAFA'),
    (Name: 'Springgreen'; Value: '#FF00FF7F'),
    (Name: 'Steelblue'; Value: '#FF4682B4'),
    (Name: 'Tan'; Value: '#FFD2B48C'),
    (Name: 'Teal'; Value: '#FF008080'),
    (Name: 'Thistle'; Value: '#FFD8BFD8'),
    (Name: 'Tomato'; Value: '#FFFF6347'),
    (Name: 'Turquoise'; Value: '#FF40E0D0'),
    (Name: 'Violet'; Value: '#FFEE82EE'),
    (Name: 'Wheat'; Value: '#FFF5DEB3'),
    (Name: 'White'; Value: '#FFFFFFFF'),
    (Name: 'Whitesmoke'; Value: '#FFF5F5F5'),
    (Name: 'Yellow'; Value: '#FFFFFF00'),
    (Name: 'Yellowgreen'; Value: '#FF9ACD32')
    );

type

  PIntArray = ^TIntArray;
  TIntArray = array[0..0] of integer;

  TvxPoint = packed record
    X: single;
    Y: single;
  end;

  TvxCubicBezier = array[0..3] of TvxPoint;

  PvgPointArray = ^TvxPointArray;
  TvxPointArray = array[0..0] of TvxPoint;

  TvxRect = packed record
    case Integer of
      0: (Left, Top, Right, Bottom: single);
      1: (TopLeft, BottomRight: TvxPoint);
  end;

  TvxCorner = (
    vgCornerTopLeft,
    vgCornerTopRight,
    vgCornerBottomLeft,
    vgCornerBottomRight
    );

  TvxCorners = set of TvxCorner;

  TvxCornerType = (
    vgCornerRound,
    vgCornerBevel,
    vgCornerInnerRound,
    vgCornerInnerLine
    );

  TvxSide = (
    vgSideTop,
    vgSideLeft,
    vgSideBottom,
    vgSideRight
    );

  TvxSides = set of TvxSide;

  TvxVectorArray = array[0..2] of single;

  TvxVector = packed record
    case integer of
      0: (
        V: TvxVectorArray;
        );
      1: (
        X: single;
        Y: single;
        W: single;
        );
  end;

  TvxMatrixArray = array[0..2] of TvxVector;

  TvxMatrix = packed record
    case integer of
      0: (
        M: TvxMatrixArray;
        );
      1: (m11, m12, m13: single;
        m21, m22, m23: single;
        m31, m32, m33: single);
  end;

  TvxPolygon = array of TvxPoint;
  PvgPolygon = ^TvxPolygon;

  {$IFNDEF NOVCL}
  {$IFDEF FPC}
  TMessage = TLMessage;
  {$ENDIF}
  {$ENDIF}

  PvgColor = ^TvxColor;
  TvxColor = cardinal;

  PvgColorRec = ^TvxColorRec;
  TvxColorRec = packed record
    case longword of
      0: (Color: TvxColor);
      2: (HiWord, LoWord: Word);
      {$IFDEF  FPC_BIG_ENDIAN}
      3: (A, R, G, B: System.Byte);
      {$ELSE}
      3: (B, G, R, A: System.Byte);
      {$ENDIF}
  end;

  PvgColorArray = ^TvxColorArray;
  TvxColorArray = array[0..4] of TvxColor;

  PvgColorRecArray = ^TvxColorRecArray;
  TvxColorRecArray = array[0..0] of TvxColorRec;

  PvgColor24 = ^TvxColor24;
  TvxColor24 = packed record
    case longword of
      0: (R, G, B: Byte);
  end;

  PvgColor24Array = ^TvxColor24Array;
  TvxColor24Array = array[0..0] of TvxColor24;

const
  cPI: Single = 3.141592654;
  cPIdiv180: Single = 0.017453292;
  c180divPI: Single = 57.29577951;
  c2PI: Single = 6.283185307;
  cPIdiv2: Single = 1.570796326;
  cPIdiv4: Single = 0.785398163;
  c3PIdiv4: Single = 2.35619449;
  cInv2PI: Single = 1 / 6.283185307;
  cInv360: Single = 1 / 360;
  c180: Single = 180;
  c360: Single = 360;
  cOneHalf: Single = 0.5;

  Epsilon: Single = 1E-40;
  IdentityMatrix: TvxMatrix = (m11: 1.0; m12: 0.0; m13: 0.0;
    m21: 0.0; m22: 1.0; m23: 0.0;
    m31: 0.0; m32: 0.0; m33: 1.0);
  ZeroMatrix: TvxMatrix = (m11: 0.0; m12: 0.0; m13: 0.0;
    m21: 0.0; m22: 0.0; m23: 0.0;
    m31: 0.0; m32: 0.0; m33: 0.0);
  NullRect: TvxRect = (Left: 0; Top: 0; Right: 0; Bottom: 0);

  AllCorners: TvxCorners = [
  vgCornerTopLeft,
    vgCornerTopRight,
    vgCornerBottomLeft,
    vgCornerBottomRight
    ];

  AllSides: TvxSides = [
  vgSideTop,
    vgSideLeft,
    vgSideBottom,
    vgSideRight
    ];

  ClosePolygon: TvxPoint = (X: $FFFF; Y: $FFFF);

  CurveKappa = 0.5522847498;
  CurveKappaInv = 1 - CurveKappa;

  vgWideNull = System.WideChar(#0);
  vgWideTabulator = System.WideChar(#9);
  vgWideSpace = System.WideChar(#32);
  vgWideCarriageReturn = System.WideChar($D);
  vgWideLineFeed = System.WideChar($A);
  vgWideVerticalTab = System.WideChar($B);
  vgWideFormFeed = System.WideChar($C);
  vgWideLineSeparator = System.WideChar($2028);
  vgWideParagraphSeparator = System.WideChar($2029);

  BOM_LSB_FIRST = System.WideChar($FEFF); // this is how the BOM appears on x86 systems when written by a x86 system
  BOM_MSB_FIRST = System.WideChar($FFFE);

type

  TvxCanvas = class;
  TvxObject = class;
  TvxVisualObject = class;
  TvxObjectClass = class of TvxObject;
  TvxResources = class;
  TvxControl = class;
  TvxBitmap = class;

  IvgScene = interface
    ['{16DB110E-DA7D-4e75-BC2D-999FA12E45F5}']
    procedure AddObject(AObject: TvxObject);
    procedure RemoveObject(AObject: TvxObject);
    procedure BeginDrag;
    procedure BeginResize;
    procedure AddUpdateRect(R: TvxRect);
    procedure InsertObject(const ClassName: string);
    function GetActiveControl: TvxControl;
    function GetDisableUpdate: boolean;
    procedure SetDisableUpdate(Value: boolean);
    function GetDesignTime: boolean;
    function GetCanvas: TvxCanvas;
    function GetRoot: TvxObject;
    function GetOwner: TComponent;
    function GetComponent: TComponent;
    function GetStyle: TvxResources;
    procedure SetStyle(const Value: TvxResources);
    function GetTransparency: boolean;
    procedure UpdateResource;
    procedure Notification(AComponent: TComponent; Operation: TOperation);
    function GetSelected: TvxVisualObject;
    function GetDesignPlaceObject: TvxVisualObject;
    function GetUpdateRectsCount: integer;
    function GetUpdateRect(const Index: integer): TvxRect;
    procedure SetCaptured(const Value: TvxVisualObject);
    function GetCaptured: TvxVisualObject;
    procedure SetFocused(const Value: TvxVisualObject);
    function GetFocused: TvxVisualObject;
    procedure SetDesignRoot(const Value: TvxVisualObject);
    function GetMousePos: TvxPoint;
    function LocalToScreen(const Point: TvxPoint): TvxPoint;
    procedure BeginVCLDrag(Source: TObject; ABitmap: TvxBitmap);
    procedure DoDesignSelect(AObject: TObject);
    function GetAnimatedCaret: boolean;
    { virtual keyboard }
    function ShowKeyboardForControl(AObject: TvxObject): boolean;
    function HideKeyboardForControl(AObject: TvxObject): boolean;
  end;

  {$I dcm_widestr.inc}

  TvxStorageItem = class(TPersistent)
  private
    FType: TValueType;
    FAsString: WideString;
    FAsFloat: single;
    FAsInteger: integer;
    FStream: TMemoryStream;
    procedure SetAsString(const Value: WideString);
    procedure SetAsFloat(const Value: single);
    procedure SetAsInteger(const Value: integer);
    procedure SetAsBool(const Value: boolean);
    function GetAsStream: TMemoryStream;
    function GetAsBool: boolean;
  protected
    procedure WriteItem(W: TWriter);
    procedure ReadItem(R: TReader);
  public
    constructor Create; virtual;
    destructor Destroy; override;
    property AsString: WideString read FAsString write SetAsString;
    property AsFloat: single read FAsFloat write SetAsFloat;
    property AsInteger: integer read FAsInteger write SetAsInteger;
    property AsBool: boolean read GetAsBool write SetAsBool;
    property AsStream: TMemoryStream read GetAsStream;
  end;

  TvxStorage = class(TPersistent)
  private
    FItems: TvxWideStrings;
    function GetValues(Name: string): TvxStorageItem;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure LoadFromStream(S: TStream);
    procedure SaveToStream(S: TStream);
    procedure LoadFromFile(FileName: string);
    procedure SaveToFile(FileName: string);
    property Values[Name: string]: TvxStorageItem read GetValues;
  end;

  TvxSplineVector = array[0..3] of single;
  TvxSplineMatrix = array of TvxSplineVector;

  TvxSpline = class(TObject)
  private
    matX, matY: TvxSplineMatrix;
    len: integer;
  public
    constructor Create(const Polygon: TvxPolygon);
    destructor Destroy; override;
    procedure SplineXY(const t: single; var X, Y: Single);
  end;

  TvxBounds = class(TPersistent)
  private
    FRight: single;
    FBottom: single;
    FTop: single;
    FLeft: single;
    FOnChange: TNotifyEvent;
    FDefaultValue: TvxRect;
    function GetRect: TvxRect;
    procedure SetRect(const Value: TvxRect);
    procedure SetBottom(const Value: single);
    procedure SetLeft(const Value: single);
    procedure SetRight(const Value: single);
    procedure SetTop(const Value: single);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadRect(Reader: TReader);
    procedure WriteRect(Writer: TWriter);
  public
    constructor Create(const ADefaultValue: TvxRect); virtual;
    procedure Assign(Source: TPersistent); override;
    function MarginRect(const R: TvxRect): TvxRect;
    function PaddinRect(const R: TvxRect): TvxRect;
    function Width: single;
    function Height: single;
    property Rect: TvxRect read GetRect write SetRect;
    property DefaultValue: TvxRect read FDefaultValue write FDefaultValue;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    function Empty: boolean;
    function MarginEmpty: boolean;
  published
    property Left: single read FLeft write SetLeft stored false;
    property Top: single read FTop write SetTop stored false;
    property Right: single read FRight write SetRight stored false;
    property Bottom: single read FBottom write SetBottom stored false;
  end;

  TvxPosition = class(TPersistent)
  private
    FOnChange: TNotifyEvent;
    FY: single;
    FX: single;
    FDefaultValue: TvxPoint;
    procedure SetPoint(const Value: TvxPoint);
    procedure SetX(const Value: single);
    procedure SetY(const Value: single);
    function GetPoint: TvxPoint;
    function GetVector: TvxVector;
    procedure SetVector(const Value: TvxVector);
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadPoint(Reader: TReader);
    procedure WritePoint(Writer: TWriter);
  public
    constructor Create(const ADefaultValue: TvxPoint); virtual;
    procedure Assign(Source: TPersistent); override;
    function Empty: boolean;
    procedure Reflect(const Normal: TvxVector);
    property Point: TvxPoint read GetPoint write SetPoint;
    property Vector: TvxVector read GetVector write SetVector;
    property DefaultValue: TvxPoint read FDefaultValue write FDefaultValue;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  published
    property X: single read FX write SetX stored false;
    property Y: single read FY write SetY stored false;
  end;

  TvxTransform = class(TPersistent)
  private
    FMatrix: TvxMatrix;
    FRotateAngle: single;
    FPosition: TvxPosition;
    FScale: TvxPosition;
    FSkew: TvxPosition;
    FRotateCenter: TvxPosition;
    FOnChanged: TNotifyEvent;
    procedure SetRotateAngle(const Value: single);
  protected
    procedure MatrixChanged(Sender: TObject);
    property Skew: TvxPosition read FSkew write FSkew;
  public
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property Matrix: TvxMatrix read FMatrix;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
  published
    property Position: TvxPosition read FPosition write FPosition;
    property Scale: TvxPosition read FScale write FScale;
    property RotateAngle: single read FRotateAngle write SetRotateAngle;
    property RotateCenter: TvxPosition read FRotateCenter write FRotateCenter;
  end;

  TvxGradientPoint = class(TCollectionItem)
  private
    FColor: TvxColor;
    FOffset: single;
    function GetColor: string;
    procedure SetColor(const Value: string);
  protected
  public
    {$IFDEF FPC}
    constructor Create(ACollection: TCollection); override;
    {$ELSE}
    constructor Create(Collection: TCollection); override;
    {$ENDIF}
    procedure Assign(Source: TPersistent); override;
    property IntColor: TvxColor read FColor write FColor;
  published
    property Color: string read GetColor write SetColor;
    property Offset: single read FOffset write FOffset;
  end;

  TvxGradientPoints = class(TCollection)
  private
    function GetPoint(Index: integer): TvxGradientPoint;
  public
    property Points[Index: integer]: TvxGradientPoint read GetPoint; default;
  end;

  TvxGradientStyle = (
    vgLinearGradient,
    vgRadialGradient
    );

  TvxGradient = class(TPersistent)
  private
    FPoints: TvxGradientPoints;
    FOnChanged: TNotifyEvent;
    FStartPosition: TvxPosition;
    FStopPosition: TvxPosition;
    FStyle: TvxGradientStyle;
    FRadialTransform: TvxTransform;
    procedure SetStartPosition(const Value: TvxPosition);
    procedure SetStopPosition(const Value: TvxPosition);
    procedure PositionChanged(Sender: TObject);
    procedure SetColor(const Value: string);
    procedure SetColor1(const Value: string);
    function isLinearStored: Boolean;
    procedure SetStyle(const Value: TvxGradientStyle);
    function isRadialStored: Boolean;
    procedure SetRadialTransform(const Value: TvxTransform);
  public
    constructor Create;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    procedure Change;
    function InterpolateColor(Offset: single): TvxColor;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
    property Color: string write SetColor;
    property Color1: string write SetColor1;
  published
    property Points: TvxGradientPoints read FPoints write FPoints;
    property Style: TvxGradientStyle read FStyle write SetStyle;
    { linear }
    property StartPosition: TvxPosition read FStartPosition write SetStartPosition stored isLinearStored;
    property StopPosition: TvxPosition read FStopPosition write SetStopPosition stored isLinearStored;
    { radial }
    property RadialTransform: TvxTransform read FRadialTransform write SetRadialTransform stored isRadialStored;
  end;

  TvxVisual = class(TPersistent)
  private
    FOnChanged: TNotifyEvent;
    FVisualObject: TvxVisualObject;
    procedure SetVisualObject(const Value: TvxVisualObject);
  public
    constructor Create;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
  published
    property VisualObject: TvxVisualObject read FVisualObject write SetVisualObject;
  end;

  TvxBrush = class;
  TvxBrushObject = class;

  TvxBrushResource = class(TPersistent)
  private
    FResource: TvxBrushObject;
    FResourceName: string;
    FOnChanged: TNotifyEvent;
    function GetBrush: TvxBrush;
    procedure SetResource(const Value: TvxBrushObject);
    function GetResourceName: string;
    procedure SetResourceName(const Value: string);
  public
    destructor Destroy; override;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
    procedure Assign(Source: TPersistent); override;
    property Brush: TvxBrush read GetBrush;
  published
    property Resource: TvxBrushObject read FResource write SetResource stored false;
    property ResourceName: string read GetResourceName write SetResourceName;
  end;

  TvxWrapMode = (
    vgWrapTile,
    vgWrapTileOriginal,
    vgWrapTileStretch
    );

  TvxBrushBitmap = class(TPersistent)
  private
    FOnChanged: TNotifyEvent;
    FBitmap: TvxBitmap;
    FWrapMode: TvxWrapMode;
    procedure SetWrapMode(const Value: TvxWrapMode);
    procedure SetBitmap(Value: TvxBitmap);
  public
    constructor Create;
    destructor Destroy; override;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
    procedure Assign(Source: TPersistent); override;
  published
    property Bitmap: TvxBitmap read FBitmap write SetBitmap;
    property WrapMode: TvxWrapMode read FWrapMode write SetWrapMode;
  end;

  TvxBrushStyle = (
    vgBrushNone,
    vgBrushSolid,
    vgBrushGradient,
    vgBrushBitmap,
    vgBrushResource,
    vgBrushVisual
    );

  TvxBrush = class(TPersistent)
  private
    FColor: TvxColor;
    FStyle: TvxBrushStyle;
    FOnChanged: TNotifyEvent;
    FGradient: TvxGradient;
    FVisual: TvxVisual;
    FDefaultStyle: TvxBrushStyle;
    FDefaultColor: TvxColor;
    FResource: TvxBrushResource;
    FBitmap: TvxBrushBitmap;
    procedure SetColor(const Value: string);
    procedure SetStyle(const Value: TvxBrushStyle);
    procedure SetGradient(const Value: TvxGradient);
    procedure SetVisual(const Value: TvxVisual);
    function isColorStored: Boolean;
    function isGradientStored: Boolean;
    function isVisualStored: Boolean;
    function GetColor: string;
    procedure SetSolidColor(const Value: TvxColor);
    function isStyleStored: Boolean;
    procedure SetResource(const Value: TvxBrushResource);
    function isResourceStored: Boolean;
    function isBitmapStored: Boolean;
    function GetSolidColor: TvxColor;
  protected
    procedure GradientChanged(Sender: TObject);
    procedure VisualChanged(Sender: TObject);
    procedure ResourceChanged(Sender: TObject);
    procedure BitmapChanged(Sender: TObject);
  public
    constructor Create(const ADefaultStyle: TvxBrushStyle; const ADefaultColor: TvxColor);
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
    property SolidColor: TvxColor read GetSolidColor write SetSolidColor;
    property DefaultColor: TvxColor read FDefaultColor write FDefaultColor;
    property DefaultStyle: TvxBrushStyle read FDefaultStyle write FDefaultStyle;
  published
    property Color: string read GetColor write SetColor stored isColorStored; // common
    property Bitmap: TvxBrushBitmap read FBitmap write FBitmap stored isBitmapStored;
    property Style: TvxBrushStyle read FStyle write SetStyle stored isStyleStored;
    property Gradient: TvxGradient read FGradient write SetGradient stored isGradientStored;
    property Resource: TvxBrushResource read FResource write SetResource stored isResourceStored;
    property Visual: TvxVisual read FVisual write SetVisual stored isVisualStored;
  end;

  TvxFontStyle = (
    vgFontRegular,
    vgFontBold,
    vgFontItalic,
    vgFontBoldItalic,
    vgFontUnderline,
    vgFontStrikeout
    );

  TvxFont = class(TPersistent)
  private
    FSize: single;
    FFamily: string;
    FStyle: TvxFontStyle;
    FClearType: boolean;
    FOnChanged: TNotifyEvent;
    procedure SetFamily(const Value: string);
    procedure SetSize(const Value: single);
    procedure SetStyle(const Value: TvxFontStyle);
    procedure SetClearType(const Value: boolean);
    function isFamilyStored: Boolean;
    function isSizeStored: Boolean;
    procedure AssignTo(Dest: TPersistent); override;
  public
    constructor Create;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
  published
    property ClearType: boolean read FClearType write SetClearType default true;
    property Family: string read FFamily write SetFamily stored isFamilyStored;
    property Size: single read FSize write SetSize stored isSizeStored;
    property Style: TvxFontStyle read FStyle write SetStyle default vgFontRegular;
  end;

  TvxTextAlign = (
    vgTextAlignCenter,
    vgTextAlignNear,
    vgTextAlignFar
    );

  TvxFilter = class(TPersistent)
  private
  public
  published
    class function GetFileTypes: string; virtual;
    class function GetImageSize(const AFileName: string): TvxPoint; virtual;
    function LoadFromFile(const AFileName: string; const Rotate: single; var Bitmap: TvxBitmap): boolean; virtual; abstract;
    function LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single; const UseEmbedded: boolean;
      var Bitmap: TvxBitmap): boolean; virtual; abstract;
    function SaveToFile(const AFileName: string; var Bitmap: TvxBitmap; const Params: string = ''): boolean; virtual; abstract;
    function LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean; virtual; abstract;
    { Format is a string from "jpeg,png,bmp" }
    function SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
      const Params: string = ''): boolean; virtual; abstract;
  end;
  TvxFilterClass = class of TvxFilter;

  { TvxBitmap }

  TvxBitmapObject = class;

  TvxBitmap = class({$IFDEF KS_COMPILER6_UP}TInterfacedPersistent, IStreamPersist{$ELSE}TPersistent{$ENDIF})
  private
    FBits: PvgColorArray;
    FHandle: THandle;
    FHeight: integer;
    FOnChange: TNotifyEvent;
    FWidth: integer;
    FNeedUpdate: boolean;
    FOnThreadLoaded: TNotifyEvent;
    FOnBitmapCreate: TNotifyEvent;
    FOnBitmapDestroy: TNotifyEvent;
    FResource: TvxBitmapObject;
    FResourceName: string;
    function GetCanvas: TvxCanvas;
    function GetScanline(y: integer): PvgColorArray;
    procedure SetHeight(const Value: integer);
    procedure SetWidth(const Value: integer);
    function GetPixels(x, y: integer): TvxColor;
    procedure SetResource(const Value: TvxBitmapObject);
    function GetResourceName: string;
    procedure SetResourceName(const Value: string);
    function GetBitmap: TvxBitmap;
  protected
    { internal }
    fData: TObject;
    fFont: TFont;
    FCanvas: TvxCanvas;
    FOnDestroyHandle: TNotifyEvent;
    procedure Recreate;
    procedure DoLoaded(Sender: TObject);
    { vcl }
    procedure AssignTo(Dest: TPersistent); override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadBitmap(Stream: TStream);
    procedure WriteBitmap(Stream: TStream);
  public
    constructor Create(const AWidth, AHeight: integer; const APremulAlpha: boolean = true); virtual;
    constructor CreateFromStream(const AStream: TStream); virtual;
    constructor CreateFromBitmapAndMask(const Bitmap, Mask: TvxBitmap);
    procedure Assign(Source: TPersistent); override;
    destructor Destroy; override;
    procedure SetSize(const AWidth, AHeight: integer);
    procedure Clear(const AColor: TvxColor = 0); virtual;
    procedure ClearRect(const ARect: TvxRect; const AColor: TvxColor = 0); virtual;
    procedure BitmapChanged;
    function IsEmpty: boolean;
    { vcl }
    {$IFNDEF NOVCL}
    procedure DrawGraphic(const Graphic: TGraphic; const DstRect: TvxRect);
    {$ENDIF}
    { Manipulation }
    //procedure TextOut(X, Y: Single; AText: string);

    procedure Rotate(const Angle: single);
    procedure FlipHorizontal;
    procedure FlipVertical;
    procedure InvertAlpha;
    procedure FillColor(const Color: TvxColor);
    { Mask }
    function CreateMask: PByteArray;
    procedure ApplyMask(const Mask: PByteArray; const DstX: integer = 0; const DstY: integer = 0);
    { Thumb }
    function CreateThumbnail(const Width, Height: integer): TvxBitmap;
    { I/O }
    procedure LoadFromFile(const AFileName: string; const Rotate: single = 0);
    procedure LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single;
      const UseEmbedded: boolean = true);
    procedure SaveToFile(const AFileName: string; const Params: string = '');
    procedure LoadFromStream(Stream: TStream);
    procedure SaveToStream(Stream: TStream);
    { }
    property Canvas: TvxCanvas read GetCanvas;
    property Pixels[x, y: integer]: TvxColor read GetPixels;
    property Scanline[y: integer]: PvgColorArray read GetScanline;
    property StartLine: PvgColorArray read FBits;
    property Width: integer read FWidth write SetWidth;
    property Height: integer read FHeight write SetHeight;
    { internal usage only }
    property Handle: THandle read FHandle write FHandle;

    property Font: TFont read fFont write fFont;

    property OnDestroyHandle: TNotifyEvent read FOnDestroyHandle write FOnDestroyHandle;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnThreadLoaded: TNotifyEvent read FOnThreadLoaded write FOnThreadLoaded;
    property OnBitmapCreate: TNotifyEvent read FOnBitmapCreate write FOnBitmapCreate;
    property OnBitmapDestroy: TNotifyEvent read FOnBitmapDestroy write FOnBitmapDestroy;
    property NeedUpdate: boolean read FNeedUpdate write FNeedUpdate;
    property ResourceBitmap: TvxBitmap read GetBitmap; // use to resoruce link

    property Data: TObject read fData write fData;
  published
    { This property allow to link bitmap with BitmapObject. }
    property Resource: TvxBitmapObject read FResource write SetResource stored false;
    { This property allow to link bitmap with BitmapObject by name. }
    property ResourceName: string read GetResourceName write SetResourceName;
  end;

  TvxPathPointKind = (
    vgPathPointMoveTo,
    vgPathPointLineTo,
    vgPathPointCurveTo,
    vgPathPointClose
    );

  TvxPathPoint = packed record
    Kind: TvxPathPointKind;
    Point: TvxPoint;
  end;

  TvxPathObject = class;

  TvxPathData = class(TPersistent)
  private
    FOnChanged: TNotifyEvent;
    FResource: TvxPathObject;
    FResourceName: string;
    FStartPoint: TvxPoint;
    function GetPathString: Ansistring;
    procedure SetPathString(const Value: Ansistring);
    procedure AddArcSvgPart(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single);
    procedure AddArcSvg(const P1, Radius: TvxPoint; Angle: single; const LargeFlag, SweepFlag: boolean; const P2: TvxPoint);
    procedure SetResource(const Value: TvxPathObject);
    function GetResourceName: string;
    procedure SetResourceName(const Value: string);
    function GetPath: TvxPathData;
  protected
    { vcl }
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadPath(Stream: TStream);
    procedure WritePath(Stream: TStream);
  public
    PathData: array of TvxPathPoint;
    constructor Create; virtual;
    destructor Destroy; override;
    procedure Assign(Source: TPersistent); override;
    property OnChanged: TNotifyEvent read FOnChanged write FOnChanged;
    { creation }
    function LastPoint: TvxPoint;
    procedure MoveTo(const P: TvxPoint);
    procedure MoveToRel(const P: TvxPoint);
    procedure LineTo(const P: TvxPoint);
    procedure LineToRel(const P: TvxPoint);
    procedure HLineTo(const x: single);
    procedure HLineToRel(const x: single);
    procedure VLineTo(const y: single);
    procedure VLineToRel(const y: single);
    procedure CurveTo(const ControlPoint1, ControlPoint2, EndPoint: TvxPoint);
    procedure CurveToRel(const ControlPoint1, ControlPoint2, EndPoint: TvxPoint);
    procedure SmoothCurveTo(const ControlPoint2, EndPoint: TvxPoint);
    procedure SmoothCurveToRel(const ControlPoint2, EndPoint: TvxPoint);
    procedure ClosePath;
    { shapes }
    procedure AddEllipse(const ARect: TvxRect);
    procedure AddRectangle(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners;
      const ACornerType: TvxCornerType = vgCornerRound);
    procedure AddArc(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single);
    { modification }
    procedure Clear;
    procedure Flatten(const Flatness: single = 0.25);
    procedure Scale(const scaleX, scaleY: single);
    procedure Offset(const dX, dY: single);
    procedure ApplyMatrix(const M: TvxMatrix);
    { params }
    function GetBounds: TvxRect;
    { convert }
    function FlattenToPolygon(var Polygon: TvxPolygon; const Flatness: single = 0.25): TvxPoint;
    function IsEmpty: boolean;
    { resoruces }
    property ResourcePath: TvxPathData read GetPath;
  published
    property Data: AnsiString read GetPathString write SetPathString stored false;
    { This property allow to link path with PathObject. }
    property Resource: TvxPathObject read FResource write SetResource stored false;
    { This property allow to link path with PathObject by name. }
    property ResourceName: string read GetResourceName write SetResourceName;
  end;

  TvxStrokeCap = (
    vgCapFlat,
    vgCapRound
    );

  TvxStrokeJoin = (
    vgJoinMiter,
    vgJoinRound,
    vgJoinBevel
    );

  TvxStrokeDash = (
    vgDashSolid,
    vgDashDash,
    vgDashDot,
    vgDashDashDot,
    vgDashDashDotDot,
    vgDashCustom
    );

  TvxSaveData = record
    Index: cardinal;
    Matrix: TvxMatrix;
    AbsoluteMatrix, InvertMatrix: TvxMatrix;
    Fill: TvxBrush;
    Stroke: TvxBrush;
    StrokeThickness: single;
    StrokeCap: TvxStrokeCap;
    StrokeJoin: TvxStrokeJoin;
    StrokeDash: TvxStrokeDash;
    Dash: array of single;
    DashOffset: single;
    Font: TvxFont;
    // custom data
    Data: Pointer;
  end;

  TvxSaveDataArray = array of TvxSaveData;

  TvxCanvas = class(TPersistent)
  private
  protected
    FWidth, FHeight: integer;
    FMatrix: TvxMatrix;
    FFill: TvxBrush;
    FStroke: TvxBrush;
    FStrokeThickness: single;
    FStrokeCap: TvxStrokeCap;
    FStrokeJoin: TvxStrokeJoin;
    FStrokeDash: TvxStrokeDash;
    FDash: array of single;
    FDashOffset: single;
    FFont: TvxFont;
    FBitmap: TvxBitmap;
    FResized: boolean;
    FSaveData: TvxSaveDataArray;
    FBuffered: boolean;
    FBufferBits: Pointer;
    FHandle: THandle;
    FParent: THandle;
    FScene: IvgScene;
    procedure FontChanged(Sender: TObject); virtual;
    procedure SetStrokeDash(const Value: TvxStrokeDash);
    procedure AssignTo(Dest: TPersistent); override;
  public
    constructor Create(const AWidth, AHeight: integer); virtual;
    constructor CreateFromBitmap(const ABitmap: TvxBitmap); virtual;
    destructor Destroy; override;
    { scene }
    function BeginScene: boolean; virtual;
    procedure EndScene; virtual;
    { buffer }
    procedure FlushBuffer(const X, Y: integer; const DC: Cardinal); virtual; abstract;
    procedure FlushBufferRect(const X, Y: integer; const DC: Cardinal; const ARect: TvxRect); virtual; abstract;
    procedure FreeBuffer; virtual; abstract;
    procedure ResizeBuffer(const AWidth, AHeight: integer); virtual; abstract;
    procedure Clear(const Color: cardinal); virtual; abstract;
    procedure ClearRect(const ARect: TvxRect; const AColor: TvxColor = 0); virtual; abstract;
    class function GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray; virtual;
    { i/o }
    procedure SaveToStream(S: TStream);
    procedure SaveToBits(Bits: Pointer);
    { matrix }
    procedure SetMatrix(const M: TvxMatrix); virtual;
    procedure MultyMatrix(const M: TvxMatrix); virtual;
    { cliping }
    function SaveCanvas: cardinal; virtual; abstract;
    procedure RestoreCanvas(const AState: cardinal); virtual; abstract;
    procedure SetClipRects(const ARects: array of TvxRect); virtual; abstract;
    procedure IntersectClipRect(const ARect: TvxRect); virtual; abstract;
    procedure ExcludeClipRect(const ARect: TvxRect); virtual; abstract;
    procedure ResetClipRect; virtual; abstract;
    { drawing }
    procedure DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single); virtual; abstract;
    procedure FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); virtual; abstract;
    procedure DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); virtual; abstract;
    procedure FillEllipse(const ARect: TvxRect; const AOpacity: single); virtual; abstract;
    procedure DrawEllipse(const ARect: TvxRect; const AOpacity: single); virtual; abstract;
    procedure FillArc(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single; const AOpacity: single);
    procedure DrawArc(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single; const AOpacity: single);
    function PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean; virtual; abstract;
    procedure FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); virtual; abstract;
    procedure DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); virtual; abstract;
    procedure DrawBitmap(const ABitmap: TvxBitmap; const SrcRect, DstRect: TvxRect; const AOpacity: single;
      const HighSpeed: boolean = false); virtual; abstract;
    procedure DrawThumbnail(const ABitmap: TvxBitmap; const Width, Height: single); virtual; abstract;
    { routines }
    procedure DrawRectSides(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ASides: TvxSides;
      const ACornerType: TvxCornerType = vgCornerRound);
    { linear polygon }
    procedure FillPolygon(const Points: TvxPolygon; const AOpacity: single); virtual;
    procedure DrawPolygon(const Points: TvxPolygon; const AOpacity: single); virtual;
    { text }
    function LoadFontFromStream(AStream: TStream): boolean; virtual;
    procedure FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
      const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter); virtual; abstract;
    procedure MeasureText(var ARect: TvxRect; AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter); virtual; abstract;
    function TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean; virtual; abstract;
    function TextWidth(const AText: WideString): single;
    function TextHeight(const AText: WideString): single;
    { dash and cap  }
    procedure SetCustomDash(Dash: array of single; Offset: single);
    { properties }
    property Stroke: TvxBrush read FStroke;
    property StrokeThickness: single read FStrokeThickness write FStrokeThickness;
    property StrokeCap: TvxStrokeCap read FStrokeCap write FStrokeCap;
    property StrokeDash: TvxStrokeDash read FStrokeDash write SetStrokeDash;
    property StrokeJoin: TvxStrokeJoin read FStrokeJoin write FStrokeJoin;
    property Fill: TvxBrush read FFill;
    property Font: TvxFont read FFont;
    { usage in PaintTo }
    property Matrix: TvxMatrix read FMatrix;
    { read only }
    property Width: integer read FWidth;
    property Height: integer read FHeight;
    { Internal }
    property Scene: IvgScene read FScene write FScene;
    property Handle: THandle read FHandle write FHandle;
    property Parent: THandle read FParent write FParent;
    property Buffered: boolean read FBuffered;
    property BufferBits: Pointer read FBufferBits;
  published
  end;
  TvxCanvasClass = class of TvxCanvas;

  TvxMouseEvent = procedure(Sender: TObject; Button: TMouseButton;
    Shift: TShiftState; X, Y: single) of object;
  TvxMouseMoveEvent = procedure(Sender: TObject; Shift: TShiftState;
    X, Y, Dx, Dy: single) of object;
  TvxMouseWheelEvent = procedure(Sender: TObject; Shift: TShiftState;
    WheelDelta: Integer; MousePos: TvxPoint; var Handled: Boolean) of object;
  TvxKeyEvent = procedure(Sender: TObject; var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState) of object;

  TvxProcessTickEvent = procedure(Sender: TObject; time, deltaTime: single) of object;

  TvxAnimationType = (
    vgAnimationIn,
    vgAnimationOut,
    vgAnimationInOut
    );

  TvxInterpolationType = (
    vgInterpolationLinear,
    vgInterpolationQuadratic,
    vgInterpolationCubic,
    vgInterpolationQuartic,
    vgInterpolationQuintic,
    vgInterpolationSinusoidal,
    vgInterpolationExponential,
    vgInterpolationCircular,
    vgInterpolationElastic,
    vgInterpolationBack,
    vgInterpolationBounce
    );

  TvxObjectSortCompare = function(item1, item2: TvxObject): integer;

  TvxObject = class(TComponent)
  private
    FStored: boolean;
    FResourceName: string;
    FNotifyList: TList;
    FTagObject: TObject;
    FTagFloat: single;
    FTagString: string;
    FBindingName: string;
    FIndex: integer;
    function GetScene: IvgScene;
    procedure ReaderSetName(Reader: TReader; Component: TComponent;
      var Name: string);
    procedure ReaderError(Reader: TReader; const Message: string;
      var Handled: Boolean);
    procedure SetResourceName(const Value: string);
    procedure SetStored(const Value: boolean);
    function GetChild(Index: integer): TvxObject;
    function GetChildrenCount: integer;
    procedure SetBindingName(const Value: string);
    function GetIndex: integer;
    procedure SetIndex(Idx: integer);
  protected
    FIsVisual: boolean;
    FVisual: TvxVisualObject;
    FChildren: TList;
    FParent: TvxObject;
    FScene: IvgScene;
    procedure SetNewScene(AScene: IvgScene); virtual;
    procedure DoReleaseTimer(Sender: TObject);
    { VCL }
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    procedure SetParentComponent(Value: TComponent); override;
    function GetParentComponent: TComponent; override;
    function HasParent: Boolean; override;
    { }
    procedure ChangeParent; virtual;
    procedure SetParent(const Value: TvxObject); virtual;
    function HasClipParent: TvxVisualObject;
    { binding }
    function GetBinding(Index: string): Variant; virtual;
    procedure SetBinding(Index: string; const Value: Variant); virtual;
    function GetData: Variant; virtual;
    procedure SetData(const Value: Variant); virtual;
    { internal streaming }
    procedure IntLoadFromBinStream(const AStream: TStream);
    procedure IntSaveToBinStream(const AStream: TStream);
    { ani }
    procedure DoAniFinished(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Release(Delay: single = 0.1);
    { design }
    function ItemClass: string; virtual;
    { clone }
    function Clone(const AOwner: TComponent): TvxObject;
    procedure CloneChildFromStream(AStream: TStream);
    { childs  }
    procedure AddObject(AObject: TvxObject); virtual;
    procedure RemoveObject(AObject: TvxObject); virtual;
    procedure Exchange(AObject1, AObject2: TvxObject); virtual;
    procedure DeleteChildren; virtual;
    procedure BringToFront;
    procedure SendToBack;
    procedure AddObjectsToList(const AList: TList);
    procedure AddControlsToList(const AList: TList);
    procedure Sort(Compare: TvxObjectSortCompare);
    { notify }
    procedure AddFreeNotify(const AObject: TObject);
    procedure RemoveFreeNotify(const AObject: TObject);
    { i/o }
    procedure LoadFromStream(const AStream: TStream);
    procedure SaveToStream(const Stream: TStream);
    procedure LoadFromBinStream(const AStream: TStream);
    procedure SaveToBinStream(const AStream: TStream);
    { resoruce }
    function FindResource(const AResource: string): TvxObject; virtual;
    procedure UpdateResource; virtual;
    { animations }
    procedure StartAnimation(const AName: WideString); virtual;
    procedure StopAnimation(const AName: WideString); virtual;
    procedure StartTriggerAnimation(AInstance: TvxObject; ATrigger: string); virtual;
    procedure StartTriggerAnimationWait(AInstance: TvxObject; ATrigger: string); virtual;
    procedure StopTriggerAnimation(AInstance: TvxObject); virtual;
    procedure ApplyTriggerEffect(AInstance: TvxObject; ATrigger: string); virtual;
    { animation property }
    procedure AnimateFloat(const APropertyName: string; const NewValue: single; Duration: single = 0.2;
      AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
    procedure AnimateColor(const APropertyName: string; const NewValue: string; Duration: single = 0.2;
      AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
    procedure AnimateFloatDelay(const APropertyName: string; const NewValue: single; Duration: single = 0.2;
      Delay: single = 0.0; AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
    procedure AnimateFloatWait(const APropertyName: string; const NewValue: single; Duration: single = 0.2;
      AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
    { }
    property IsVisual: boolean read FIsVisual;
    property Visual: TvxVisualObject read FVisual;
    property Scene: IvgScene read FScene;
    property Stored: boolean read FStored write SetStored;
    { }
    property TagObject: TObject read FTagObject write FTagObject;
    property TagFloat: single read FTagFloat write FTagFloat;
    property TagString: string read FTagString write FTagString;
    { children }
    property ChildrenCount: integer read GetChildrenCount;
    property Children[Index: integer]: TvxObject read GetChild;
    { binding }
    function FindBinding(const ABinding: string): TvxObject;
    property Data: Variant read GetData write SetData;
    property Binding[Index: string]: Variant read GetBinding write SetBinding;
  published
    property Index: integer read GetIndex write SetIndex stored false;
    property Parent: TvxObject read FParent write SetParent stored false;
    property BindingName: string read FBindingName write SetBindingName;
    property ResourceName: string read FResourceName write SetResourceName;
  end;

  TvxAnimation = class(TvxObject)
  private
    FDuration: single;
    FDelay, FDelayTime: single;
    FTime: single;
    FInverse: boolean;
    FTrigger, FTriggerInverse: string;
    FLoop: boolean;
    FPause: boolean;
    FRunning: boolean;
    FOnFinish: TNotifyEvent;
    FOnProcess: TNotifyEvent;
    FHideOnFinish: boolean;
    FInterpolation: TvxInterpolationType;
    FAnimationType: TvxAnimationType;
    FEnabled: boolean;
    FAutoReverse: boolean;
    procedure SetEnabled(const Value: boolean);
  protected
    function NormalizedTime: single;
    procedure ProcessAnimation; virtual;
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; virtual;
    procedure Stop; virtual;
    procedure StopAtCurrent; virtual;
    procedure StartTrigger(AInstance: TvxObject; ATrigger: string); virtual;
    procedure ProcessTick(time, deltaTime: single);
    property Running: boolean read FRunning;
    property Pause: boolean read FPause write FPause;
  published
    property AnimationType: TvxAnimationType read FAnimationType write FAnimationType default vgAnimationIn;
    property AutoReverse: boolean read FAutoReverse write FAutoReverse default false;
    property Enabled: boolean read FEnabled write SetEnabled default false;
    property Delay: single read FDelay write FDelay;
    property Duration: single read FDuration write FDuration;
    property Interpolation: TvxInterpolationType read FInterpolation write FInterpolation default vgInterpolationLinear;
    property Inverse: boolean read FInverse write FInverse default false;
    property HideOnFinish: boolean read FHideOnFinish write FHideOnFinish default false;
    property Loop: boolean read FLoop write FLoop default false;
    property Trigger: string read FTrigger write FTrigger;
    property TriggerInverse: string read FTriggerInverse write FTriggerInverse;
    property OnProcess: TNotifyEvent read FOnProcess write FOnProcess;
    property OnFinish: TNotifyEvent read FOnFinish write FOnFinish;
  end;

  TvxEffect = class(TvxObject)
  private
    FEnabled: boolean;
    FTrigger: string;
    procedure SetEnabled(const Value: boolean);
  protected
    DisablePaint: boolean;
    AfterPaint: boolean;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; virtual;
    function GetOffset: TvxPoint; virtual;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); virtual;
    procedure ApplyTrigger(AInstance: TvxObject; ATrigger: string); virtual;
    procedure UpdateParentEffects;
    property GetDisablePaint: boolean read DisablePaint;
  published
    property Trigger: string read FTrigger write FTrigger;
    property Enabled: boolean read FEnabled write SetEnabled default true;
  end;

  TvxAlign = (
    vaNone,
    vaTopLeft,
    vaTopRight,
    vaBottomLeft,
    vaBottomRight,
    vaTop,
    vaLeft,
    vaRight,
    vaBottom,
    vaMostTop,
    vaMostBottom,
    vaMostLeft,
    vaMostRight,
    vaClient,
    vaContents,
    vaCenter,
    vaVertCenter,
    vaHorzCenter,
    vaHorizontal,
    vaVertical,
    vaScale,
    vaFit,
    vaFitLeft,
    vaFitRight
    );

  TOnPaintEvent = procedure(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect) of object;

  TvxDragMode = (
    vgDragManual,
    vgDragAutomatic
    );

  TvxDragObject = record
    Source: TObject;
    Files: array of WideString;
    Data: Variant;
  end;

  TvxDragEnterEvent = procedure(Sender: TObject; const Data: TvxDragObject; const Point: TvxPoint) of object;
  TvxDragOverEvent = procedure(Sender: TObject; const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean) of object;
  TvxDragDropEvent = procedure(Sender: TObject; const Data: TvxDragObject; const Point: TvxPoint) of object;

  TvxCanFocusedEvent = procedure(Sender: TObject; var ACanFocused: boolean) of object;

  { TvxVisualObject }
  TvxPopup = class;

  TvxVisualObject = class(TvxObject)
  private
    FOnMouseUp: TvxMouseEvent;
    FOnMouseDown: TvxMouseEvent;
    FOnMouseMove: TvxMouseMoveEvent;
    FOnMouseWheel: TvxMouseWheelEvent;
    FOnClick: TNotifyEvent;
    FOnDblClick: TNotifyEvent;
    FMouseInObject: boolean;
    FHitTest: boolean;
    FClipChildren: boolean;
    FAutoCapture: boolean;
    FMargins: TvxBounds;
    FAlign: TvxAlign;
    FDisableDefaultAlign: boolean;
    FPadding: TvxBounds;
    FTempCanvas: TvxCanvas;
    FRotateAngle: single;
    FPosition: TvxPosition;
    FScale: TvxPosition;
    FSkew: TvxPosition;
    FRotateCenter: TvxPosition;
    FCanFocused: boolean;
    FIsMouseOver: boolean;
    FIsFocused: boolean;
    FOnCanFocused: TvxCanFocusedEvent;
    FOnEnterFocus: TNotifyEvent;
    FOnKillFocus: TNotifyEvent;
    FDisableFocusEffect: boolean;
    FClipParent: boolean;
    FVelocity: TvxPosition;
    FOnMouseLeave: TNotifyEvent;
    FOnMouseEnter: TNotifyEvent;
    FDesignHide: boolean;
    FOnPaint: TOnPaintEvent;
    FOnBeforePaint: TOnPaintEvent;
    FCanClipped: boolean;
    FCursor: TCursor;
    FDragMode: TvxDragMode;
    FDragDisableHighlight: boolean;
    FOnDragEnter: TvxDragEnterEvent;
    FOnDragDrop: TvxDragDropEvent;
    FOnDragLeave: TNotifyEvent;
    FOnDragOver: TvxDragOverEvent;
    FOnDragEnd: TNotifyEvent;
    FIsDragOver: boolean;
    FOnKeyDown: TvxKeyEvent;
    FOnKeyUp: TvxKeyEvent;
    FHint: WideString;
    FShowHint: boolean;
    {$IFNDEF NOVCL}
    FPopupMenu: TPopupMenu;
    {$ENDIF}
    FPopup: TvxPopup;
    FRecalcEnabled, FEnabled, FAbsoluteEnabled: boolean;
    FTabOrder: TTabOrder;
    FTabList: TList;
    FNeedAlign: boolean;
    FOnApplyResource: TNotifyEvent;
    procedure CreateCaret;
    procedure SetEnabled(const Value: boolean);
    function GetInvertAbsoluteMatrix: TvxMatrix;
    procedure SetRotateAngle(const Value: single);
    procedure SetPosition(const Value: TvxPosition);
    procedure SetHitTest(const Value: boolean);
    procedure SetClipChildren(const Value: boolean);
    function CheckHitTest(const AHitTest: boolean): boolean;
    function GetCanvas: TvxCanvas;
    procedure SetLocked(const Value: boolean);
    procedure SetTempCanvas(const Value: TvxCanvas);
    procedure SetOpacity(const Value: single);
    procedure SetDesignHide(const Value: boolean);
    procedure SetTabOrder(const Value: TTabOrder);
    procedure UpdateDesignHide(const Value: boolean);
    function isOpacityStored: Boolean;
    function GetChildrenRect: TvxRect;
    procedure SetCursor(const Value: TCursor);
    function GetAbsoluteWidth: single;
    function GetAbsoluteHeight: single;
    function GetTabOrder: TTabOrder;
    procedure UpdateTabOrder(Value: TTabOrder);
  protected
    FHeight, FLastHeight: single;
    FWidth, FLastWidth: single;
    FVisible: boolean;
    FLocalMatrix: TvxMatrix;
    FAbsoluteMatrix: TvxMatrix;
    FRecalcAbsolute: boolean;
    FUpdateEffects: boolean;
    FEffectBitmap: TvxBitmap;
    FLocked: boolean;
    FOpacity, FAbsoluteOpacity: single;
    FRecalcOpacity: boolean;
    FInPaintTo: boolean;
    FUpdateRect: TvxRect;
    FRecalcUpdateRect: boolean;
    FCaret: TvxVisualObject;
    FPressed, FDoubleClick: boolean;
    FUpdating: integer;
    FDisableAlign: boolean;
    FDisableEffect: boolean;
    FHasEffect: boolean;
    function HasDisablePaintEffect: boolean;
    function HasAfterPaintEffect: boolean;
    procedure SetInPaintTo(value: boolean);
    {}
    procedure Loaded; override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure DeleteChildren; override;
    procedure SetVisible(const Value: boolean); virtual;
    { matrix }
    procedure SetHeight(const Value: single); virtual;
    procedure SetWidth(const Value: single); virtual;
    procedure SetAlign(const Value: TvxAlign); virtual;
    function GetAbsoluteRect: TvxRect; virtual;
    function GetAbsoluteMatrix: TvxMatrix; virtual;
    function GetChildrenMatrix: TvxMatrix; virtual;
    function GetAbsoluteScale: TvxPoint; virtual;
    function GetLocalRect: TvxRect; virtual;
    function GetUpdateRect: TvxRect; virtual;
    function GetBoundsRect: TvxRect; virtual;
    function GetParentedRect: TvxRect; virtual;
    function GetClipRect: TvxRect; virtual;
    function GetEffectsRect: TvxRect; virtual;
    function GetAbsoluteEnabled: boolean; virtual;
    procedure SetBoundsRect(const Value: TvxRect); virtual;
    procedure RecalcOpacity; virtual;
    procedure RecalcAbsolute; virtual;
    procedure RecalcAbsoluteNow;
    procedure RecalcUpdateRect;
    procedure RecalcNeedAlign;
    procedure RecalcEnabled;
    procedure RecalcHasEffect;
    procedure FixupTabList;
    { opacity }
    function GetAbsoluteOpacity: single; virtual;
    { design }
    procedure DesignSelect; virtual;
    procedure DesignClick; virtual;
    procedure DesignInsert; virtual;
    { events }
    procedure BeginAutoDrag; virtual;
    procedure Capture;
    procedure ReleaseCapture;
    procedure Click; virtual;
    procedure DblClick; virtual;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); virtual;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); virtual;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); virtual;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); virtual;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); virtual;
    procedure KeyUp(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); virtual;
    procedure DialogKey(var Key: Word; Shift: TShiftState); virtual;
    procedure MouseEnter; virtual;
    procedure MouseLeave; virtual;
    procedure ContextMenu(const ScreenPosition: TvxPoint); virtual;
    procedure DragEnter(const Data: TvxDragObject; const Point: TvxPoint); virtual;
    procedure DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean); virtual;
    procedure DragDrop(const Data: TvxDragObject; const Point: TvxPoint); virtual;
    procedure DragLeave; virtual;
    procedure DragEnd; virtual;
    function EnterFocusChildren(AObject: TvxVisualObject): boolean; virtual;
    procedure EnterFocus; virtual;
    procedure KillFocus; virtual;
    procedure SetNewScene(AScene: IvgScene); override;
    { control resources }
    procedure ApplyResource; virtual;
    { paint }
    procedure BeforePaint; virtual;
    procedure Paint; virtual;
    procedure AfterPaint; virtual;
    procedure PaintChildren; virtual;
    { changes }
    procedure MarginsChanged(Sender: TObject); virtual;
    procedure PaddingChanged(Sender: TObject); virtual;
    procedure MatrixChanged(Sender: TObject); virtual;
    { props }
    property MouseInObject: boolean read FMouseInObject write FMouseInObject;
    property TempCanvas: TvxCanvas read FTempCanvas write SetTempCanvas;
    property Skew: TvxPosition read FSkew write FSkew;
  public
    DisableDesignResize: boolean;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    { matrix }
    function AbsoluteToLocal(P: TvxPoint): TvxPoint; virtual;
    function LocalToAbsolute(P: TvxPoint): TvxPoint; virtual;
    function AbsoluteToLocalVector(P: TvxVector): TvxVector; virtual;
    function LocalToAbsoluteVector(P: TvxVector): TvxVector; virtual;
    function ObjectByPoint(X, Y: single): TvxVisualObject; virtual;
    function PointInObject(X, Y: single): boolean; virtual;
    procedure SetBounds(X, Y, AWidth, AHeight: single); virtual;
    procedure SetSizeWithoutChange(AWidth, AHeight: single);
    function CheckParentVisible: boolean; virtual;
    { drag and drop }
    function MakeScreenshot: TvxBitmap;
    function FindTarget(const APoint: TvxPoint; const Data: TvxDragObject): TvxVisualObject;
    { caret }
    procedure ShowCaretProc;
    procedure SetCaretPos(const APoint: TvxPoint);
    procedure SetCaretSize(const ASize: TvxPoint);
    procedure SetCaretColor(const AColor: TvxColor);
    procedure HideCaret;
    { align }
    procedure BeginUpdate; virtual;
    procedure EndUpdate; virtual;
    procedure Realign; virtual;
    { effects }
    procedure UpdateEffects;
    { }
    procedure GetTabOrderList(List: TList; Children: boolean);
    procedure SetFocus;
    procedure PaintTo(const ACanvas: TvxCanvas; const ARect: TvxRect; const AParent: TvxObject = nil);
    procedure ApplyEffect;
    procedure Repaint; virtual;
    procedure InvalidateRect(ARect: TvxRect);
    procedure Lock;
    property AbsoluteMatrix: TvxMatrix read GetAbsoluteMatrix;
    property AbsoluteOpacity: single read GetAbsoluteOpacity;
    property AbsoluteWidth: single read GetAbsoluteWidth;
    property AbsoluteHeight: single read GetAbsoluteHeight;
    property AbsoluteScale: TvxPoint read GetAbsoluteScale;
    property AbsoluteEnabled: boolean read GetAbsoluteEnabled;
    property InvertAbsoluteMatrix: TvxMatrix read GetInvertAbsoluteMatrix;
    property LocalRect: TvxRect read GetLocalRect;
    property AbsoluteRect: TvxRect read GetAbsoluteRect;
    property UpdateRect: TvxRect read GetUpdateRect;
    property BoundsRect: TvxRect read GetBoundsRect write SetBoundsRect;
    property ParentedRect: TvxRect read GetParentedRect;
    property ClipRect: TvxRect read GetClipRect;
    property Canvas: TvxCanvas read GetCanvas;
    property AutoCapture: boolean read FAutoCapture write FAutoCapture default false;
    property CanFocused: boolean read FCanFocused write FCanFocused default false;
    property DisableFocusEffect: boolean read FDisableFocusEffect write FDisableFocusEffect default false;
    property DisableDefaultAlign: boolean read FDisableDefaultAlign write FDisableDefaultAlign;
    property TabOrder: TTabOrder read GetTabOrder write SetTabOrder default -1;
  published
    { triggers }
    property IsMouseOver: boolean read FIsMouseOver;
    property IsDragOver: boolean read FIsDragOver;
    property IsFocused: boolean read FIsFocused;
    property IsVisible: boolean read FVisible;
    { props }
    property Align: TvxAlign read FAlign write SetAlign default vaNone;
    property Cursor: TCursor read FCursor write SetCursor default crDefault;
    property DragMode: TvxDragMode read FDragMode write FDragMode default vgDragManual;
    property DragDisableHighlight: boolean read FDragDisableHighlight write FDragDisableHighlight default false;
    property Enabled: boolean read FEnabled write SetEnabled default true;
    property Position: TvxPosition read FPosition write SetPosition;
    property RotateAngle: single read FRotateAngle write SetRotateAngle;
    property RotateCenter: TvxPosition read FRotateCenter write FRotateCenter;
    property Locked: boolean read FLocked write SetLocked default false;
    property Width: single read FWidth write SetWidth;
    property Height: single read FHeight write SetHeight;
    property Margins: TvxBounds read FMargins write FMargins;
    property Padding: TvxBounds read FPadding write FPadding;
    property Opacity: single read FOpacity write SetOpacity stored isOpacityStored;
    property ClipChildren: boolean read FClipChildren write SetClipChildren default false;
    property ClipParent: boolean read FClipParent write FClipParent default false;
    property HitTest: boolean read FHitTest write SetHitTest default true;
    property Hint: WideString read FHint write FHint;
    property ShowHint: boolean read FShowHint write FShowHint default false;
    property CanClipped: boolean read FCanClipped write FCanClipped default true;
    {$IFNDEF NOVCL}
    property PopupMenu: TPopupMenu read FPopupMenu write FPopupMenu;
    {$ENDIF}
    property Popup: TvxPopup read FPopup write FPopup;
    property Scale: TvxPosition read FScale write FScale;
    property Visible: boolean read FVisible write SetVisible default true;
    property DesignHide: boolean read FDesignHide write SetDesignHide default false;
    property OnDragEnter: TvxDragEnterEvent read FOnDragEnter write FOnDragEnter;
    property OnDragLeave: TNotifyEvent read FOnDragLeave write FOnDragLeave;
    property OnDragOver: TvxDragOverEvent read FOnDragOver write FOnDragOver;
    property OnDragDrop: TvxDragDropEvent read FOnDragDrop write FOnDragDrop;
    property OnDragEnd: TNotifyEvent read FOnDragEnd write FOnDragEnd;
    property OnKeyDown: TvxKeyEvent read FOnKeyDown write FOnKeyDown;
    property OnKeyUp: TvxKeyEvent read FOnKeyUp write FOnKeyUp;
    property OnClick: TNotifyEvent read FOnClick write FOnClick;
    property OnDblClick: TNotifyEvent read FOnDblClick write FOnDblClick;
    property OnCanFocused: TvxCanFocusedEvent read FOnCanFocused write FOnCanFocused;
    property OnEnterFocus: TNotifyEvent read FOnEnterFocus write FOnEnterFocus;
    property OnKillFocus: TNotifyEvent read FOnKillFocus write FOnKillFocus;
    property OnMouseDown: TvxMouseEvent read FOnMouseDown write FOnMouseDown;
    property OnMouseMove: TvxMouseMoveEvent read FOnMouseMove write FOnMouseMove;
    property OnMouseUp: TvxMouseEvent read FOnMouseUp write FOnMouseUp;
    property OnMouseWheel: TvxMouseWheelEvent read FOnMouseWheel write FOnMouseWheel;
    property OnMouseEnter: TNotifyEvent read FOnMouseEnter write FOnMouseEnter;
    property OnMouseLeave: TNotifyEvent read FOnMouseLeave write FOnMouseLeave;
    property OnBeforePaint: TOnPaintEvent read FOnBeforePaint write FOnBeforePaint;
    property OnPaint: TOnPaintEvent read FOnPaint write FOnPaint;
    property OnApplyResource: TNotifyEvent read FOnApplyResource write FOnApplyResource;
  end;

  TvxBrushObject = class(TvxObject)
  private
    FBrush: TvxBrush;
  protected
    procedure SetName(const NewName: TComponentName); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Brush: TvxBrush read FBrush write FBrush;
  end;

  TvxPathObject = class(TvxObject)
  private
    FPath: TvxPathData;
  protected
    procedure SetName(const NewName: TComponentName); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Path: TvxPathData read FPath write FPath;
  end;

  TvxBitmapObject = class(TvxObject)
  private
    FBitmap: TvxBitmap;
  protected
    procedure SetName(const NewName: TComponentName); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Bitmap: TvxBitmap read FBitmap write FBitmap;
  end;

  TvxOrientation = (
    vgHorizontal,
    vgVertical
    );

  {$IFNDEF NOVCL}

  { TvxControlActionLink }

  TvxControlActionLink = class;

  TvxControlActionLink = class(TActionLink)
  protected
    FClient: TvxControl;
    procedure AssignClient(AClient: TObject); override;
    function IsCaptionLinked: Boolean; override;
    function IsEnabledLinked: Boolean; override;
    function IsHelpLinked: Boolean; override;
    function IsHintLinked: Boolean; override;
    function IsVisibleLinked: Boolean; override;
    function IsOnExecuteLinked: Boolean; override;
    function DoShowHint(var HintStr: string): Boolean; virtual;
    procedure SetCaption(const Value: string); override;
    procedure SetEnabled(Value: Boolean); override;
    procedure SetHelpContext(Value: THelpContext); override;
    procedure SetHelpKeyword(const Value: string); override;
    procedure SetHelpType(Value: THelpType); override;
    procedure SetHint(const Value: string); override;
    procedure SetVisible(Value: Boolean); override;
    procedure SetOnExecute(Value: TNotifyEvent); override;
  end;

  TvxControlActionLinkClass = class of TvxControlActionLink;
  {$ENDIF}

  TvxControl = class(TvxVisualObject)
  private
    procedure SetResource(const Value: string);
    procedure SetBindingSource(const Value: TvxControl);
  protected
    FResourceLink: TvxObject;
    FNeedResource: boolean;
    FBindingObjects: TList;
    FBindingSource: TvxControl;
    FAutoTranslate: boolean;
    {$IFNDEF NOVCL}
    FActionLink: TvxControlActionLink;
    {$ENDIF}
    FHelpType: THelpType;
    FHelpKeyword: string;
    FHelpContext: THelpContext;
    function IsHelpContextStored: Boolean;
    procedure SetHelpContext(const Value: THelpContext);
    procedure SetHelpKeyword(const Value: string);
    function GetAction: TBasicAction; virtual;
    procedure SetAction(Value: TBasicAction);
    procedure DoActionChange(Sender: TObject);
    procedure ActionChange(Sender: TObject; CheckDefaults: Boolean); virtual;
    procedure InitiateAction; virtual;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure Loaded; override;
    { control }
    procedure ApplyStyle; virtual;
    procedure FreeStyle; virtual;
    procedure EnterFocus; override;
    { }
    procedure BeforePaint; override;
    function GetResourceObject: TvxVisualObject;
    { binding }
    procedure SetData(const Value: Variant); override;
    procedure ToBindingObjects;
    procedure AddBindingObject(AObject: TvxControl);
    procedure RemoveBindingObject(AObject: TvxControl);
  public
    FResource: string;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function FindResource(const AResource: string): TvxObject; override;
    procedure Paint; override;
    procedure ApplyResource; override;
    procedure UpdateResource; override;
    property BindingSource: TvxControl read FBindingSource write SetBindingSource;
    property AutoTranslate: boolean read FAutoTranslate write FAutoTranslate;
    property Action: TBasicAction read GetAction write SetAction;
  published
    property HelpType: THelpType read FHelpType write FHelpType default htContext;
    property HelpKeyword: string read FHelpKeyword write SetHelpKeyword stored IsHelpContextStored;
    property HelpContext: THelpContext read FHelpContext write SetHelpContext stored IsHelpContextStored default 0;
    property Resource: string read FResource write SetResource;
    property TabOrder default -1;
  end;

  TvxBackground = class(TvxControl)
  private
    FFill: TvxBrush;
    procedure SetFill(const Value: TvxBrush);
  protected
    procedure PaintChildren; override;
    procedure FillChanged(Sender: TObject); virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
  published
    property Resource;
    property Fill: TvxBrush read FFill write SetFill;
  end;

  TvxContent = class(TvxVisualObject)
  private
  protected
    FParentAligning: boolean;
    function GetParentComponent: TComponent; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
    procedure Paint; override;
  published
  end;

  IvgSizeGrip = interface
    ['{181729B7-53B2-45ea-97C7-91E1F3CBAABE}']
  end;

  TvxResources = class(TComponent)
  private
    FResource: TStrings;
    FRoot: TvxObject;
    FSceneList: TList;
    FFileName: string;
    procedure SetResource(const Value: TStrings);
    procedure SetFileName(const Value: string);
    procedure DoResourceChanged(Sender: TObject);
  protected
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure Loaded; override;
    { vcl }
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadResources(Stream: TStream);
    procedure WriteResources(Stream: TStream);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddSceneUpdater(const Scene: IvgScene);
    procedure RemoveSceneUpdater(const Scene: IvgScene);
    procedure FillStrings;
    procedure UpdateScenes;
    property Root: TvxObject read FRoot write FRoot;
  published
    property Resource: TStrings read FResource write SetResource stored false;
    property FileName: string read FFileName write SetFileName;
  end;

  TvxLang = class(TComponent)
  private
    FLang: string;
    FResources: TvxWideStrings;
    FOriginal: TvxWideStrings;
    FAutoSelect: boolean;
    FFileName: string;
    FStoreInForm: boolean;
    procedure SetLang(const Value: string);
    function GetLangStr(Index: WideString): TvxWideStrings;
  protected
    { vcl }
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadResources(Stream: TStream);
    procedure WriteResources(Stream: TStream);
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddLang(AName: WideString);
    procedure LoadFromFile(AFileName: string);
    procedure SaveToFile(AFileName: string);
    property Original: TvxWideStrings read FOriginal;
    property Resources: TvxWideStrings read FResources;
    property LangStr[Index: WideString]: TvxWideStrings read GetLangStr;
  published
    property AutoSelect: boolean read FAutoSelect write FAutoSelect default true;
    property FileName: string read FFileName write FFileName;
    property StoreInForm: boolean read FStoreInForm write FStoreInForm default true;
    property Lang: string read FLang write SetLang;
  end;

  TvxDesigner = class(TComponent)
  private
    FScenes: TList;
  protected
    procedure CallDesignSelect(AObject: TObject);
  public
    procedure SelectObject(ADesigner: TComponent; AObject: TvxObject; MultiSelection: array of TvxObject); virtual; abstract;
    procedure Modified(ADesigner: TComponent); virtual; abstract;
    function UniqueName(ADesigner: TComponent; ClassName: string): string; virtual; abstract;
    function IsSelected(ADesigner: TComponent; const AObject: TObject): boolean; virtual; abstract;
    procedure AddScene(const Scene: IvgScene); virtual;
    procedure RemoveScene(const Scene: IvgScene); virtual;
    procedure EditStyle(const Res: TvxResources; const ASelected: string); virtual;
    // runtime
    procedure AddObject(AObject: TvxObject); virtual;
    procedure DeleteObject(AObject: TvxObject); virtual;
    function AddMethod(MethodName: string): TMethod; virtual;
    function GetMethodName(Method: TMethod): string; virtual;
  end;

  {$IFNDEF NOVCL}

  TvxCustomScene = class;

  TvxFrame = class(TvxVisualObject)
  private
    FNeedClone: boolean;
    FSceneObject: TvxCustomScene;
    FBuffer: TvxBitmap;
    procedure SetSceneObject(const Value: TvxCustomScene);
  protected
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure Loaded; override;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property SceneObject: TvxCustomScene read FSceneObject write SetSceneObject;
  end;

  { TvxCustomScene }

  TvxTimer = class(TTimer)
  end;

  TvxCustomScene = class(TCustomControl, IvgScene{$IFDEF WINDOWS}, IDropTarget{$ENDIF})
  private
    {$IFDEF FPCWIN}
    PrevWndProc: WNDPROC;
    FWStyle: string;
    {$ENDIF}
    {$IFDEF FPC}
    FShift: TShiftState;
    {$ENDIF}
    {$IFDEF WINDOWS}
    FDC: THandle;
    {$ENDIF}
    FCanvas: TvxCanvas;
    FDisableUpdate: boolean;
    FChildren: TList;
    FDesignRoot, FSelected, FCaptured, FHovered, FFocused: TvxVisualObject;
    FSelection: array of TvxObject;
    FDesignPlaceObject: TvxVisualObject;
    FDesignGridLines: array of TvxVisualObject;
    FDesignPopup: TPopupMenu;
    FDesignChangeSelection: TNotifyEvent;
    FUnsnapMousePos, FMousePos, FDownPos: TvxPoint;
    FMoving, FLeftTop, FRightTop, FLeftBottom, FRightBottom, FTop, FBottom, FLeft, FRight, FRotate: boolean;
    FLeftTopHot, FRightTopHot, FLeftBottomHot, FRightBottomHot, FTopHot, FBottomHot, FLeftHot, FRightHot, FRotateHot: boolean;
    FResizeSize: TPoint;
    FDragging, FResizing: boolean;
    FDesignTime: boolean;
    FFill: TvxBrush;
    FTransparency: boolean;
    FSnapToGrid: boolean;
    FSnapToLines: boolean;
    FSnapGridShow: boolean;
    FSnapGridSize: single;
    FInsertObject: string;
    FAlignRoot: boolean;
    FDesignPopupEnabled: boolean;
    FOpenInFrame: TvxFrame;
    FCloneFrame: TForm;
    FDrawing: boolean;
    FOnFlush: TNotifyEvent;
    FShowTimer: TvxTimer;
    FDBCSLeadChar: Word;
    FStyle: TvxResources;
    FShowUpdateRects: boolean;
    FLoadCursor: TCursor;
    VCLDragSource: TCustomControl;
    FActiveControl: TvxControl;
    FAnimatedCaret: boolean;
    procedure SetActiveControl(AControl: TvxControl);
    procedure DoShowTimer(Sender: TObject);
    {$IFDEF WINDOWS}
    function GetDataObject: TvxDragObject;
    function DragEnter(const dataObj: IDataObject; grfKeyState: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF};
      pt: TPoint; var dwEffect: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}): HResult; stdcall;
    function DragOver(grfKeyState: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}; pt: TPoint;
      var dwEffect: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}): HResult; stdcall;
    function DragLeave: HResult; stdcall;
    function Drop(const dataObj: IDataObject; grfKeyState: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}; pt: TPoint;
      var dwEffect: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}): HResult; stdcall;
    procedure WMAddUpdateRect(var Msg: TMessage); message WM_ADDUPDATERECT;
    procedure CMMouseLeave(var Message: TMessage); message CM_MOUSELEAVE;
    procedure WMEraseBkgnd(var Msg: TWMEraseBkgnd); message WM_ERASEBKGND;
    procedure WMPaint(var Msg: TWMPaint); message WM_PAINT;
    {$ENDIF}
    {$IFNDEF FPC}
    procedure WMImeStartComposition(var Message: TMessage); message WM_IME_STARTCOMPOSITION;
    procedure WMImeComposition(var Message: TMessage); message WM_IME_COMPOSITION;
    procedure WMKeyDown(var Message: TWMKeyDown); message WM_KEYDOWN;
    procedure WMKeyUp(var Message: TWMKeyUp); message WM_KEYUP;
    procedure WMChar(var Message: TWMChar); message WM_CHAR;
    procedure WMGetDlgCode(var Msg: TWMGetDlgCode); message WM_GETDLGCODE;
    {$ENDIF}
    {$IFDEF LINUX}
    procedure EraseBackground(DC: HDC); override;
    {$ENDIF}
    {$IFNDEF UCL}
    procedure CMShowingChanged(var Message: {$IFDEF FPC}TLMessage{$ELSE}TMessage{$ENDIF}); message CM_SHOWINGCHANGED;
    procedure CMDesignHitTest(var Msg: {$IFDEF FPC}TLMMouse{$ELSE}TWMMouse{$ENDIF}); message CM_DESIGNHITTEST;
    procedure CMHintShow(var Message: {$IFDEF FPC}TLMessage{$ELSE}TMessage{$ENDIF}); message CM_HINTSHOW;
    {$ENDIF}
    function GetCount: integer;
    procedure SetChildren(Index: integer; const Value: TvxObject);
    function GetChildrenObject(Index: integer): TvxObject;
    procedure SetFill(const Value: TvxBrush);
    procedure FillChanged(Sender: TObject);
    procedure SetSnapGridShow(const Value: boolean);
    procedure AddUpdateRectsFromGridLines;
    function SnapToGridValue(Value: single): single;
    procedure SetSnapGridSize(const Value: single);
    procedure SnapToGridLines(AllowChangePosition: boolean);
    function SnapPointToGridLines(const APoint: TvxPoint): TvxPoint;
    procedure ReadDesignSnapGridShow(Reader: TReader);
    procedure WriteDesignSnapGridShow(Writer: TWriter);
    procedure ReadDesignSnapToGrid(Reader: TReader);
    procedure WriteDesignSnapToGrid(Writer: TWriter);
    procedure ReadDesignSnapToLines(Reader: TReader);
    procedure WriteDesignSnapToLines(Writer: TWriter);
    { design }
    procedure doDesignTabOrderBtnClick(Sender: TObject);
    procedure doDesignTabOrderRebuildList(ListBox: TvxVisualObject);
    procedure doDesignPopupTabOrder(Sender: TObject);
    procedure doDesignPopupEditStyle(Sender: TObject);
    procedure doDesignPopupCreateStyle(Sender: TObject);
    procedure doDesignPopupLoadFromFile(Sender: TObject);
    procedure doDesignPopupDesignHide(Sender: TObject);
    procedure doDesignPopupAddItem(Sender: TObject);
    procedure doDesignPopupAdd(Sender: TObject);
    procedure doDesignPopupDel(Sender: TObject);
    procedure doDesignPopupReorder(Sender: TObject);
    procedure doDesignPopupGrid(Sender: TObject);
    procedure doDesignPopupCopy(Sender: TObject);
    function GetRoot: TvxObject;
    procedure SetFocused(const Value: TvxVisualObject);
    procedure DoDesignSelect(AObject: TObject);
    procedure UpdateLayer;
    procedure SetSelected(const Value: TvxVisualObject);
    procedure doDesignPopupPaste(Sender: TObject);
    procedure SetStyle(const Value: TvxResources);
    { IvgScene }
    function GetActiveControl: TvxControl;
    function GetDisableUpdate: boolean;
    function GetDesignTime: boolean;
    function GetCanvas: TvxCanvas;
    function GetOwner: TComponent;
    function GetComponent: TComponent;
    function GetSelected: TvxVisualObject;
    function GetDesignPlaceObject: TvxVisualObject;
    procedure SetDisableUpdate(Value: boolean);
    function GetUpdateRectsCount: integer;
    function GetUpdateRect(const Index: integer): TvxRect;
    procedure SetCaptured(const Value: TvxVisualObject);
    function GetCaptured: TvxVisualObject;
    function GetFocused: TvxVisualObject;
    procedure SetDesignRoot(const Value: TvxVisualObject);
    function GetMousePos: TvxPoint;
    function GetStyle: TvxResources;
    function GetTransparency: boolean;
    procedure SetTransparency(const Value: boolean);
    procedure BeginVCLDrag(Source: TObject; ABitmap: TvxBitmap);
    procedure EndDragEvent(Sender, Target: TObject; X, Y: Integer);
    function GetAnimatedCaret: boolean;
    function LocalToScreen(const Point: TvxPoint): TvxPoint;
    function ShowKeyboardForControl(AObject: TvxObject): boolean;
    function HideKeyboardForControl(AObject: TvxObject): boolean;
  protected
    FUpdateRects: array of TvxRect;
    procedure CreateHandle;
    {$IFNDEF UCL} override;
    {$ENDIF}
    {$IFDEF WINDOWS}
    procedure CreateWnd;
    {$IFNDEF UCL} override;
    {$ENDIF}
    procedure DestroyWnd;
    {$IFNDEF UCL} override;
    {$ENDIF}
    {$ENDIF}
    procedure InitiateAction; override;
    procedure Loaded; override;
    procedure Resize; override;
    procedure Draw; virtual;
    procedure Paint; override;
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure MouseMove(Shift: TShiftState; X, Y: Integer); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState;
      X, Y: Integer); override;
    procedure DoDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState;
      var Accept: Boolean);
    procedure DoDragDrop(Sender, Source: TObject;
      X, Y: Integer);
    {$IFDEF FPC}
    procedure KeyUp(var Key: Word; Shift: TShiftState); override;
    procedure KeyDown(var Key: Word; Shift: TShiftState); override;
    procedure KeyPress(var Key: char); override;
    procedure UTF8KeyPress(var UTF8Key: TUTF8Char); override;
    {$ENDIF}
    procedure UnicodeKeyUp(var Key: Word; var Char: System.WideChar; Shift: TShiftState);
    procedure UnicodeKeyDown(var Key: Word; var Char: System.WideChar; Shift: TShiftState);
    function DoMouseWheel(Shift: TShiftState; WheelDelta: Integer;
      MousePos: TPoint): Boolean;
    {$IFNDEF UCL} override;
    {$ENDIF}
    { }
    function ObjectByPoint(X, Y: single): TvxVisualObject;
  public
    FPopupPos: TPoint;
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DeleteChildren;
    procedure SetBounds(ALeft, ATop, AWidth, AHeight: Integer); override;
    procedure UpdateBuffer;
    procedure UpdateResource;
    property Canvas: TvxCanvas read FCanvas;
    { children }
    procedure AddObject(AObject: TvxObject);
    procedure RemoveObject(AObject: TvxObject);
    procedure RealignRoot;
    { managment }
    procedure BeginDrag;
    procedure BeginResize;
    { paint }
    procedure AddUpdateRect(R: TvxRect);
    { design }
    procedure OpenDesignPopup;
    procedure InsertObject(const ClassName: string);
    property DesignTime: boolean read FDesignTime write FDesignTime stored false;
    { debug }
    property ShowUpdateRects: boolean read FShowUpdateRects write FShowUpdateRects stored false;
    { }
    property Count: integer read GetCount;
    property Root: TvxObject read GetRoot;
    property Children[Index: integer]: TvxObject read GetChildrenObject write SetChildren;
    property Selected: TvxVisualObject read FSelected write SetSelected;
    property Captured: TvxVisualObject read FCaptured;
    property Hovered: TvxVisualObject read FHovered;
    property Focused: TvxVisualObject read FFocused write SetFocused;
    property DisableUpdate: boolean read FDisableUpdate;
    property IsDrawing: boolean read FDrawing;
    { use as emebbded }
    procedure CreateEmbedded(const AWidth, AHeight: integer; AOnFlush: TNotifyEvent);
    procedure EmbeddedMouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    procedure EmbeddedMouseMove(Shift: TShiftState; X, Y: Integer);
    procedure EmbeddedMouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
    function EmbeddedMouseWheel(Shift: TShiftState; WheelDelta: Integer): Boolean;
    procedure EmbeddedKeyUp(var Key: Word; var Char: System.WideChar; Shift: TShiftState);
    procedure EmbeddedKeyDown(var Key: Word; var Char: System.WideChar; Shift: TShiftState);
    property OnFlush: TNotifyEvent read FOnFlush write FOnFlush;
    { design }
    property DesignPopupEnabled: boolean read FDesignPopupEnabled write FDesignPopupEnabled;
    property DesignSnapGridShow: boolean read FSnapGridShow write SetSnapGridShow;
    property DesignSnapToGrid: boolean read FSnapToGrid write FSnapToGrid;
    property DesignSnapToLines: boolean read FSnapToLines write FSnapToLines;
    property DesignChangeSelection: TNotifyEvent read FDesignChangeSelection write FDesignChangeSelection;
    { can be published }
    property Align;
    property AnimatedCaret: boolean read FAnimatedCaret write FAnimatedCaret default true;
    property ActiveControl: TvxControl read FActiveControl write SetActiveControl;
    property DesignSnapGridSize: single read FSnapGridSize write SetSnapGridSize;
    property Fill: TvxBrush read FFill write SetFill;
    property Transparency: boolean read FTransparency write SetTransparency default false;
    property Style: TvxResources read FStyle write SetStyle;
    property TabStop;
  published
  end;

  TDicomScene = class(TvxCustomScene)
  published
    property Align;
    property AnimatedCaret;
    property Fill;
    property Transparency;
    property Style;
    property TabStop;
    property ActiveControl; // must be last
  end;

  {$ELSE}
  TvxTimer = class(TComponent)
  private
    FInterval: Cardinal;
    FTimerHandle: THandle;
    FOnTimer: TNotifyEvent;
    FEnabled: Boolean;
    procedure Timer;
  protected
    procedure SetEnabled(Value: Boolean); virtual;
    procedure SetInterval(Value: Cardinal); virtual;
    procedure SetOnTimer(Value: TNotifyEvent); virtual;
    procedure DoOnTimer; virtual;
    procedure UpdateTimer; virtual;
    procedure KillTimer; virtual;
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property Enabled: Boolean read FEnabled write SetEnabled default True;
    property Interval: Cardinal read FInterval write SetInterval default 1000;
    property OnTimer: TNotifyEvent read FOnTimer write SetOnTimer;
  end;
  {$ENDIF}

  TvxPlacement = (
    vgPlacementBottom,
    vgPlacementTop,
    vgPlacementLeft,
    vgPlacementRight,
    vgPlacementCenter,
    vgPlacementBottomCenter,
    vgPlacementTopCenter,
    vgPlacementLeftCenter,
    vgPlacementRightCenter,
    vgPlacementAbsolute,
    vgPlacementMouse,
    vgPlacementMouseCenter
    );

  TvxPlacementScene = (
    vgPlacementSceneNew,
    vgPlacementSceneTarget
    );

  TvxPopup = class(TvxControl)
  private
    FSaveParent: TvxObject;
    FSaveFocused: TvxVisualObject;
    FSaveScale: TvxPoint;
    {$IFNDEF NOVCL}
    FPopupForm: TCustomForm;
    FPopupScene: TDicomScene;
    FDragTimer: TvxTimer;
    {$ELSE}
    FPopupScene: TvxObject;
    {$ENDIF}
    FPopupLayout: TvxVisualObject;
    FIsOpen: boolean;
    FStaysOpen: boolean;
    FPlacement: TvxPlacement;
    FPlacementTarget: TvxVisualObject;
    FPlacementRectangle: TvxBounds;
    FHorizontalOffset: single;
    FVerticalOffset: single;
    FDragWithParent: boolean;
    FAnimating: boolean;
    FStyle: TvxResources;
    FPlacementScene: TvxPlacementScene;
    FModalResult: TModalResult;
    FModal: boolean;
    FOnClosePopup: TNotifyEvent;
    procedure SetIsOpen(const Value: boolean);
    procedure SetPlacementRectangle(const Value: TvxBounds);
    procedure SetModalResult(const Value: TModalResult);
    procedure Dotimer(Sender: TObject);
  protected
    procedure ApplyPlacement; virtual;
    procedure Paint; override;
    procedure KillFocus; override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure DialogKey(var Key: Word; Shift: TShiftState); override;
    procedure DoFormClose(Sender: TObject; var Action: TCloseAction);
    procedure DoPopupLayoutClick(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function PopupModal: TModalResult; virtual;
    procedure Popup; virtual;
    procedure ClosePopup; virtual;
    property ModalResult: TModalResult read FModalResult write SetModalResult;
    property PlacementScene: TvxPlacementScene read FPlacementScene write FPlacementScene default vgPlacementSceneNew;
  published
    property IsOpen: boolean read FIsOpen write SetIsOpen;
    property HorizontalOffset: single read FHorizontalOffset write FHorizontalOffset;
    property VerticalOffset: single read FVerticalOffset write FVerticalOffset;
    property Placement: TvxPlacement read FPlacement write FPlacement default vgPlacementBottom;
    property PlacementTarget: TvxVisualObject read FPlacementTarget write FPlacementTarget;
    property PlacementRectangle: TvxBounds read FPlacementRectangle write SetPlacementRectangle;
    property StaysOpen: boolean read FStaysOpen write FStaysOpen default false;
    property Style: TvxResources read FStyle write FStyle;
    property DragWithParent: boolean read FDragWithParent write FDragWithParent default false;
    property OnClosePopup: TNotifyEvent read FOnClosePopup write FOnClosePopup;
    property Resource;
    property Visible default false;
  end;

  TvxPopupItem = class(TvxControl)
  private
    FPopup: TvxPopup;
    FPlacement: TvxPlacement;
    FHorizontalOffset: single;
    FVerticalOffset: single;
    procedure SetPlacement(Value: TvxPlacement);
    procedure SetHorizontalOffset(Value: single);
    procedure SetVerticalOffset(Value: single);
  protected
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadRect(Reader: TReader);
    procedure WriteRect(Writer: TWriter);
    procedure MouseEnter; override;
    procedure MouseLeave; override;
    procedure DesignClick; override;
    procedure ApplyPlacement;
    procedure DoClosePopup(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddObject(AObject: TvxObject); override;
    procedure Realign; override;
  published
    property Resource;
    property Placement: TvxPlacement read FPlacement write SetPlacement default vgPlacementBottom;
    property HorizontalOffset: single read FHorizontalOffset write SetHorizontalOffset;
    property VerticalOffset: single read FVerticalOffset write SetVerticalOffset;
  end;

  TvxMessageType = (vgMessageWarning, vgMessageError, vgMessageInformation, vgMessageConfirmation, vgMessageCustom);
  TvxMessageButton = (vgButtonYes, vgButtonNo, vgButtonOK, vgButtonCancel, vgButtonAbort, vgButtonRetry, vgButtonIgnore,
    vgButtonAll, vgButtonNoToAll, vgButtonYesToAll, vgButtonHelp);
  TvxMessageButtons = set of TvxMessageButton;

  TvxMessagePopup = class(TvxPopup)
  private
    FDisableScene: boolean;
  protected
    procedure ApplyPlacement; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function PopupModal: TModalResult; override;
  published
    property Resource;
    property StaysOpen default true;
    property DragWithParent default true;
    property DisableScene: boolean read FDisableScene write FDisableScene default true;
  end;

function MessagePopup(const ACaption, AMessage: WideString; AType: TvxMessageType;
  Buttons: TvxMessageButtons; const AOwner: IvgScene; const Target: TvxVisualObject = nil;
  const ADisableScene: boolean = true;
  const ABitmap: TvxBitmap = nil;
  const AStyle: TvxResources = nil): integer;

var
  vgSceneCount: integer = 0;
  aniThread: TvxTimer;
  ObjectList: TStringList;
  vgDesigner: TvxDesigner;
  DefaultCanvasClass: TvxCanvasClass;
  DefaultPrinterCanvasClass: TvxCanvasClass;
  DefaultFilterClass: TvxFilterClass;
  DefaultStyles: TvxObject;

procedure RegisterVGObject(const Category: string; const AObject: TvxObjectClass);
procedure RegisterVGObjects(const Category: string; AClasses: array of TvxObjectClass);

function CreateObjectFromStream(AOwner: TComponent; const AStream: TStream): TvxObject;
function CreateObjectFromBinStream(AOwner: TComponent; const AStream: TStream): TvxObject;
function LoadObjectFromStream(AObject: TvxObject; const AStream: TStream): TvxObject;

{ Variants }

function VarIsObject(Value: Variant): boolean;
function ObjectToVariant(const AObject: TObject): Variant;
function VariantToObject(const Value: Variant): TObject;

function VarIsEvent(Value: Variant): boolean;
function EventToVariant(const AMethod: TNotifyEvent): Variant;
function VariantToEvent(const Value: Variant): TNotifyEvent;

{ Resources }

procedure AddResource(const AObject: TvxObject);
procedure RemoveResource(const AObject: TvxObject);
function FindResource(const AResource: string): TvxObject;

{ Scenes }

procedure AddScene(const AScene: IvgScene);
procedure RemoveScene(const AScene: IvgScene);

{ Lang }

procedure LoadLangFromFile(AFileName: string);
procedure LoadLangFromStrings(AStr: TvxWideStrings);
procedure ResetLang;
procedure UpdateLang;

type

  TvxCustomTranslateProc = function(AText: WideString): WideString;

var
  CustomTranslateProc: TvxCustomTranslateProc;

  { This function use to collect string which can be translated. Just place this function at Application start. }
procedure CollectLangStart;
procedure CollectLangFinish;
{ This function return Strings with collected text }
function CollectLangStrings: TvxWideStrings;

function Translate(const AText: WideString): WideString;
function TranslateText(const AText: WideString): WideString;

{ Strings }

function vgPointToString(R: TvxPoint): Ansistring;
function vgStringToPoint(S: Ansistring): TvxPoint;

function vgRectToString(R: TvxRect): Ansistring;
function vgStringToRect(S: Ansistring): TvxRect;

function vgColorToStr(Value: TvxColor): string;
function vgStrToColor(Value: string): TvxColor;

function vgFloatToStr(Value: single): string;
function vgStrToFloat(Value: string): single;

{ Geometry }

procedure vgSinCos(const Theta: single; var Sin, Cos: single);
function vgRadToDeg(const Degrees: single): single;
function vgDegToRad(const Degrees: single): single;
function vgNormalizeAngle(const angle: Single): Single;
function vgPoint(X, Y: single): TvxPoint;
function vgMinPoint(P1, P2: TvxPoint): TvxPoint;
function vgScalePoint(P: TvxPoint; dx, dy: single): TvxPoint;
function vgRect(ALeft, ATop, ARight, ABottom: single): TvxRect;
function vgNormalizeRect(const Pts: array of TvxPoint): TvxRect;
function vgNormalizeRect2(const ARect: TvxRect): TvxRect;
function vgRectWidth(const R: TvxRect): single;
function vgRectHeight(const R: TvxRect): single;
function vgRectCenter(var R: TvxRect; Bounds: TvxRect): TvxRect;
function vgFitRect(var R: TvxRect; BoundsRect: TvxRect): single;
function vgIsRectEmpty(Rect: TvxRect): boolean;
procedure vgOffsetRect(var R: TvxRect; const Dx, Dy: single);
procedure vgMultiplyRect(var R: TvxRect; const Dx, Dy: single);
procedure vgInflateRect(var R: TvxRect; const Dx, Dy: single);
function vgIntersectRect(const Rect1, Rect2: TvxRect): boolean; overload;
function vgIntersectRect(var DestRect: TvxRect; const SrcRect1, SrcRect2: TvxRect): boolean; overload;
function vgPtInRect(const P: TvxPoint; const Rect: TvxRect): boolean;
function vgUnionRect(const ARect1, ARect2: TvxRect): TvxRect;
function vgPointFromVector(const v: TvxVector): TvxPoint;
function vgMatrixMultiply(const M1, M2: TvxMatrix): TvxMatrix;
function vgMatrixDeterminant(const M: TvxMatrix): single;
procedure vgAdjointMatrix(var M: TvxMatrix);
procedure vgScaleMatrix(var M: TvxMatrix; const factor: single);
procedure vgInvertMatrix(var M: TvxMatrix);
function vgVector(const x, y: Single; const w: single = 1.0): TvxVector; overload;
function vgVector(const P: TvxPoint; const w: single = 1.0): TvxVector; overload;
function vgVectorTransform(const V: TvxVector; const M: TvxMatrix): TvxVector;
function vgCreateRotationMatrix(angle: single): TvxMatrix;
function vgVectorAdd(const v1: TvxVector; const v2: TvxVector): TvxVector;
function vgVectorSubtract(const v1: TvxVector; const v2: TvxVector): TvxVector;
function vgVectorNorm(const v: TvxVector): Single;
function vgVectorNormalize(const v: TvxVector): TvxVector;
function vgVectorScale(const v: TvxVector; factor: Single): TvxVector;
function vgVectorLength(const v: TvxVector): Single;
function vgVectorDotProduct(const V1, V2: TvxVector): Single;
function vgVectorAngleCosine(const V1, V2: TvxVector): Single;
function vgVectorCrossProductZ(const V1, V2: TvxVector): single;
function vgVectorCombine2(const V1, V2: TvxVector; const F1, F2: Single): TvxVector;
function vgVectorReflect(const V, N: TvxVector): TvxVector;
function vgVectorAngle(const V, N: TvxVector): single;

{ Colors }

function vgAppendColor(start, stop: TvxColor): TvxColor;
function vgSubtractColor(start, stop: TvxColor): TvxColor;
function vgRGBtoBGR(const C: TvxColor): TvxColor;
{$IFNDEF NOVCL}
function vgColorFromVCL(const C: TColor): TvxColor;
{$ENDIF}
function vgCorrectColor(const C: TvxColor): TvxColor;
function vgPremultyAlpha(const C: TvxColor): TvxColor;
function vgUnpremultyAlpha(const C: TvxColor): TvxColor;
function vgOpacity(const C: TvxColor; const AOpacity: single): TvxColor;
function vgColor(R, G, B: Byte; A: Byte = $FF): TvxColor;
function vgHSLtoRGB(H, S, L: Single): TvxColor;
procedure vgRGBtoHSL(RGB: TvxColor; out H, S, L: single);
function vgChangeHSL(const C: TvxColor; dH, dS, dL: single): TvxColor;

{ Animation }

function vgInterpolateSingle(const start, stop, t: single): single;
function vgInterpolateRotation(start, stop, t: Single): Single;
function vgInterpolateColor(start, stop: TvxColor; t: single): TvxColor;

function vgInterpolateLinear(T, B, C, D: Double): Double;
function vgInterpolateSine(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateQuint(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateQuart(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateQuad(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateExpo(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateElastic(T, B, C, D, A, P: Double; aType: TvxAnimationType): Double;
function vgInterpolateCubic(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateCirc(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateBounce(T, B, C, D: Double; aType: TvxAnimationType): Double;
function vgInterpolateBack(T, B, C, D, S: Double; aType: TvxAnimationType): Double;

{ Help functions }

procedure vgReverseBytes(p: Pointer; Count: integer);
procedure vgMoveLongword(const Src: Pointer; Dst: Pointer; Count: Integer);
procedure vgFillLongword(Src: Pointer; Count: Integer; Value: Longword);
procedure vgFillAlpha(Src: Pointer; Count: Integer; Alpha: byte);
procedure vgFillLongwordRect(Src: Pointer; W, H, X1, Y1, X2, Y2: Integer; Value: Longword);
function vgGetToken(var S: Ansistring; Separators: Ansistring; Stop: Ansistring = ''): Ansistring;
function vgWideGetToken(var Pos: integer; const S: WideString; Separators: WideString; Stop: WideString = ''): WideString;
function vgMaxFloat(A1, A2: single): single;
function vgMinFloat(A1, A2: single): single;
function vgMinMax(x, mi, ma: single): single;

{$IFDEF WINDOWS}
procedure UseDirect2DCanvas;
{$ENDIF}

type

  TvxColorAnimation = class(TvxAnimation)
  private
    FStartColor: TvxColor;
    FStopColor: TvxColor;
    FPath, FPropertyName: AnsiString;
    FInstance: TObject;
    FStartFromCurrent: boolean;
    function GetStartColor: string;
    function GetStopColor: string;
    procedure SetStartColor(const Value: string);
    procedure SetStopColor(const Value: string);
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property StartValue: string read GetStartColor write SetStartColor;
    property StartFromCurrent: boolean read FStartFromCurrent write FStartFromCurrent default false;
    property StopValue: string read GetStopColor write SetStopColor;
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
  end;

  TvxGradientAnimation = class(TvxAnimation)
  private
    FStartGradient: TvxGradient;
    FStopGradient: TvxGradient;
    FPath, FPropertyName: AnsiString;
    FInstance: TObject;
    FStartFromCurrent: boolean;
    procedure SetStartGradient(const Value: TvxGradient);
    procedure SetStopGradient(const Value: TvxGradient);
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property StartValue: TvxGradient read FStartGradient write SetStartGradient;
    property StartFromCurrent: boolean read FStartFromCurrent write FStartFromCurrent default false;
    property StopValue: TvxGradient read FStopGradient write SetStopGradient;
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
  end;

  TvxFloatAnimation = class(TvxAnimation)
  private
    FStartFloat: single;
    FStopFloat: single;
    FPath, FPropertyName: AnsiString;
    FInstance: TObject;
    FStartFromCurrent: boolean;
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
    procedure Stop; override;
  published
    property StartValue: single read FStartFloat write FStartFloat stored true;
    property StartFromCurrent: boolean read FStartFromCurrent write FStartFromCurrent default false;
    property StopValue: single read FStopFloat write FStopFloat stored true;
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
  end;

  TvxRectAnimation = class(TvxAnimation)
  private
    FStartRect: TvxBounds;
    FCurrent: TvxBounds;
    FStopRect: TvxBounds;
    FPath, FPropertyName: AnsiString;
    FInstance: TObject;
    FStartFromCurrent: boolean;
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property StartValue: TvxBounds read FStartRect write FStartRect;
    property StartFromCurrent: boolean read FStartFromCurrent write FStartFromCurrent default false;
    property StopValue: TvxBounds read FStopRect write FStopRect;
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
  end;

  TvxBitmapAnimation = class(TvxAnimation)
  private
    FPropertyName: AnsiString;
    FInstance: TObject;
    FStartBitmap: TvxBitmap;
    FStopBitmap: TvxBitmap;
    FCurrent: TvxBitmap;
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property StartValue: TvxBitmap read FStartBitmap write FStartBitmap;
    property StopValue: TvxBitmap read FStopBitmap write FStopBitmap;
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
  end;

  TvxBitmapListAnimation = class(TvxAnimation)
  private
    FPropertyName: AnsiString;
    FInstance: TObject;
    FCurrent: TvxBitmap;
    FAnimationCount: Integer;
    FAnimationBitmap: TvxBitmap;
    FLastAnimationStep: Integer;
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
    property AnimationBitmap: TvxBitmap read FAnimationBitmap write FAnimationBitmap;
    property AnimationCount: Integer read FAnimationCount write FAnimationCount;
  end;

  { Key Animations }

  TvxKey = class(TCollectionItem)
  private
    FKey: single;
    procedure SetKey(const Value: single);
  public
  published
    property Key: single read FKey write SetKey;
  end;

  TvxKeys = class(TCollection)
  private
  public
    function FindKeys(const Time: single; var Key1, Key2: TvxKey): boolean;
  published
  end;

  TvxColorKey = class(TvxKey)
  private
    FValue: string;
  public
  published
    property Value: string read FValue write FValue;
  end;

  TvxColorKeyAnimation = class(TvxAnimation)
  private
    FPropertyName: AnsiString;
    FInstance: TObject;
    FKeys: TvxKeys;
    FPath: AnsiString;
    FStartFromCurrent: boolean;
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
    property Keys: TvxKeys read FKeys write FKeys;
    property StartFromCurrent: boolean read FStartFromCurrent write FStartFromCurrent;
  end;

  TvxFloatKey = class(TvxKey)
  private
    FValue: single;
  public
  published
    property Value: single read FValue write FValue;
  end;

  TvxFloatKeyAnimation = class(TvxAnimation)
  private
    FPropertyName: AnsiString;
    FInstance: TObject;
    FKeys: TvxKeys;
    FPath: AnsiString;
    FStartFromCurrent: boolean;
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
    property Keys: TvxKeys read FKeys write FKeys;
    property StartFromCurrent: boolean read FStartFromCurrent write FStartFromCurrent;
  end;

  { Path Animation }

  TvxPathAnimation = class(TvxAnimation)
  private
    FPath: TvxPathData;
    FPolygon: TvxPolygon;
    FObj: TvxVisualObject;
    FStart: TvxPoint;
    FRotate: boolean;
    FSpline: TvxSpline;
    procedure SetPath(const Value: TvxPathData);
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property Path: TvxPathData read FPath write SetPath;
    property Rotate: boolean read FRotate write FRotate default false;
  end;

  { Switch Animations }

  TvxPathSwitcher = class(TvxAnimation)
  private
    FPath, FPropertyName: AnsiString;
    FInstance: TObject;
    FPathTrue: string;
    FPathFalse: string;
    procedure SetPathFalse(const Value: string);
    procedure SetPathTrue(const Value: string);
  protected
    procedure ProcessAnimation; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Start; override;
  published
    property PathTrue: string read FPathTrue write SetPathTrue;
    property PathFalse: string read FPathFalse write SetPathFalse;
    property PropertyName: AnsiString read FPropertyName write FPropertyName;
  end;

type

  TvxShadowEffect = class(TvxEffect)
  private
    FDistance: single;
    FSoftness: single;
    FShadowColor: TvxColor;
    FOpacity: single;
    FDirection: single;
    procedure SetDistance(const Value: single);
    procedure SetSoftness(const Value: single);
    procedure SetShadowColor(const Value: string);
    procedure SetOpacity(const Value: single);
    function GetShadowColor: string;
    procedure SetDirection(const Value: single);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; override;
    function GetOffset: TvxPoint; override;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); override;
  published
    property Distance: single read FDistance write SetDistance;
    property Direction: single read FDirection write SetDirection;
    property Softness: single read FSoftness write SetSoftness;
    property Opacity: single read FOpacity write SetOpacity;
    property ShadowColor: string read GetShadowColor write SetShadowColor;
  end;

  TvxBlurEffect = class(TvxEffect)
  private
    FSoftness: single;
    procedure SetSoftness(const Value: single);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; override;
    function GetOffset: TvxPoint; override;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); override;
  published
    property Softness: single read FSoftness write SetSoftness;
  end;

  TvxGlowEffect = class(TvxEffect)
  private
    FSoftness: single;
    FGlowColor: TvxColor;
    FOpacity: single;
    procedure SetSoftness(const Value: single);
    procedure SetOpacity(const Value: single);
    function GetGlowColor: string;
    procedure SetGlowColor(const Value: string);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; override;
    function GetOffset: TvxPoint; override;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); override;
  published
    property Softness: single read FSoftness write SetSoftness;
    property Opacity: single read FOpacity write SetOpacity;
    property GlowColor: string read GetGlowColor write SetGlowColor;
  end;

  TvxInnerGlowEffect = class(TvxGlowEffect)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; override;
    function GetOffset: TvxPoint; override;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); override;
  published
  end;

  TvxBevelEffect = class(TvxEffect)
  private
    FDirection: single;
    FSize: integer;
    procedure SetDirection(const Value: single);
    procedure SetSize(const Value: integer);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; override;
    function GetOffset: TvxPoint; override;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); override;
  published
    property Direction: single read FDirection write SetDirection;
    property Size: integer read FSize write SetSize;
  end;

  TvxReflectionEffect = class(TvxEffect)
  private
    FOffset: integer;
    FOpacity: single;
    FLength: single;
    procedure SetOpacity(const Value: single);
    procedure SetOffset(const Value: integer);
    procedure SetLength(const Value: single);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function GetRect(const ARect: TvxRect): TvxRect; override;
    function GetOffset: TvxPoint; override;
    procedure ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single); override;
  published
    property Opacity: single read FOpacity write SetOpacity;
    property Offset: integer read FOffset write SetOffset;
    property Length: single read FLength write SetLength;
  end;

procedure Blur(const Canvas: TvxCanvas; const Bitmap: TvxBitmap; const Radius: integer; UseAlpha: boolean = true);

type

  { TvxShape }

  TvxShape = class(TvxVisualObject)
  private
    FFill: TvxBrush;
    FStrokeThickness: single;
    FStroke: TvxBrush;
    FStrokeCap: TvxStrokeCap;
    FStrokeJoin: TvxStrokeJoin;
    FStrokeDash: TvxStrokeDash;
    procedure SetFill(const Value: TvxBrush);
    procedure SetStroke(const Value: TvxBrush);
    procedure SetStrokeThickness(const Value: single);
    function isStrokeThicknessStored: Boolean;
    procedure SetStrokeCap(const Value: TvxStrokeCap);
    procedure SetStrokeJoin(const Value: TvxStrokeJoin);
    procedure SetStrokeDash(const Value: TvxStrokeDash);
  protected
    procedure FillChanged(Sender: TObject); virtual;
    procedure StrokeChanged(Sender: TObject); virtual;
    //    function GetUpdateRect: TvxRect; override;
    function GetShapeRect: TvxRect;
    procedure BeforePaint; override;
    procedure AfterPaint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property Fill: TvxBrush read FFill write SetFill;
    property Stroke: TvxBrush read FStroke write SetStroke;
    property StrokeThickness: single read FStrokeThickness write SetStrokeThickness stored isStrokeThicknessStored;
    property StrokeCap: TvxStrokeCap read FStrokeCap write SetStrokeCap default vgCapFlat;
    property StrokeDash: TvxStrokeDash read FStrokeDash write SetStrokeDash default vgDashSolid;
    property StrokeJoin: TvxStrokeJoin read FStrokeJoin write SetStrokeJoin default vgJoinMiter;
    property ShapeRect: TvxRect read GetShapeRect;
  published
  end;

  TvxLineType = (
    vgLineNormal,
    vgLineHorizontal,
    vgLineVertical
    );

  TvxLine = class(TvxShape)
  private
    FLineType: TvxLineType;
    procedure SetLineType(const Value: TvxLineType);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    procedure Paint; override;
  published
    property Stroke;
    property StrokeCap;
    property StrokeDash;
    property StrokeJoin;
    property StrokeThickness;
    property LineType: TvxLineType read FLineType write SetLineType;
  end;

  TvxRectangle = class(TvxShape)
  private
    FyRadius: single;
    FxRadius: single;
    FCorners: TvxCorners;
    FCornerType: TvxCornerType;
    FSides: TvxSides;
    function IsCornersStored: Boolean;
    function IsSidesStored: Boolean;
  protected
    procedure SetxRadius(const Value: single); virtual;
    procedure SetyRadius(const Value: single); virtual;
    procedure SetCorners(const Value: TvxCorners); virtual;
    procedure SetCornerType(const Value: TvxCornerType); virtual;
    procedure SetSides(const Value: TvxSides); virtual;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Fill;
    property Stroke;
    property StrokeCap;
    property StrokeDash;
    property StrokeJoin;
    property StrokeThickness;
    property xRadius: single read FxRadius write SetxRadius;
    property yRadius: single read FyRadius write SetyRadius;
    property Corners: TvxCorners read FCorners write SetCorners stored IsCornersStored;
    property CornerType: TvxCornerType read FCornerType write SetCornerType default vgCornerRound;
    property Sides: TvxSides read FSides write SetSides stored IsSidesStored;
  end;

  TvxSidesRectangle = class(TvxRectangle)
  end;

  TvxBlurRectangle = class(TvxRectangle)
  private
    FBuffer: TvxBitmap;
    FSoftness: single;
    FRecreate: boolean;
    procedure SetSoftness(const Value: single);
  protected
    procedure FillChanged(Sender: TObject); override;
    procedure SetxRadius(const Value: single); override;
    procedure SetyRadius(const Value: single); override;
    procedure SetCorners(const Value: TvxCorners); override;
    procedure SetCornerType(const Value: TvxCornerType); override;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Softness: single read FSoftness write SetSoftness;
  end;

  TvxRoundRect = class(TvxShape)
  private
    FCorners: TvxCorners;
    function IsCornersStored: Boolean;
  protected
    procedure SetCorners(const Value: TvxCorners); virtual;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Fill;
    property Stroke;
    property StrokeCap;
    property StrokeDash;
    property StrokeJoin;
    property StrokeThickness;
    property Corners: TvxCorners read FCorners write SetCorners stored IsCornersStored;
  end;

  TvxBlurRoundRect = class(TvxRoundRect)
  private
    FBuffer: TvxBitmap;
    FSoftness: single;
    FRecreate: boolean;
    procedure SetSoftness(const Value: single);
  protected
    procedure SetCorners(const Value: TvxCorners); override;
    procedure FillChanged(Sender: TObject); override;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Softness: single read FSoftness write SetSoftness;
  end;

  TvxCalloutPosition = (
    vgCalloutTop,
    vgCalloutLeft,
    vgCalloutBottom,
    vgCalloutRight
    );

  TvxCalloutRectangle = class(TvxRectangle)
  private
    FPath: TvxPathData;
    FCalloutWidth: single;
    FCalloutLength: single;
    FCalloutPosition: TvxCalloutPosition;
    FCalloutOffset: single;
    procedure SetCalloutWidth(const Value: single);
    procedure SetCalloutLength(const Value: single);
    procedure SetCalloutPosition(const Value: TvxCalloutPosition);
    procedure SetCalloutOffset(const Value: single);
  protected
    procedure CreatePath;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Fill;
    property CalloutWidth: single read FCalloutWidth write SetCalloutWidth;
    property CalloutLength: single read FCalloutLength write SetCalloutLength;
    property CalloutPosition: TvxCalloutPosition read FCalloutPosition write SetCalloutPosition default vgCalloutTop;
    property CalloutOffset: single read FCalloutOffset write SetCalloutOffset;
    property Stroke;
    property StrokeCap;
    property StrokeDash;
    property StrokeJoin;
    property StrokeThickness;
  end;

  TvxEllipse = class(TvxShape)
  private
  protected
    function PointInObject(X, Y: single): boolean; override;
    procedure Paint; override;
  public
  published
    property Fill;
    property Stroke;
    property StrokeCap;
    property StrokeDash;
    property StrokeJoin;
    property StrokeThickness;
  end;

  TvxCircle = class(TvxEllipse)
  private
  protected
    procedure Paint; override;
  public
  published
  end;

  TvxPie = class(TvxEllipse)
  private
    FStartAngle: single;
    FEndAngle: single;
    procedure SetEndAngle(const Value: single);
    procedure SetStartAngle(const Value: single);
  protected
    function PointInObject(X, Y: single): boolean; override;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property StartAngle: single read FStartAngle write SetStartAngle;
    property EndAngle: single read FEndAngle write SetEndAngle;
  end;

  TvxArc = class(TvxEllipse)
  private
    FStartAngle: single;
    FEndAngle: single;
    procedure SetEndAngle(const Value: single);
    procedure SetStartAngle(const Value: single);
  protected
    function PointInObject(X, Y: single): boolean; override;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property StartAngle: single read FStartAngle write SetStartAngle;
    property EndAngle: single read FEndAngle write SetEndAngle;
  end;

  TvxPathWrap = (
    vgPathOriginal,
    vgPathFit,
    vgPathStretch,
    vgPathTile
    );

  TvxCustomPath = class(TvxShape)
  private
    FData: TvxPathData;
    FWrapMode: TvxPathWrap;
    procedure SetData(const Value: TvxPathData);
    procedure SetWrapMode(const Value: TvxPathWrap);
  protected
    function PointInObject(X, Y: single): boolean; override;
    procedure DoChanged(Sender: TObject);
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property Data: TvxPathData read FData write SetData;
    property WrapMode: TvxPathWrap read FWrapMode write SetWrapMode default vgPathStretch;
  published
    property Fill;
    property Stroke;
    property StrokeCap;
    property StrokeDash;
    property StrokeJoin;
    property StrokeThickness;
  end;

  TvxPath = class(TvxCustomPath)
  private
  published
    property Data;
    property WrapMode;
  end;

  TvxText = class(TvxShape)
  private
    FText: WideString;
    FFont: TvxFont;
    FVertTextAlign: TvxTextAlign;
    FHorzTextAlign: TvxTextAlign;
    FWordWrap: boolean;
    FAutoSize: boolean;
    FStretch: boolean;
    procedure SetText(const Value: WideString);
    procedure SetFont(const Value: TvxFont);
    procedure SetHorzTextAlign(const Value: TvxTextAlign);
    procedure SetVertTextAlign(const Value: TvxTextAlign);
    procedure SetWordWrap(const Value: boolean);
    procedure SetAutoSize(const Value: boolean);
    procedure SetStretch(const Value: boolean);
  protected
    procedure FontChanged(Sender: TObject); virtual;
    procedure Paint; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure AdjustSize;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
  published
    property AutoSize: boolean read FAutoSize write SetAutoSize default false;
    property Fill;
    property Font: TvxFont read FFont write SetFont;
    property HorzTextAlign: TvxTextAlign read FHorzTextAlign write SetHorzTextAlign default vgTextAlignCenter;
    property VertTextAlign: TvxTextAlign read FVertTextAlign write SetVertTextAlign default vgTextAlignCenter;
    property Text: WideString read FText write SetText;
    property Stretch: boolean read FStretch write SetStretch default false;
    property WordWrap: boolean read FWordWrap write SetWordWrap default true;
  end;

  TvxImageWrap = (
    vgImageOriginal,
    vgImageFit,
    vgImageStretch,
    vgImageTile
    );

  { TvxImage }

  TvxImage = class(TvxVisualObject)
  private
    FBitmap: TvxBitmap;
    // FBuffer: TvxBitmap;
    FStretchThread: TThread;
    FOnBitmapLoaded: TNotifyEvent;
    FBitmapMargins: TvxBounds;
    FWrapMode: TvxImageWrap;
    FDisableInterpolation: boolean;

    fSelected: Boolean;
    procedure SetBitmap(const Value: TvxBitmap);
    procedure SetWrapMode(const Value: TvxImageWrap);
    procedure SetSelected(const Value: Boolean);
  protected
    procedure DoBitmapLoaded(Sender: TObject);
    procedure DoBitmapDestroy(Sender: TObject);
    procedure DoBitmapChanged(Sender: TObject); virtual;
    procedure Loaded; override;
    procedure Realign; override;
    procedure Paint; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property Selected: Boolean read fSelected write SetSelected;
  published
    property Bitmap: TvxBitmap read FBitmap write SetBitmap;
    property BitmapMargins: TvxBounds read FBitmapMargins write FBitmapMargins;
    property WrapMode: TvxImageWrap read FWrapMode write SetWrapMode;
    property DisableInterpolation: boolean read FDisableInterpolation write FDisableInterpolation default false;
    property OnBitmapLoaded: TNotifyEvent read FOnBitmapLoaded write FOnBitmapLoaded;
  end;

  TvxPaintEvent = procedure(Sender: TObject; const Canvas: TvxCanvas) of object;

  TvxPaintBox = class(TvxVisualObject)
  private
    FOnPaint: TvxPaintEvent;
  protected
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property OnPaint: TvxPaintEvent read FOnPaint write FOnPaint;
  end;

  TvxSelection = class(TvxVisualObject)
  private
    FParentBounds: boolean;
    FOnChange: TNotifyEvent;
    FHideSelection: boolean;
    FMinSize: integer;
    FOnTrack: TNotifyEvent;
    FProportional: boolean;
    FGripSize: single;
    procedure SetHideSelection(const Value: boolean);
    procedure SetMinSize(const Value: integer);
    procedure SetGripSize(const Value: single);
  protected
    FRatio: single;
    FMove, FLeftTop, FLeftBottom, FRightTop, FRightBottom: boolean;
    FLeftTopHot, FLeftBottomHot, FRightTopHot, FRightBottomHot: boolean;
    FDownPos, FMovePos: TvxPoint;
    function GetAbsoluteRect: TvxRect; override;
    function PointInObject(X, Y: single): boolean; override;
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseLeave; override;
  published
    property GripSize: single read FGripSize write SetGripSize;
    property ParentBounds: boolean read FParentBounds write FParentBounds default true;
    property HideSelection: boolean read FHideSelection write SetHideSelection;
    property MinSize: integer read FMinSize write SetMinSize default 15;
    property Proportional: boolean read FProportional write FProportional;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnTrack: TNotifyEvent read FOnTrack write FOnTrack;
  end;

  TvxSelectionPoint = class(TvxVisualObject)
  private
    FOnChange: TNotifyEvent;
    FOnTrack: TNotifyEvent;
    FParentBounds: boolean;
    FGripSize: single;
    procedure SetGripSize(const Value: single);
  protected
    FPressed: boolean;
    procedure Paint; override;
    procedure SetHeight(const Value: single); override;
    procedure SetWidth(const Value: single); override;
    function PointInObject(X, Y: single): boolean; override;
    function GetUpdateRect: TvxRect; override;
    procedure MouseEnter; override;
    procedure MouseLeave; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
  published
    property GripSize: single read FGripSize write SetGripSize;
    property ParentBounds: boolean read FParentBounds write FParentBounds default true;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnTrack: TNotifyEvent read FOnTrack write FOnTrack;
  end;

  TvxDesignFrame = class(TvxVisualObject)
  private
    FOnChange: TNotifyEvent;
    FOnTrack: TNotifyEvent;
  protected
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseLeave; override;
  published
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnTrack: TNotifyEvent read FOnTrack write FOnTrack;
  end;

  TvxScrollArrowLeft = class(TvxCustomPath)
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxScrollArrowRight = class(TvxCustomPath)
  public
    constructor Create(AOwner: TComponent); override;
  end;

type

  TvxSelectionItem = class(TvxControl) { Deprecated }
  private
  protected
    procedure PaintChildren; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure Paint; override;
  published
    property Resource;
  end;

  TvxPanel = class(TvxControl)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Resource;
  end;

  TvxCalloutPanel = class(TvxPanel)
  private
    FCalloutLength: single;
    FCalloutWidth: single;
    FCalloutPosition: TvxCalloutPosition;
    FCalloutOffset: single;
    procedure SetCalloutLength(const Value: single);
    procedure SetCalloutPosition(const Value: TvxCalloutPosition);
    procedure SetCalloutWidth(const Value: single);
    procedure SetCalloutOffset(const Value: single);
  protected
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property CalloutWidth: single read FCalloutWidth write SetCalloutWidth;
    property CalloutLength: single read FCalloutLength write SetCalloutLength;
    property CalloutPosition: TvxCalloutPosition read FCalloutPosition write SetCalloutPosition default vgCalloutTop;
    property CalloutOffset: single read FCalloutOffset write SetCalloutOffset;
  end;

  TvxStatusBar = class(TvxControl)
  private
    FShowSizeGrip: boolean;
    procedure SetShowSizeGrip(const Value: boolean);
  protected
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Align default vaBottom;
    property Resource;
    property ShowSizeGrip: boolean read FShowSizeGrip write SetShowSizeGrip;
  end;

  TvxToolBar = class(TvxControl)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Align default vaTop;
    property Resource;
  end;

  TvxTextControl = class(TvxControl)
  private
    FFont: TvxFont;
    FTextAlign: TvxTextAlign;
    FVertTextAlign: TvxTextAlign;
    FFontFill: TvxBrush;
    FWordWrap: boolean;
    function GetText: WideString;
    procedure SetFont(const Value: TvxFont);
    procedure SetTextAlign(const Value: TvxTextAlign);
    procedure SetVertTextAlign(const Value: TvxTextAlign);
    procedure SetFontFill(const Value: TvxBrush);
    procedure FontFillChanged(Sender: TObject);
    procedure SetWordWrap(const Value: boolean);
  protected
    FText: WideString;
    procedure ApplyStyle; override;
    procedure SetText(const Value: WideString); virtual;
    procedure FontChanged(Sender: TObject); virtual;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property Font: TvxFont read FFont write SetFont;
    property FontFill: TvxBrush read FFontFill write SetFontFill;
    property Text: WideString read GetText write SetText;
    property VertTextAlign: TvxTextAlign read FVertTextAlign write SetVertTextAlign;
    property TextAlign: TvxTextAlign read FTextAlign write SetTextAlign;
    property WordWrap: boolean read FWordWrap write SetWordWrap default false;
  published
  end;

  TvxLabel = class(TvxTextControl)
  private
    FWordWrap: boolean;
    FAutoSize: boolean;
    procedure SetWordWrap(const Value: boolean);
    procedure SetAutoSize(const Value: boolean);
  protected
    procedure ApplyStyle; override;
    procedure SetText(const Value: WideString); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property AutoSize: boolean read FAutoSize write SetAutoSize default false;
    property AutoTranslate default true;
    property BindingSource;
    property Font;
    property TextAlign;
    property VertTextAlign;
    property Text;
    property Resource;
    property HitTest default false;
    property WordWrap: boolean read FWordWrap write SetWordWrap default true;
  end;

  TvxValueLabel = class(TvxLabel)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
    property AutoTranslate default false;
    property WordWrap default false;
  end;

  TvxCustomButton = class(TvxTextControl)
  private
    FPressing: boolean;
    FIsPressed: boolean;
    FModalResult: TModalResult;
    FStaysPressed: boolean;
    FRepeatTimer: TvxTimer;
    FRepeat: boolean;
    fChecked: Boolean;
    procedure SetIsPressed(const Value: boolean);
  protected
    procedure Click; override;
    procedure DblClick; override;
    procedure SetData(const Value: Variant); override;
    procedure ApplyStyle; override;
    procedure DoRepeatTimer(Sender: TObject);
    procedure DoRepeatDelayTimer(Sender: TObject);

    procedure SetChecked(const Value: boolean);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
  published
    {$IFNDEF NOVCL}
    property Action;
    {$ENDIF}
    property AutoTranslate default true;
    property StaysPressed: boolean read FStaysPressed write FStaysPressed;
    { triggers }
    property IsPressed: boolean read FIsPressed write SetIsPressed;
    property Checked: boolean read fChecked write SetChecked;
    { props }
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Font;
    property ModalResult: TModalResult read FModalResult write FModalResult default mrNone;
    property TextAlign;
    property Text;
    property RepeatClick: boolean read FRepeat write FRepeat default false;
    property WordWrap default false;
    property Resource;
  end;

  TvxButton = class(TvxCustomButton)
  private
    FDefault: boolean;
    FCancel: boolean;
  protected
    procedure DialogKey(var Key: Word; Shift: TShiftState); override;
  public
  published
    property CanFocused default true;
    property DisableFocusEffect;
    property Default: boolean read FDefault write FDefault default false;
    property Cancel: boolean read FCancel write FCancel default false;
    property TabOrder;
  end;

  TvxRoundButton = class(TvxButton)
  private
  protected
  public
  published
  end;

  TvxCircleButton = class(TvxButton)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxPopupButton = class(TvxButton)
  private
    {$IFNDEF NOVCL}
    FPopupMenu: TPopupMenu;
    {$ENDIF}
  protected
    procedure Click; override;
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    {$IFNDEF NOVCL}
    property PopupMenu: TPopupMenu read FPopupMenu write FPopupMenu;
    {$ENDIF}
  end;

  TvxButtonLayout = (
    vgGlyphLeft,
    vgGlyphRight,
    vgGlyphTop,
    vgGlyphBottom,
    vgGlyphCenter
    );

  TvxBitmapButton = class(TvxCustomButton)
  private
    FBitmap: TvxBitmap;
    FBitmapLayout: TvxButtonLayout;
    FBitmapSpacing: single;
    FBitmapSize: single;
    FBitmapPadding: single;
    procedure SetBitmap(const Value: TvxBitmap);
    procedure SetBitmapLayout(const Value: TvxButtonLayout);
    procedure SetBitmapSpacing(const Value: single);
    procedure SetBitmapSize(const Value: single);
    procedure SetBitmapPadding(const Value: single);
  protected
    {$IFNDEF NOVCL}
    procedure ActionChange(Sender: TObject; CheckDefaults: Boolean); override;
    {$ENDIF}
    procedure DoBitmapChanged(Sender: TObject);
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Bitmap: TvxBitmap read FBitmap write SetBitmap;
    property BitmapLayout: TvxButtonLayout read FBitmapLayout write SetBitmapLayout default vgGlyphLeft;
    property BitmapSpacing: single read FBitmapSpacing write SetBitmapSpacing;
    property BitmapSize: single read FBitmapSize write SetBitmapSize;
    property BitmapPadding: single read FBitmapPadding write SetBitmapPadding;
  end;

  TvxPathButton = class(TvxCustomButton)
  private
    FPath: TvxPathData;
    FPathLayout: TvxButtonLayout;
    FPathSize: single;
    FPathSpacing: single;
    FPathPadding: single;
    FStrokeThickness: single;
    FFill: TvxBrush;
    FStroke: TvxBrush;
    FStrokeCap: TvxStrokeCap;
    FStrokeDash: TvxStrokeDash;
    FStrokeJoin: TvxStrokeJoin;
    procedure SetPath(const Value: TvxPathData);
    procedure SetPathLayout(const Value: TvxButtonLayout);
    procedure SetPathPadding(const Value: single);
    procedure SetPathSize(const Value: single);
    procedure SetPathSpacing(const Value: single);
    function isStrokeThicknessStored: Boolean;
    procedure SetFill(const Value: TvxBrush);
    procedure SetStroke(const Value: TvxBrush);
    procedure SetStrokeCap(const Value: TvxStrokeCap);
    procedure SetStrokeDash(const Value: TvxStrokeDash);
    procedure SetStrokeJoin(const Value: TvxStrokeJoin);
    procedure SetStrokeThickness(const Value: single);
  protected
    procedure DoPathChanged(Sender: TObject);
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Path: TvxPathData read FPath write SetPath;
    property PathLayout: TvxButtonLayout read FPathLayout write SetPathLayout default vgGlyphLeft;
    property PathSpacing: single read FPathSpacing write SetPathSpacing;
    property PathSize: single read FPathSize write SetPathSize;
    property PathPadding: single read FPathPadding write SetPathPadding;
    property PathFill: TvxBrush read FFill write SetFill;
    property PathStroke: TvxBrush read FStroke write SetStroke;
    property PathStrokeThickness: single read FStrokeThickness write SetStrokeThickness stored isStrokeThicknessStored;
    property PathStrokeCap: TvxStrokeCap read FStrokeCap write SetStrokeCap default vgCapFlat;
    property PathStrokeDash: TvxStrokeDash read FStrokeDash write SetStrokeDash default vgDashSolid;
    property PathStrokeJoin: TvxStrokeJoin read FStrokeJoin write SetStrokeJoin default vgJoinMiter;
  end;

  TvxToolButton = class(TvxBitmapButton)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;

    procedure Paint; override;
    procedure ApplyStyle; override;
  published
    property CanFocused default false;
    property TabOrder;
    property BitmapLayout default vgGlyphTop;
  end;

  TvxToolPathButton = class(TvxPathButton)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
    property CanFocused default false;
    property TabOrder;
    property PathLayout default vgGlyphTop;
  end;

  TvxBitmapStateButton = class(TvxCustomButton)
  private
    FBitmap: TvxBitmap;
    FBitmapDown: TvxBitmap;
    FBitmapHot: TvxBitmap;
    procedure SetBitmap(const Value: TvxBitmap);
    procedure SetBitmapDown(const Value: TvxBitmap);
    procedure SetBitmapHot(const Value: TvxBitmap);
  protected
    procedure DoBitmapChanged(Sender: TObject);
    procedure ApplyStyle; override;
    procedure Paint; override;
    procedure MouseEnter; override;
    procedure MouseLeave; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure StartTriggerAnimation(AInstance: TvxObject; ATrigger: string); override;
  published
    property Bitmap: TvxBitmap read FBitmap write SetBitmap;
    property BitmapHot: TvxBitmap read FBitmapHot write SetBitmapHot;
    property BitmapDown: TvxBitmap read FBitmapDown write SetBitmapDown;
  end;

  TvxSpeedButton = class(TvxCustomButton)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property CanFocused default false;
    property RepeatClick default true;
    property TabOrder;
  end;

  TvxColorButton = class(TvxCustomButton)
  private
    FFill: TvxShape;
    FColor: string;
    FOnChange: TNotifyEvent;
    FUseStandardDialog: boolean;
    procedure SetColor(const Value: string);
  protected
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure Click; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property AutoTranslate default false;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Color: string read FColor write SetColor;
    property UseStandardDialog: boolean read FUseStandardDialog write FUseStandardDialog default true;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCornerButton = class(TvxCustomButton)
  private
    FyRadius: single;
    FxRadius: single;
    FCorners: TvxCorners;
    FCornerType: TvxCornerType;
    FSides: TvxSides;
    function IsCornersStored: Boolean;
    procedure SetxRadius(const Value: single);
    procedure SetyRadius(const Value: single);
    procedure SetCorners(const Value: TvxCorners);
    procedure SetCornerType(const Value: TvxCornerType);
    procedure SetSides(const Value: TvxSides);
    function IsSidesStored: Boolean;
  protected
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property xRadius: single read FxRadius write SetxRadius;
    property yRadius: single read FyRadius write SetyRadius;
    property Corners: TvxCorners read FCorners write SetCorners stored IsCornersStored;
    property CornerType: TvxCornerType read FCornerType write SetCornerType default vgCornerRound;
    property Sides: TvxSides read FSides write SetSides stored IsSidesStored;
  end;

  TvxCheckBox = class(TvxTextControl)
  private
    FPressing: boolean;
    FOnChange: TNotifyEvent;
    FIsPressed: boolean;
    FIsChecked: boolean;
    procedure SetIsChecked(const Value: boolean);
  protected
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  published
    { triggers }
    property IsPressed: boolean read FIsPressed;
    property IsChecked: boolean read FIsChecked write SetIsChecked;
    { props }
    property AutoTranslate default true;
    property BindingSource;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Font;
    property TextAlign;
    property Text;
    property Resource;
    property WordWrap;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxPathCheckBox = class(TvxCheckBox)
  private
    FPath: TvxPathData;
    procedure SetPath(const Value: TvxPathData);
  protected
    procedure ApplyStyle; override;
    procedure DoPathChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Resource;
    property Path: TvxPathData read FPath write SetPath;
  end;

  TvxRadioButton = class(TvxTextControl)
  private
    FPressing: boolean;
    FOnChange: TNotifyEvent;
    FIsPressed: boolean;
    FIsChecked: boolean;
    FGroupName: string;
    procedure SetIsChecked(const Value: boolean);
  protected
    procedure ApplyStyle; override;
    procedure EnterFocus; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  published
    { triggers }
    property IsPressed: boolean read FIsPressed;
    property IsChecked: boolean read FIsChecked write SetIsChecked;
    { props }
    property AutoTranslate default true;
    property BindingSource;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Font;
    property TextAlign;
    property Text;
    property Resource;
    property WordWrap;
    property GroupName: string read FGroupName write FGroupName;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxGroupBox = class(TvxTextControl)
  private
  protected
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property AutoTranslate default true;
    property Font;
    property TextAlign;
    property Text;
    property Resource;
  end;

  TvxCloseButton = class(TvxControl)
  private
    FPressing: boolean;
    FOnClick: TNotifyEvent;
    FCloseForm: boolean;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
  published
    { props }
    property Resource;
    property CloseForm: boolean read FCloseForm write FCloseForm default true;
    property OnClick: TNotifyEvent read FOnClick write FOnClick;
  end;

  TvxSizeGrip = class(TvxControl, IvgSizeGrip)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Resource;
  end;

  TvxSplitter = class(TvxControl)
  private
    FPressed: boolean;
    FControl: TvxVisualObject;
    FDownPos: TvxPoint;
    FMinSize: single;
    FMaxSize: single;
    FNewSize, FOldSize: single;
    FSplit: single;
    FShowGrip: boolean;
    procedure SetShowGrip(const Value: boolean);
  protected
    procedure ApplyStyle; override;
    procedure Paint; override;
    procedure SetAlign(const Value: TvxAlign); override;
    function FindObject: TvxVisualObject;
    procedure CalcSplitSize(X, Y: single; var NewSize, Split: single);
    procedure UpdateSize(X, Y: single);
    function DoCanResize(var NewSize: single): Boolean;
    procedure UpdateControlSize;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
  published
    property MinSize: single read FMinSize write FMinSize;
    property ShowGrip: boolean read FShowGrip write SetShowGrip default true;
  end;

  TvxProgressBar = class(TvxControl)
  private
    FMin: single;
    FValue: single;
    FMax: single;
    FOrientation: TvxOrientation;
    procedure SetMax(const Value: single);
    procedure SetMin(const Value: single);
    procedure SetOrientation(const Value: TvxOrientation);
    procedure SetValue(const Value: single);
  protected
    procedure ApplyStyle; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
  published
    property BindingSource;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property Orientation: TvxOrientation read FOrientation write SetOrientation;
    property Value: single read FValue write SetValue;
    property Resource;
  end;

  TvxCustomTrack = class;
  TvxScrollBar = class;

  TvxThumb = class(TvxControl)
  private
    FTrack: TvxCustomTrack;
    FDownOffset: TvxPoint;
    FPressed: boolean;
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
  published
    property Resource;
  end;

  TvxCustomTrack = class(TvxControl)
  private
    function GetThumb: TvxThumb;
    procedure SetFrequency(const Value: single);
    function GetIsTracking: boolean;
  protected
    FOnChange, FOnTracking: TNotifyEvent;
    FValue: single;
    FMin: single;
    FMax: single;
    FViewportSize: single;
    FOrientation: TvxOrientation;
    FTracking: boolean;
    FFrequency: single;
    procedure SetMax(const Value: single); virtual;
    procedure SetMin(const Value: single); virtual;
    procedure SetValue(Value: single);
    procedure SetViewportSize(const Value: single);
    procedure SetOrientation(const Value: TvxOrientation);
    function GetThumbRect: TvxRect;
    property Thumb: TvxThumb read GetThumb;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
    property IsTracking: boolean read GetIsTracking;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property Frequency: single read FFrequency write SetFrequency;
    property Orientation: TvxOrientation read FOrientation write SetOrientation;
    property Value: single read FValue write SetValue;
    property ViewportSize: single read FViewportSize write SetViewportSize;
    property Tracking: boolean read FTracking write FTracking default true;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnTracking: TNotifyEvent read FOnTracking write FOnTracking;
  end;

  TvxTrack = class(TvxCustomTrack)
  private
  protected
  public
  published
    property BindingSource;
    property Resource;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property Frequency: single read FFrequency write SetFrequency;
    property Orientation: TvxOrientation read FOrientation write SetOrientation;
    property Value: single read FValue write SetValue;
    property ViewportSize: single read FViewportSize write SetViewportSize;
    property Tracking: boolean read FTracking write FTracking;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxTrackBar = class(TvxCustomTrack)
  private
  protected
    procedure SetMax(const Value: single); override;
    procedure SetMin(const Value: single); override;
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property BindingSource;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Resource;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property Frequency: single read FFrequency write SetFrequency;
    property Orientation: TvxOrientation read FOrientation write SetOrientation;
    property Value: single read FValue write SetValue;
    property Tracking: boolean read FTracking write FTracking;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxScrollBar = class(TvxControl)
  private
    FOnChange: TNotifyEvent;
    FValue: single;
    FMin: single;
    FMax: single;
    FViewportSize: single;
    FOrientation: TvxOrientation;
    FSmallChange: single;
    procedure SetMax(const Value: single);
    procedure SetMin(const Value: single);
    procedure SetValue(const Value: single);
    procedure SetViewportSize(const Value: single);
    procedure SetOrientation(const Value: TvxOrientation);
  protected
    procedure DoTrackChanged(Sender: TObject);
    procedure DoMinButtonClick(Sender: TObject);
    procedure DoMaxButtonClick(Sender: TObject);
    function Track: TvxCustomTrack;
    function MinButton: TvxCustomButton;
    function MaxButton: TvxCustomButton;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
  published
    property BindingSource;
    property Resource;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property Orientation: TvxOrientation read FOrientation write SetOrientation;
    property Value: single read FValue write SetValue;
    property ViewportSize: single read FViewportSize write SetViewportSize;
    property SmallChange: single read FSmallChange write FSmallChange;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxSmallScrollBar = class(TvxScrollBar)
  private
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TvxAniIndicatorStyle = (
    vgAniIndicatorLine,
    vgAniIndicatorCircle
    );

  TvxAniIndicator = class(TvxControl)
  private
    FDragTimer: TvxTimer;
    FLayout: TvxVisualObject;
    FAni: TvxFloatAnimation;
    FEnabled: boolean;
    FStyle: TvxAniIndicatorStyle;
    procedure SetEnabled(const Value: boolean);
    procedure SetStyle(const Value: TvxAniIndicatorStyle);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
  published
    property Enabled: boolean read FEnabled write SetEnabled;
    property Style: TvxAniIndicatorStyle read FStyle write SetStyle;
  end;

  TvxAngleButton = class(TvxControl)
  private
    FPressing: boolean;
    FOnChange: TNotifyEvent;
    FOldPos: TvxPoint;
    FSaveValue, FValue: single;
    FFrequency: single;
    FTracking: boolean;
    FShowValue: boolean;
    procedure SetValue(const Value: single);
    procedure SetShowValue(const Value: boolean);
  protected
    function Tick: TvxVisualObject;
    function Text: TvxText;
    procedure ApplyStyle; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
  published
    { props }
    property BindingSource;
    property Resource;
    property Frequency: single read FFrequency write FFrequency;
    property Tracking: boolean read FTracking write FTracking default true;
    property ShowValue: boolean read FShowValue write SetShowValue default false;
    property Value: single read FValue write SetValue;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxExpanderButton = class(TvxCustomButton)
  private
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property CanFocused default false;
  end;

  TvxExpander = class(TvxTextControl)
  private
    FShowCheck: boolean;
    FIsChecked: boolean;
    FOnCheckChange: TNotifyEvent;
    procedure DoButtonClick(Sender: TObject);
    procedure SetIsChecked(const Value: boolean);
    procedure SetShowCheck(const Value: boolean);
  protected
    FIsExpanded: boolean;
    FContent: TvxContent;
    FButton: TvxCustomButton;
    FCheck: TvxCheckBox;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure SetIsExpanded(const Value: boolean); virtual;
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadContentSize(Reader: TReader);
    procedure WriteContentSize(Writer: TWriter);
    procedure DesignClick; override;
    procedure DoCheckChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
    procedure AddObject(AObject: TvxObject); override;
  published
    property Font;
    property TextAlign;
    property Text;
    property Resource;
    property AutoTranslate default true;
    property IsExpanded: boolean read FIsExpanded write SetIsExpanded default true;
    property IsChecked: boolean read FIsChecked write SetIsChecked default true;
    property ShowCheck: boolean read FShowCheck write SetShowCheck;
    property OnCheckChange: TNotifyEvent read FOnCheckChange write FOnCheckChange;
  end;

  TvxPopupBox = class(TvxCustomButton)
  private
    FItems: TvxWideStrings;
    FItemIndex: integer;
    {$IFNDEF NOVCL}
    FPopup: TPopupMenu;
    {$ENDIF}
    FOnChange: TNotifyEvent;
    procedure SetItems(const Value: TvxWideStrings);
    procedure SetItemIndex(const Value: integer);
  protected
    procedure ApplyStyle; override;
    procedure Click; override;
    procedure DoItemsChanged(Sender: TObject); virtual;
    procedure DoItemClick(Sender: TObject);
    procedure DoPopup; virtual;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure SetText(const Value: WideString); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property BindingSource;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Text stored false;
    property Items: TvxWideStrings read FItems write SetItems;
    property ItemIndex: integer read FItemIndex write SetItemIndex;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxWindow = class(TvxTextControl)
  private
    FShowCloseButton: boolean;
    FShowSizeGrip: boolean;
    FOnCloseClick: TNotifyEvent;
    procedure SetShowCloseButton(const Value: boolean);
    procedure SetShowSizeGrip(const Value: boolean);
  protected
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property ShowCloseButton: boolean read FShowCloseButton write SetShowCloseButton default true;
    property ShowSizeGrip: boolean read FShowSizeGrip write SetShowSizeGrip default true;
    property OnCloseClick: TNotifyEvent read FOnCloseClick write FOnCloseClick;
    { props }
    property AutoTranslate default true;
    property Font;
    property TextAlign;
    property Text;
    property Resource;
  end;

  TvxCloseAlign = (
    vgButtonAlignLeft,
    vgButtonAlignRight
    );

  TvxHudWindow = class(TvxWindow)
  private
    FDisableShadowOnOSX: boolean;
    FFill: TvxBrush;
    FStrokeThickness: single;
    FStroke: TvxBrush;
    FStrokeCap: TvxStrokeCap;
    FStrokeDash: TvxStrokeDash;
    FStrokeJoin: TvxStrokeJoin;
    FCloseAlign: TvxCloseAlign;
    FShowCaption: boolean;
    procedure SetDisableShadowOnOSX(const Value: boolean);
    procedure SetFill(const Value: TvxBrush);
    function isStrokeThicknessStored: Boolean;
    procedure SetStroke(const Value: TvxBrush);
    procedure SetStrokeCap(const Value: TvxStrokeCap);
    procedure SetStrokeDash(const Value: TvxStrokeDash);
    procedure SetStrokeJoin(const Value: TvxStrokeJoin);
    procedure SetStrokeThickness(const Value: single);
    procedure SetCloseAlign(const Value: TvxCloseAlign);
    procedure SetShowCaption(const Value: boolean);
  protected
    procedure ApplyStyle; override;
    procedure DoFillChanged(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property DisableShadowOnOSX: boolean read FDisableShadowOnOSX write SetDisableShadowOnOSX default true;
    property ButtonAlign: TvxCloseAlign read FCloseAlign write SetCloseAlign default vgButtonAlignLeft;
    property Fill: TvxBrush read FFill write SetFill;
    property Stroke: TvxBrush read FStroke write SetStroke;
    property StrokeThickness: single read FStrokeThickness write SetStrokeThickness stored isStrokeThicknessStored;
    property StrokeCap: TvxStrokeCap read FStrokeCap write SetStrokeCap default vgCapFlat;
    property StrokeDash: TvxStrokeDash read FStrokeDash write SetStrokeDash default vgDashSolid;
    property StrokeJoin: TvxStrokeJoin read FStrokeJoin write SetStrokeJoin default vgJoinMiter;
    property ShowCaption: boolean read FShowCaption write SetShowCaption default true;
  end;

  TvxImageControl = class(TvxControl)
  private
    FImage: TvxImage;
    FOnChange: TNotifyEvent;
    FBitmap: TvxBitmap;
    FEnableOpenDialog: boolean;
    procedure SetBitmap(const Value: TvxBitmap);
  protected
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure Click; override;
    procedure DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean); override;
    procedure DragDrop(const Data: TvxDragObject; const Point: TvxPoint); override;
    procedure DoBitmapChanged(Sender: TObject); virtual;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property CanFocused default true;
    property DisableFocusEffect;
    property EnableOpenDialog: boolean read FEnableOpenDialog write FEnableOpenDialog default true;
    property TabOrder;
    property Bitmap: TvxBitmap read FBitmap write SetBitmap;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxHudLabel = class(TvxLabel)
  private
  protected
  public
  published
  end;

  TvxHudButton = class(TvxButton)
  private
  protected
  public
  published
  end;

  TvxHudRoundButton = class(TvxButton)
  private
  protected
  public
  published
  end;

  TvxHudCircleButton = class(TvxCircleButton)
  private
  protected
  public
  published
  end;

  TvxHudCornerButton = class(TvxCornerButton)
  private
  protected
  public
  published
  end;

  TvxHudSpeedButton = class(TvxSpeedButton)
  private
  protected
  public
  published
  end;

  TvxHudCheckBox = class(TvxCheckBox)
  private
  protected
  public
  published
  end;

  TvxHudRadioButton = class(TvxRadioButton)
  private
  protected
  public
  published
  end;

  TvxHudGroupBox = class(TvxGroupBox)
  private
  protected
  public
  published
  end;

  TvxHudPopupBox = class(TvxPopupBox)
  private
  protected
  public
  published
  end;

  TvxHudAngleButton = class(TvxAngleButton)
  private
  protected
  public
  published
  end;

  TvxHudTrack = class(TvxTrack)
  private
  protected
  public
  published
  end;

  TvxHudTrackBar = class(TvxTrackBar)
  private
  protected
  public
  published
  end;

  TvxHudScrollBar = class(TvxScrollBar)
  private
  protected
  public
  published
  end;

  TvxLayerWindow = class(TvxHudWindow)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
  end;

  TvxHudPanel = class(TvxPanel)
  private
  protected
  public
  published
  end;

  TvxHudCloseButton = class(TvxCloseButton)
  private
  protected
  public
  published
  end;

  TvxHudSizeGrip = class(TvxSizeGrip)
  private
  protected
  public
  published
  end;

  TvxHudStatusBar = class(TvxStatusBar)
  private
  protected
  public
  published
  end;

type

  TvxLayout = class(TvxVisualObject)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
  published
    property HitTest default false;
  end;

  TvxScaledLayout = class(TvxVisualObject)
  private
    FOriginalWidth: single;
    FOriginalHeight: single;
    procedure SetOriginalWidth(const Value: single);
    procedure SetOriginalHeight(const Value: single);
  protected
    function GetChildrenMatrix: TvxMatrix; override;
    procedure SetHeight(const Value: single); override;
    procedure SetWidth(const Value: single); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    procedure Realign; override;
  published
    property OriginalWidth: single read FOriginalWidth write SetOriginalWidth;
    property OriginalHeight: single read FOriginalHeight write SetOriginalHeight;
  end;

  TvxScrollContent = class(TvxContent)
  private
  protected
    function GetClipRect: TvxRect; override;
    procedure PaintChildren; override;
    function ObjectByPoint(X, Y: single): TvxVisualObject; override;
    function GetUpdateRect: TvxRect; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure Paint; override;
    procedure AddObject(AObject: TvxObject); override;
    procedure RemoveObject(AObject: TvxObject); override;
  published
  end;

  TvxScrollBox = class(TvxControl)
  private
    FAutoHide: boolean;
    FDisableMouseWheel: boolean;
    FDown: boolean;
    FHScrollAni: TvxFloatAnimation;
    FVScrollAni: TvxFloatAnimation;
    FAnimated: boolean;
    FShowScrollBars: boolean;
    FShowSizeGrip: boolean;
    FMouseTracking: boolean;
    FUseSmallScrollBars: boolean;
    procedure SetShowScrollBars(const Value: boolean);
    procedure SetShowSizeGrip(const Value: boolean);
    procedure SetUseSmallScrollBars(const Value: boolean);
  protected
    FScrollDesign: TvxPoint;
    FContent: TvxScrollContent;
    FHScrollBar: TvxScrollBar;
    FVScrollBar: TvxScrollBar;
    FContentLayout: TvxVisualObject;
    FDownPos, FLastDelta, FCurrentPos: TvxPoint;
    { VCL }
    procedure Loaded; override;
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadScrollDesign(Reader: TReader);
    procedure WriteScrollDesign(Writer: TWriter);
    { }
    procedure ContentAddObject(AObject: TvxObject); virtual;
    procedure ContentBeforeRemoveObject(AObject: TvxObject); virtual;
    procedure ContentRemoveObject(AObject: TvxObject); virtual;
    procedure HScrollChange(Sender: TObject); virtual;
    procedure VScrollChange(Sender: TObject); virtual;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure CreateVScrollAni;
    procedure CreateHScrollAni;
    function ContentRect: TvxRect;
    function VScrollBarValue: single;
    function HScrollBarValue: single;
    function GetContentBounds: TvxRect; virtual;
    procedure ContentPaint(const Canvas: TvxCanvas; const ARect: TvxRect); virtual;
    procedure RealignContent(R: TvxRect); virtual;
    property ContentLayout: TvxVisualObject read FContentLayout;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure AddObject(AObject: TvxObject); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); override;
    procedure Realign; override;
    procedure Centre;
    procedure ScrollTo(const Dx, Dy: single);
    procedure InViewRect(const Rect: TvxRect);
    function ClientWidth: single;
    function ClientHeight: single;
    property HScrollBar: TvxScrollBar read FHScrollBar;
    property VScrollBar: TvxScrollBar read FVScrollBar;
  published
    property AutoHide: boolean read FAutoHide write FAutoHide default true;
    property Animated: boolean read FAnimated write FAnimated default true;
    property DisableMouseWheel: boolean read FDisableMouseWheel write FDisableMouseWheel default false;
    property MouseTracking: boolean read FMouseTracking write FMouseTracking default false;
    property ShowScrollBars: boolean read FShowScrollBars write SetShowScrollBars default true;
    property ShowSizeGrip: boolean read FShowSizeGrip write SetShowSizeGrip default false;
    property UseSmallScrollBars: boolean read FUseSmallScrollBars write SetUseSmallScrollBars default false;
  end;

  TvxVertScrollBox = class(TvxScrollBox)
  private
  protected
    function GetContentBounds: TvxRect; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxFramedScrollBox = class(TvxScrollBox)
  private
  protected
  public
  published
  end;

  TvxFramedVertScrollBox = class(TvxVertScrollBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxGridLayout = class(TvxVisualObject)
  private
    FItemWidth: single;
    FItemHeight: single;
    FOrientation: TvxOrientation;
    procedure SetItemHeight(const Value: single);
    procedure SetItemWidth(const Value: single);
    procedure SetOrientation(const Value: TvxOrientation);
  protected
    procedure Realign; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property ItemHeight: single read FItemHeight write SetItemHeight;
    property ItemWidth: single read FItemWidth write SetItemWidth;
    property Orientation: TvxOrientation read FOrientation write SetOrientation;
  end;

  TvxSplitLayout = class(TvxVisualObject)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property HitTest default false;
  end;

  {$IFNDEF NOVCL}

  TvxNonVGLayout = class(TvxLayout)
  private
    FControl: TControl;
    FVisibleTimer: TvxTimer;
    procedure SetControl(const Value: TControl);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
    function CheckParentVisible: boolean; override;
    procedure DoVisibleTimer(Sender: TObject);
    procedure MatrixChanged(Sender: TObject); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
  published
    property NonVGControl: TControl read FControl write SetControl;
  end;

  {$ENDIF}

type

  TvxListBox = class;
  TvxComboBox = class;

  { TvxListBoxItem }

  TvxListBoxItem = class(TvxTextControl)
  private
    FIsChecked: boolean;
    FCheck: TvxCheckBox;
    FIsSelected: boolean;
    procedure SetIsChecked(const Value: boolean);
    procedure DoCheckClick(Sender: TObject);
    procedure UpdateCheck;
    procedure SetIsSelected(const Value: boolean);
  protected
    function ListBox: TvxListBox;
    function ComboBox: TvxComboBox;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    function GetParentComponent: TComponent; override;
    procedure DesignInsert; override;
    procedure DesignSelect; override;
    function EnterFocusChildren(AObject: TvxVisualObject): boolean; override;
    procedure DragEnd; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
  published
    property IsChecked: boolean read FIsChecked write SetIsChecked;
    property IsSelected: boolean read FIsSelected write SetIsSelected;
    property AutoTranslate default true;
    property Font;
    property Resource;
    property Text;
    property TextAlign default vgTextAlignNear;
    property WordWrap;
  end;

  TvxListStyle = (
    vgListVertical,
    vgListHorizontal
    );

  TOnCompareListBoxItemEvent = function(Item1, Item2: TvxListBoxItem): integer of object;
  TOnListBoxDragChange = procedure(SourceItem, DestItem: TvxListBoxItem; Allow: boolean) of object;

  TvxListBox = class(TvxScrollBox)
  private
    FMouseSelecting: boolean;
    FOnChange: TNotifyEvent;
    FHideSelectionUnfocused: boolean;
    FShowCheckboxes: boolean;
    FOnChangeCheck: TNotifyEvent;
    FSorted: boolean;
    FOnCompare: TOnCompareListBoxItemEvent;
    FMultiSelect: boolean;
    FAlternatingRowBackground: boolean;
    FAllowDrag: boolean;
    FDragItem: TvxListBoxItem;
    FOnDragChange: TOnListBoxDragChange;
    function GetCount: integer;
    function GetSelected: TvxListBoxItem;
    procedure SetColumns(const Value: integer);
    procedure SetItemHeight(const Value: single);
    procedure SetItemWidth(const Value: single);
    procedure SetListStyle(const Value: TvxListStyle);
    procedure SetShowCheckboxes(const Value: boolean);
    function GetItem(Index: integer): TvxListBoxItem;
    procedure SetSorted(const Value: boolean);
    procedure SetAlternatingRowBackground(const Value: boolean);
    procedure SetMultiSelect(const Value: boolean);
    procedure SetAllowDrag(const Value: boolean);
  protected
    FColumns: integer;
    FItemWidth: single;
    FItemHeight: single;
    FListStyle: TvxListStyle;
    FFirstSelect: TvxListBoxItem;
    FSelection: TvxVisualObject;
    FSelections: TList;
    FOddFill: TvxBrush;
    FItemIndex: integer;
    procedure SortItems; virtual;
    procedure SetItemIndex(const Value: integer); virtual;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure KeyUp(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean); override;
    procedure DragDrop(const Data: TvxDragObject; const Point: TvxPoint); override;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure EnterFocus; override;
    procedure KillFocus; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    function GetContentBounds: TvxRect; override;
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    procedure HScrollChange(Sender: TObject); override;
    procedure VScrollChange(Sender: TObject); override;
    procedure ContentAddObject(AObject: TvxObject); override;
    procedure ContentBeforeRemoveObject(AObject: TvxObject); override;
    procedure ContentRemoveObject(AObject: TvxObject); override;
    procedure UpdateSelection;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ItemClass: string; override;
    procedure Clear; virtual;
    procedure SelectAll;
    procedure ClearSelection;
    procedure SelectRange(Item1, Item2: TvxListBoxItem);
    function ItemByPoint(const X, Y: single): TvxListBoxItem;
    function ItemByIndex(const Idx: integer): TvxListBoxItem;
    procedure Exchange(Item1, Item2: TvxListBoxItem);
    procedure AddObject(AObject: TvxObject); override;
    property Count: integer read GetCount;
    property Selected: TvxListBoxItem read GetSelected;
    property Items[Index: integer]: TvxListBoxItem read GetItem;
  published
    property Resource;
    property AllowDrag: boolean read FAllowDrag write SetAllowDrag default false;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property AlternatingRowBackground: boolean read FAlternatingRowBackground write SetAlternatingRowBackground default false;
    property Columns: integer read FColumns write SetColumns default 1;
    property HideSelectionUnfocused: boolean read FHideSelectionUnfocused write FHideSelectionUnfocused default true;
    property ItemIndex: integer read FItemIndex write SetItemIndex default -1;
    property ItemWidth: single read FItemWidth write SetItemWidth;
    property ItemHeight: single read FItemHeight write SetItemHeight;
    property ListStyle: TvxListStyle read FListStyle write SetListStyle default vgListVertical;
    property MultiSelect: boolean read FMultiSelect write SetMultiSelect default false;
    property Sorted: boolean read FSorted write SetSorted default false;
    property ShowCheckboxes: boolean read FShowCheckboxes write SetShowCheckboxes default false;
    property BindingSource;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnChangeCheck: TNotifyEvent read FOnChangeCheck write FOnChangeCheck;
    property OnCompare: TOnCompareListBoxItemEvent read FOnCompare write FOnCompare;
    property OnDragChange: TOnListBoxDragChange read FOnDragChange write FOnDragChange;
  end;

  TvxComboListBox = class(TvxListbox)
  private
  protected
    FComboBox: TvxControl;
    procedure ApplyResource; override;
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    function GetParentComponent: TComponent; override;
    procedure KillFocus; override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
  end;

  TvxComboBox = class(TvxControl)
  private
    FDropDownCount: integer;
    FPopup: TvxPopup;
    FListBox: TvxComboListBox;
    FOnChange: TNotifyEvent;
    FPlacement: TvxPlacement;
    procedure SetItemIndex(const Value: integer);
    function GetItemIndex: integer;
    function GetCount: integer;
    procedure SetListBoxResource(const Value: string);
    function GetListBoxResource: string;
    function GetItemHeight: single;
    procedure SetItemHeight(const Value: single);
  protected
    procedure GetChildren(Proc: TGetChildProc; Root: TComponent); override;
    procedure ApplyStyle; override;
    procedure DoListBoxChange(Sender: TObject);
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect); virtual;
    procedure DesignClick; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer;
      var Handled: boolean); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ItemClass: string; override;
    procedure Paint; override;
    procedure PaintChildren; override;
    procedure Realign; override;
    procedure Clear; virtual;
    procedure DropDown; virtual;
    procedure AddObject(AObject: TvxObject); override;
    property ListBox: TvxComboListBox read FListBox write FListBox;
    property Count: integer read GetCount;
  published
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Resource;
    property ItemIndex: integer read GetItemIndex write SetItemIndex;
    property ItemHeight: single read GetItemHeight write SetItemHeight;
    property DropDownCount: integer read FDropDownCount write FDropDownCount default 8;
    property Placement: TvxPlacement read FPlacement write FPlacement;
    property BindingSource;
    property ListBoxResource: string read GetListBoxResource write SetListBoxResource;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxStringListBox = class(TvxListBox)
  private
    FItems: TvxWideStrings;
    FTextAlign: TvxTextAlign;
    FItemStyle: string;
    FFont: TvxFont;
    procedure SetItems(const Value: TvxWideStrings);
    procedure SetTextAlign(const Value: TvxTextAlign);
    procedure SetFont(const Value: TvxFont);
  protected
    procedure SortItems; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure ApplyStyle; override;
    procedure RebuildList;
    procedure DoItemsChanged(Sender: TObject);
    procedure FontChanged(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure EndUpdate; override;
  published
    property AutoTranslate default true;
    property TextAlign: TvxTextAlign read FTextAlign write SetTextAlign default vgTextAlignCenter;
    property Font: TvxFont read FFont write SetFont;
    property Items: TvxWideStrings read FItems write SetItems;
    property ItemIndex;
    property BindingSource;
  end;

  TvxStringComboBox = class(TvxComboBox)
  private
    FItemHeight: single;
    FItems: TvxWideStrings;
    FTextAlign: TvxTextAlign;
    FItemStyle: string;
    procedure SetItemHeight(const Value: single);
    procedure SetItems(const Value: TvxWideStrings);
    procedure SetTextAlign(const Value: TvxTextAlign);
  protected
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure ApplyStyle; override;
    procedure RebuildList;
    procedure DoItemsChanged(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Clear; override;
  published
    property AutoTranslate default true;
    property TextAlign: TvxTextAlign read FTextAlign write SetTextAlign default vgTextAlignCenter;
    property ItemHeight: single read FItemHeight write SetItemHeight;
    property Items: TvxWideStrings read FItems write SetItems;
    property ItemIndex;
  end;

  TvxHorzListBox = class(TvxListBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
    property ListStyle default vgListHorizontal;
  end;

  TvxImageThread = class(TThread)
  private
    FImage: TvxImage;
    FTempBitmap: TvxBitmap;
    FFileName: string;
    FUseThumbnails: boolean;
  protected
    procedure Execute; override;
    procedure Finished;
  public
    constructor Create(const AImage: TvxImage; const AFileName: string; const AUseThumbnails: boolean);
    destructor Destroy; override;
  end;

  TvxImageListBoxItem = class(TvxListBoxItem)
  private
    function TextBorder: TvxVisualObject;
  protected
    procedure ApplyStyle; override;
  public
    function Text: TvxText;
  published
  end;

  TvxImageListBox = class(TvxListBox)
  private
    FFolder: string;
    FShowFileName: boolean;
    FItemHeight: single;
    FUseThumbnails: boolean;
    function GetSelectedFileName: string;
    procedure SetShowFileName(const Value: boolean);
    procedure SetItemHeight(const Value: single);
    function GetSelectedImage: TvxImage;
    function GetImage(Index: integer): TvxImage;
  protected
    procedure DoApplyResource(Sender: TObject);
    procedure BeginAutoDrag; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure AddFolder(const Folder: string);
    procedure AddFile(const AFile: string);
    procedure AddBitmap(const AFile: string; const ABitmap: TvxBitmap);
    procedure Clear; override;
    property Images[Index: integer]: TvxImage read GetImage;
    property SelectedFileName: string read GetSelectedFileName;
    property SelectedImage: TvxImage read GetSelectedImage;
  published
    property ShowFileName: boolean read FShowFileName write SetShowFileName;
    property UseThumbnails: boolean read FUseThumbnails write FUseThumbnails default true;
    property ItemHeight: single read FItemHeight write SetItemHeight;
  end;

  TvxHudImageListBox = class(TvxImageListBox)
  private
  protected
  public
  published
  end;

  TvxHorzImageListBox = class(TvxImageListBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
    property ListStyle default vgListHorizontal;
  end;

  TvxHudHorzImageListBox = class(TvxHorzImageListBox)
  private
  protected
  public
  published
  end;

  TvxHudListBox = class(TvxListBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudHorzListBox = class(TvxHorzListBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudStringListBox = class(TvxStringListBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudComboBox = class(TvxComboBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudStringComboBox = class(TvxStringComboBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

type

  TvxTreeView = class;

  TvxTreeViewItem = class(TvxTextControl)
  private
    FIsExpanded: boolean;
    FButton: TvxCustomButton;
    FCheck: TvxCheckBox;
    FGlobalIndex: integer;
    FIsChecked: boolean;
    FIsSelected: boolean;
    procedure SetIsExpanded(const Value: boolean);
    procedure DoButtonClick(Sender: TObject);
    procedure DoCheckClick(Sender: TObject);
    function GetCount: integer;
    procedure SetIsChecked(const Value: boolean);
    procedure UpdateCheck;
    function GetItem(Index: integer): TvxTreeViewItem;
    procedure SetIsSelected(const Value: boolean);
  protected
    procedure DesignClick; override;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure Realign; override;
    procedure DragEnd; override;
    function EnterFocusChildren(AObject: TvxVisualObject): boolean; override;
  public
    constructor Create(AOwner: TComponent); override;
    procedure Paint; override;
    procedure AddObject(AObject: TvxObject); override;
    procedure RemoveObject(AObject: TvxObject); override;
    function ItemClass: string; override;
    function ItemByPoint(const X, Y: single): TvxTreeViewItem;
    function ItemByIndex(const Idx: integer): TvxTreeViewItem;
    property Count: integer read GetCount;
    property GlobalIndex: integer read FGlobalIndex write FGlobalIndex;
    function TreeView: TvxTreeView;
    function Level: integer;
    property Items[Index: integer]: TvxTreeViewItem read GetItem;
  published
    property IsChecked: boolean read FIsChecked write SetIsChecked;
    property IsExpanded: boolean read FIsExpanded write SetIsExpanded;
    property IsSelected: boolean read FIsSelected write SetIsSelected;
    property AutoTranslate default true;
    property Font;
    property Resource;
    property Text;
    property TextAlign default vgTextAlignNear;
  end;

  TOnCompareTreeViewItemEvent = function(Item1, Item2: TvxTreeViewItem): integer of object;
  TOnTreeViewDragChange = procedure(SourceItem, DestItem: TvxTreeViewItem; Allow: boolean) of object;

  TvxTreeView = class(TvxScrollBox)
  private
    FMouseSelecting: boolean;
    FOnChange: TNotifyEvent;
    FSelected: TvxTreeViewItem;
    FItemHeight: single;
    FCountExpanded: integer;
    FHideSelectionUnfocused: boolean;
    FGlobalCount: integer;
    FShowCheckboxes: boolean;
    FOnChangeCheck: TNotifyEvent;
    FSorted: boolean;
    FOnCompare: TOnCompareTreeViewItemEvent;
    FMultiSelect: boolean;
    FFirstSelect: TvxTreeViewItem;
    FSelection: TvxVisualObject;
    FSelections: TList;
    FAllowDrag: boolean;
    FDragItem: TvxTreeViewItem;
    FOnDragChange: TOnTreeViewDragChange;
    FGlobalList: TList;
    procedure SetItemHeight(const Value: single);
    procedure SetShowCheckboxes(const Value: boolean);
    function GetItem(Index: integer): TvxTreeViewItem;
    procedure SetSorted(const Value: boolean);
    procedure SortItems;
    function GetSelection: TvxSelectionItem;
    procedure ClearSelection;
    procedure SelectAll;
    procedure SelectRange(Item1, Item2: TvxTreeViewItem);
    procedure UpdateSelection;
    procedure SetAllowDrag(const Value: boolean);
    function GetCount: integer;
  protected
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure SetSelected(const Value: TvxTreeViewItem); virtual;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure EnterFocus; override;
    procedure KillFocus; override;
    procedure HScrollChange(Sender: TObject); override;
    procedure VScrollChange(Sender: TObject); override;
    function GetContentBounds: TvxRect; override;
    procedure UpdateGlobalIndexes;
    procedure ContentAddObject(AObject: TvxObject); override;
    procedure ContentRemoveObject(AObject: TvxObject); override;
    function GetItemRect(Item: TvxTreeViewItem): TvxRect;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ItemClass: string; override;
    procedure EndUpdate; override;
    procedure Clear;
    procedure ExpandAll;
    procedure CollapseAll;
    function ItemByPoint(const X, Y: single): TvxTreeViewItem;
    function ItemByIndex(const Idx: integer): TvxTreeViewItem;
    function ItemByGlobalIndex(const Idx: integer): TvxTreeViewItem;
    procedure AddObject(AObject: TvxObject); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure KeyUp(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean); override;
    procedure DragDrop(const Data: TvxDragObject; const Point: TvxPoint); override;
    property Count: integer read GetCount;
    property GlobalCount: integer read FGlobalCount;
    property CountExpanded: integer read FCountExpanded;
    property Selected: TvxTreeViewItem read FSelected write SetSelected;
    property Items[Index: integer]: TvxTreeViewItem read GetItem;
  published
    property Resource;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property AllowDrag: boolean read FAllowDrag write SetAllowDrag default false;
    property ItemHeight: single read FItemHeight write SetItemHeight;
    property HideSelectionUnfocused: boolean read FHideSelectionUnfocused write FHideSelectionUnfocused default true;
    property MultiSelect: boolean read FMultiSelect write FMultiSelect default false;
    property ShowCheckboxes: boolean read FShowCheckboxes write SetShowCheckboxes default false;
    property Sorted: boolean read FSorted write SetSorted default false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnChangeCheck: TNotifyEvent read FOnChangeCheck write FOnChangeCheck;
    property OnCompare: TOnCompareTreeViewItemEvent read FOnCompare write FOnCompare;
    property OnDragChange: TOnTreeViewDragChange read FOnDragChange write FOnDragChange;
  end;

type

  TvxCustomTextBox = class(TvxControl)
  private
    FText: WideString;
    FFontFill: TvxBrush;
    FFont: TvxFont;
    FTextAlign: TvxTextAlign;
    FOnChange: TNotifyEvent;
    FReadOnly: boolean;
    FSelStart: integer;
    FSelLength: integer;
    FCaretPosition: integer;
    FMaxLength: integer;
    FFirstVisibleChar: integer;
    FLMouseSelecting: boolean;
    FDisableCaret: boolean;
    FPassword: boolean;
    {$IFNDEF NOVCL}
    FPopupMenu: TPopupMenu;
    {$ENDIF}
    FOnTyping: TNotifyEvent;
    FSelectionFill: TvxBrush;
    FOnChangeTracking: TNotifyEvent;
    procedure InsertText(const AText: WideString);
    function GetSelLength: integer;
    function GetSelStart: integer;
    function GetSelText: WideString;
    procedure SetSelLength(const Value: integer);
    procedure SetSelStart(const Value: integer);
    function GetSelRect: TvxRect;
    procedure SetCaretPosition(const Value: integer);
    function GetCoordinatePosition(x: single): integer;
    procedure SetMaxLength(const Value: Integer);
    function GetNextWordBeging(StartPosition: integer): integer;
    function GetPrivWordBeging(StartPosition: integer): integer;
    procedure UpdateFirstVisibleChar;
    procedure UpdateCaretePosition;
    procedure SetPassword(const Value: boolean);
    procedure CreatePopupMenu;
    procedure DoCopy(Sender: TObject);
    procedure DoCut(Sender: TObject);
    procedure DoDelete(Sender: TObject);
    procedure DoPaste(Sender: TObject);
    procedure UpdatePopupMenuItems;
    procedure DoSelectAll(Sender: TObject);
    procedure SetFont(const Value: TvxFont);
    procedure SetTextAlign(const Value: TvxTextAlign);
  protected
    FNeedChange: boolean;
    FFilterChar: WideString;
    FShowCaret: boolean;
    FLastKey: Word;
    FLastChar: System.WideChar;
    procedure ApplyStyle; override;
    procedure Change; virtual;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    function GetPasswordCharWidth: single;
    function TextWidth(const Str: WideString): single;
    procedure SetText(const Value: WideString); virtual;
    procedure FontChanged(Sender: TObject); virtual;
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure KeyUp(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure EnterFocus; override;
    procedure KillFocus; override;
    procedure DblClick; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    procedure ContextMenu(const ScreenPosition: TvxPoint); override;
    procedure ClearSelection;
    procedure CopyToClipboard;
    procedure CutToClipboard;
    procedure PasteFromClipboard;
    procedure SelectAll;
    function GetCharX(a: integer): single;
    function ContentRect: TvxRect;
    property CaretPosition: integer read FCaretPosition write SetCaretPosition;
    property SelStart: integer read GetSelStart write SetSelStart;
    property SelLength: integer read GetSelLength write SetSelLength;
    property SelText: WideString read GetSelText;
    property MaxLength: Integer read FMaxLength write SetMaxLength default 0;
    property ShowCaret: boolean read FShowCaret write FShowCaret default true;
    property FontFill: TvxBrush read FFontFill;
    property SelectionFill: TvxBrush read FSelectionFill;
    property Password: boolean read FPassword write SetPassword;
    property Text: WideString read FText write SetText;
    property FilterChar: WideString read FFilterChar write FFilterChar;
  published
    property Cursor default crIBeam;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Font: TvxFont read FFont write SetFont;
    property TextAlign: TvxTextAlign read FTextAlign write SetTextAlign default vgTextAlignNear;
    property Resource;
    property BindingSource;
    property ReadOnly: boolean read FReadOnly write FReadOnly;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnChangeTracking: TNotifyEvent read FOnChangeTracking write FOnChangeTracking;
    property OnTyping: TNotifyEvent read FOnTyping write FOnTyping;
  end;

  TvxTextBox = class(TvxCustomTextBox)
  private
  protected
  public
  published
    property Password;
    property Text;
  end;

  TvxValueType = (
    vgValueInteger,
    vgValueFloat
    );

  TvxNumberBox = class(TvxCustomTextBox)
  private
    FValue: single;
    FMin: single;
    FMax: single;
    FPressed: boolean;
    FPressedPos: TvxPoint;
    FPressedVert: boolean;
    FPressedInc: single;
    FValueType: TvxValueType;
    FHorzIncrement: single;
    FVertIncrement: single;
    FDecimalDigits: integer;
    procedure SetMax(const Value: single);
    procedure SetMin(const Value: single);
    procedure SetValue(const AValue: single);
    procedure SetValueType(const Value: TvxValueType);
    procedure SetDecimalDigits(const Value: integer);
  protected
    procedure Change; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure SetText(const Value: WideString); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    procedure PaintChildren; override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
  published
    property DecimalDigits: integer read FDecimalDigits write SetDecimalDigits default 2;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property ShowCaret default true;
    property Value: single read FValue write SetValue;
    property ValueType: TvxValueType read FValueType write SetValueType;
    property HorzIncrement: single read FHorzIncrement write FHorzIncrement;
    property VertIncrement: single read FVertIncrement write FVertIncrement;
  end;

  TvxSpinBox = class(TvxCustomTextBox)
  private
    FValue: single;
    FMin: single;
    FMax: single;
    FValueType: TvxValueType;
    FMinus, FPlus: TvxCustomButton;
    FIncrement: single;
    FDecimalDigits: integer;
    procedure SetMax(const Value: single);
    procedure SetMin(const Value: single);
    procedure SetValue(const AValue: single);
    procedure SetValueType(const Value: TvxValueType);
    procedure SetDecimalDigits(const Value: integer);
  protected
    procedure SetText(const Value: WideString); override;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure Change; override;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure DoMinusClick(Sender: TObject);
    procedure DoPlusClick(Sender: TObject);
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property DecimalDigits: integer read FDecimalDigits write SetDecimalDigits default 2;
    property Min: single read FMin write SetMin;
    property Max: single read FMax write SetMax;
    property Increment: single read FIncrement write FIncrement;
    property ShowCaret default true;
    property Value: single read FValue write SetValue;
    property ValueType: TvxValueType read FValueType write SetValueType;
    property TextAlign default vgTextAlignCenter;
  end;

  TvxComboTextBox = class(TvxCustomTextBox)
  private
    FDropDownCount: integer;
    FPopup: TvxPopup;
    FListBox: TvxComboListBox;
    FPlacement: TvxPlacement;
    FItems: TvxWideStrings;
    FItemHeight: single;
    procedure DoItemsChanged(Sender: TObject);
    procedure RebuildList;
    procedure SetItemHeight(const Value: single);
    procedure SetItems(const Value: TvxWideStrings);
    function GetItemIndex: integer;
    procedure SetItemIndex(const Value: integer);
    function GetCount: integer;
    function GetListBoxResource: string;
    procedure SetListBoxResource(const Value: string);
  protected
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure ChangeParent; override;
    procedure DoTyping(Sender: TObject);
    procedure DoClosePopup(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
    procedure DropDown;
    property ListBox: TvxComboListBox read FListBox write FListBox;
    property Count: integer read GetCount;
  published
    property Cursor default crDefault;
    property DropDownCount: integer read FDropDownCount write FDropDownCount default 8;
    property ItemHeight: single read FItemHeight write SetItemHeight;
    property ItemIndex: integer read GetItemIndex write SetItemIndex;
    property Items: TvxWideStrings read FItems write SetItems;
    property ListBoxResource: string read GetListBoxResource write SetListBoxResource;
    property Text;
  end;

  TvxComboTrackBar = class(TvxCustomTextBox)
  private
    FPopup: TvxPopup;
    FTrackBar: TvxTrackBar;
    FPlacement: TvxPlacement;
    function GetFrequency: single;
    function GetMax: single;
    function GetMin: single;
    procedure SetFrequency(const Value: single);
    procedure SetMax(const Value: single);
    procedure SetMin(const Value: single);
    procedure SetValue(const AValue: single);
    function GetValue: single;
  protected
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure ChangeParent; override;
    procedure DoTrackChange(Sender: TObject); virtual;
    procedure DropDown;
    procedure DoClosePopup(Sender: TObject);
    procedure Change; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    property TrackBar: TvxTrackBar read FTrackBar write FTrackBar;
  published
    property Min: single read GetMin write SetMin;
    property Max: single read GetMax write SetMax;
    property Value: single read GetValue write SetValue;
    property Frequency: single read GetFrequency write SetFrequency;
    property Text stored false;
  end;

  TvxTextBoxClearBtn = class(TvxCustomTextBox)
  private
    FClearBtn: TvxCustomButton;
  protected
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure DoClearBtnClick(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Password;
    property Text;
  end;

  TvxRoundTextBox = class(TvxTextBox)
  private
  protected
  public
  published
  end;

  TvxHudTextBox = class(TvxTextBox)
  private
  protected
  public
  published
  end;

  TvxHudRoundTextBox = class(TvxTextBox)
  private
  protected
  public
  published
  end;

  TvxHudNumberBox = class(TvxNumberBox)
  private
  protected
  public
  published
  end;

  TvxHudSpinBox = class(TvxSpinBox)
  private
  protected
  public
  published
  end;

  TvxHudComboTextBox = class(TvxComboTextBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudComboTrackBar = class(TvxComboTrackBar)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

type

  TEditCharCase = (vgecNormal, vgecUpperCase, vgecLowerCase);

  TInsertOption = (ioSelected, ioMoveCaret, ioCanUndo, ioUnDoPairedWithPriv);
  TInsertOptions = set of TInsertOption;
  TDeleteOption = (doMoveCaret, doCanUndo);
  TDeleteOptions = set of TDeleteOption;

  TActionType = (atDelete, atInsert);

  TLinesBegs = array of integer;
  PLinesBegs = ^TLinesBegs;

  TCaretPosition = record
    Line, Pos: integer;
  end;

  PEdtAction = ^TEdtAction;

  TEdtAction = record
    ActionType: TActionType;
    PairedWithPriv: boolean;
    StartPosition: integer;
    DeletedFragment: WideString; {For atDelete}
    Length: integer; {For atInsert}
  end;

  TvxMemo = class;

  TEdtActionStack = class(TStack)
  private
    FOwner: TvxMemo;
  public
    constructor Create(AOwner: TvxMemo);
    destructor Destroy; override;

    procedure FragmentInserted(StartPos, FragmentLength: integer; IsPairedWithPriv: boolean);
    procedure FragmentDeleted(StartPos: integer; Fragment: WideString);
    procedure CaretMovedBy(Shift: integer);

    function RollBackAction: boolean;
  end;

  TSelArea = array of TvxRect;

  TvxMemo = class(TvxScrollBox)
  private
    FNeedChange: boolean;
    FText: WideString;
    FFontFill: TvxBrush;
    FFont: TvxFont;
    FTextAlign: TvxTextAlign;
    FInternalMustUpdateLines: boolean;
    FLMouseSelecting: boolean;
    FOldMPt: TvxPoint;
    FCaretPosition: TCaretPosition;
    FFirstVisibleChar: integer;
    FUnwrapLines: TvxWideStrings;
    {$IFNDEF NOVCL}
    FPopupMenu: TPopupMenu;
    {$ENDIF}
    FAutoSelect: boolean;
    FCharCase: TEditCharCase;
    FHideSelection: Boolean;
    FMaxLength: Integer;
    FReadOnly: Boolean;
    FOnChange: TNotifyEvent;
    FTextAlignment: TAlignment;
    FActionStack: TEdtActionStack;
    FLines: TvxWideStrings;
    FWordWrap: boolean;
    FLinesBegs: array of integer;
    FSelStart: TCaretPosition;
    FSelEnd: TCaretPosition;
    FSelected: boolean;
    FOldSelStartPos, FOldSelEndPos, FOldCaretPos: integer;
    FSelectionFill: TvxBrush;
    FOnChangeTracking: TNotifyEvent;
    function GetSelBeg: TCaretPosition;
    function GetSelEnd: TCaretPosition;
    procedure StorePositions;
    procedure RestorePositions;
    procedure SelectAtPos(APos: TCaretPosition);
    procedure SetCaretPosition(const Value: TCaretPosition);
    procedure SetSelLength(const Value: integer);
    procedure SetSelStart(const Value: integer);
    function GetSelStart: integer;
    function GetSelLength: integer;
    procedure UpdateHScrlBarByCaretPos;
    procedure UpdateVScrlBarByCaretPos;
    function GetSelText: WideString;
    procedure SetAutoSelect(const Value: boolean);
    procedure SetCharCase(const Value: TEditCharCase);
    procedure SetHideSelection(const Value: Boolean);
    procedure SetMaxLength(const Value: Integer);
    procedure SelectAtMousePoint;
    function GetNextWordBeging(StartPosition: TCaretPosition): TCaretPosition;
    function GetPrivWordBeging(StartPosition: TCaretPosition): TCaretPosition;
    function GetPositionShift(APos: TCaretPosition; Delta: integer {char count}): TCaretPosition;
    procedure MoveCareteBy(Delta: integer);
    procedure MoveCaretLeft;
    procedure MoveCaretRight;
    procedure MoveCaretVertical(LineDelta: integer);
    procedure MoveCaretDown;
    procedure MoveCaretUp;
    procedure MoveCaretPageUp;
    procedure MoveCaretPageDown;
    procedure UpdateCaretPosition(UpdateScrllBars: boolean);
    procedure SetTextAlignment(const Value: TAlignment);
    procedure SetLines(const Value: TvxWideStrings);
    procedure GetLineBounds(LineIndex: integer; var LineBeg, LineLength: integer);
    function GetLineCount: integer;
    function GetLine(Index: integer): WideString; //Returns Line without special symbols at the end.
    function GetLineInternal(Index: integer): WideString; //Returns Line with special symbols at the end.
    procedure InsertLine(Index: Integer; const S: WideString);
    procedure DeleteLine(Index: Integer);
    procedure ClearLines;
    procedure SetWordWrap(const Value: boolean);
    function GetPageSize: single;
    function GetLineWidth(LineNum: Integer): single;
    function GetWidestLine: integer;
    function FillLocalLinesBegs(PText: PWideString; ABegChar, AEndChar: integer;
      TmpLinesBegs: PLinesBegs): integer;
    procedure UpdateRngLinesBegs(PText: PWideString; AUpdBegLine, AUpdEndLine,
      AUpdBegChar, AUpdEndChar, ACharDelta, AOldWideslLineWidth: integer);
    function GetShowSelection: boolean;
    function GetLineRealEnd(AStartPos: TCaretPosition; PText: PWideString): TCaretPosition;
    procedure SetFont(const Value: TvxFont);
    procedure SetTextAlign(const Value: TvxTextAlign);
    function TextWidth(const Str: WideString): single;
    procedure HScrlBarChange(Sender: TObject);
    procedure SetUpdateState(Updating: Boolean);
    function GetUnwrapLines: TvxWideStrings;
  protected
    FUpdating: boolean;
    FWidesLineIndex: integer;
    FTextWidth: array of integer;
    function GetLineHeight: single;
    function GetPointPosition(Pt: TvxPoint): TCaretPosition;
    procedure SetText(const Value: WideString); virtual;
    function GetSelArea: TSelArea; virtual;
    procedure DrawPasswordChar(SymbolRect: TvxRect; Selected: boolean); virtual;
    procedure CreatePopupMenu; virtual;
    procedure UpdatePopupMenuItems; virtual;
    procedure ApplyStyle; override;
    function ContentPos: TvxPoint;
    procedure Change; virtual;
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    function ValidText(NewText: WideString): boolean; virtual;
    function CanAutoSize(var NewWidth, NewHeight: Integer): Boolean; //override;
    procedure ContextMenu(const ScreenPosition: TvxPoint); override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; x, y: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; x, y: single); override;
    procedure MouseMove(Shift: TShiftState; x, y, dx, dy: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure SelectWord;
    procedure FontChanged(Sender: TObject);
    procedure DoUndo(Sender: TObject);
    procedure DoCut(Sender: TObject);
    procedure DoCopy(Sender: TObject);
    procedure DoPaste(Sender: TObject);
    procedure DoDelete(Sender: TObject);
    procedure DoSelectAll(Sender: TObject);
    procedure UpdateLines;
    { inherited }
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure EnterFocus; override;
    procedure KillFocus; override;
    procedure VScrollChange(Sender: TObject);
    function GetContentBounds: TvxRect; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure CopyToClipboard;
    procedure PasteFromClipboard;
    procedure CutToClipboard;
    procedure ClearSelection;
    procedure SelectAll;
    procedure GoToTextEnd;
    procedure GoToTextBegin;
    procedure GotoLineEnd;
    procedure GoToLineBegin;
    function GetPositionPoint(ACaretPos: TCaretPosition): TvxPoint;
    procedure UnDo;
    procedure InsertAfter(Position: TCaretPosition; S: WideString; Options: TInsertOptions);
    procedure DeleteFrom(Position: TCaretPosition; ALength: integer; Options: TDeleteOptions);
    function TextPosToPos(APos: integer): TCaretPosition;
    function PosToTextPos(APostion: TCaretPosition): integer;
    property SelStart: integer read GetSelStart write SetSelStart;
    property SelLength: integer read GetSelLength write SetSelLength;
    property SelText: WideString read GetSelText;
    property CaretPosition: TCaretPosition read FCaretPosition write SetCaretPosition;
    property LineWidth[LineNum: Integer]: single read GetLineWidth;
    { return unwrapped lines }
    property UnwrapLines: TvxWideStrings read GetUnwrapLines;
    { custom colors - only work when style was loaded }
    property FontFill: TvxBrush read FFontFill;
    property SelectionFill: TvxBrush read FSelectionFill;
  published
    property Cursor default crIBeam;
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property AutoSelect: boolean read FAutoSelect write SetAutoSelect default true;
    property CharCase: TEditCharCase read FCharCase write SetCharCase default vgecNormal;
    property Enabled;
    property HideSelection: Boolean read FHideSelection write SetHideSelection default True;
    property Lines: TvxWideStrings read FLines write SetLines stored false;
    property MaxLength: Integer read FMaxLength write SetMaxLength default 0;
    property ReadOnly: Boolean read FReadOnly write FReadOnly default False;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnChangeTracking: TNotifyEvent read FOnChangeTracking write FOnChangeTracking;
    property WordWrap: boolean read FWordWrap write SetWordWrap;
    property Font: TvxFont read FFont write SetFont;
    property Text: WideString read FText write SetText stored true;
    property TextAlign: TvxTextAlign read FTextAlign write SetTextAlign default vgTextAlignNear;
    property Resource;
  end;

  TvxHudMemo = class(TvxMemo)
  private
  protected
  public
  published
  end;

function ComposeCaretPos(ALine, APos: integer): TCaretPosition;

const
  colorPickSize = 10;

type

  TvxBitmapTrackBar = class(TvxTrackBar)
  private
    FBitmap: TvxBitmap;
    FBackground: TvxShape;
  protected
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure Realign; override;
    procedure UpdateBitmap;
    procedure FillBitmap; virtual;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
  end;

  TvxHueTrackBar = class(TvxBitmapTrackBar)
  private
  protected
    procedure FillBitmap; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxAlphaTrackBar = class(TvxBitmapTrackBar)
  private
  protected
    procedure FillBitmap; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxBWTrackBar = class(TvxBitmapTrackBar)
  private
  protected
    procedure FillBitmap; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxColorBox = class(TvxControl)
  private
    FColor: TvxColor;
    procedure SetColor(const Value: TvxColor);
  protected
  public
    constructor Create(AOwner: TComponent); override;
    procedure Paint; override;
    property Color: TvxColor read FColor write SetColor;
  published
  end;

  TvxColorQuad = class(TvxControl)
  private
    FColorBox: TvxColorBox;
    FColorBitmap: TvxBitmap;
    FHue: single;
    FSat: single;
    FLum: single;
    FOnChange: TNotifyEvent;
    FAlpha: single;
    procedure SetHue(const Value: single);
    procedure SetLum(const Value: single);
    procedure SetSat(const Value: single);
    procedure SetAlpha(const Value: single);
    procedure SetColorBox(const Value: TvxColorBox);
  protected
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    function GetAbsoluteRect: TvxRect; override;
    function pointInObject(X, Y: single): boolean; override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
  published
    property Hue: single read FHue write SetHue;
    property Lum: single read FLum write SetLum;
    property Sat: single read FSat write SetSat;
    property Alpha: single read FAlpha write SetAlpha;
    property ColorBox: TvxColorBox read FColorBox write SetColorBox;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxColorPicker = class(TvxControl)
  private
    FHueBitmap: TvxBitmap;
    FHue: single;
    FColorQuad: TvxColorQuad;
    procedure SetHue(const Value: single);
    function GetColor: TvxColor;
    procedure SetColor(const Value: TvxColor);
  protected
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    function GetAbsoluteRect: TvxRect; override;
    function pointInObject(X, Y: single): boolean; override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    property Color: TvxColor read GetColor write SetColor;
  published
    property Hue: single read FHue write SetHue;
    property ColorQuad: TvxColorQuad read FColorQuad write FColorQuad;
  end;

  TvxGradientEdit = class(TvxControl)
  private
    FBitmap: TvxBitmap;
    FGradient: TvxGradient;
    FCurrentPoint: integer;
    FCurrentPointInvisible: boolean;
    FMoving: boolean;
    FOnChange: TNotifyEvent;
    FOnSelectPoint: TNotifyEvent;
    FColorPicker: TvxColorPicker;
    procedure SetGradient(const Value: TvxGradient);
    function GetPointRect(const Point: integer): TvxRect;
    procedure DoChanged(Sender: TObject);
    procedure SetCurrentPoint(const Value: integer);
    procedure SetColorPicker(const Value: TvxColorPicker);
  protected
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Paint; override;
    procedure UpdateGradient;
    property Gradient: TvxGradient read FGradient write SetGradient;
    property CurrentPoint: integer read FCurrentPoint write SetCurrentPoint;
  published
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnSelectPoint: TNotifyEvent read FOnSelectPoint write FOnSelectPoint;
    property ColorPicker: TvxColorPicker read FColorPicker write SetColorPicker;
  end;

  TvxColorPanel = class(TvxControl)
  private
    FOnChange: TNotifyEvent;
    FColorQuad: TvxColorQuad;
    FAlphaTrack: TvxAlphaTrackBar;
    FHueTrack: TvxHueTrackBar;
    FColorBox: TvxColorBox;
    FUseAlpha: boolean;
    function GetColor: string;
    procedure SetColor(const Value: string);
    procedure SetColorBox(const Value: TvxColorBox);
    procedure SetUseAlpha(const Value: boolean);
  protected
    procedure DoAlphaChange(Sender: TObject);
    procedure DoHueChange(Sender: TObject);
    procedure DoQuadChange(Sender: TObject);
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure Loaded; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property Color: string read GetColor write SetColor;
    property ColorBox: TvxColorBox read FColorBox write SetColorBox;
    property UseAlpha: boolean read FUseAlpha write SetUseAlpha default true;
  end;

  TvxComboColorBox = class(TvxControl)
  private
    FPopup: TvxPopup;
    FColorPanel: TvxColorPanel;
    FColorBox: TvxColorBox;
    FColorText: TvxTextBox;
    FPlacement: TvxPlacement;
    FOnChange: TNotifyEvent;
    function GetValue: string;
    procedure SetValue(const Value: string);
    function GetUseAlpha: boolean;
    procedure SetUseAlpha(const Value: boolean);
  protected
    procedure ApplyStyle; override;
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure ChangeParent; override;
    procedure DoColorChange(Sender: TObject); virtual;
    procedure DoTextChange(Sender: TObject); virtual;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DropDown;
  published
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Color: string read GetValue write SetValue;
    property UseAlpha: boolean read GetUseAlpha write SetUseAlpha default true;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxHudHueTrackBar = class(TvxHueTrackBar)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudAlphaTrackBar = class(TvxAlphaTrackBar)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudBWTrackBar = class(TvxBitmapTrackBar)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

  TvxHudComboColorBox = class(TvxComboColorBox)
  private
  protected
  public
    constructor Create(AOwner: TComponent); override;
  published
  end;

type

  TvxTabItem = class(TvxTextControl)
  private
    FIndex: integer;
    FLayout: TvxVisualObject;
    FIsSelected: boolean;
    procedure SetIndex(const Value: integer);
  protected
    procedure ApplyStyle; override;
    procedure DesignSelect; override;
    procedure DesignInsert; override;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure SetVisible(const Value: boolean); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure Realign; override;
    procedure Select(ASelected: boolean);
  published
    { trigger }
    property IsSelected: boolean read FIsSelected;
    { props }
    property AutoTranslate default true;
    property Font;
    property Index: integer read FIndex write SetIndex;
    property TextAlign;
    property VertTextAlign;
    property Text;
    property Layout: TvxVisualObject read FLayout write FLayout;
    property Resource;
  end;

  TvxTabControl = class(TvxControl)
  private
    FItemIndex: integer;
    FOnChange: TNotifyEvent;
    FItemHeight: single;
    FFullSize: boolean;
    FBackground: TvxVisualObject;
    procedure SetItemIndex(const Value: integer);
    procedure SetItemHeight(const Value: single);
    procedure SetFullSize(const Value: boolean);
  protected
    function TabItem(AIndex: integer): TvxTabItem;
    function TabCount: integer;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure PaintChildren; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ItemClass: string; override;
    procedure Realign; override;
    procedure AddObject(AObject: TvxObject); override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); override;
    procedure KeyDown(var Key: Word; var KeyChar: WideChar; Shift: TShiftState); //override;
    procedure KeyUp(var Key: Word; var KeyChar: WideChar; Shift: TShiftState); //override;
    procedure SetItem(AItem: TvxTabItem);
  published
    property Resource;
    property FullSize: boolean read FFullSize write SetFullSize default false;
    property ItemIndex: integer read FItemIndex write SetItemIndex default -1;
    property ItemHeight: single read FItemHeight write SetItemHeight;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  { HUD }

  TvxHudTabItem = class(TvxTabItem)
  private
  public
  end;

  TvxHudTabControl = class(TvxTabControl)
  private
  protected
  public
    function ItemClass: string; override;
  published
  end;

type

  TvxIPhoneButton = class(TvxBitmapButton)
  private
    FBackground: TvxBrush;
    procedure SetBackground(const Value: TvxBrush);
  protected
    procedure BackChanged(Sender: TObject);
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    { props }
    property Background: TvxBrush read FBackground write SetBackground;
    { inherited }
    property Resource;
  end;

  TvxDockBar = class(TvxControl)
  private
    FMousePos: TvxPoint;
    FMaxSize: single;
    FMinSize: single;
    FAmplitude: single;
    procedure SetMaxSize(const Value: single);
    procedure SetMinSize(const Value: single);
  protected
    procedure Realign; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseLeave; override;
    procedure Paint; override;
  published
    property MinSize: single read FMinSize write SetMinSize;
    property MaxSize: single read FMaxSize write SetMaxSize;
    property Resource;
  end;

  TvxDropTarget = class(TvxTextControl)
  private
    FOnDrop: TvxDragDropEvent;
    FFilter: string;
  protected
    procedure DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean); override;
    procedure DragDrop(const Data: TvxDragObject; const Point: TvxPoint); override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Filter: string read FFilter write FFilter;
    property Font;
    property Text;
    property OnDroped: TvxDragDropEvent read FOnDrop write FOnDrop;
  end;

  TvxPlotGrid = class(TvxVisualObject)
  private
    FMarks: single;
    FFrequency: single;
    FLineFill: TvxBrush;
    procedure SetFrequency(const Value: single);
    procedure SetMarks(const Value: single);
    procedure SetLineFill(const Value: TvxBrush);
    procedure LineFillChanged(Sender: TObject);
  protected
    procedure Paint; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property LineFill: TvxBrush read FLineFill write SetLineFill;
    property Marks: single read FMarks write SetMarks;
    property Frequency: single read FFrequency write SetFrequency;
  end;

  TvxImageViewer = class(TvxScrollBox)
  private
    FBack: TvxRectangle;
    FImage: TvxImage;
    FScale: single;
    FMouseScaling: boolean;
    FShowBackground: boolean;
    function GetBitmap: TvxBitmap;
    procedure SetBitmap(const Value: TvxBitmap);
    procedure SetScale(const Value: single);
    function GetBackgroundFill: TvxBrush;
    procedure SetBackgroundFill(const Value: TvxBrush);
    procedure SetShowBackground(const Value: boolean);
  protected
    function GetContentBounds: TvxRect; override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); override;
    procedure DoBitmapChange(Sender: TObject);
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure BestFit;
  published
    property BackgroundFill: TvxBrush read GetBackgroundFill write SetBackgroundFill;
    property Bitmap: TvxBitmap read GetBitmap write SetBitmap;
    property BitmapScale: single read FScale write SetScale;
    property ShowBackground: boolean read FShowBackground write SetShowBackground default false;
    property MouseScaling: boolean read FMouseScaling write FMouseScaling default true;
  end;

  { Calendar control }

  TvxCalDayOfWeek = (vgMonday, vgTuesday, vgWednesday, vgThursday,
    vgFriday, vgSaturday, vgSunday, vgLocaleDefault);

  TvxCalendar = class(TvxControl)
  private
    FDateTime: TDateTime;
    FDays: TvxListBox;
    FToday, FPrev, FNext: TvxButton;
    FMonths: TvxPopupBox;
    FYears: TvxPopupBox;
    FWeeks: TvxGridLayout;
    FFirstDayOfWeek: TvxCalDayOfWeek;
    FFirstDayOfWeekNum: integer;
    FWeek: TvxGridLayout;
    FTodayDefault: Boolean;
    FOnChange: TNotifyEvent;
    FWeekNumbers: Boolean;
    FOnDayChange: TNotifyEvent;
    function GetDate: TDate;
    procedure SetDate(Value: TDate);
    procedure SetDateTime(const Value: TDateTime);
    procedure SetFirstDayOfWeek(const Value: TvxCalDayOfWeek);
    procedure SetTodayDefault(const Value: Boolean);
    procedure SetWeekNumbers(const Value: Boolean);
  protected
    FDisableDayChange: integer;
    procedure DoPrevClick(Sender: TObject);
    procedure DoNextClick(Sender: TObject);
    procedure DoTodayClick(Sender: TObject);
    procedure DoDayChange(Sender: TObject);
    procedure DoMonthChange(Sender: TObject);
    procedure DoYearChange(Sender: TObject);
    procedure FillList;
    function GetData: Variant; override;
    procedure SetData(const Value: Variant); override;
    procedure MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure Realign; override;
    property DateTime: TDateTime read FDateTime write SetDateTime;
  published
    property BindingSource;
    property Date: TDate read GetDate write SetDate;
    property FirstDayOfWeek: TvxCalDayOfWeek read FFirstDayOfWeek write SetFirstDayOfWeek
      default vgLocaleDefault;
    property TodayDefault: Boolean read FTodayDefault write SetTodayDefault default false;
    property WeekNumbers: Boolean read FWeekNumbers write SetWeekNumbers default false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
    property OnDayChange: TNotifyEvent read FOnDayChange write FOnDayChange;
  end;

  TvxCalendarBox = class(TvxTextControl)
  private
    FPopup: TvxPopup;
    FCalendar: TvxCalendar;
    FPlacement: TvxPlacement;
    function GetDate: TDate;
    procedure SetDate(const Value: TDate);
  protected
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure DoClosePopup(Sender: TObject);
    procedure DoCalendarChanged(Sender: TObject);
    procedure DoDayChanged(Sender: TObject);
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    procedure ApplyStyle; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DropDown;
    property Calendar: TvxCalendar read FCalendar;
  published
    property CanFocused default true;
    property DisableFocusEffect;
    property TabOrder;
    property Cursor default crDefault;
    property Date: TDate read GetDate write SetDate;
    property TextAlign default vgTextAlignNear;
  end;

  TvxCalendarTextBox = class(TvxCustomTextBox)
  private
    FPopup: TvxPopup;
    FCalendar: TvxCalendar;
    FPlacement: TvxPlacement;
    function GetDate: TDate;
    procedure SetDate(const Value: TDate);
  protected
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure DoClosePopup(Sender: TObject);
    procedure DoCalendarChanged(Sender: TObject);
    procedure DoDayChanged(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    procedure DropDown;
    property Calendar: TvxCalendar read FCalendar;
  published
    property Cursor default crDefault;
    property Date: TDate read GetDate write SetDate;
  end;

  { Compound controls }

  TvxCompoundTrackBar = class(TvxControl)
  private
    FValueLabel: TvxLabel;
    FTextLabel: TvxLabel;
    FTrackBar: TvxTrackBar;
    FDecimalDigits: integer;
    FOnChange: TNotifyEvent;
    FSuffix: WideString;
    function GetValue: single;
    procedure SetValue(const Value: single);
    procedure SetDecimalDigits(const Value: integer);
    procedure SetSuffix(const Value: WideString);
  protected
    procedure DoTrack(Sender: TObject);
    procedure DoTracking(Sender: TObject);
    procedure UpdateLabel;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property DecimalDigits: integer read FDecimalDigits write SetDecimalDigits default 2;
    property TextLabel: TvxLabel read FTextLabel;
    property TrackBar: TvxTrackBar read FTrackBar;
    property ValueLabel: TvxLabel read FValueLabel;
    property Suffix: WideString read FSuffix write SetSuffix;
    property Value: single read GetValue write SetValue stored false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundAngleBar = class(TvxControl)
  private
    FValueLabel: TvxLabel;
    FTextLabel: TvxLabel;
    FAngleBar: TvxAngleButton;
    FDecimalDigits: integer;
    FOnChange: TNotifyEvent;
    function GetValue: single;
    procedure SetValue(const Value: single);
  protected
    procedure DoChange(Sender: TObject);
    procedure UpdateLabel;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property AngleButton: TvxAngleButton read FAngleBar;
    property ValueLabel: TvxLabel read FValueLabel;
    property Value: single read GetValue write SetValue stored false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundTextBox = class(TvxControl)
  private
    FTextLabel: TvxLabel;
    FTextBox: TvxTextBox;
    FOnChange: TNotifyEvent;
    function GetText: WideString;
    procedure SetText(const Value: WideString);
  protected
    procedure DoChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property TextBox: TvxTextBox read FTextBox;
    property Value: WideString read GetText write SetText stored false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundMemo = class(TvxControl)
  private
    FTextLabel: TvxLabel;
    FMemo: TvxMemo;
    FOnChange: TNotifyEvent;
    function GetText: WideString;
    procedure SetText(const Value: WideString);
  protected
    procedure DoChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property Memo: TvxMemo read FMemo;
    property Value: WideString read GetText write SetText stored false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundNumberBox = class(TvxControl)
  private
    FTextLabel: TvxLabel;
    FNumberBox: TvxNumberBox;
    FOnChange: TNotifyEvent;
    function GetValue: single;
    procedure SetValue(const Value: single);
  protected
    procedure DoChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property NumberBox: TvxNumberBox read FNumberBox;
    property Value: single read GetValue write SetValue stored false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundPopupBox = class(TvxControl)
  private
    FTextLabel: TvxLabel;
    FPopupBox: TvxPopupBox;
    FOnChange: TNotifyEvent;
    function GetItemIndex: integer;
    procedure SetItemIndex(const Value: integer);
  protected
    procedure DoChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property PopupBox: TvxPopupBox read FPopupBox;
    property Value: integer read GetItemIndex write SetItemIndex;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundColorButton = class(TvxControl)
  private
    FTextLabel: TvxLabel;
    FColorButton: TvxColorButton;
    FOnChange: TNotifyEvent;
    function GetValue: string;
    procedure SetValue(const Value: string);
  protected
    procedure DoChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property ColorButton: TvxColorButton read FColorButton;
    property Value: string read GetValue write SetValue stored false;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

  TvxCompoundImage = class(TvxControl)
  private
    FTextLabel: TvxLabel;
    FImage: TvxImageControl;
    FOnChange: TNotifyEvent;
  protected
    procedure DoChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  published
    property TextLabel: TvxLabel read FTextLabel;
    property Image: TvxImageControl read FImage;
    property OnChange: TNotifyEvent read FOnChange write FOnChange;
  end;

type

  TvxImageList = class(TCustomImageList)
  private
    FImages: TList;
    function GetCount: integer;
    function GetBitmap(Index: integer): TvxBitmap;
    procedure UpdateList;
  protected
    procedure DefineProperties(Filer: TFiler); override;
    procedure ReadData(Stream: TStream);
    {$IFDEF KS_COMPILER7_UP} override;
    {$ENDIF}
    procedure WriteData(Stream: TStream);
    {$IFDEF KS_COMPILER7_UP} override;
    {$ENDIF}
    procedure ReadImage(Stream: TStream);
    procedure WriteImage(Stream: TStream);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function Add(Bitmap: TvxBitmap): integer;
    procedure Clear;
    property Images[Index: integer]: TvxBitmap read GetBitmap;
    property Count: integer read GetCount;
  published
    property Height default 32;
    property Width default 32;
  end;

type
  TvxBrushDesign = class(TForm)
    panelSolid: TvxRectangle;
    panelGradient: TvxRectangle;
    solidQuad: TvxColorQuad;
    solidPicker: TvxColorPicker;
    gradQuad: TvxColorQuad;
    vgBrushDesigner: TDicomScene;
    solidCont: TvxRectangle;
    gradEditor: TvxGradientEdit;
    dsgnRoot: TvxBackground;
    Layout1: TvxLayout;
    ext1: TvxLabel;
    Layout2: TvxLayout;
    Layout3: TvxLayout;
    gradPicker: TvxColorPicker;
    brushTabControl: TvxTabControl;
    tabNone: TvxTabItem;
    tabSolid: TvxTabItem;
    tabGradient: TvxTabItem;
    Text1: TvxLabel;
    Text2: TvxLabel;
    Text3: TvxLabel;
    brushList: TvxListBox;
    textSolidR: TvxNumberBox;
    textSolidG: TvxNumberBox;
    textSolidB: TvxNumberBox;
    textSolidA: TvxNumberBox;
    textGradR: TvxNumberBox;
    textGradG: TvxNumberBox;
    textGradB: TvxNumberBox;
    textGradA: TvxNumberBox;
    textSolidHex: TvxTextBox;
    textGradHex: TvxTextBox;
    gradColorRect: TvxColorBox;
    solidColorRect: TvxColorBox;
    tabBitmap: TvxTabItem;
    panelBitmap: TvxLayout;
    tabRes: TvxTabItem;
    panerRes: TvxLayout;
    bitmapImage: TvxImage;
    Layout5: TvxLayout;
    btnSelectBitmap: TvxButton;
    resList: TvxListBox;
    Layout6: TvxLayout;
    btnMakeRes: TvxButton;
    Label1: TvxLabel;
    Rectangle1: TvxRectangle;
    tileModeList: TvxPopupBox;
    btnCancel: TvxButton;
    btnOK: TvxButton;
    makeResLayout: TvxLayout;
    gradAngle: TvxAngleButton;
    gradAlabel: TvxLabel;
    gradKind: TvxPopupBox;
    gradAngleLabel: TvxLabel;
    HudWindow1: TvxHudWindow;
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure solidQuadChange(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure gradEditorChange(Sender: TObject);
    procedure gradQuadChange(Sender: TObject);
    procedure brushListChange(Sender: TObject);
    procedure brushTabControlChange(Sender: TObject);
    procedure textGradRChange(Sender: TObject);
    procedure textGradHexChange(Sender: TObject);
    procedure textSolidHexChange(Sender: TObject);
    procedure btnSelectBitmapClick(Sender: TObject);
    procedure btnMakeResClick(Sender: TObject);
    procedure resListChange(Sender: TObject);
    procedure tileModeListChange(Sender: TObject);
    procedure btnOKClick(Sender: TObject);
    procedure btnCancelClick(Sender: TObject);
    procedure textSolidRChange(Sender: TObject);
    procedure gradAngleChange(Sender: TObject);
    procedure gradKindChange(Sender: TObject);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); //override;
    function UniqueName(S: string): string; //override;
  private
    FBrush: TvxBrush;
    FScene: IvgScene;
    FComp: TPersistent;
    procedure SetBrush(const Value: TvxBrush);
    procedure SetComp(const Value: TPersistent);
    procedure rebuilResList;
    { Private declarations }
  public
    { Public declarations }
    property Comp: TPersistent read FComp write SetComp;
    property Brush: TvxBrush read FBrush write SetBrush;
  end;

  TvxBrushStyles = set of TvxBrushStyle;

  TvxBrushDialog = class(TComponent)
  private
    FShowStyles: TvxBrushStyles;
    FShowBrushList: boolean;
    FShowMakeResource: boolean;
    FBrush: TvxBrush;
    FComponent: TComponent;
    FTitle: WideString;
    procedure SetBrush(const Value: TvxBrush);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function Execute: boolean;
    property Brush: TvxBrush read FBrush write SetBrush;
    property Component: TComponent read FComponent write FComponent;
  published
    property ShowStyles: TvxBrushStyles read FShowStyles write FShowStyles;
    property ShowBrushList: boolean read FShowBrushList write FShowBrushList default true;
    property ShowMakeResource: boolean read FShowMakeResource write FShowMakeResource;
    property Title: WideString read FTitle write FTitle;
  end;

var
  vgDesign: TvxBrushDesign;

procedure SelectInDesign(AObject: TObject; AComp: TPersistent);
procedure ShowBrushDialog(const Brush: TvxBrush; const ShowStyles: TvxBrushStyles; const ShowBrushList: boolean = true);
procedure ShowGradientDialog(const Gradient: TvxGradient);
function ShowColorDialog(const Color: string): string;

type
  TvxBitmapEditor = class(TForm)
    vgScene1: TDicomScene;
    Root1: TvxBackground;
    Button1: TvxButton;
    Layout1: TvxLayout;
    Button2: TvxButton;
    btnOk: TvxButton;
    ScrollBox1: TvxScrollBox;
    Rectangle1: TvxPanel;
    Preview: TvxPaintBox;
    labelScale: TvxLabel;
    trackScale: TvxTrack;
    cropButton: TvxButton;
    Image1: TvxImage;
    btnPaste: TvxButton;
    Layout2: TvxLayout;
    btnFit: TvxButton;
    btnOriginal: TvxButton;
    editControl: TvxControl;
    Button3: TvxButton;
    GroupBox1: TvxGroupBox;
    newWidth: TvxNumberBox;
    Label1: TvxLabel;
    Label2: TvxLabel;
    newHeight: TvxNumberBox;
    resizeLayout: TvxBackground;
    ShadowEffect1: TvxShadowEffect;
    Button4: TvxButton;
    Button5: TvxButton;
    btnResize: TvxButton;
    btnSave: TvxButton;
    SaveDialog1: TSaveDialog;
    procedure Button1Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure PreviewPaint(Sender: TObject; const Canvas: TvxCanvas);
    procedure trackScaleChange(Sender: TObject);
    procedure cropButtonClick(Sender: TObject);
    procedure btnOkClick(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure trackScaleMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Single);
    procedure btnPasteClick(Sender: TObject);
    procedure btnFitClick(Sender: TObject);
    procedure btnOriginalClick(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure btnResizeClick(Sender: TObject);
    procedure Button4Click(Sender: TObject);
    procedure Button5Click(Sender: TObject);
    procedure newWidthChange(Sender: TObject);
    procedure newHeightChange(Sender: TObject);
    procedure btnSaveClick(Sender: TObject);
  private
    { Private declarations }
    FBitmap: TvxBitmap;
    FSourceRect: TvxRect;
    FCropRect: TvxSelection;
    FOldScale: single;
    FFileName: string;
  public
    { Public declarations }
    procedure AssignFromBitmap(B: TvxBitmap);
    procedure AssignToBitmap(B: TvxBitmap);
    property FileName: string read FFileName write FFileName;
  end;

var
  vgBitmapEditor: TvxBitmapEditor;

type
  TfrmDsgnImageList = class(TForm)
    vgScene1: TDicomScene;
    Root1: TvxBackground;
    HudWindow1: TvxHudWindow;
    ImageList: TvxImageListBox;
    btnAddFiles: TvxHudButton;
    OpenDialog1: TOpenDialog;
    HudButton1: TvxHudButton;
    btnDelete: TvxHudButton;
    btnClear: TvxHudButton;
    btnCancel: TvxHudButton;
    procedure btnAddFilesClick(Sender: TObject);
    procedure btnClearClick(Sender: TObject);
    procedure btnDeleteClick(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  frmDsgnImageList: TfrmDsgnImageList;

procedure ShowDsgnImageList(ImgList: TvxImageList);

type

  TvxOnChangeProperty = procedure(Sender: TObject; PropertyName: string) of object;

  TvxInspector = class(TvxTreeView)
  private
    FSelectedObject: TComponent;
    FEditBox: TvxTextBox;
    FComboBox: TvxPopupBox;
    FEditButton: TvxButton;
    FDisabledProperties: TStrings;
    FShowProperties: boolean;
    FShowEvents: boolean;
    FOnChangeProperty: TvxOnChangeProperty;
    procedure RebuildList;
    procedure RebuildEditor;
    procedure SetSelectedObject(const Value: TComponent);
    procedure SetDisabledProperties(const Value: TStrings);
    procedure SetShowEvents(const Value: boolean);
    procedure SetShowProperties(const Value: boolean);
    procedure UpdateEditorPos;
  protected
    function Editor: TvxControl;
    procedure InsAddObject(ItemRoot: TvxObject; Root: TObject);
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure DialogKey(var Key: Word; Shift: TShiftState); override;
    procedure SetSelected(const Value: TvxTreeViewItem); override;
    procedure VScrollChange(Sender: TObject); override;
    procedure DoEditorChange(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property DisabledProperties: TStrings read FDisabledProperties write SetDisabledProperties;
    property SelectedObject: TComponent read FSelectedObject write SetSelectedObject;
    property ShowProperties: boolean read FShowProperties write SetShowProperties default true;
    property ShowEvents: boolean read FShowEvents write SetShowEvents default false;
    property OnChangeProperty: TvxOnChangeProperty read FOnChangeProperty write FOnChangeProperty;
  end;

const
  merge3 = 0;

  {$IFDEF LINUX}

  {$IFDEF win32}
  {$DEFINE pangowin}
  pangocairolib = 'libpangocairo-1.0-0.dll';
  {$IFDEF FPC}
  {$IFNDEF NO_SMART_LINK}
  {$SMARTLINK on}
  {$ENDIF}
  {$ENDIF}
  {$ELSE}
  {$IFDEF UseCustomLibs}
  pangocairolib = '';
  {$ELSE}
  pangocairolib = 'libpangocairo-1.0.so.0';
  gdkcairolib = 'libgdkcairo-1.0.so.0';
  {$ENDIF}
  {$ENDIF}

  {$IFDEF LINUX}
type
  PGInputStream = Pointer;
function g_memory_input_stream_new_from_data(const Data: Pointer; size: gssize; Notify: Pointer): PGInputStream; cdecl; external gliblib;

procedure gdk_cairo_set_source_pixbuf(cr: Pcairo_t; const Pb: PGdkPixbuf; const x, y: double); cdecl; external LIB_CAIRO;

function gdk_pixbuf_get_file_info(filename: Pchar; var width, height: gint): integer; cdecl; external gdkpixbuflib;
function gdk_pixbuf_new_from_stream(stream: PGInputStream; Cancelable: pointer; error: PPGError): PGdkPixbuf; cdecl; external gdkpixbuflib;

function gdk_pixbuf_save_to_buffer(pb: PGdkPixbuf; var bug: PByte; var Len: gsize; const typ: PChar; Error: Pointer): gboolean; cdecl; external gdkpixbuflib;
function gdk_pixbuf_save_to_bufferv(pb: PGdkPixbuf; var bug: PByte; var Len: gsize; const typ: PChar; option_keys: PPchar; option_values: PPchar; Error: Pointer): gboolean; cdecl; external gdkpixbuflib;

function gdk_screen_get_rgba_colormap(const screen: PGdkScreen): PGdkColormap; cdecl; external gdklib;
procedure gdk_window_set_composited(window: PGdkWindow; Composited: gboolean); cdecl; external gdklib;

procedure cairo_path_extents(cr: Pcairo_t; var x1, y1, x2, y2: double); cdecl; external LIB_CAIRO;

function gdk_cairo_create(drawable: PGdkDrawable): Pcairo_t; cdecl; external LIB_CAIRO;
function pango_cairo_create_context(cr: Pcairo_t): PPangoContext; cdecl; external pangocairolib;
function pango_cairo_create_layout(cr: Pcairo_t): PPangoLayout; cdecl; external pangocairolib;
procedure pango_cairo_update_layout(cr: Pcairo_t; layout: PPangoLayout); cdecl; external pangocairolib;
procedure pango_cairo_show_layout(cr: Pcairo_t; layout: PPangoLayout); cdecl; external pangocairolib;
procedure pango_cairo_layout_path(cr: Pcairo_t; layout: PPangoLayout); cdecl; external pangocairolib;
procedure pango_layout_set_height(layout: PPangoLayout; height: longint); cdecl; external pangolib;
{$ENDIF}

{$ENDIF}

const
  merged2d = 0;

  {$IFDEF WINDOWS}
procedure SetD2DDefault;
{$ENDIF}

const
  mergegdip = 0;

  {$IFDEF WINDOWS}
procedure InitGDIP;
procedure FreeGDIP;
{$ENDIF}

const
  merge2 = 0;

  {$IFDEF DARWIN}

type

  { TvxFilterQuartz }

  TvxFilterQuartz = class(TvxFilter)
  private
  public
  published
    class function GetFileTypes: string; override;
    class function GetImageSize(const AFileName: string): TvxPoint; override;
    function LoadFromFile(const AFileName: string; const Rotate: single; var Bitmap: TvxBitmap): boolean; override;
    function LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single; const UseEmbedded: boolean; var Bitmap: TvxBitmap): boolean; override;
    function SaveToFile(const AFileName: string; var Bitmap: TvxBitmap; const Params: string = ''): boolean; override;
    function LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean; override;
    function SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
      const Params: string = ''): boolean; override;
  end;

  { TvxCanvasQuartz }

  TvxCanvasQuartz = class(TvxCanvas)
  private
    Func: CGFunctionRef;
    BitmapRef: CGImageRef;
    Callback: CGFunctionCallbacks;
    Shading: CGShadingRef;
    ColorSpace: CGColorSpaceRef;
  protected
    procedure ApplyFill(ARect: TvxRect; const AOpacity: single);
    procedure DeApplyFill(ARect: TvxRect; const AOpacity: single);
    procedure ApplyStroke(ARect: TvxRect; const AOpacity: single);
    procedure FontChanged(Sender: TObject); override;
    procedure UpdateBitmap(ABitmap: TvxBitmap);
    procedure DoDestroyBitmap(Sender: TObject);
  public
    constructor Create(const AWidth, AHeight: integer); override;
    constructor CreateFromBitmap(const ABitmap: TvxBitmap); override;
    destructor Destroy; override;
    { buffer }
    procedure FreeBuffer; override;
    procedure ResizeBuffer(const AWidth, AHeight: integer); override;
    procedure FlushBuffer(const X, Y: integer; const DC: Cardinal); override;
    procedure FlushBufferRect(const X, Y: integer; const DC: Cardinal; const ARect: TvxRect); override;
    procedure Clear(const Color: cardinal); override;
    procedure ClearRect(const ARect: TvxRect; const AColor: TvxColor = 0); override;
    class function GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray; override;
    { matrix }
    procedure SetMatrix(const M: TvxMatrix); override;
    procedure MultyMatrix(const M: TvxMatrix); override;
    { cliping }
    function SaveCanvas: cardinal; override;
    procedure RestoreCanvas(const AState: cardinal); override;
    procedure SetClipRects(const ARects: array of TvxRect); override;
    procedure IntersectClipRect(const ARect: TvxRect); override;
    procedure ExcludeClipRect(const ARect: TvxRect); override;
    procedure ResetClipRect; override;
    { drawing }
    procedure DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single); override;
    procedure FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure FillEllipse(const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawEllipse(const ARect: TvxRect; const AOpacity: single); override;
    function PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean; override;
    procedure FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawBitmap(const ABitmap: TvxBitmap; const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false); override;
    procedure FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
      const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    procedure MeasureText(var ARect: TvxRect; AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    function TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean; override;
  published
  end;

function CGRectFromRect(const R: TvxRect): CGRect;

{$ENDIF}

type
  TvxLangDesigner = class(TForm)
    vgScene1: TDicomScene;
    Root1: TvxHudWindow;
    vgResources1: TvxResources;
    OriginalList: TvxHudListBox;
    btnAddItem: TvxHudCornerButton;
    langList: TvxHudPopupBox;
    ToolBar1: TvxToolBar;
    inputLang: TvxHudTextBox;
    HudLabel1: TvxHudLabel;
    layoutSelect: TvxLayout;
    HudLabel2: TvxHudLabel;
    btnAddNewLang: TvxHudButton;
    btnCancalAdd: TvxHudButton;
    layoutAdd: TvxLayout;
    layoutAddText: TvxLayout;
    btnAddText: TvxHudButton;
    btnCancelAddText: TvxHudButton;
    inputAddText: TvxHudTextBox;
    btnRemoveItem: TvxHudCornerButton;
    btnCollect: TvxHudCornerButton;
    SaveDialog1: TSaveDialog;
    OpenDialog1: TOpenDialog;
    btnAddLang: TvxHudButton;
    btnLoadTxt: TvxHudButton;
    btnCreateTemplate: TvxHudCornerButton;
    btnLoadLng: TvxHudCornerButton;
    btnSaveLng: TvxHudCornerButton;
    OpenDialog2: TOpenDialog;
    SaveDialog2: TSaveDialog;
    procedure btnAddClick(Sender: TObject);
    procedure btnAddLangClick(Sender: TObject);
    procedure langListChange(Sender: TObject);
    procedure btnAddItemClick(Sender: TObject);
    procedure btnRemoveItemClick(Sender: TObject);
    procedure btnAddNewLangClick(Sender: TObject);
    procedure btnCancalAddClick(Sender: TObject);
    procedure btnCancelAddTextClick(Sender: TObject);
    procedure btnAddTextClick(Sender: TObject);
    procedure btnCollectClick(Sender: TObject);
    procedure btnCreateTemplateClick(Sender: TObject);
    procedure btnLoadTxtClick(Sender: TObject);
    procedure btnLoadLngClick(Sender: TObject);
    procedure btnSaveLngClick(Sender: TObject);
  private
    { Private declarations }
    FLang: TvxLang;
    FCurLang: WideString;
    procedure RebuildOriginalList;
    procedure DoTranslateChanged(Sender: TObject);
  public
    { Public declarations }
  end;

var
  vgLangDesigner: TvxLangDesigner;

procedure ShowDsgnLang(Lang: TvxLang);

type
  TvxPathDataDesigner = class(TForm)
    vgScene1: TDicomScene;
    Root1: TvxBackground;
    previewLayout: TvxLayout;
    Layout2: TvxLayout;
    PathData: TvxMemo;
    Button2: TvxButton;
    Button3: TvxButton;
    labelMemo: TvxLabel;
    Label3: TvxLabel;
    previewPath: TvxPath;
    Button1: TvxButton;
    procedure PathDataChange(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure Button1Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  vgPathDataDesigner: TvxPathDataDesigner;

type
  TvxStyleDesigner = class(TForm)
    vgScene1: TDicomScene;
    Root1: TvxBackground;
    ObjectsTree: TvxTreeView;
    vgScene2: TDicomScene;
    Root2: TvxBackground;
    Inspector: TvxInspector;
    DesignScene: TDicomScene;
    vgScene3: TDicomScene;
    Root4: TvxBackground;
    OpenDialog1: TOpenDialog;
    Button1: TvxButton;
    SaveDialog1: TSaveDialog;
    Button2: TvxButton;
    btnClear: TvxButton;
    btnLoadDefault: TvxButton;
    btnBack: TvxButton;
    rectBack: TvxRectangle;
    vgBrushDialog1: TvxBrushDialog;
    Button3: TvxButton;
    Button4: TvxButton;
    btnCancel: TvxButton;
    ClearTimer: TTimer;
    Resources1: TvxResources;
    textFilter: TvxTextBoxClearBtn;
    Splitter1: TSplitter;
    Splitter2: TSplitter;
    vgScene4: TDicomScene;
    Root3: TvxBackground;
    StatusBar1: TvxStatusBar;
    Label1: TvxLabel;
    procedure ObjectsTreeChange(Sender: TObject);
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
    procedure Button3Click(Sender: TObject);
    procedure btnClearClick(Sender: TObject);
    procedure btnLoadDefaultClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure btnBackClick(Sender: TObject);
    procedure ObjectsTreeMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Single);
    procedure ClearTimerTimer(Sender: TObject);
    procedure ObjectsTreeDragChange(SourceItem, DestItem: TvxTreeViewItem;
      Allow: Boolean);
    procedure InspectorChangeProperty(Sender: TObject;
      PropertyName: string);
    procedure ObjectsTreeChangeCheck(Sender: TObject);
    procedure DesignRootDragOver(Sender: TObject;
      const Data: TvxDragObject; const Point: TvxPoint;
      var Accept: Boolean);
    procedure textFilterChangeTracking(Sender: TObject);
  private
    { Private declarations }
    FDragObj: TvxObject;
    FResource: TvxResources;
    procedure UpdateTree;
    procedure LoadFromStrings(Str: TStrings);
    procedure SaveToStrings(Str: TStrings);
    procedure DoDeleteButton(Sender: TObject);
    procedure DoVisCheck(Sender: TObject);
    procedure DeleteObject(AObject: TvxObject; FreeObject: boolean);
    procedure TreeItemApplyResource(Sender: TObject);
  protected
    procedure Notification(AComponent: TComponent; Operation: TOperation); override;
  public
    { Public declarations }
  end;

var
  vgStyleDesigner: TvxStyleDesigner;

function DesignResources(AResource: TvxResources; Current: string): boolean;

type

  TvxCustomGrid = class;
  TvxHeader = class;

  TvxHeaderItem = class(TvxCornerButton)
  private
    FSplitter: TvxVisualObject;
    FLeftSplitter: TvxVisualObject;
  protected
    procedure DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean); override;
    procedure DragDrop(const Data: TvxDragObject; const Point: TvxPoint); override;
    procedure DragEnd; override;
    procedure DoSplitterMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y, Dx, Dy: single);
    procedure DoLeftSplitterMouseMove(Sender: TObject; Shift: TShiftState;
      X, Y, Dx, Dy: single);
    function Header: TvxHeader;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property CanFocused default false;
    property TextAlign default vgTextAlignNear;
    property DragMode default vgDragAutomatic;
  end;

  TvxOnRealignItemEvent = procedure(Sender: TObject; OldIndex, NewIndex: integer) of object;
  TvxOnResizeItemEvent = procedure(Sender: TObject; var NewSize: single) of object;

  TvxHeader = class(TvxControl)
  private
    FOnRealignItem: TvxOnRealignItemEvent;
    FOnResizeItem: TvxOnResizeItemEvent;
    FOffset: single; // hscroll offset used in grid
    FLastItem: TvxHeaderItem;
    FRadius: single;
    FSides: TvxSides;
    function GetItem(Index: integer): TvxHeaderItem;
    procedure SetRadius(const Value: single);
    procedure SetSides(const Value: TvxSides);
  public
    constructor Create(AOwner: TComponent); override;
    procedure Paint; override;
    procedure Realign; override;
    function ItemClass: string; override;
    property Items[Index: integer]: TvxHeaderItem read GetItem;
  published
    property CanFocused default false;
    property ClipChildren default true;
    property OnRealignItem: TvxOnRealignItemEvent read FOnRealignItem write FOnRealignItem;
    property OnResizeItem: TvxOnResizeItemEvent read FOnResizeItem write FOnResizeItem;
    property Radius: single read FRadius write SetRadius;
    property Sides: TvxSides read FSides write SetSides;
  end;

  TvxTextCell = class(TvxTextBox)
  private
  end;

  TvxCheckCell = class(TvxCheckBox)
  private
  public
  end;

  TvxProgressCell = class(TvxProgressBar)
  private
  public
  end;

  TvxPopupCell = class(TvxPopupBox)
  private
  public
  end;

  TvxImageCell = class(TvxImageControl)
  private
  public
  end;

  TvxColumn = class(TvxControl)
  private
    FReadOnly: boolean;
    procedure SetHeader(const Value: WideString);
  protected
    FCellControls: array of TvxControl;
    FUpdateColumn: boolean;
    FHeader: WideString;
    FSaveData: Variant;
    FDisableChange: boolean;
    function Grid: TvxCustomGrid;
    procedure UpdateColumn; virtual;
    procedure UpdateSelected;
    procedure ClearColumn;
    function CreateCellControl: TvxControl; virtual;
    procedure DoTextChanged(Sender: TObject);
    procedure DoCanFocused(Sender: TObject; var ACanFocused: boolean);
    procedure DoEnterFocus(Sender: TObject);
    procedure DoKeyDown(Sender: TObject; var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
  public
    constructor Create(AOwner: TComponent); override;
    function CellControlByPoint(X, Y: single): TvxControl;
    function CellControlByRow(Row: integer): TvxControl;
  published
    property Resource;
    property Header: WideString read FHeader write SetHeader;
    property ReadOnly: boolean read FReadOnly write FReadOnly default false;
  end;

  TvxCheckColumn = class(TvxColumn)
  private
    function CreateCellControl: TvxControl; override;
    procedure DoCheckChanged(Sender: TObject);
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TvxProgressColumn = class(TvxColumn)
  private
    FMin: single;
    FMax: single;
  protected
    function CreateCellControl: TvxControl; override;
  public
    constructor Create(AOwner: TComponent); override;
  published
    property Min: single read FMin write FMin;
    property Max: single read FMax write FMax;
  end;

  TvxPopupColumn = class(TvxColumn)
  private
    FItems: TvxWideStrings;
    procedure SetItems(const Value: TvxWideStrings);
  protected
    function CreateCellControl: TvxControl; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
    property Items: TvxWideStrings read FItems write SetItems;
  end;

  TvxImageColumn = class(TvxColumn)
  private
    function CreateCellControl: TvxControl; override;
  public
    constructor Create(AOwner: TComponent); override;
  end;

  TOnGetValue = procedure(Sender: TObject; const Col, Row: integer; var Value: Variant) of object;
  TOnSetValue = procedure(Sender: TObject; const Col, Row: integer; const Value: Variant) of object;
  TOnEdititingDone = procedure(Sender: TObject; const Col, Row: integer) of object;

  TvxCustomGrid = class(TvxScrollBox)
  private
    FMouseSelecting: boolean;
    FItemHeight: single;
    FSelection: TvxVisualObject;
    FFocus: TvxVisualObject;
    FRowCount: integer;
    FOnGetValue: TOnGetValue;
    FOnSetValue: TOnSetValue;
    FSelections: TList;
    FAlternatingRowBackground: boolean;
    FOddFill: TvxBrush;
    FLineFill: TvxBrush;
    FShowHorzLines: boolean;
    FShowVertLines: boolean;
    FReadOnly: boolean;
    FColumnIndex: integer;
    FHeader: TvxHeader;
    FShowHeader: boolean;
    FShowSelectedCell: boolean;
    FOnEdititingDone: TOnEdititingDone;
    FMultiSelect: boolean;
    function GetColumnCount: integer;
    function GetColumn(Index: integer): TvxColumn;
    procedure SetRowCount(const Value: integer);
    procedure SetRowHeight(const Value: single);
    function GetVisibleRows: integer;
    procedure SetAlternatingRowBackground(const Value: boolean);
    procedure SetShowHorzLines(const Value: boolean);
    procedure SetShowVertLines(const Value: boolean);
    procedure SetColumnIndex(const Value: integer);
    procedure SetShowHeader(const Value: boolean);
    procedure SetShowSelectedCell(const Value: boolean);
  protected
    FSelected: integer;
    FRowHeight: single;
    procedure Notification(AComponent: TComponent;
      Operation: TOperation); override;
    procedure ApplyStyle; override;
    procedure FreeStyle; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single); override;
    procedure MouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: single); override;
    procedure KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState); override;
    procedure HScrollChange(Sender: TObject); override;
    procedure VScrollChange(Sender: TObject); override;
    function GetContentBounds: TvxRect; override;
    procedure UpdateColumns; virtual;
    procedure UpdateHeader;
    procedure UpdateSelection;
    procedure Reset; virtual;
    procedure DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    procedure DoContentPaint2(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
    { data }
    function GetTopRow: integer; virtual;
    function GetValue(Col, Row: integer): Variant; virtual;
    procedure SetValue(Col, Row: integer; const Value: Variant); virtual;
    function IsSelected(Row: integer): boolean;
    procedure SetSelected(const Value: integer); virtual;
    function CanEditAcceptKey(Key: System.WideChar): Boolean; virtual;
    function CanEditModify: Boolean; virtual;
    { header }
    procedure DoRealignItem(Sender: TObject; OldIndex, NewIndex: integer);
    procedure DoResizeItem(Sender: TObject; var NewSize: single);
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ItemClass: string; override;
    function ColumnByIndex(const Idx: integer): TvxColumn;
    function ColumnByPoint(const X, Y: single): TvxColumn;
    function RowByPoint(const X, Y: single): integer;
    procedure AddObject(AObject: TvxObject); override;
    procedure RemoveObject(AObject: TvxObject); override;
    property TopRow: integer read GetTopRow;
    property VisibleRows: integer read GetVisibleRows;
    property ColumnCount: integer read GetColumnCount;
    property ColumnIndex: integer read FColumnIndex write SetColumnIndex;
    property Columns[Index: integer]: TvxColumn read GetColumn;
    property RowCount: integer read FRowCount write SetRowCount;
    property Selected: integer read FSelected write SetSelected;
    property OnGetValue: TOnGetValue read FOnGetValue write FOnGetValue;
    property OnSetValue: TOnSetValue read FOnSetValue write FOnSetValue;
  published
    property Resource;
    property AlternatingRowBackground: boolean read FAlternatingRowBackground write SetAlternatingRowBackground default false;
    property CanFocused default true;
    property DisableFocusEffect;
    property RowHeight: single read FRowHeight write SetRowHeight;
    property ShowSelectedCell: boolean read FShowSelectedCell write SetShowSelectedCell default true;
    property ShowVertLines: boolean read FShowVertLines write SetShowVertLines default true;
    property ShowHorzLines: boolean read FShowHorzLines write SetShowHorzLines default true;
    property ShowHeader: boolean read FShowHeader write SetShowHeader default true;
    property ReadOnly: boolean read FReadOnly write FReadOnly default false;
    property TabOrder;
    property OnEdititingDone: TOnEdititingDone read FOnEdititingDone write FOnEdititingDone;
  end;

  TvxGrid = class(TvxCustomGrid)
  private
  public
  published
    property RowCount;
    property OnGetValue;
    property OnSetValue;
  end;

  TvxStringColumn = class(TvxColumn)
  private
    FCells: array of WideString;
  published
    procedure UpdateColumn; override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TvxStringGrid = class(TvxCustomGrid)
  private
    function GetCells(ACol, ARow: Integer): WideString;
    procedure SetCells(ACol, ARow: Integer; const Value: WideString);
  protected
    function GetValue(Col, Row: integer): Variant; override;
    procedure SetValue(Col, Row: integer; const Value: Variant); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
    function ItemClass: string; override;
    property Cells[ACol, ARow: Integer]: WideString read GetCells write SetCells;
  published
    property RowCount;
  end;

implementation {===============================================================}

uses math, typinfo, dcm_dicom_view;
{$R *.res}

{ TvxImageList }

constructor TvxImageList.Create(AOwner: TComponent);
begin
  inherited;
  FImages := TList.Create;
  Width := 32;
  Height := 32;
end;

destructor TvxImageList.Destroy;
begin
  Clear;
  FImages.Free;
  inherited;
end;

procedure TvxImageList.Clear;
var
  i: integer;
begin
  inherited Clear;

  for i := 0 to FImages.Count - 1 do
    TvxBitmap(FImages[i]).Free;
  FImages.Clear;
end;

function TvxImageList.Add(Bitmap: TvxBitmap): integer;
var
  B: TvxBitmap;
  R: TvxRect;
begin
  B := TvxBitmap.Create(Width, Height);
  R := vgRect(0, 0, Bitmap.Width, Bitmap.Height);
  vgFitRect(R, vgRect(0, 0, Width, Height));
  B.Canvas.DrawBitmap(Bitmap, vgRect(0, 0, Bitmap.Width, Bitmap.Height), R, 1);

  Result := FImages.Add(B);
  UpdateList;
end;

procedure TvxImageList.ReadImage(Stream: TStream);
var
  i: integer;
  S, C: cardinal;
  M: TMemoryStream;
  B: TvxBitmap;
begin
  Stream.Read(C, 4);
  for i := 0 to C - 1 do
  begin
    M := TMemoryStream.Create;

    Stream.Read(S, 4);
    M.SetSize(S);
    Stream.Read(M.Memory^, S);

    B := TvxBitmap.CreateFromStream(M);
    FImages.Add(B);

    M.Free;
  end;
  UpdateList;
end;

procedure TvxImageList.WriteImage(Stream: TStream);
var
  i: integer;
  S: cardinal;
  M: TMemoryStream;
begin
  S := FImages.Count;
  Stream.Write(S, 4);
  for i := 0 to FImages.Count - 1 do
  begin
    M := TMemoryStream.Create;
    TvxBitmap(FImages[i]).SaveToStream(M);

    S := M.Size;
    Stream.Write(S, 4);
    Stream.Write(M.Memory^, M.Size);

    M.Free;
  end;
end;

procedure TvxImageList.DefineProperties(Filer: TFiler);
begin
  inherited DefineProperties(Filer);
  Filer.DefineBinaryProperty('Images', ReadImage, WriteImage, FImages.Count > 0);
end;

function TvxImageList.GetCount: integer;
begin
  Result := FImages.Count;
end;

function TvxImageList.GetBitmap(Index: integer): TvxBitmap;
begin
  if (Index >= 0) and (Index < Count) then
    Result := TvxBitmap(FImages[Index])
  else
    Result := nil;
end;

procedure TvxImageList.UpdateList;
var
  i: integer;
  B: TBitmap;
begin
  if not (csDesigning in ComponentState) then
    Exit;

  inherited Clear;

  for i := 0 to FImages.Count - 1 do
  begin
    if (Images[i].Width <> Width) or (Images[i].Height <> Height) then
      Continue;

    B := TBitmap.Create;
    B.Assign(Images[i]);
    inherited AddMasked(B, 0);
    B.Free;
  end;
end;

procedure TvxImageList.ReadData(Stream: TStream);
begin
end;

procedure TvxImageList.WriteData(Stream: TStream);
begin
end;

{ TvxAnimation ===================================================================}

constructor TvxColorAnimation.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.2;
  FStartColor := $FFFFFFFF;
  FStartColor := $FFFFFFFF;
end;

destructor TvxColorAnimation.Destroy;
begin
  inherited;
end;

procedure TvxColorAnimation.Start;
var
  Persistent: string;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      FPath := FPropertyName;
      while Pos('.', FPath) > 0 do
      begin
        Persistent := vgGetToken(FPath, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;
  end;
  if (FInstance <> nil) and StartFromCurrent then
  begin
    { is string prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkString, tkLString, tkWString{$IFDEF FPC}, tkAString{$ENDIF}{$IFDEF KS_COMPILER11_UP}, tkUString{$ENDIF}]) <> nil then
      StartValue := GetStrProp(FInstance, FPath);
    { is int prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkInteger]) <> nil then
      StartValue := vgColorToStr(GetOrdProp(FInstance, FPath));
  end;
  inherited;
end;

procedure TvxColorAnimation.ProcessAnimation;
begin
  if FInstance <> nil then
  begin
    { is string prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkString, tkLString, tkWString{$IFDEF FPC}, tkAString{$ENDIF}{$IFDEF KS_COMPILER11_UP}, tkUString{$ENDIF}]) <> nil then
      SetStrProp(FInstance, FPath, vgColorToStr(vgInterpolateColor(FStartColor, FStopColor, NormalizedTime)));
    { is int prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkInteger]) <> nil then
      SetOrdProp(FInstance, FPath, vgInterpolateColor(FStartColor, FStopColor, NormalizedTime));
  end;
end;

function TvxColorAnimation.GetStartColor: string;
begin
  Result := vgColorToStr(FStartColor);
end;

function TvxColorAnimation.GetStopColor: string;
begin
  Result := vgColorToStr(FStopColor);
end;

procedure TvxColorAnimation.SetStartColor(const Value: string);
begin
  FStartColor := vgStrToColor(Value);
end;

procedure TvxColorAnimation.SetStopColor(const Value: string);
begin
  FStopColor := vgStrToColor(Value);
end;

{ TvxAnimation ===================================================================}

constructor TvxGradientAnimation.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.2;
  FStartGradient := TvxGradient.Create;
  FStopGradient := TvxGradient.Create;
end;

destructor TvxGradientAnimation.Destroy;
begin
  FStartGradient.Free;
  FStopGradient.Free;
  inherited;
end;

procedure TvxGradientAnimation.Start;
var
  Persistent: string;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      FPath := FPropertyName;
      while Pos('.', FPath) > 0 do
      begin
        Persistent := vgGetToken(FPath, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;
  end;
  if (FInstance <> nil) and StartFromCurrent then
  begin
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkClass]) <> nil then
    begin
      StartValue := TvxGradient(GetObjectProp(FInstance, FPath, TvxGradient));
    end;
  end;
  inherited;
end;

procedure TvxGradientAnimation.ProcessAnimation;
var
  i: integer;
  G: TvxGradient;
begin
  if FInstance <> nil then
  begin
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkClass]) <> nil then
    begin
      with TvxGradient(GetObjectProp(FInstance, FPath, TvxGradient)) do
      begin
        for i := 0 to Points.Count - 1 do
        begin
          if (i < FStopGradient.Points.Count) or (i < FStartGradient.Points.Count) then
            Points[i].Color := vgColorToStr(vgInterpolateColor(vgStrToColor(FStartGradient.Points[i].Color),
              vgStrToColor(FStopGradient.Points[i].Color), NormalizedTime));
        end;
        Change;
      end;
    end;
  end;
end;

procedure TvxGradientAnimation.SetStartGradient(const Value: TvxGradient);
begin
  FStartGradient.Assign(Value);
end;

procedure TvxGradientAnimation.SetStopGradient(const Value: TvxGradient);
begin
  FStopGradient.Assign(Value);
end;

{ TvxAnimation ===================================================================}

constructor TvxFloatAnimation.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.2;
  FStartFloat := 0;
  FStopFloat := 0;
end;

destructor TvxFloatAnimation.Destroy;
begin
  inherited;
end;

procedure TvxFloatAnimation.Start;
var
  Persistent: string;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      FPath := FPropertyName;
      while Pos('.', FPath) > 0 do
      begin
        Persistent := vgGetToken(FPath, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;
  end;
  if (FInstance <> nil) and StartFromCurrent then
  begin
    { is float prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkFloat]) <> nil then
    begin
      StartValue := GetFloatProp(FInstance, FPath);
    end;
  end;
  inherited;
end;

procedure TvxFloatAnimation.Stop;
begin
  inherited;
  FInstance := nil;
end;

procedure TvxFloatAnimation.ProcessAnimation;
begin
  if FInstance <> nil then
  begin
    { is float prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkFloat]) <> nil then
    begin
      SetFloatProp(FInstance, FPath, vgInterpolateSingle(FStartFloat, FStopFloat, NormalizedTime));
    end;
  end;
end;

{ TvxAnimation ===================================================================}

constructor TvxRectAnimation.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.2;
  FStartRect := TvxBounds.Create(vgRect(0, 0, 0, 0));
  FStopRect := TvxBounds.Create(vgRect(0, 0, 0, 0));
  FCurrent := TvxBounds.Create(vgRect(0, 0, 0, 0));
end;

destructor TvxRectAnimation.Destroy;
begin
  FCurrent.Free;
  FStartRect.Free;
  FStopRect.Free;
  inherited;
end;

procedure TvxRectAnimation.Start;
var
  Persistent: string;
  Value: TObject;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      FPath := FPropertyName;
      while Pos('.', FPath) > 0 do
      begin
        Persistent := vgGetToken(FPath, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;
  end;
  if (FInstance <> nil) and StartFromCurrent then
  begin
    { is Rect prop }
    if GetPropInfo(FInstance.ClassInfo, FPropertyName, [tkClass]) <> nil then
    begin
      Value := GetObjectProp(FInstance, FPropertyName);
      if (Value <> nil) and (Value is TPersistent) then
        FStartRect.Assign(TPersistent(Value));
    end;
  end;
  inherited;
end;

procedure TvxRectAnimation.ProcessAnimation;
var
  Value: TObject;
begin
  if FInstance <> nil then
  begin
    { calc value }
    FCurrent.Left := vgInterpolateSingle(FStartRect.Left, FStopRect.Left, NormalizedTime);
    FCurrent.Top := vgInterpolateSingle(FStartRect.Top, FStopRect.Top, NormalizedTime);
    FCurrent.Right := vgInterpolateSingle(FStartRect.Right, FStopRect.Right, NormalizedTime);
    FCurrent.Bottom := vgInterpolateSingle(FStartRect.Bottom, FStopRect.Bottom, NormalizedTime);

    { is Rect prop }
    if GetPropInfo(FInstance.ClassInfo, FPath, [tkClass]) <> nil then
    begin
      Value := GetObjectProp(FInstance, FPath);
      if (Value <> nil) and (Value is TPersistent) then
        TPersistent(Value).Assign(FCurrent);
    end;
  end;
end;

{ TvxAnimation ===================================================================}

constructor TvxBitmapAnimation.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.2;
  FStartBitmap := TvxBitmap.Create(1, 1);
  FStopBitmap := TvxBitmap.Create(1, 1);
  FCurrent := TvxBitmap.Create(1, 1);
end;

destructor TvxBitmapAnimation.Destroy;
begin
  FCurrent.Free;
  FStartBitmap.Free;
  FStopBitmap.Free;
  inherited;
end;

procedure TvxBitmapAnimation.ProcessAnimation;
var
  Persistent, Path: string;
  Value: TObject;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      Path := FPropertyName;
      while Pos('.', FPropertyName) > 0 do
      begin
        Persistent := vgGetToken(FPropertyName, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;

    if FInstance <> nil then
    begin
      { is Bitmap prop }
      if GetPropInfo(FInstance.ClassInfo, FPropertyName, [tkClass]) <> nil then
      begin
        { calc new value }
        Value := GetObjectProp(FInstance, FPropertyName);
        if (Value <> nil) and (Value is TPersistent) then
        begin
          if Inverse then
          begin
            { assign to start }
            FCurrent.Assign(FStopBitmap);
            { draw final with alpha }
            if FCurrent.Canvas.BeginScene then
            begin
              FCurrent.Canvas.Clear(0);
              FCurrent.Canvas.DrawBitmap(FStartBitmap, vgRect(0, 0, FCurrent.Width, FCurrent.Height),
                vgRect(0, 0, FStartBitmap.Width, FStartBitmap.Height), 1 - NormalizedTime);
              FCurrent.Canvas.EndScene;
            end;
          end
          else
          begin
            { assign to start }
            FCurrent.Assign(FStartBitmap);
            { draw final with alpha }
            if FCurrent.Canvas.BeginScene then
            begin
              FCurrent.Canvas.Clear(0);
              FCurrent.Canvas.DrawBitmap(FStopBitmap, vgRect(0, 0, FCurrent.Width, FCurrent.Height),
                vgRect(0, 0, FStopBitmap.Width, FStopBitmap.Height), NormalizedTime);
              FCurrent.Canvas.EndScene;
            end;
          end;
          { assign }
          TPersistent(Value).Assign(FCurrent);
        end;
      end;
    end;
  end;
end;

{ TvxBitmapListAnimation }

constructor TvxBitmapListAnimation.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.2;
  FCurrent := TvxBitmap.Create(0, 0);
  FAnimationBitmap := TvxBitmap.Create(0, 0);
  FAnimationCount := 1;
  FLastAnimationStep := 0;
end;

destructor TvxBitmapListAnimation.Destroy;
begin
  FCurrent.Free;
  FAnimationBitmap.Free;
  inherited;
end;

procedure TvxBitmapListAnimation.ProcessAnimation;
var
  Persistent, Path: string;
  Value: TObject;
  LeftPos, CurrentIndex: Integer;
  NowValue: Single;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      Path := FPropertyName;
      while Pos('.', FPropertyName) > 0 do
      begin
        Persistent := vgGetToken(FPropertyName, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;

    if FInstance <> nil then
    begin
      { is Bitmap prop }
      if GetPropInfo(FInstance.ClassInfo, FPropertyName, [tkClass]) <> nil then
      begin
        { calc new value }
        Value := GetObjectProp(FInstance, FPropertyName);
        if (Value <> nil) and (Value is TvxBitmap) then
        begin
          NowValue := vgInterpolateSingle(0, FAnimationCount - 1, NormalizedTime);

          FCurrent.SetSize(TvxBitmap(Value).Height, TvxBitmap(Value).Width);

          CurrentIndex := Trunc(NowValue);

          LeftPos := CurrentIndex * (FAnimationBitmap.Width div FAnimationCount) + CurrentIndex;

          if FCurrent.Canvas.BeginScene then
          begin
            FCurrent.Canvas.Clear(0);
            FCurrent.Canvas.DrawBitmap(FAnimationBitmap,
              vgRect(LeftPos, 0, LeftPos + FCurrent.Width, FCurrent.Height),
              vgRect(0, 0, FAnimationBitmap.Width div FAnimationCount, FAnimationBitmap.Height), 1);
            FCurrent.Canvas.EndScene;
          end;

          TPersistent(Value).Assign(FCurrent);
        end;
      end;
    end;
  end;
end;

{ Key Animation ===============================================================}

{ TvxKey }

procedure TvxKey.SetKey(const Value: single);
begin
  FKey := Value;
  if FKey < 0 then
    FKey := 0;
  if FKey > 1 then
    FKey := 1;
end;

{ TvxKeys }

function TvxKeys.FindKeys(const Time: single; var Key1, Key2: TvxKey): boolean;
var
  i: integer;
begin
  Result := false;
  if Count < 2 then
    Exit;
  for i := 0 to Count - 2 do
    if ((Time >= TvxKey(Items[i]).Key) and (Time <= TvxKey(Items[i + 1]).Key)) then
    begin
      Result := true;
      Key1 := TvxKey(Items[i]);
      Key2 := TvxKey(Items[i + 1]);
      Exit;
    end;
end;

{ TvxColorKeyAnimation ========================================================}

constructor TvxColorKeyAnimation.Create(AOwner: TComponent);
begin
  inherited;
  FKeys := TvxKeys.Create(TvxColorKey);
end;

destructor TvxColorKeyAnimation.Destroy;
begin
  FKeys.Free;
  inherited;
end;

procedure TvxColorKeyAnimation.Start;
var
  Persistent: string;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      FPath := FPropertyName;
      while Pos('.', FPath) > 0 do
      begin
        Persistent := vgGetToken(FPath, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;
  end;
  if (FInstance <> nil) and StartFromCurrent then
  begin
    if Keys.Count > 0 then
    begin
      { is string prop }
      if GetPropInfo(FInstance.ClassInfo, FPath, [tkString, tkLString, tkWString{$IFDEF FPC}, tkAString{$ENDIF}{$IFDEF KS_COMPILER11_UP}, tkUString{$ENDIF}]) <> nil then
        TvxColorKey(Keys.Items[0]).Value := GetStrProp(FInstance, FPath);
      { is int prop }
      if GetPropInfo(FInstance.ClassInfo, FPath, [tkInteger]) <> nil then
        TvxColorKey(Keys.Items[0]).Value := vgColorToStr(GetOrdProp(FInstance, FPath));
    end;
  end;
  inherited;
end;

procedure TvxColorKeyAnimation.ProcessAnimation;
var
  Key1, Key2: TvxKey;
begin
  if FInstance <> nil then
  begin
    if FKeys.FindKeys(NormalizedTime, Key1, Key2) then
    begin
      if (TvxFloatKey(Key2).Key - TvxFloatKey(Key1).Key) = 0 then
        Exit;
      { is string prop }
      if GetPropInfo(FInstance.ClassInfo, FPath, [tkString, tkLString, tkWString{$IFDEF FPC}, tkAString{$ENDIF}{$IFDEF KS_COMPILER11_UP}, tkUString{$ENDIF}]) <> nil then
        SetStrProp(FInstance, FPath, vgColorToStr(vgInterpolateColor(vgStrToColor(TvxColorKey(Key1).Value), vgStrToColor(TvxColorKey(Key2).Value), (NormalizedTime - TvxFloatKey(Key1).Key) / (TvxFloatKey(Key2).Key - TvxFloatKey(Key1).Key))));
      { is int prop }
      if GetPropInfo(FInstance.ClassInfo, FPath, [tkInteger]) <> nil then
        SetOrdProp(FInstance, FPath, vgInterpolateColor(vgStrToColor(TvxColorKey(Key1).Value), vgStrToColor(TvxColorKey(Key2).Value), (NormalizedTime - TvxFloatKey(Key1).Key) / (TvxFloatKey(Key2).Key - TvxFloatKey(Key1).Key)));
    end;
  end;
end;

{ TvxFloatKeyAnimation ========================================================}

constructor TvxFloatKeyAnimation.Create(AOwner: TComponent);
begin
  inherited;
  FKeys := TvxKeys.Create(TvxFloatKey);
end;

destructor TvxFloatKeyAnimation.Destroy;
begin
  FKeys.Free;
  inherited;
end;

procedure TvxFloatKeyAnimation.Start;
var
  Persistent: string;
begin
  if (Parent <> nil) and (FPropertyName <> '') then
  begin
    if FInstance = nil then
    begin
      FInstance := Parent;
      FPath := FPropertyName;
      while Pos('.', FPath) > 0 do
      begin
        Persistent := vgGetToken(FPath, '.');
        if GetPropInfo(FInstance.ClassInfo, Persistent, [tkClass]) <> nil then
          FInstance := GetObjectProp(FInstance, Persistent);
      end;
    end;
  end;
  if (FInstance <> nil) and StartFromCurrent then
  begin
    if Keys.Count > 0 then
    begin
      { is string prop }
      if GetPropInfo(FInstance.ClassInfo, FPath, [tkFloat]) <> nil then
        TvxFloatKey(Keys.Items[0]).Value := GetFloatProp(FInstance, FPath);
    end;
  end;
  inherited;
end;

procedure TvxFloatKeyAnimation.ProcessAnimation;
var
  Key1, Key2: TvxKey;
begin
  if FInstance <> nil then
  begin
    if FKeys.FindKeys(NormalizedTime, Key1, Key2) then
    begin
      if (TvxFloatKey(Key2).Key - TvxFloatKey(Key1).Key) = 0 then
        Exit;
      if GetPropInfo(FInstance.ClassInfo, FPath, [tkFloat]) <> nil then
        SetFloatProp(FInstance, FPath, vgInterpolateSingle(TvxFloatKey(Key1).Value, TvxFloatKey(Key2).Value, (NormalizedTime - TvxFloatKey(Key1).Key) / (TvxFloatKey(Key2).Key - TvxFloatKey(Key1).Key)));
    end;
  end;
end;

{ TvxPathAnimation }

constructor TvxPathAnimation.Create(AOwner: TComponent);
begin
  inherited;
  FPath := TvxPathData.Create;
end;

destructor TvxPathAnimation.Destroy;
begin
  if FSpline <> nil then
    FreeAndNil(FSpline);
  FPath.Free;
  inherited;
end;

procedure TvxPathAnimation.ProcessAnimation;
var
  OldP, P1: TvxPoint;
begin
  if (Length(FPolygon) > 0) and (FObj <> nil) then
  begin
    OldP := FObj.Position.Point;
    FSpline.SplineXY(NormalizedTime * Length(FPolygon), P1.X, P1.Y);
    FObj.Position.X := FStart.X + P1.X;
    FObj.Position.Y := FStart.Y + P1.Y;
    if FRotate and (NormalizedTime <> 0) and (NormalizedTime <> 1) and ((OldP.X <> FObj.Position.X) and (OldP.Y <> FObj.Position.Y)) then
    begin
      if Inverse then
      begin
        if vgVectorCrossProductZ(vgVector(FObj.Position.X - OldP.X, FObj.Position.Y - OldP.Y), vgVector(0, 1)) < 0 then
          FObj.RotateAngle := 180 + vgRadToDeg(ArcCos(vgVectorAngleCosine(vgVector(FObj.Position.X - OldP.X, FObj.Position.Y - OldP.Y), vgVector(0, 1))))
        else
          FObj.RotateAngle := 180 - vgRadToDeg(ArcCos(vgVectorAngleCosine(vgVector(FObj.Position.X - OldP.X, FObj.Position.Y - OldP.Y), vgVector(0, 1))))
      end
      else
      begin
        if vgVectorCrossProductZ(vgVector(FObj.Position.X - OldP.X, FObj.Position.Y - OldP.Y), vgVector(0, 1)) < 0 then
          FObj.RotateAngle := vgRadToDeg(ArcCos(vgVectorAngleCosine(vgVector(FObj.Position.X - OldP.X, FObj.Position.Y - OldP.Y), vgVector(0, 1))))
        else
          FObj.RotateAngle := -vgRadToDeg(ArcCos(vgVectorAngleCosine(vgVector(FObj.Position.X - OldP.X, FObj.Position.Y - OldP.Y), vgVector(0, 1))))
      end;
    end;
  end;
end;

procedure TvxPathAnimation.SetPath(const Value: TvxPathData);
begin
  FPath.Assign(Value);
end;

procedure TvxPathAnimation.Start;
var
  i: integer;
begin
  inherited;
  if FSpline <> nil then
    FreeAndNil(FSpline);
  SetLength(FPolygon, 0);
  if Assigned(Scene) and (Scene.GetCanvas <> nil) then
  begin
    FPath.FlattenToPolygon(FPolygon);
    if Length(FPolygon) > 1 then
      for i := 1 to High(FPolygon) do
        if (FPolygon[i].X = ClosePolygon.X) and (FPolygon[i].Y = ClosePolygon.Y) then
          FPolygon[i] := FPolygon[i - 1];
    FSpline := TvxSpline.Create(FPolygon);
  end;
  if (Parent <> nil) and (Parent.IsVisual) then
    FObj := Parent.Visual
  else
    FObj := nil;
  if FObj <> nil then
    FStart := FObj.Position.Point;
end;

{ TvxPathSwitcher =============================================================}

constructor TvxPathSwitcher.Create(AOwner: TComponent);
begin
  inherited;
  Duration := 0.001;
end;

destructor TvxPathSwitcher.Destroy;
begin
  inherited;
end;

procedure TvxPathSwitcher.Start;
begin
  inherited;
end;

procedure TvxPathSwitcher.ProcessAnimation;
begin
  inherited;
end;

procedure TvxPathSwitcher.SetPathFalse(const Value: string);
begin
  FPathFalse := Value;
end;

procedure TvxPathSwitcher.SetPathTrue(const Value: string);
begin
  FPathTrue := Value;
end;

{$IFDEF LINUX}

type

  { TvxFilterGtk }

  TvxFilterGtk = class(TvxFilter)
  private
  public
  published
    class function GetFileTypes: string; override;
    class function GetImageSize(const AFileName: string): TvxPoint; override;
    function LoadFromFile(const AFileName: string; const Rotate: single; var Bitmap: TvxBitmap): boolean; override;
    function LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single; const UseEmbedded: boolean; var Bitmap: TvxBitmap): boolean; override;
    function SaveToFile(const AFileName: string; var Bitmap: TvxBitmap; const Params: string = ''): boolean; override;
    function LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean; override;
    function SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
      const Params: string = ''): boolean; override;
  end;

  { TvxCanvasCairo }

  TvxCanvasCairo = class(TvxCanvas)
  private
    grad: Pcairo_pattern_t;
    sr: Pcairo_surface_t;
    memcr: Pcairo_t;
    memsr: Pcairo_surface_t;
    memlayout: PPangoLayout;
  protected
    procedure ApplyFill(ARect: TvxRect; const AOpacity: single);
    procedure DeapplyFill;
    procedure ApplyStroke(ARect: TvxRect; const AOpacity: single);
    procedure FontChanged(Sender: TObject); override;
    procedure UpdateBitmap(ABitmap: TvxBitmap);
    procedure DoDestroyBitmap(Sender: TObject);
    class function GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray; override;
  public
    constructor Create(const AWidth, AHeight: integer); override;
    constructor CreateFromBitmap(const ABitmap: TvxBitmap); override;
    destructor Destroy; override;
    { buffer }
    procedure FreeBuffer; override;
    procedure ResizeBuffer(const AWidth, AHeight: integer); override;
    procedure FlushBuffer(const X, Y: integer; const DC: Cardinal); override;
    procedure FlushBufferRect(const X, Y: integer; const DC: Cardinal; const ARect: TvxRect); override;
    procedure Clear(const Color: cardinal); override;
    procedure ClearRect(const ARect: TvxRect; const AColor: TvxColor = 0); override;
    { matrix }
    procedure SetMatrix(const M: TvxMatrix); override;
    procedure MultyMatrix(const M: TvxMatrix); override;
    { cliping }
    function SaveCanvas: cardinal; override;
    procedure RestoreCanvas(const AState: cardinal); override;
    procedure SetClipRects(const ARects: array of TvxRect); override;
    procedure IntersectClipRect(const ARect: TvxRect); override;
    procedure ExcludeClipRect(const ARect: TvxRect); override;
    procedure ResetClipRect; override;
    { drawing }
    procedure DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single); override;
    procedure FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure FillEllipse(const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawEllipse(const ARect: TvxRect; const AOpacity: single); override;
    procedure FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
      const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    procedure MeasureText(var ARect: TvxRect; AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    function PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean; override;
    procedure FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawBitmap(const ABitmap: TvxBitmap; const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false); override;
    procedure DrawThumbnail(const ABitmap: TvxBitmap; const Width, Height: single); override;
    function TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean; override;
  published
  end;

procedure SwapRB(const Buf: Pointer; const Size: integer);
var
  i: integer;
  b: byte;
begin
  for i := 0 to Size - 1 do
  begin
    b := PvgColorRecArray(Buf)[i].R;
    PvgColorRecArray(Buf)[i].R := PvgColorRecArray(Buf)[i].B;
    PvgColorRecArray(Buf)[i].B := b;
  end;
end;

{ TvxFilterGtk }

class function TvxFilterGtk.GetFileTypes: string;
begin
  Result := '*.jpg;*.jpeg;*.gif;*.tif;*.tiff;*.png;*.bmp;*.JPG;*.JPEG;*.GIF;*.TIF;*.TIFF;*.PNG;*.BMP';
end;

class function TvxFilterGtk.GetImageSize(const AFileName: string): TvxPoint;
var
  W, H: gint;
begin
  Result := vgPoint(0, 0);
  if gdk_pixbuf_get_file_info(PChar(AFileName), W, H) <> 0 then
    Result := vgPoint(W, H);
end;

function TvxFilterGtk.LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean;
var
  GS: PGInputStream;
  res, pb: PGdkPixbuf;
  MS: TMemoryStream;
begin
  Result := false;
  if AStream.Size = 0 then
    Exit;

  MS := TMemoryStream.Create;
  MS.CopyFrom(AStream, AStream.Size);

  GS := g_memory_input_stream_new_from_data(MS.Memory, MS.Size, nil);
  if GS <> nil then
  begin
    pb := gdk_pixbuf_new_from_stream(GS, nil, nil);
    if pb <> nil then
    begin
      Bitmap.SetSize(gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb));
      res := gdk_pixbuf_new_from_data(Pguchar(Bitmap.StartLine), GDK_COLORSPACE_RGB, true,
        8, gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb), gdk_pixbuf_get_width(pb) * 4, nil, nil);
      if res <> nil then
      begin
        gdk_pixbuf_copy_area(pb, 0, 0, gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb),
          res, 0, 0);
        g_object_unref(res);
        { swap }
        SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
        Result := true;
      end;
      g_object_unref(pb);
    end;
    g_object_unref(GS);
  end;
  MS.Free;
end;

function TvxFilterGtk.SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
  const Params: string = ''): boolean;
var
  pb: PGdkPixbuf;
  buf: PByte;
  size: gsize;
  k, o: array[0..10] of PChar;
  param, name, value, S, encoderType, opts, keys: string;
  i: integer;
begin
  Result := false;
  encoderType := 'png';
  if (LowerCase(Format) = 'jpg') or (LowerCase(Format) = 'jpeg') then
    encoderType := 'jpeg';
  if (LowerCase(Format) = 'bmp') then
    encoderType := 'bmp';
  if (LowerCase(Format) = 'png') then
    encoderType := 'png';
  if (LowerCase(Format) = 'tif') or (LowerCase(Format) = 'tiff') then
    encoderType := 'tif';
  if (LowerCase(Format) = 'gif') then
    encoderType := 'gif';

  pb := gdk_pixbuf_new_from_data(Pguchar(Bitmap.StartLine), GDK_COLORSPACE_RGB, true,
    8, Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, nil, nil);

  if pb <> nil then
  begin
    opts := '';
    keys := '';
    i := 0;
    if Params <> '' then
    begin
      S := Params;
      while S <> '' do
      begin
        param := vgGetToken(S, ' ');
        name := vgGetToken(param, '=');
        value := vgGetToken(param, '');
        if CompareText(name, 'quality') = 0 then
        begin
          o[i] := PChar('quality');
          k[i] := PChar(value);
          inc(i);
        end;
      end;
      o[i] := nil;
      k[i] := nil;
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
      if gdk_pixbuf_save_to_bufferv(pb, buf, size, PChar(encoderType), @o[0], @k[0], nil) then
      begin
        AStream.Write(buf^, size);
        g_free(buf);
        Result := true;
      end;
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
    end
    else
    begin
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
      if gdk_pixbuf_save_to_buffer(pb, buf, size, PChar(encoderType), nil) then
      begin
        AStream.Write(buf^, size);
        g_free(buf);
        Result := true;
      end;
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
    end;
    g_object_unref(pb);
  end;
end;

function TvxFilterGtk.LoadFromFile(const AFileName: string; const Rotate: single;
  var Bitmap: TvxBitmap): boolean;
var
  res, pb: PGdkPixbuf;
begin
  pb := gdk_pixbuf_new_from_file(PChar(AFileName), nil);
  if pb <> nil then
  begin
    Bitmap.SetSize(gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb));
    res := gdk_pixbuf_new_from_data(Pguchar(Bitmap.StartLine), GDK_COLORSPACE_RGB, true,
      8, gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb), gdk_pixbuf_get_width(pb) * 4, nil, nil);
    if res <> nil then
    begin
      gdk_pixbuf_copy_area(pb, 0, 0, gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb),
        res, 0, 0);
      g_object_unref(res);
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
      Result := true;
    end;
    g_object_unref(pb);
  end
  else
    Result := false;
end;

function TvxFilterGtk.LoadThumbnailFromFile(const AFileName: string;
  const AFitWidth, AFitHeight: single; const UseEmbedded: boolean; var Bitmap: TvxBitmap): boolean;
var
  res, pb: PGdkPixbuf;
begin
  pb := gdk_pixbuf_new_from_file_at_scale(PChar(AFileName), round(AFitWidth), round(AFitHeight), true, nil);
  if pb <> nil then
  begin
    Bitmap.SetSize(gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb));
    res := gdk_pixbuf_new_from_data(Pguchar(Bitmap.StartLine), GDK_COLORSPACE_RGB, true,
      8, gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb), gdk_pixbuf_get_width(pb) * 4, nil, nil);
    if res <> nil then
    begin
      gdk_pixbuf_copy_area(pb, 0, 0, gdk_pixbuf_get_width(pb), gdk_pixbuf_get_Height(pb),
        res, 0, 0);
      g_object_unref(res);
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
      Result := true;
    end;
    g_object_unref(pb);
  end
  else
    Result := false;
end;

function TvxFilterGtk.SaveToFile(const AFileName: string;
  var Bitmap: TvxBitmap; const Params: string = ''): boolean;
var
  pb: PGdkPixbuf;
  param, name, value, S, encoderType, opts, keys: string;
  i: integer;
  k, o: array[0..10] of PChar;
begin
  Result := false;
  encoderType := 'png';
  if (LowerCase(ExtractFileExt(AFileName)) = '.jpg') or (LowerCase(ExtractFileExt(AFileName)) = '.jpeg') then
    encoderType := 'jpeg';
  if (LowerCase(ExtractFileExt(AFileName)) = '.bmp') then
    encoderType := 'bmp';
  if (LowerCase(ExtractFileExt(AFileName)) = '.png') then
    encoderType := 'png';
  if (LowerCase(ExtractFileExt(AFileName)) = '.tif') or (LowerCase(ExtractFileExt(AFileName)) = '.tiff') then
    encoderType := 'tiff';
  if (LowerCase(ExtractFileExt(AFileName)) = '.gif') then
    encoderType := 'gif';
  if encoderType = '' then
    Exit;

  pb := gdk_pixbuf_new_from_data(Pguchar(Bitmap.StartLine), GDK_COLORSPACE_RGB, true,
    8, Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, nil, nil);
  if pb <> nil then
  begin
    opts := '';
    keys := '';
    i := 0;
    if Params <> '' then
    begin
      S := Params;
      while S <> '' do
      begin
        param := vgGetToken(S, ' ');
        name := vgGetToken(param, '=');
        value := vgGetToken(param, '');
        if CompareText(name, 'quality') = 0 then
        begin
          o[i] := PChar('quality');
          k[i] := PChar(value);
          inc(i);
        end;
      end;
      o[i] := nil;
      k[i] := nil;
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
      Result := gdk_pixbuf_savev(pb, PChar(AFileName), PChar(encoderType), @o[0], @k[0], nil);
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
    end
    else
    begin
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
      Result := gdk_pixbuf_save(pb, PChar(AFileName), PChar(encoderType), nil);
      SwapRB(Bitmap.Startline, Bitmap.Width * Bitmap.Height);
    end;
    gdk_pixbuf_unref(pb);
  end;
end;

{ TvxCanvasCairo }

var
  CS: string;

var
  ColorArray: array[0..100] of cardinal;
  OffsetArray: array[0..100] of single;

constructor TvxCanvasCairo.Create(const AWidth, AHeight: integer);
begin
  inherited;
  memsr := cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1, 1);
  memcr := cairo_create(memsr);
  memlayout := pango_cairo_create_layout(memcr);
end;

constructor TvxCanvasCairo.CreateFromBitmap(const ABitmap: TvxBitmap);
begin
  inherited;
  memsr := cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 1, 1);
  memcr := cairo_create(memsr);
  memlayout := pango_cairo_create_layout(memcr);

  FBitmap := ABitmap;
  UpdateBitmap(FBitmap);
  if FBitmap.Handle <> 0 then
    FHandle := Integer(cairo_create(Pcairo_surface_t(FBitmap.Handle)))
end;

destructor TvxCanvasCairo.Destroy;
begin
  g_object_unref(memlayout);
  cairo_destroy(memcr);
  cairo_surface_destroy(memsr);
  inherited;
end;

procedure TvxCanvasCairo.FreeBuffer;
begin
  if (FBitmap <> nil) and (Handle <> 0) then
  begin
    cairo_destroy(Pcairo_t(Handle));
  end;
  if FBufferBits <> nil then
    System.FreeMem(FBufferBits);
  if FBuffered then
  begin
    cairo_destroy(Pcairo_t(Handle));
    cairo_surface_destroy(sr);
  end;
  Handle := 0;
end;

procedure TvxCanvasCairo.ResizeBuffer(const AWidth, AHeight: integer);
begin
  if (AWidth = FWidth) and (AHeight = FHeight) then
    Exit;
  FreeBuffer;
  FWidth := AWidth;
  FHeight := AHeight;
  if FWidth <= 0 then
    FWidth := 1;
  if FHeight <= 0 then
    FHeight := 1;
  FResized := true;

  if FWidth * FHeight = 0 then
    Exit;

  if FBuffered then
  begin
    GetMem(FBufferBits, FWidth * FHeight * 4);
    sr := cairo_image_surface_create_for_data(FBufferBits, CAIRO_FORMAT_ARGB32,
      FWidth, FHeight, FWidth * 4);
    Handle := Integer(cairo_create(sr));
  end
  else
  begin
    GetMem(FBufferBits, 4);
  end;
end;

procedure TvxCanvasCairo.FlushBuffer(const X, Y: integer; const DC: Cardinal);
begin
end;

procedure TvxCanvasCairo.FlushBufferRect(const X, Y: integer;
  const DC: Cardinal; const ARect: TvxRect);
begin
end;

procedure TvxCanvasCairo.Clear(const Color: cardinal);
begin
  if FBufferBits = nil then
    Exit;
  if not FBuffered then
  begin
    with TvxColorRec(Color) do
      cairo_set_source_rgba(Pcairo_t(Handle), R / $FF, G / $FF, B / $FF, A / $FF);
    cairo_paint(Pcairo_t(Handle));
  end
  else
    vgFillLongword(FBufferBits, FWidth * FHeight, Color);
end;

procedure TvxCanvasCairo.ClearRect(const ARect: TvxRect; const AColor: TvxColor);
var
  R: TRect;
begin
  if FBufferBits = nil then
    Exit;
  R := Rect(Trunc(ARect.Left), Trunc(ARect.Top), Round(ARect.Right), Round(ARect.Bottom));
  if R.Left < 0 then
    R.Left := 0;
  if R.Top < 0 then
    R.Top := 0;
  if R.Top < 0 then
    R.Top := 0;
  if R.Right > FWidth then
    R.Right := FWidth;
  if R.Bottom > FHeight then
    R.Bottom := FHeight;
  if R.Bottom < R.Top then
    R.Bottom := R.Top;
  if R.Right < R.Left then
    R.Right := R.Left;
  if (R.Right < 0) or (R.Top < 0) or (R.Left > FWidth) or (R.Top > FHeight) then
    Exit;
  if not FBuffered then
  begin
    with TvxColorRec(AColor) do
      cairo_set_source_rgba(Pcairo_t(Handle), R / $FF, G / $FF, B / $FF, A / $FF);
    cairo_rectangle(Pcairo_t(Handle), R.Left, R.Top, R.right - R.left, R.bottom - R.top);
    cairo_fill(Pcairo_t(Handle));
  end
  else
    vgFillLongwordRect(FBufferBits, FWidth, FHeight, R.Left, R.Top, R.Right, R.Bottom, AColor);
end;

class function TvxCanvasCairo.GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray;
begin
  if (y >= 0) and (y < Bitmap.Height) and (Bitmap.StartLine <> nil) then
    Result := @PvgColorArray(Bitmap.StartLine)[(y) * Bitmap.Width]
  else
    Result := nil;
end;

procedure TvxCanvasCairo.SetMatrix(const M: TvxMatrix);
var
  cm: cairo_matrix_t;
begin
  if Handle = 0 then
    Exit;

  FMatrix := M;
  with FMatrix do
  begin
    cm.xx := m11;
    cm.yx := m12;
    cm.xy := m21;
    cm.yy := m22;
    cm.x0 := m31;
    cm.y0 := m32;
  end;
  cairo_set_matrix(Pcairo_t(Handle), @cm);
end;

procedure TvxCanvasCairo.MultyMatrix(const M: TvxMatrix);
var
  cm: cairo_matrix_t;
begin
  if Handle = 0 then
    Exit;
  inherited;
  with M do
  begin
    cm.xx := m11;
    cm.yx := m12;
    cm.xy := m21;
    cm.yy := m22;
    cm.x0 := m31;
    cm.y0 := m32;
  end;
  cairo_transform(Pcairo_t(Handle), @cm);
end;

function TvxCanvasCairo.SaveCanvas: cardinal;
var
  i: integer;
begin
  Result := InvalideCanvasState;
  if Handle = 0 then
    Exit;

  cairo_save(Pcairo_t(Handle));

  // find exists
  if Length(FSaveData) > 0 then
    for i := 0 to High(FSaveData) do
      if FSaveData[i].Index = InvalideCanvasState then
      begin
        Result := i;
        Break;
      end;
  if Result = InvalideCanvasState then
  begin
    SetLength(FSaveData, Length(FSaveData) + 1);
    Result := High(FSaveData);
  end;
  FSaveData[Result].Index := Result;
  FSaveData[Result].Matrix := FMatrix;
  FSaveData[Result].Stroke := TvxBrush.Create(vgBrushSolid, InvalideCanvasState);
  FSaveData[Result].Stroke.Assign(Stroke);
  FSaveData[Result].Fill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FSaveData[Result].Fill.Assign(Fill);
  FSaveData[Result].StrokeThickness := FStrokeThickness;
  FSaveData[Result].StrokeCap := StrokeCap;
  FSaveData[Result].StrokeJoin := StrokeJoin;
  FSaveData[Result].StrokeDash := StrokeDash;
  if StrokeDash <> vgDashSolid then
  begin
    SetLength(FSaveData[Result].Dash, Length(FDash));
    Move(FDash[0], FSaveData[Result].Dash[0], SizeOf(FDash[0]) * Length(FDash));
  end;
  FSaveData[Result].DashOffset := FDashOffset;
  FSaveData[Result].Font := TvxFont.Create;
  FSaveData[Result].Font.Assign(Font);
end;

procedure TvxCanvasCairo.RestoreCanvas(const AState: cardinal);
begin
  if Handle = 0 then
    Exit;

  if (AState >= 0) and (AState < Length(FSaveData)) then
  begin
    cairo_restore(Pcairo_t(Handle));
    FSaveData[AState].Index := InvalideCanvasState;

    FMatrix := FSaveData[AState].Matrix;
    Stroke.Assign(FSaveData[AState].Stroke);
    FSaveData[AState].Stroke.Free;
    Fill.Assign(FSaveData[AState].Fill);
    FSaveData[AState].Fill.Free;
    SetMatrix(FMatrix);
    FStrokeThickness := FSaveData[AState].StrokeThickness;
    FStrokeCap := FSaveData[AState].StrokeCap;
    FStrokeJoin := FSaveData[AState].StrokeJoin;
    FStrokeDash := FSaveData[AState].StrokeDash;
    if StrokeDash <> vgDashSolid then
    begin
      SetLength(FDash, Length(FSaveData[AState].Dash));
      Move(FSaveData[AState].Dash[0], FDash[0], SizeOf(FDash[0]) * Length(FDash));
    end;
    FDashOffset := FSaveData[AState].DashOffset;
    Font.Assign(FSaveData[AState].Font);
    FSaveData[AState].Font.Free;
  end
end;

procedure TvxCanvasCairo.SetClipRects(const ARects: array of TvxRect);
var
  i: integer;
begin
  if Handle = 0 then
    Exit;

  cairo_reset_clip(Pcairo_t(Handle));
  for i := 0 to High(ARects) do
  begin
    cairo_rectangle(Pcairo_t(Handle), ARects[i].Left, ARects[i].Top, vgRectWidth(ARects[i]), vgRectHeight(ARects[i]));
  end;
  cairo_clip(Pcairo_t(Handle));
end;

procedure TvxCanvasCairo.IntersectClipRect(const ARect: TvxRect);
begin
  if Handle = 0 then
    Exit;

  cairo_rectangle(Pcairo_t(Handle), ARect.Left, ARect.Top, vgRectWidth(ARect), vgRectHeight(ARect));
  cairo_clip(Pcairo_t(Handle));
end;

procedure TvxCanvasCairo.ExcludeClipRect(const ARect: TvxRect);
var
  R: TvxRect;
  i: integer;
  RR: array[0..3] of TvxRect;
begin
  if Handle = 0 then
    Exit;

  R := ARect;
  RR[0] := vgRect(0, 0, R.Left, FHeight);
  RR[1] := vgRect(R.Right, 0, FWidth, FHeight);
  RR[2] := vgRect(R.Left, 0, R.Right, R.Top);
  RR[3] := vgRect(R.Left, R.Bottom, R.Right, FHeight);
  for i := 0 to High(RR) do
  begin
    cairo_rectangle(Pcairo_t(Handle), RR[i].Left, RR[i].Top, vgRectWidth(RR[i]), vgRectHeight(RR[i]));
  end;
  cairo_clip(Pcairo_t(Handle));
end;

procedure TvxCanvasCairo.ResetClipRect;
begin
  if Handle = 0 then
    Exit;

  cairo_reset_clip(Pcairo_t(Handle));
end;

procedure TvxCanvasCairo.ApplyFill(ARect: TvxRect; const AOpacity: single);
var
  C: TvxColor;
  i: integer;
  count: integer;
  cm: cairo_matrix_t;
begin
  if Handle = 0 then
    Exit;

  if (FFill.Style = vgBrushResource) and (FFill.Resource <> nil) and (FFill.Resource.Brush <> nil) then
    FFill.Assign(FFill.Resource.Brush);

  with FFill do
  begin
    case Style of
      vgBrushSolid:
        begin
          with TvxColorRec(vgOpacity(SolidColor, AOpacity)) do
            cairo_set_source_rgba(Pcairo_t(Handle), R / $FF, G / $FF, B / $FF, A / $FF);
        end;
      vgBrushGradient:
        begin
          if Gradient.Points.Count > 1 then
          begin
            count := 0;

            if Gradient.Points[0].Offset > 0 then
            begin
              ColorArray[count] := vgOpacity(Gradient.Points[0].IntColor, AOpacity);
              OffsetArray[count] := 0;
              count := count + 1;
            end;
            for i := 0 to Gradient.Points.Count - 1 do
            begin
              ColorArray[i + count] := vgOpacity(Gradient.Points[i].IntColor, AOpacity);
              OffsetArray[i + count] := Gradient.Points[i].Offset;
            end;
            if Gradient.Points[Gradient.Points.Count - 1].Offset < 1 then
            begin
              count := count + 1;
              ColorArray[Gradient.Points.Count + count - 1] := vgOpacity(Gradient.Points[Gradient.Points.Count - 1].IntColor, AOpacity);
              OffsetArray[Gradient.Points.Count + count - 1] := 1;
            end;

            if Gradient.Style = vgLinearGradient then
            begin
              { Linear }
              grad := cairo_pattern_create_linear(ARect.Left + Gradient.StartPosition.X * ARect.Right, ARect.Top + Gradient.StartPosition.Y * ARect.Bottom,
                ARect.Left + Gradient.StopPosition.X * ARect.Right, ARect.Top + Gradient.StopPosition.Y * ARect.Bottom);
              for i := 0 to Gradient.Points.Count + count - 1 do
                with TvxColorRec(ColorArray[i]) do
                  cairo_pattern_add_color_stop_rgba(grad, OffsetArray[i], R / $FF, G / $FF, B / $FF, A / $FF);
              //              TGPLinearGradientBrush(FGPBrush).SetWrapMode(WrapModeTileFlipX);
              cairo_set_source(Pcairo_t(Handle), grad);
            end
            else
            begin
              { Radial }
              grad := cairo_pattern_create_radial((ARect.Left + ARect.Right) / 2, (ARect.Top + ARect.Bottom) / 2, 0,
                (ARect.Left + ARect.Right) / 2, (ARect.Top + ARect.Bottom) / 2, vgMaxFloat(vgRectWidth(ARect), vgRectWidth(ARect)));
              for i := 0 to Gradient.Points.Count + count - 1 do
                with TvxColorRec(ColorArray[i]) do
                  cairo_pattern_add_color_stop_rgba(grad, OffsetArray[i], R / $FF, G / $FF, B / $FF, A / $FF);
              //              TGPLinearGradientBrush(FGPBrush).SetWrapMode(WrapModeTileFlipX);
              cairo_set_source(Pcairo_t(Handle), grad);
            end;
          end
          else
            cairo_set_source_rgba(Pcairo_t(Handle), 0, 0, 0, 0);
        end;
      vgBrushBitmap:
        begin
          if (Bitmap.Bitmap <> nil) and (Bitmap.Bitmap.Width > 0) and (Bitmap.Bitmap.Height > 0) then
          begin
            UpdateBitmap(Bitmap.Bitmap);
            if (Bitmap.Bitmap.Handle <> 0) then
            begin
              grad := cairo_pattern_create_for_surface(Pcairo_surface_t(Bitmap.Bitmap.Handle));
              if Bitmap.WrapMode = vgWrapTileStretch then
              begin
                cairo_matrix_init_scale(@cm, Bitmap.Bitmap.Width / (vgRectWidth(ARect) + (StrokeThickness / 2)),
                  Bitmap.Bitmap.Height / (vgRectHeight(ARect) + (StrokeThickness / 2)));
                cairo_pattern_set_matrix(grad, @cm);
              end;
              if Bitmap.WrapMode = vgWrapTile then
                cairo_pattern_set_extend(grad, CAIRO_EXTEND_REPEAT);
              cairo_set_source(Pcairo_t(Handle), grad);
            end
            else
              cairo_set_source_rgba(Pcairo_t(Handle), 0, 0, 0, 0);
          end
          else
            cairo_set_source_rgba(Pcairo_t(Handle), 0, 0, 0, 0);
        end;
    else
      cairo_set_source_rgba(Pcairo_t(Handle), 0, 0, 0, 0);
    end;
  end;
end;

procedure TvxCanvasCairo.DeapplyFill;
begin
  if Handle = 0 then
    Exit;

  with FFill do
  begin
    case Style of
      vgBrushSolid:
        begin
        end;
      vgBrushGradient:
        begin
          cairo_pattern_destroy(grad);
        end;
      vgBrushResource:
        begin
        end;
      vgBrushVisual:
        begin
        end;
      vgBrushBitmap:
        begin
          cairo_pattern_destroy(grad);
        end;
    end;
  end;
end;

procedure TvxCanvasCairo.ApplyStroke(ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  dash: array of double;
begin
  if Handle = 0 then
    Exit;

  if (FStroke.Style = vgBrushResource) and (FStroke.Resource <> nil) and (FStroke.Resource.Brush <> nil) then
    FStroke.Assign(FStroke.Resource.Brush);

  with FStroke do
  begin
    case Style of
      vgBrushSolid:
        begin
          with TvxColorRec(vgOpacity(SolidColor, AOpacity)) do
            cairo_set_source_rgba(Pcairo_t(Handle), R / $FF, G / $FF, B / $FF, A / $FF);
        end;
      (*      vgBrushGradient:
              begin
                if Gradient.Points.Count > 1 then
                begin
                  for i := 0 to Gradient.Points.Count - 1 do
                  begin
                    ColorArray[i] := vgOpacity(Gradient.Points[i].IntColor, AOpacity);
                    OffsetArray[i] := Gradient.Points[i].Offset;
                  end;
                  FGPPenBrush := TGPLinearGradientBrush.Create(MakePoint(ARect.Left + Gradient.StartPosition.X * ARect.Right, ARect.Top + Gradient.StartPosition.Y * ARect.Bottom),
                    MakePoint(ARect.Left + Gradient.StopPosition.X * ARect.Right, ARect.Top + Gradient.StopPosition.Y * ARect.Bottom), SolidColor, SolidColor);
                  TGPLinearGradientBrush(FGPPenBrush).SetInterpolationColors(PGPColor(@ColorArray), PSingle(@OffsetArray), Gradient.Points.Count);
                  if Abs(FStroke.Gradient.StartPosition.X - FStroke.Gradient.StopPosition.X) < Abs(FStroke.Gradient.StartPosition.Y - FStroke.Gradient.StopPosition.Y) then
                    TGPLinearGradientBrush(FGPPenBrush).ScaleTransform(vgRectHeight(ARect), vgRectWidth(ARect))
                  else
                    TGPLinearGradientBrush(FGPPenBrush).ScaleTransform(vgRectWidth(ARect), vgRectHeight(ARect));
                end
                else
                  FGPPenBrush := TGPSolidBrush.Create(vgOpacity(SolidColor, AOpacity));
              end;
            vgBrushVisual:
              begin
                FGPPenBrush := TGPSolidBrush.Create($00000000);
              end;
            vgBrushBitmap:
              begin
                if (Bitmap.Bitmap <> nil) and (Bitmap.Bitmap.Width > 0) and (Bitmap.Bitmap.Height > 0) then
                begin
                  UpdateBitmap(Bitmap.Bitmap);
                  if (Bitmap.Bitmap.Handle <> 0) then
                  begin
                    if Bitmap.WrapMode <> vgWrapTileStretch then
                      FGPPenBrush := TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle), TWrapMode(Bitmap.WrapMode))
                    else
                    begin
                      FGPPenBrush := TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle), WrapModeClamp);
                      TGPTextureBrush(FGPPenBrush).ScaleTransform(vgRectWidth(ARect) / Bitmap.Bitmap.Width, vgRectHeight(ARect) / Bitmap.Bitmap.Height);
                    end;
                  end
                  else
                    FGPPenBrush := TGPSolidBrush.Create($00000000);
                end
                else
                  FGPPenBrush := TGPSolidBrush.Create($00000000);
              end; *)
    else
      cairo_set_source_rgba(Pcairo_t(Handle), 0, 0, 0, 0);
    end;
  end;

  case StrokeCap of
    vgCapFlat: cairo_set_line_cap(Pcairo_t(Handle), CAIRO_LINE_CAP_BUTT);
    vgCapRound: cairo_set_line_cap(Pcairo_t(Handle), CAIRO_LINE_CAP_ROUND);
  end;
  if Length(FDash) > 0 then
  begin
    SetLength(dash, Length(FDash));
    for i := 0 to High(FDash) do
    begin
      dash[i] := FDash[i] * StrokeThickness;
      if (StrokeCap = vgCapRound) then
      begin
        if odd(i) then
          dash[i] := (FDash[i] + 1) * StrokeThickness
        else
          dash[i] := (FDash[i] - 1) * StrokeThickness;
      end;
    end;
    cairo_set_dash(Pcairo_t(Handle), @dash[0], Length(FDash), FDashOffset);
  end
  else
    cairo_set_dash(Pcairo_t(Handle), nil, 0, 0);
  case StrokeJoin of
    vgJoinMiter: cairo_set_line_join(Pcairo_t(Handle), CAIRO_LINE_JOIN_MITER);
    vgJoinRound: cairo_set_line_join(Pcairo_t(Handle), CAIRO_LINE_JOIN_ROUND);
    vgJoinBevel: cairo_set_line_join(Pcairo_t(Handle), CAIRO_LINE_JOIN_BEVEL);
  end;
  cairo_set_line_width(Pcairo_t(Handle), StrokeThickness);
end;

procedure TvxCanvasCairo.FontChanged(Sender: TObject);
begin
end;

procedure TvxCanvasCairo.DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single);
begin
  if Handle = 0 then
    Exit;

  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(vgRect(APt1.X, APt1.Y, APt2.X, APt2.Y), AOpacity);
    cairo_move_to(Pcairo_t(Handle), APt1.X, APt1.Y);
    cairo_line_to(Pcairo_t(Handle), APt2.X, APt2.Y);
    cairo_stroke(Pcairo_t(Handle));
  end;
end;

procedure TvxCanvasCairo.DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners;
  const AOpacity: single; const ACornerType: TvxCornerType = vgCornerRound);
var
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if Handle = 0 then
    Exit;

  if FStroke.Style <> vgBrushNone then
  begin
    R := ARect;
    ApplyStroke(ARect, AOpacity);
    if (xRadius < Epsilon) and (yRadius < Epsilon) then
    begin
      cairo_rectangle(Pcairo_t(Handle), R.Left, R.Top, vgRectWidth(R), vgRectHeight(R));
      cairo_stroke(Pcairo_t(Handle));
    end
    else
    begin
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
      x2 := x1 * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
      y2 := y1 * CurveKappaInv;
      cairo_new_path(Pcairo_t(Handle));
      cairo_move_to(Pcairo_t(Handle), R.Left, R.Top + y1);
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Left + x2, R.Top + y1);
              cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top + y2);
              cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Left, R.Top);
        cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top);
      end;
      cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Top);
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Right, R.Top + y1);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Top + y2);
              cairo_line_to(Pcairo_t(Handle), R.Right - x2, R.Top + y1);
              cairo_line_to(Pcairo_t(Handle), R.Right, R.Top + y1);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Right, R.Top);
        cairo_line_to(Pcairo_t(Handle), R.Right, R.Top + y1);
      end;
      cairo_line_to(Pcairo_t(Handle), R.Right, R.Bottom - y1);
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Right - x2, R.Bottom - y1);
              cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom - y2);
              cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Right, R.Bottom);
        cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom);
      end;
      cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Bottom);
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom - y1);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Bottom - y2);
              cairo_line_to(Pcairo_t(Handle), R.Left + x2, R.Bottom - y1);
              cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom - y1);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom);
        cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom - y1);
      end;
    end;
    cairo_close_path(Pcairo_t(Handle));
    cairo_stroke(Pcairo_t(Handle));
  end;
end;

procedure TvxCanvasCairo.FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if Handle = 0 then
    Exit;

  if FFill.Style <> vgBrushNone then
  begin
    R := ARect;
    ApplyFill(R, AOpacity);
    if ((xRadius = 0) and (yRadius = 0)) or (ACorners = []) then
    begin
      cairo_rectangle(Pcairo_t(Handle), R.Left, R.Top, vgRectWidth(R), vgRectHeight(R));
      cairo_fill(Pcairo_t(Handle));
    end
    else
    begin
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
      x2 := x1 * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
      y2 := y1 * CurveKappaInv;
      cairo_new_path(Pcairo_t(Handle));
      cairo_move_to(Pcairo_t(Handle), R.Left, R.Top + y1);
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Left + x2, R.Top + y1);
              cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top + y2);
              cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Left, R.Top);
        cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Top);
      end;
      cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Top);
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Right, R.Top + y1);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Top + y2);
              cairo_line_to(Pcairo_t(Handle), R.Right - x2, R.Top + y1);
              cairo_line_to(Pcairo_t(Handle), R.Right, R.Top + y1);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Right, R.Top);
        cairo_line_to(Pcairo_t(Handle), R.Right, R.Top + y1);
      end;
      cairo_line_to(Pcairo_t(Handle), R.Right, R.Bottom - y1);
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Right - x2, R.Bottom - y1);
              cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom - y2);
              cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Right, R.Bottom);
        cairo_line_to(Pcairo_t(Handle), R.Right - x1, R.Bottom);
      end;
      cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Bottom);
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom - y1);
          vgCornerInnerRound: cairo_curve_to(Pcairo_t(Handle), R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
          vgCornerInnerLine:
            begin
              cairo_line_to(Pcairo_t(Handle), R.Left + x1, R.Bottom - y2);
              cairo_line_to(Pcairo_t(Handle), R.Left + x2, R.Bottom - y1);
              cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom - y1);
            end;
        else
          cairo_curve_to(Pcairo_t(Handle), R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1)
        end;
      end
      else
      begin
        cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom);
        cairo_line_to(Pcairo_t(Handle), R.Left, R.Bottom - y1);
      end;
    end;
    cairo_close_path(Pcairo_t(Handle));
    cairo_fill(Pcairo_t(Handle));
    DeapplyFill;
  end;
end;

procedure TvxCanvasCairo.DrawEllipse(const ARect: TvxRect; const AOpacity: single);
begin
  if Handle = 0 then
    Exit;

  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(ARect, AOpacity);
    cairo_save(Pcairo_t(Handle));
    cairo_translate(Pcairo_t(Handle), (ARect.Left + ARect.Right) / 2, (ARect.Top + ARect.Bottom) / 2);
    cairo_scale(Pcairo_t(Handle), vgRectWidth(ARect) / 2, vgRectHeight(ARect) / 2);
    cairo_arc(Pcairo_t(Handle), 0, 0, 1, 0, Pi * 2);
    cairo_restore(Pcairo_t(Handle));
    cairo_stroke(Pcairo_t(Handle));
  end;
end;

procedure TvxCanvasCairo.FillEllipse(const ARect: TvxRect; const AOpacity: single);
begin
  if Handle = 0 then
    Exit;

  if FFill.Style <> vgBrushNone then
  begin
    ApplyFill(ARect, AOpacity);
    cairo_save(Pcairo_t(Handle));
    cairo_translate(Pcairo_t(Handle), (ARect.Left + ARect.Right) / 2, (ARect.Top + ARect.Bottom) / 2);
    cairo_scale(Pcairo_t(Handle), vgRectWidth(ARect) / 2, vgRectHeight(ARect) / 2);
    cairo_arc(Pcairo_t(Handle), 0, 0, 1, 0, Pi * 2);
    cairo_restore(Pcairo_t(Handle));
    cairo_fill(Pcairo_t(Handle));
    DeapplyFill;
  end;
end;

procedure TvxCanvasCairo.FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter);
var
  text: string;
  pdesc: PPangoFontDescription;
  playout: PPangoLayout;
  FullString: string;
  lineWidth: longint;
  pr, pr2: TPangoRectangle;
begin
  if Handle = 0 then
    Exit;

  ApplyFill(ARect, AOpacity);
  cairo_save(Pcairo_t(Handle));

  cairo_rectangle(Pcairo_t(Handle), ARect.Left, ARect.Top, vgRectWidth(ARect), vgRectHeight(ARect));
  cairo_clip(Pcairo_t(Handle));

  cairo_translate(Pcairo_t(Handle), ARect.left, ARect.Top);

  playout := pango_cairo_create_layout(Pcairo_t(Handle));
  if playout <> nil then
  begin
    FullString := FFont.Family;
    pdesc := pango_font_description_from_string(Pchar(FullString + ' ' + IntToStr(Round(FFont.Size * 0.75))));
    if pdesc = nil then
      pdesc := pango_font_description_from_string(Pchar('Sans ' + IntToStr(Round(FFont.Size * 0.75))));
    if pdesc <> nil then
    begin
      if FFont.Style in [vgFontItalic, vgFontBoldItalic] then
        pango_font_description_set_style(pdesc, PANGO_STYLE_ITALIC);
      if FFont.Style in [vgFontBold, vgFontBoldItalic] then
        pango_font_description_set_weight(pdesc, PANGO_WEIGHT_BOLD);
      pango_layout_set_font_description(playout, pdesc);
      pango_font_description_free(pdesc);
    end;
    pango_layout_set_height(playout, Round(vgRectHeight(ARect) * PANGO_SCALE));

    if WordWrap then
      pango_layout_set_width(playout, Round(vgRectWidth(ARect) * PANGO_SCALE))
    else
      pango_layout_set_width(playout, 5000 * PANGO_SCALE);
    // formating
    case ATextAlign of
      vgTextAlignCenter:
        begin
          pango_layout_set_alignment(playout, PANGO_ALIGN_CENTER);
          if not WordWrap then
            cairo_translate(Pcairo_t(Handle), -2500 + (vgRectWidth(ARect) / 2), 0);
        end;
      vgTextAlignNear:
        begin
          pango_layout_set_alignment(playout, PANGO_ALIGN_LEFT);
        end;
      vgTextAlignFar:
        begin
          pango_layout_set_alignment(playout, PANGO_ALIGN_RIGHT);
          if not WordWrap then
            cairo_translate(Pcairo_t(Handle), -5000 + vgRectWidth(ARect), 0);
        end;
    end;
    text := UTF8Encode(AText);
    pango_layout_set_text(playout, PAnsiChar(text), -1);

    pango_layout_get_pixel_extents(playout, @pr, @pr2);
    case AVTextAlign of
      vgTextAlignCenter:
        begin
          cairo_translate(Pcairo_t(Handle), 0, (vgRectHeight(ARect) - pr2.height) / 2);
        end;
      vgTextAlignNear:
        begin
        end;
      vgTextAlignFar:
        begin
          cairo_translate(Pcairo_t(Handle), 0, (vgRectHeight(ARect) - pr2.height));
        end;
    end;

    pango_cairo_show_layout(Pcairo_t(Handle), playout);

    g_object_unref(playout);
  end;
  cairo_restore(Pcairo_t(Handle));
  DeapplyFill;
end;

procedure TvxCanvasCairo.MeasureText(var ARect: TvxRect;
  AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const ATextAlign, AVTextAlign: TvxTextAlign);
var
  text: string;
  pdesc: PPangoFontDescription;
  FullString: string;
  lineWidth: longint;
  pr, pr2: TPangoRectangle;
begin
  if not WordWrap then
    ARect.Right := ARect.Left;
  if Length(AText) = 0 then
    Exit;

  FullString := FFont.Family;
  pdesc := pango_font_description_from_string(Pchar(FullString + ' ' + IntToStr(Round(FFont.Size * 0.75))));
  if pdesc = nil then
    pdesc := pango_font_description_from_string(Pchar('Sans ' + IntToStr(Round(FFont.Size * 0.75))));
  if pdesc <> nil then
  begin
    if FFont.Style in [vgFontItalic, vgFontBoldItalic] then
      pango_font_description_set_style(pdesc, PANGO_STYLE_ITALIC);
    if FFont.Style in [vgFontBold, vgFontBoldItalic] then
      pango_font_description_set_weight(pdesc, PANGO_WEIGHT_BOLD);
    pango_layout_set_font_description(memlayout, pdesc);
    pango_font_description_free(pdesc);
  end;

  pango_layout_set_height(memlayout, Round(vgRectHeight(ARect) * PANGO_SCALE));

  if WordWrap then
    pango_layout_set_width(memlayout, Round(vgRectWidth(ARect) * PANGO_SCALE))
  else
    pango_layout_set_width(memlayout, 5000 * PANGO_SCALE);
  // formating
  case ATextAlign of
    vgTextAlignCenter:
      begin
        pango_layout_set_alignment(memlayout, PANGO_ALIGN_CENTER);
      end;
    vgTextAlignNear:
      begin
        pango_layout_set_alignment(memlayout, PANGO_ALIGN_LEFT);
      end;
    vgTextAlignFar:
      begin
        pango_layout_set_alignment(memlayout, PANGO_ALIGN_RIGHT);
      end;
  end;

  text := UTF8Encode(AText);
  pango_layout_set_text(memlayout, PChar(text), -1);

  pango_layout_get_pixel_extents(memlayout, @pr, @pr2);

  ARect.Right := ARect.Left + pr2.width;
  ARect.Bottom := ARect.Top + pr2.height;
end;

function TvxCanvasCairo.TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
  const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean;
var
  text: string;
  pdesc: PPangoFontDescription;
  FullString: string;
  lineWidth: longint;
  pr, pr2: TPangoRectangle;
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH, VOffset, HOffset: single;
  cpath: Pcairo_path_t;
  pathdata: Pcairo_path_data_t;
  pointtype: cairo_path_data_type_t;
  CP1, CP2: TvxPoint;
begin
  if AText <> '' then
  begin
    Path.Clear;

    FullString := FFont.Family;
    pdesc := pango_font_description_from_string(Pchar(FullString + ' ' + IntToStr(Round(FFont.Size * 0.75))));
    if pdesc = nil then
      pdesc := pango_font_description_from_string(Pchar('Sans ' + IntToStr(Round(FFont.Size * 0.75))));
    if pdesc <> nil then
    begin
      if FFont.Style in [vgFontItalic, vgFontBoldItalic] then
        pango_font_description_set_style(pdesc, PANGO_STYLE_ITALIC);
      if FFont.Style in [vgFontBold, vgFontBoldItalic] then
        pango_font_description_set_weight(pdesc, PANGO_WEIGHT_BOLD);
      pango_layout_set_font_description(memlayout, pdesc);
      pango_font_description_free(pdesc);
    end;

    pango_layout_set_height(memlayout, Round(vgRectHeight(ARect) * PANGO_SCALE));

    if WordWrap then
      pango_layout_set_width(memlayout, Round(vgRectWidth(ARect) * PANGO_SCALE))
    else
      pango_layout_set_width(memlayout, 5000 * PANGO_SCALE);
    // formating
    HOffset := 0;
    case ATextAlign of
      vgTextAlignCenter:
        begin
          pango_layout_set_alignment(memlayout, PANGO_ALIGN_CENTER);
          if not WordWrap then
            HOffset := -2500 + (vgRectWidth(ARect) / 2);
        end;
      vgTextAlignNear:
        begin
          pango_layout_set_alignment(memlayout, PANGO_ALIGN_LEFT);
        end;
      vgTextAlignFar:
        begin
          pango_layout_set_alignment(memlayout, PANGO_ALIGN_RIGHT);
          if not WordWrap then
            HOffset := -5000 + vgRectWidth(ARect);
        end;
    end;

    text := UTF8Encode(AText);
    pango_layout_set_text(memlayout, PAnsiChar(text), -1);

    pango_layout_get_pixel_extents(memlayout, @pr, @pr2);
    case AVTextAlign of
      vgTextAlignCenter:
        begin
          VOffset := (vgRectHeight(ARect) - pr2.height) / 2;
        end;
      vgTextAlignNear:
        begin
          VOffset := 0;
        end;
      vgTextAlignFar:
        begin
          VOffset := vgRectHeight(ARect) - pr2.height;
        end;
    end;
    // create path
    cairo_new_path(memcr);
    // draw text
    pango_cairo_layout_path(memcr, memlayout);
    // parse path
    cpath := cairo_copy_path(memcr);
    if cpath <> nil then
    begin
      pathdata := cpath^.data;
      i := 0;
      while i < cpath^.num_data do
      begin
        // point type
        pointtype := pathdata.header._type;
        Inc(PathData);
        Inc(i);
        if pointtype = CAIRO_PATH_CLOSE_PATH then
        begin
          Path.ClosePath;
          Continue;
        end;
        // point
        if pointtype = CAIRO_PATH_MOVE_TO then
        begin
          Path.MoveTo(vgPoint(pathdata.point.x + HOffset, pathdata.point.y + VOffset));
        end;
        if pointtype = CAIRO_PATH_LINE_TO then
        begin
          Path.LineTo(vgPoint(pathdata.point.x + HOffset, pathdata.point.y + VOffset));
        end;
        if pointtype = CAIRO_PATH_CURVE_TO then
        begin
          CP1 := vgPoint(pathdata.point.x + HOffset, pathdata.point.y + VOffset);
          Inc(PathData);
          Inc(i);
          CP2 := vgPoint(pathdata.point.x + HOffset, pathdata.point.y + VOffset);
          Inc(PathData);
          Inc(i);
          Path.CurveTo(CP1, CP2, vgPoint(pathdata.point.x + HOffset, pathdata.point.y + VOffset));
        end;
        Inc(PathData);
        Inc(i);
      end;
    end;
    Result := true;
    cairo_path_destroy(cpath);
  end
  else
    Result := false;
end;

{ Bitmaps }

procedure TvxCanvasCairo.DrawThumbnail(const ABitmap: TvxBitmap;
  const Width, Height: single);
{var
  scale: single;
  graphics: TGPGraphics;}
begin
  {  UpdateBitmap(ABitmap);
    if ABitmap.Handle = 0 then Exit;
    scale := Width / ABitmap.Width;
    if FBitmap <> nil then
    begin
      Fgraphics.ScaleTransform(scale, scale);
      Fgraphics.DrawImage(TGPBitmap(ABitmap.Handle), 0, 0, ABitmap.Width, ABitmap.Height);
    end;}
end;

procedure TvxCanvasCairo.DrawBitmap(const ABitmap: TvxBitmap;
  const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false);
var
  pat: Pcairo_pattern_t;
  pb, subpb: PGdkPixbuf;
  cm: cairo_matrix_t;
  sc: single;
begin
  UpdateBitmap(ABitmap);
  if Handle = 0 then
    Exit;
  if ABitmap.Handle = 0 then
    Exit;

  if (SrcRect.Left <> 0) or (SrcRect.top <> 0) or (SrcRect.right <> ABitmap.Width) or (SrcRect.bottom <> ABitmap.Height) then
  begin
    pb := gdk_pixbuf_new_from_data(Pguchar(ABitmap.StartLine), GDK_COLORSPACE_RGB, true,
      8, ABitmap.Width, ABitmap.Height, ABitmap.Width * 4, nil, nil);
    if pb <> nil then
    begin
      subpb := gdk_pixbuf_new_subpixbuf(pb, Trunc(SrcRect.Left), Trunc(SrcRect.top), trunc(vgRectWidth(SrcRect)), trunc(vgRectHeight(SrcRect)));
      if subpb <> nil then
      begin
        cairo_save(Pcairo_t(Handle));

        gdk_cairo_set_source_pixbuf(Pcairo_t(Handle), subpb, 0, 0);

        pat := cairo_get_source(Pcairo_t(Handle));
        cairo_matrix_init_translate(@cm, -DstRect.Left * (vgRectWidth(SrcRect) / vgRectWidth(DstRect)), -DstRect.Top * (vgRectHeight(SrcRect) / vgRectHeight(DstRect)));
        cairo_matrix_scale(@cm, vgRectWidth(SrcRect) / vgRectWidth(DstRect), vgRectHeight(SrcRect) / vgRectHeight(DstRect));
        cairo_pattern_set_matrix(pat, @cm);
        if HighSpeed then
          cairo_pattern_set_filter(pat, CAIRO_FILTER_FAST)
        else
          cairo_pattern_set_filter(pat, CAIRO_FILTER_BEST);
        cairo_pattern_set_extend(pat, CAIRO_EXTEND_NONE);

        cairo_set_source(Pcairo_t(Handle), pat);
        cairo_rectangle(Pcairo_t(Handle), DstRect.Left, DstRect.Top, vgRectWidth(DstRect), vgRectHeight(DstRect));
        cairo_clip(Pcairo_t(Handle));
        cairo_paint_with_alpha(Pcairo_t(Handle), AOpacity);
        cairo_restore(Pcairo_t(Handle));

        g_object_unref(subpb);
      end;
      g_object_unref(pb);
    end;
    Exit;
  end;
  cairo_save(Pcairo_t(Handle));
  pat := cairo_pattern_create_for_surface(Pcairo_surface_t(ABitmap.Handle));
  cairo_matrix_init_translate(@cm, -DstRect.Left * (vgRectWidth(SrcRect) / vgRectWidth(DstRect)), -DstRect.Top * (vgRectHeight(SrcRect) / vgRectHeight(DstRect)));
  cairo_matrix_scale(@cm, vgRectWidth(SrcRect) / vgRectWidth(DstRect), vgRectHeight(SrcRect) / vgRectHeight(DstRect));
  cairo_pattern_set_matrix(pat, @cm);
  if HighSpeed then
    cairo_pattern_set_filter(pat, CAIRO_FILTER_FAST)
  else
    cairo_pattern_set_filter(pat, CAIRO_FILTER_BEST);
  cairo_pattern_set_extend(pat, CAIRO_EXTEND_NONE);

  cairo_set_source(Pcairo_t(Handle), pat);
  cairo_rectangle(Pcairo_t(Handle), DstRect.Left, DstRect.Top, vgRectWidth(DstRect), vgRectHeight(DstRect));
  cairo_clip(Pcairo_t(Handle));
  cairo_paint_with_alpha(Pcairo_t(Handle), AOpacity);
  cairo_pattern_destroy(pat);
  cairo_restore(Pcairo_t(Handle));
end;

procedure TvxCanvasCairo.UpdateBitmap(ABitmap: TvxBitmap);
begin
  // update bitmap to GDI+ bitmap
  if ABitmap = nil then
    Exit;
  // create - if need
  if ABitmap.Handle = 0 then
  begin
    ABitmap.Handle := Cardinal(cairo_image_surface_create_for_data(PByte(ABitmap.StartLine), CAIRO_FORMAT_ARGB32,
      ABitmap.Width, ABitmap.Height, ABitmap.Width * 4));
  end;
  // clear flag
  ABitmap.NeedUpdate := false;
  ABitmap.OnDestroyHandle := DoDestroyBitmap;
end;

procedure TvxCanvasCairo.DoDestroyBitmap(Sender: TObject);
begin
  if (Sender <> nil) then
  begin
    if (TvxBitmap(Sender).Handle <> 0) then
      cairo_surface_destroy(Pcairo_surface_t(TvxBitmap(Sender).Handle));
    TvxBitmap(Sender).Handle := 0;
  end;
end;

{ Path }

procedure TvxCanvasCairo.DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
begin
  if Handle = 0 then
    Exit;
  if FStroke.Style = vgBrushNone then
    Exit;
  ApplyStroke(ARect, AOpacity);
  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);
  { draw }
  cairo_save(Pcairo_t(Handle));
  cairo_new_path(Pcairo_t(Handle));
  i := 0;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          cairo_move_to(Pcairo_t(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointLineTo:
        begin
          cairo_line_to(Pcairo_t(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          cairo_curve_to(Pcairo_t(Handle), CP1.X, CP1.Y, CP2.X, CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointClose:
        begin
          cairo_close_path(Pcairo_t(Handle));
        end;
    end;
    inc(i);
  end;
  cairo_stroke(Pcairo_t(Handle));
  cairo_restore(Pcairo_t(Handle));
end;

procedure TvxCanvasCairo.FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
begin
  if Handle = 0 then
    Exit;
  if FFill.Style = vgBrushNone then
    Exit;
  ApplyFill(ARect, AOpacity);
  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);
  cairo_save(Pcairo_t(Handle));
  cairo_new_path(Pcairo_t(Handle));
  i := 0;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          cairo_move_to(Pcairo_t(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointLineTo:
        begin
          cairo_line_to(Pcairo_t(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          cairo_curve_to(Pcairo_t(Handle), CP1.X, CP1.Y, CP2.X, CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointClose:
        begin
          cairo_close_path(Pcairo_t(Handle));
        end;
    end;
    inc(i);
  end;
  cairo_fill(Pcairo_t(Handle));
  DeApplyFill;
  cairo_restore(Pcairo_t(Handle));
end;

function TvxCanvasCairo.PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean;
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
begin
  Result := false;
  if Handle = 0 then
    Exit;
  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);
  cairo_save(Pcairo_t(Handle));
  cairo_new_path(Pcairo_t(Handle));
  i := 0;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          cairo_move_to(Pcairo_t(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointLineTo:
        begin
          cairo_line_to(Pcairo_t(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          cairo_curve_to(Pcairo_t(Handle), CP1.X, CP1.Y, CP2.X, CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointClose:
        begin
          cairo_close_path(Pcairo_t(Handle));
        end;
    end;
    inc(i);
  end;
  cairo_restore(Pcairo_t(Handle));
  Result := cairo_in_fill(Pcairo_t(Handle), APoint.X, APoint.Y) > 0;
end;

{$ENDIF}

{$IFDEF WINDOWS}
{$I dcm_d2d.inc}

var
  Res: HResult;

const
  TargetMode: TD2D1_RenderTargetType = D2D1_RENDER_TARGET_TYPE_software;

type

  TvxHackBitmap = class(TvxBitmap);

var
  Factory: ID2D1Factory;
  DWriteFactory: IDWriteFactory;
  ImagingFactory: IWICImagingFactory;

type

  TvxFilterWIC = class(TvxFilter)
  private
  public
  published
    class function GetFileTypes: string; override;
    class function GetImageSize(const AFileName: string): TvxPoint; override;
    function LoadFromFile(const AFileName: string; const Rotate: single; var Bitmap: TvxBitmap): boolean; override;
    function SaveToFile(const AFileName: string; var Bitmap: TvxBitmap; const Params: string = ''): boolean; override;
    function LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single; const UseEmbedded: boolean;
      var Bitmap: TvxBitmap): boolean; override;
    function LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean; override;
    function SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
      const Params: string = ''): boolean; override;
  end;

  TvxCanvasD2D = class(TvxCanvas)
  private
    FBufferHandle: cardinal;
    FBitmapInfo: TBitmapInfo;
    RenderTarget: ID2D1RenderTarget;
    Brush: ID2D1Brush;
    StrokeBrush: ID2D1Brush;
    StrokeStyle: ID2D1StrokeStyle;
    Layer: ID2D1Layer;
    FSaved: Pointer;
    WICBitmap: IWICBitmap;
    FLastState: integer;
    procedure CreateResources;
    procedure DisposeResources;
  protected
    procedure ApplyFill(ARect: TvxRect; const AOpacity: single);
    procedure ApplyStroke(ARect: TvxRect; const AOpacity: single);
    procedure FontChanged(Sender: TObject); override;
    procedure IntFillPath(P: ID2D1Geometry; R: TvxRect; Opacity: single);
    procedure IntFillRect(R: TvxRect; Opacity: single);
    class function GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray; override;
  public
    constructor Create(const AWidth, AHeight: integer); override;
    constructor CreateFromBitmap(const ABitmap: TvxBitmap); override;
    destructor Destroy; override;
    { begin and }
    function BeginScene: boolean; override;
    procedure EndScene; override;
    { buffer }
    procedure FreeBuffer; override;
    procedure ResizeBuffer(const AWidth, AHeight: integer); override;
    procedure FlushBuffer(const X, Y: integer; const DC: Cardinal); override;
    procedure FlushBufferRect(const X, Y: integer; const DC: Cardinal; const ARect: TvxRect); override;
    procedure Clear(const Color: TvxColor); override;
    procedure ClearRect(const ARect: TvxRect; const AColor: TvxColor = 0); override;
    { matrix }
    procedure SetMatrix(const M: TvxMatrix); override;
    procedure MultyMatrix(const M: TvxMatrix); override;
    { cliping }
    function SaveCanvas: cardinal; override;
    procedure RestoreCanvas(const AState: cardinal); override;
    procedure SetClipRects(const ARects: array of TvxRect); override;
    procedure IntersectClipRect(const ARect: TvxRect); override;
    procedure ExcludeClipRect(const ARect: TvxRect); override;
    procedure ResetClipRect; override;
    { drawing }
    procedure DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single); override;
    procedure FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure FillEllipse(const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawEllipse(const ARect: TvxRect; const AOpacity: single); override;
    procedure FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
      const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    procedure MeasureText(var ARect: TvxRect; AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    function TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean; override;
    function PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean; override;
    procedure FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawBitmap(const ABitmap: TvxBitmap; const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false); override;
    procedure DrawThumbnail(const ABitmap: TvxBitmap; const Width, Height: single); override;
  published
  end;

procedure SAFE_RELEASE(var i);
begin
  if IUnknown(i) <> nil then
    IUnknown(i) := nil;
end;

{ TvxFilterWIC }

class function TvxFilterWIC.GetFileTypes: string;
begin
  Result := '*.bmp;*.jpg;*.jpeg;*.png;*.tif;*.tiff;*.gif;*.ico;*.wmp'
end;

class function TvxFilterWIC.GetImageSize(const AFileName: string): TvxPoint;
var
  bmp: IWICBitmapSource;
  dec: IWICBitmapDecoder;
  frame: IWICBitmapFrameDecode;
  conv: IWICFormatConverter;
  W, H: cardinal;
  fn: WideString;
begin
  W := 0;
  H := 0;
  fn := AFileName;
  ImagingFactory.CreateDecoderFromFilename(PWideChar(fn), nil, $FFFFFFFF, WICDecodeMetadataCacheOnDemand, dec);
  if Assigned(dec) then
  begin
    dec.GetFrame(0, frame);
    if Assigned(frame) then
    begin
      frame.GetSize(W, H);
    end;
  end;
  Result := vgPoint(W, H);
end;

function TvxFilterWIC.LoadFromFile(const AFileName: string;
  const Rotate: single; var Bitmap: TvxBitmap): boolean;
var
  bmp: IWICBitmapSource;
  dec: IWICBitmapDecoder;
  frame: IWICBitmapFrameDecode;
  conv: IWICFormatConverter;
  W, H: cardinal;
  fn: WideString;
begin
  fn := AFileName;
  Result := false;
  ImagingFactory.CreateDecoderFromFilename(PWideChar(fn), nil, $FFFFFFFF, WICDecodeMetadataCacheOnDemand, dec);
  if Assigned(dec) then
  begin
    dec.GetFrame(0, frame);
    if Assigned(frame) then
    begin
      ImagingFactory.CreateFormatConverter(conv);
      Res := conv.Initialize(frame, GUID_WICPixelFormat32bppPBGRA, WICBitmapDitherTypeNone, nil, 0, 0);
      if Res = 0 then
      begin
        conv.GetSize(W, H);

        Bitmap.SetSize(W, H);
        Bitmap.Clear($FFFF0000);
        Res := conv.CopyPixels(nil, W * 4, W * H * 4, PByte(Bitmap.Startline));
        Result := true;
      end;
    end;
  end;
end;

function TvxFilterWIC.LoadFromStream(const AStream: TStream;
  var Bitmap: TvxBitmap): boolean;
var
  bmp: IWICBitmapSource;
  dec: IWICBitmapDecoder;
  mem: TMemoryStream;
  stream: IWICStream;
  frame: IWICBitmapFrameDecode;
  conv: IWICFormatConverter;
  W, H: cardinal;
begin
  Result := false;
  mem := TMemoryStream.Create;
  mem.CopyFrom(AStream, AStream.Size);
  ImagingFactory.CreateStream(stream);
  stream.InitializeFromMemory(mem.Memory, mem.Size);

  ImagingFactory.CreateDecoderFromStream(stream, nil, WICDecodeMetadataCacheOnDemand, dec);
  if Assigned(dec) then
  begin
    dec.GetFrame(0, frame);
    if Assigned(frame) then
    begin
      ImagingFactory.CreateFormatConverter(conv);
      Res := conv.Initialize(frame, GUID_WICPixelFormat32bppPBGRA, WICBitmapDitherTypeNone, nil, 0, 0);
      if Res = 0 then
      begin
        conv.GetSize(W, H);

        Bitmap.SetSize(W, H);
        Res := conv.CopyPixels(nil, W * 4, W * H * 4, PByte(Bitmap.Startline));
        Result := true;
      end;
    end;
  end;
  mem.Free;
end;

function TvxFilterWIC.LoadThumbnailFromFile(const AFileName: string;
  const AFitWidth, AFitHeight: single; const UseEmbedded: boolean;
  var Bitmap: TvxBitmap): boolean;
var
  bmp: IWICBitmapSource;
  dec: IWICBitmapDecoder;
  scale: single;
  scaler: IWICBitmapScaler;
  frame: IWICBitmapFrameDecode;
  conv: IWICFormatConverter;
  W, H: cardinal;
  R: TvxRect;
  fn: WideString;
begin
  fn := AFileName;
  Result := false;
  ImagingFactory.CreateDecoderFromFilename(PWideChar(fn), nil, $FFFFFFFF, WICDecodeMetadataCacheOnDemand, dec);
  if Assigned(dec) then
  begin
    dec.GetFrame(0, frame);
    if UseEmbedded then
      frame.GetThumbnail(bmp);
    if Assigned(bmp) then
    begin
      ImagingFactory.CreateFormatConverter(conv);
      Res := conv.Initialize(bmp, GUID_WICPixelFormat32bppPBGRA, WICBitmapDitherTypeNone, nil, 0, 0);
      if Res = 0 then
      begin
        conv.GetSize(W, H);

        Bitmap.SetSize(W, H);
        Bitmap.Clear($FFFF0000);
        Res := conv.CopyPixels(nil, W * 4, W * H * 4, PByte(Bitmap.Startline));
        Result := true;
      end;
    end
    else
    begin
      if Assigned(frame) then
      begin
        frame.GetSize(W, H);
        R := vgRect(0, 0, W, H);
        scale := vgFitRect(R, vgRect(0, 0, AFitWidth, AFitHeight));
        if scale = 0 then
          scale := 0.001;
        if scale < 1 then
          scale := 1;

        ImagingFactory.CreateBitmapScaler(scaler);
        Res := scaler.Initialize(frame, round(W / scale), round(H / scale), WICBitmapInterpolationModeLinear);

        ImagingFactory.CreateFormatConverter(conv);
        Res := conv.Initialize(scaler, GUID_WICPixelFormat32bppPBGRA, WICBitmapDitherTypeNone, nil, 0, 0);
        if Res = 0 then
        begin
          conv.GetSize(W, H);

          Bitmap.SetSize(W, H);
          Bitmap.Clear($FFFF0000);
          Res := conv.CopyPixels(nil, W * 4, W * H * 4, PByte(Bitmap.Startline));
          Result := true;
        end;
      end;
    end;
  end;
end;

function TvxFilterWIC.SaveToFile(const AFileName: string;
  var Bitmap: TvxBitmap; const Params: string): boolean;
var
  bmp: IWICBitmap;
  enc: IWICBitmapEncoder;
  encoderType: TGuid;
  stream: IWICStream;
  frame: IWICBitmapFrameEncode;
  conv: IWICFormatConverter;
  props: IPropertyBag2;
  W, H: cardinal;
  fn: WideString;
  pformat: WICPixelFormatGUID;
  buf: PByte;
  pname: TPropBag2;
  pvalue: Variant;
  S, param, name, value: ansistring;
  i: integer;
begin
  fn := AFileName;
  Result := false;
  encoderType := GUID_ContainerFormatPng;
  if (LowerCase(ExtractFileExt(AFileName)) = '.jpg') or (LowerCase(ExtractFileExt(AFileName)) = '.jpeg') then
    encoderType := GUID_ContainerFormatJpeg;
  if (LowerCase(ExtractFileExt(AFileName)) = '.bmp') then
    encoderType := GUID_ContainerFormatBmp;
  if (LowerCase(ExtractFileExt(AFileName)) = '.png') then
    encoderType := GUID_ContainerFormatPng;
  if (LowerCase(ExtractFileExt(AFileName)) = '.tif') or (LowerCase(ExtractFileExt(AFileName)) = '.tiff') then
    encoderType := GUID_ContainerFormatTiff;
  if (LowerCase(ExtractFileExt(AFileName)) = '.gif') then
    encoderType := GUID_ContainerFormatGif;
  if (LowerCase(ExtractFileExt(AFileName)) = '.wmp') then
    encoderType := GUID_ContainerFormatWmp;
  ImagingFactory.CreateEncoder(encoderType, nil, enc);
  if Assigned(enc) then
  begin
    ImagingFactory.CreateStream(stream);
    stream.InitializeFromFilename(PWideChar(fn), $FFFFFFFF);
    enc.Initialize(stream, WICBitmapEncoderNoCache);
    enc.CreateNewFrame(frame, props);
    if Assigned(frame) then
    begin
      { set params }
{      if Params <> '' then
      begin
        S := Params;
        i := 0;
        while S <> '' do
        begin
          param := vgGetToken(S, ' ');
          name := vgGetToken(param, '=');
          value := vgGetToken(param, '');
          if CompareText(name, 'quality') = 0 then
          begin
            Fillchar(pname, SizeOf(pname), 0);
            pname.dwType := 1;//PROPBAG2_TYPE_DATA;
            pname.vt := VT_VARIANT;
            pname.pstrName := PWideChar(WideString('ImageQuality'));
            pvalue := vgStrToFloat(value) / 100;
            Res := props.Write(1, @pname, @value);
          end;
          Inc(i);
        end;
      end;}
      Res := frame.Initialize(props);
      { }
      Res := frame.SetSize(Bitmap.Width, Bitmap.Height);
      pformat := GUID_WICPixelFormat32bppPBGRA;
      Res := frame.SetPixelFormat(pformat);
      if IsEqualGuid(pformat, GUID_WICPixelFormat32bppPBGRA) then
      begin
        Res := frame.WritePixels(Bitmap.Height, Bitmap.Width * 4, Bitmap.Width * Bitmap.Height * 4, PByte(Bitmap.Startline));
        Res := frame.Commit;
        Res := enc.Commit;
      end
      else
      begin
        ImagingFactory.CreateBitmapFromMemory(Bitmap.Width, Bitmap.Height, GUID_WICPixelFormat32bppPBGRA,
          Bitmap.Width * 4, Bitmap.Width * Bitmap.Height * 4, PByte(Bitmap.Startline), bmp);
        ImagingFactory.CreateFormatConverter(conv);
        Res := conv.Initialize(bmp, pformat, WICBitmapDitherTypeNone, nil, 0, 0);
        Res := frame.WriteSource(bmp, nil);
        Res := frame.Commit;
        Res := enc.Commit;
      end;
    end;
  end;
end;

function TvxFilterWIC.SaveToStream(const AStream: TStream;
  var Bitmap: TvxBitmap; const Format, Params: string): boolean;
var
  bmp: IWICBitmap;
  enc: IWICBitmapEncoder;
  encoderType: TGuid;
  stream: IWICStream;
  frame: IWICBitmapFrameEncode;
  conv: IWICFormatConverter;
  props: IPropertyBag2;
  W, H: cardinal;
  fn: WideString;
  pformat: WICPixelFormatGUID;
  buf: PByte;
  adapter: TStreamAdapter;
  str: Pointer;
  strSize: integer;
  stg: TStatStg;
begin
  Result := false;
  encoderType := GUID_ContainerFormatPng;
  if LowerCase(Format) = 'jpeg' then
    encoderType := GUID_ContainerFormatJpeg;
  if LowerCase(Format) = 'jpg' then
    encoderType := GUID_ContainerFormatJpeg;
  if LowerCase(Format) = 'png' then
    encoderType := GUID_ContainerFormatPng;
  if LowerCase(Format) = 'bmp' then
    encoderType := GUID_ContainerFormatBmp;
  if LowerCase(Format) = 'tif' then
    encoderType := GUID_ContainerFormatTiff;
  if LowerCase(Format) = 'tiff' then
    encoderType := GUID_ContainerFormatTiff;
  if LowerCase(Format) = 'gif' then
    encoderType := GUID_ContainerFormatGif;
  if LowerCase(Format) = 'wmp' then
    encoderType := GUID_ContainerFormatWmp;
  ImagingFactory.CreateEncoder(encoderType, nil, enc);
  if Assigned(enc) then
  begin
    ImagingFactory.CreateStream(stream);
    adapter := TStreamAdapter.Create(AStream);
    IUnknown(adapter)._AddRef;
    stream.InitializeFromIStream(adapter);
    enc.Initialize(stream, WICBitmapEncoderNoCache);
    enc.CreateNewFrame(frame, props);
    if Assigned(frame) then
    begin
      frame.Initialize(props);
      Res := frame.SetSize(Bitmap.Width, Bitmap.Height);
      pformat := GUID_WICPixelFormat32bppPBGRA;
      Res := frame.SetPixelFormat(pformat);
      if IsEqualGuid(pformat, GUID_WICPixelFormat32bppPBGRA) then
      begin
        Res := frame.WritePixels(Bitmap.Height, Bitmap.Width * 4, Bitmap.Width * Bitmap.Height * 4, PByte(Bitmap.Startline));
        Res := frame.Commit;
        Res := enc.Commit;
      end
      else
      begin
        ImagingFactory.CreateBitmapFromMemory(Bitmap.Width, Bitmap.Height, GUID_WICPixelFormat32bppPBGRA,
          Bitmap.Width * 4, Bitmap.Width * Bitmap.Height * 4, PByte(Bitmap.Startline), bmp);
        ImagingFactory.CreateFormatConverter(conv);
        Res := conv.Initialize(bmp, pformat, WICBitmapDitherTypeNone, nil, 0, 0);
        Res := frame.WriteSource(bmp, nil);
        Res := frame.Commit;
        Res := enc.Commit;
      end;
    end;
    IUnknown(adapter)._Release;
  end;
end;

{ Canvas =====}

const
  D2DERR_RECREATE_TARGET = HResult($8899000C);

procedure SetD2DDefault;
begin
  if D2DLibrary <> 0 then
  begin
    DefaultCanvasClass := TvxCanvasD2D;
    DefaultFilterClass := TvxFilterWIC;
  end;
end;

function D2Rect(const R: TvxRect): TD2D1_RectF;
begin
  Result := TD2D1_RectF(R);
end;

function D2Color(const AColor: TvxColor; const Opacity: single): TD2D1_ColorF;
begin
  with TvxColorRec(AColor) do
    Result := D2D1ColorF(R / $FF, G / $FF, B / $FF, (A / $FF) * Opacity);
end;

function D2Point(X, Y: single): TD2D1_Point2F;
begin
  Result.X := X;
  Result.Y := Y;
end;

function D2Size(W, H: cardinal): TD2D_SizeU;
begin
  Result.Width := W;
  Result.Height := H;
end;

function D2Matrix(M: TvxMatrix): TD2D1_Matrix3X2F;
begin
  Result._11 := M.m11;
  Result._12 := M.m12;
  Result._21 := M.m21;
  Result._22 := M.m22;
  Result._31 := M.m31;
  Result._32 := M.m32;
end;

function D2Bezier(x1, y1, x2, y2, x3, y3: single): TD2D1_BezierSegment;
begin
  Result.Point1.X := x1;
  Result.Point1.Y := y1;
  Result.Point2.X := x2;
  Result.Point2.Y := y2;
  Result.Point3.X := x3;
  Result.Point3.Y := y3;
end;

function D2Ellipse(R: TvxRect): TD2D1_Ellipse;
begin
  Result.Point.x := (R.Right + R.left) / 2;
  Result.Point.y := (R.bottom + R.top) / 2;
  Result.RadiusX := (R.Right - R.left) / 2;
  Result.RadiusY := (R.bottom - R.top) / 2;
end;

function D2FontStyle(Style: TvxFontStyle): TDWrite_FontStyle;
begin
  case Style of
    vgFontRegular: Result := DWRITE_FONT_STYLE_NORMAL;
    vgFontBold: Result := DWRITE_FONT_STYLE_NORMAL;
    vgFontItalic: Result := DWRITE_FONT_STYLE_OBLIQUE;
    vgFontBoldItalic: Result := DWRITE_FONT_STYLE_OBLIQUE;
    vgFontUnderline: Result := DWRITE_FONT_STYLE_NORMAL;
    vgFontStrikeout: Result := DWRITE_FONT_STYLE_NORMAL;
  end;
end;

function D2FontWeight(Style: TvxFontStyle): TDWrite_FontWeight;
begin
  case Style of
    vgFontRegular: Result := DWRITE_FONT_WEIGHT_NORMAL;
    vgFontBold: Result := DWRITE_FONT_WEIGHT_BOLD;
    vgFontItalic: Result := DWRITE_FONT_WEIGHT_NORMAL;
    vgFontBoldItalic: Result := DWRITE_FONT_WEIGHT_BOLD;
    vgFontUnderline: Result := DWRITE_FONT_WEIGHT_NORMAL;
    vgFontStrikeout: Result := DWRITE_FONT_WEIGHT_NORMAL;
  end;
end;

function BitmapProp(DXGI: TDXGI_Format; AlphaMode: TD2D1_AlphaMode): TD2D1_BitmapProperties;
begin
  Result.PixelFormat.Format := DXGI;
  Result.PixelFormat.AlphaMode := AlphaMode;
  Result.DpiX := 0;
  Result.DpiY := 0;
end;

{ TvxCanvasD2D }

const
  SavedCount = 200;

type

  TSaveData = record
    GdiIndex: integer;
    Matrix: TvxMatrix;
    AbsoluteMatrix, InvertMatrix: TvxMatrix;
    StrokeThickness: single;
    Stroke: TvxBrush;
    Fill: TvxBrush;
  end;

  PSaveDataArray = ^TSaveDataArray;
  TSaveDataArray = array[0..100] of TSaveData;

var
  D2DLoadcount: integer = 0;

procedure AddD2DRef;
begin
  if Factory = nil then
  begin
    D2D1CreateFactory(D2D1_FACTORY_TYPE_MULTI_THREADED, ID2D1Factory, nil, Factory);
    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, IDWriteFactory, IUnknown(DWriteFactory));
    CoCreateInstance(CLSID_WICImagingFactory, nil, CLSCTX_INPROC_SERVER or CLSCTX_LOCAL_SERVER, IUnknown, ImagingFactory);
  end;
  D2DLoadcount := D2DLoadcount + 1;
end;

procedure DecD2DRef;
begin
  D2DLoadcount := D2DLoadcount - 1;
  if D2DLoadcount = 0 then
  begin
    SAFE_RELEASE(ImagingFactory);
    SAFE_RELEASE(DWriteFactory);
    SAFE_RELEASE(Factory);
  end;
end;

constructor TvxCanvasD2D.Create(const AWidth, AHeight: integer);
begin
  AddD2DRef;
  inherited;
  GetMem(FSaved, SizeOf(TSaveData) * SavedCount);
end;

constructor TvxCanvasD2D.CreateFromBitmap(const ABitmap: TvxBitmap);
begin
  AddD2DRef;
  inherited;
  FBitmap := ABitmap;
  //  UpdateBitmap(FBitmap);
  GetMem(FSaved, SizeOf(TSaveData) * SavedCount);
  if Assigned(ImagingFactory) then
  begin
    ImagingFactory.CreateBitmapFromMemory(FBitmap.Width, FBitmap.Height, GUID_WICPixelFormat32bppPBGRA,
      FBitmap.Width * 4, FBitmap.Width * FBitmap.Height * 4, PByte(FBitmap.Startline), WICBitmap);
    CreateResources;
  end;
end;

destructor TvxCanvasD2D.Destroy;
begin
  FreeMem(FSaved, SizeOf(TSaveData) * 100);
  SAFE_RELEASE(Brush);
  SAFE_RELEASE(StrokeBrush);
  SAFE_RELEASE(StrokeStyle);
  inherited;
  DecD2DRef;
end;

procedure TvxCanvasD2D.FreeBuffer;
begin
  DisposeResources;
  if FBuffered then
  begin
    if FBufferHandle = 0 then
      Exit;
    if FHandle <> 0 then
      DeleteDC(FHandle);
    FHandle := 0;
    if FBufferHandle <> 0 then
      DeleteObject(FBufferHandle);
    FBufferHandle := 0;
  end;
end;

procedure TvxCanvasD2D.CreateResources;
var
  SizeInPixels: D2D1_SIZE_U;
begin
  if RenderTarget = nil then
  begin
    SizeInPixels.width := FWidth;
    SizeInPixels.height := FHeight;
    if FBitmap <> nil then
    begin
      Factory.CreateWicBitmapRenderTarget(WICBitmap, D2D1RenderTargetProperties(TargetMode, D2D1PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED)),
        RenderTarget);
    end
    else
    begin
      if FBuffered then
      begin
        if FHandle = 0 then
        begin
          if Assigned(ImagingFactory) then
          begin
            ImagingFactory.CreateBitmapFromMemory(FBitmap.Width, FBitmap.Height, GUID_WICPixelFormat32bppPBGRA,
              FBitmap.Width * 4, FBitmap.Width * FBitmap.Height * 4, PByte(FBitmap.Startline), WICBitmap);
            Factory.CreateWicBitmapRenderTarget(WICBitmap, D2D1RenderTargetProperties(TargetMode, D2D1PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED)),
              RenderTarget);
          end;
        end
        else
        begin
          Factory.CreateDCRenderTarget(D2D1RenderTargetProperties(TargetMode, D2D1PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED)),
            ID2D1DCRenderTarget(RenderTarget));
          ID2D1DCRenderTarget(RenderTarget).BindDC(FHandle, Rect(0, 0, FWidth, FHeight));
        end;
      end
      else
        Factory.CreateHWndRenderTarget(D2D1RenderTargetProperties(TargetMode, D2D1PixelFormat(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED)),
          D2D1HwndRenderTargetProperties(FParent, SizeInPixels),
          ID2D1HwndRenderTarget(RenderTarget));
    end;
    RenderTarget.SetDpi(96, 96);
    RenderTarget.SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE_DEFAULT);
  end
end;

procedure TvxCanvasD2D.DisposeResources;
begin
  SAFE_RELEASE(StrokeBrush);
  SAFE_RELEASE(Brush);
  SAFE_RELEASE(Layer);
  SAFE_RELEASE(RenderTarget);
  SAFE_RELEASE(WICBitmap);
end;

procedure TvxCanvasD2D.Clear(const Color: TvxColor);
begin
  RenderTarget.Clear(D2Color(Color, 1));
end;

procedure TvxCanvasD2D.ClearRect(const ARect: TvxRect;
  const AColor: TvxColor);
begin
end;

procedure TvxCanvasD2D.ResizeBuffer(const AWidth, AHeight: integer);
var
  Size: D2D1_SIZE_U;
begin
  if Assigned(FScene) and (FScene.GetTransparency) and not FBuffered then
  begin
    FBuffered := true;
  end;
  if (AWidth = FWidth) and (AHeight = FHeight) then
    Exit;
  if (FParent <> 0) and not (FBuffered) and (RenderTarget <> nil) then
  begin
    FWidth := AWidth;
    FHeight := AHeight;
    if FWidth <= 0 then
      FWidth := 1;
    if FHeight <= 0 then
      FHeight := 1;
    Size.Width := AWidth;
    Size.Height := AHeight;
    ID2D1HwndRenderTarget(RenderTarget).Resize(Size);
    Exit;
  end;
  FreeBuffer;
  FWidth := AWidth;
  FHeight := AHeight;
  if FWidth <= 0 then
    FWidth := 1;
  if FHeight <= 0 then
    FHeight := 1;
  FResized := true;
  if FBuffered then
  begin
    { Initialization }
    with FBitmapInfo.bmiHeader do
    begin
      biSize := SizeOf(TBitmapInfoHeader);
      biPlanes := 1;
      biBitCount := 32;
      biCompression := BI_RGB;
      biWidth := AWidth;
      if biWidth <= 0 then
        biWidth := 1;
      biHeight := -AHeight;
      if biHeight >= 0 then
        biHeight := -1;
    end;
    { Create new DIB }
    FBufferHandle := CreateDIBSection(0, FBitmapInfo, DIB_RGB_COLORS, Pointer(FBufferBits), 0, 0);
    if FBufferBits = nil then
      raise Exception.Create('Can''t allocate the DIB handle');

    FHandle := CreateCompatibleDC(0);
    if FHandle = 0 then
    begin
      DeleteObject(FBufferHandle);
      FHandle := 0;
      FBufferBits := nil;
      raise Exception.Create('Can''t create compatible DC');
    end;

    if SelectObject(FHandle, FBufferHandle) = 0 then
    begin
      DeleteDC(FHandle);
      DeleteObject(FBufferHandle);
      FHandle := 0;
      FBufferHandle := 0;
      FBufferBits := nil;
      raise Exception.Create('Can''t select an object into DC');
    end;
  end;
end;

procedure TvxCanvasD2D.FlushBuffer(const X, Y: integer;
  const DC: Cardinal);
begin
  if FBufferHandle = 0 then
    Exit;
  if DC = 0 then
    Exit;
  Windows.BitBlt(DC, X, Y, FWidth, FHeight, FHandle, 0, 0, SRCCOPY);
end;

procedure TvxCanvasD2D.FlushBufferRect(const X, Y: integer;
  const DC: Cardinal; const ARect: TvxRect);
var
  R: TRect;
begin
  if FBufferHandle = 0 then
    Exit;
  if DC = 0 then
    Exit;
  R := Rect(trunc(ARect.left), trunc(ARect.top), trunc(ARect.right) + 1, trunc(ARect.bottom) + 1);
  with R do
  begin
    Windows.BitBlt(DC, X + R.left, Y + R.top, R.right - R.left, R.bottom - R.top, FHandle, R.left, R.top, SRCCOPY);
  end;
end;

function TvxCanvasD2D.BeginScene: boolean;
begin
  CreateResources;
  Result := inherited BeginScene and (RenderTarget <> nil);
  if Result then
  begin
    FLastState := -1;
    if (FParent <> 0) and not (FBuffered) then
      Result := (LongWord(ID2D1HwndRenderTarget(RenderTarget).CheckWindowState) and LongWord(D2D1_WINDOW_STATE_OCCLUDED) = 0);
    RenderTarget.BeginDraw;
  end;
end;

procedure TvxCanvasD2D.EndScene;
var
  Res: HResult;
begin
  inherited;
  if RenderTarget <> nil then
  begin
    if Assigned(Layer) then
    begin
      RenderTarget.PopLayer;
      SAFE_RELEASE(Layer);
    end;
    Res := RenderTarget.EndDraw;
    if Res = D2DERR_RECREATE_TARGET then
    begin
      DisposeResources;
    end
    else
      if Res <> 0 then
    begin
      //Res := 10;
    end;
    if WICBitmap <> nil then
    begin
      Res := WICBitmap.CopyPixels(nil, Width * 4, Width * Height * 4, PByte(FBitmap.Startline));
    end;
  end;
end;

class function TvxCanvasD2D.GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray;
begin
  if (y >= 0) and (y < Bitmap.Height) and (Bitmap.StartLine <> nil) then
    Result := @PvgColorArray(Bitmap.StartLine)[(y) * Bitmap.Width]
  else
    Result := nil;
end;

procedure TvxCanvasD2D.SetMatrix(const M: TvxMatrix);
begin
  FMatrix := M;
  RenderTarget.SetTransform(D2Matrix(FMatrix));
end;

procedure TvxCanvasD2D.MultyMatrix(const M: TvxMatrix);
var
  T: TvxMatrix;
begin
  inherited;
  {  RenderTarget.GetTransform(D2D_MATRIX_3X2_F(T));
    M := vgMatrixMultipy(T, M);
    RenderTarget.SetTransform(D2Matrix(T));}
end;

function TvxCanvasD2D.SaveCanvas: cardinal;
var
  i: integer;
  B: ID2D1DrawingStateBlock;
begin
  Result := InvalideCanvasState;
  if RenderTarget = nil then
    Exit;

  // find exists
  if Length(FSaveData) > 0 then
    for i := 0 to High(FSaveData) do
      if FSaveData[i].Index = InvalideCanvasState then
      begin
        Result := i;
        Break;
      end;
  if Result = InvalideCanvasState then
  begin
    SetLength(FSaveData, Length(FSaveData) + 1);
    Result := High(FSaveData);
  end;
  Factory.CreateDrawingStateBlock(nil, nil, B);
  B._AddRef;
  RenderTarget.SaveDrawingState(B);

  FLastState := Result;
  FSaveData[Result].Index := Cardinal(B);
  FSaveData[Result].Matrix := FMatrix;
  FSaveData[Result].Stroke := TvxBrush.Create(vgBrushSolid, InvalideCanvasState);
  FSaveData[Result].Stroke.Assign(Stroke);
  FSaveData[Result].Fill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FSaveData[Result].Fill.Assign(Fill);
  FSaveData[Result].StrokeThickness := FStrokeThickness;
  FSaveData[Result].StrokeCap := StrokeCap;
  FSaveData[Result].StrokeJoin := StrokeJoin;
  FSaveData[Result].StrokeDash := StrokeDash;
  if StrokeDash <> vgDashSolid then
  begin
    SetLength(FSaveData[Result].Dash, Length(FDash));
    Move(FDash[0], FSaveData[Result].Dash[0], SizeOf(FDash[0]) * Length(FDash));
  end;
  FSaveData[Result].DashOffset := FDashOffset;
  FSaveData[Result].Font := TvxFont.Create;
  FSaveData[Result].Font.Assign(Font);
  FSaveData[Result].Data := nil;
end;

procedure TvxCanvasD2D.RestoreCanvas(const AState: cardinal);
var
  B: ID2D1DrawingStateBlock;
begin
  if RenderTarget = nil then
    Exit;

  if (AState >= 0) and (AState < Length(FSaveData)) then
  begin
    B := ID2D1DrawingStateBlock(FSaveData[AState].Index);
    RenderTarget.RestoreDrawingState(B);
    B._Release;
    SAFE_RELEASE(B);

    if FSaveData[AState].Data <> nil then
    begin
      RenderTarget.PopLayer;
      SAFE_RELEASE(ID2D1Layer(FSaveData[AState].Data));
      FSaveData[AState].Data := nil;
    end;

    FSaveData[AState].Index := InvalideCanvasState;

    FMatrix := FSaveData[AState].Matrix;
    Stroke.Assign(FSaveData[AState].Stroke);
    FSaveData[AState].Stroke.Free;
    Fill.Assign(FSaveData[AState].Fill);
    FSaveData[AState].Fill.Free;
    SetMatrix(FMatrix);
    FStrokeThickness := FSaveData[AState].StrokeThickness;
    FStrokeCap := FSaveData[AState].StrokeCap;
    FStrokeJoin := FSaveData[AState].StrokeJoin;
    FStrokeDash := FSaveData[AState].StrokeDash;
    if StrokeDash <> vgDashSolid then
    begin
      SetLength(FDash, Length(FSaveData[AState].Dash));
      Move(FSaveData[AState].Dash[0], FDash[0], SizeOf(FDash[0]) * Length(FDash));
    end;
    FDashOffset := FSaveData[AState].DashOffset;
    Font.Assign(FSaveData[AState].Font);
    FSaveData[AState].Font.Free;
  end
end;

procedure TvxCanvasD2D.SetClipRects(const ARects: array of TvxRect);
var
  i: integer;
  Geoms: array of ID2D1Geometry;
  FClipGeom: ID2D1GeometryGroup;
  LayerPar: TD2D1_LayerParameters;
  R: TvxRect;
begin
  if Length(ARects) > 0 then
  begin
    RenderTarget.SetTransform(D2Matrix(IdentityMatrix));
    for i := 0 to High(ARects) do
    begin
      R := ARects[i];
      RenderTarget.PushAxisAlignedClip(D2Rect(R), D2D1_ANTIALIAS_MODE_ALIASED);
      RenderTarget.Clear(D2Color(0, 0));
      RenderTarget.PopAxisAlignedClip;
    end;
    SAFE_RELEASE(FClipGeom);
    SetLength(Geoms, Length(ARects));
    for i := 0 to High(ARects) do
    begin
      Factory.CreateRectangleGeometry(D2Rect(ARects[i]), ID2D1RectangleGeometry(Geoms[i]));
    end;
    Factory.CreateGeometryGroup(D2D1_FILL_MODE_WINDING, @Geoms[0], Length(Geoms), FClipGeom);
    for i := 0 to High(ARects) do
    begin
      SAFE_RELEASE(Geoms[i]);
    end;

    RenderTarget.CreateLayer(nil, Layer);
    LayerPar.ContentBounds := D2Rect(vgRect(0, 0, FWidth, FHeight));
    LayerPar.GeometricMask := FClipGeom;
    LayerPar.MaskAntialiasMode := D2D1_ANTIALIAS_MODE_ALIASED;
    LayerPar.MaskTransform := D2Matrix(IdentityMatrix);
    LayerPar.Opacity := 1;
    LayerPar.OpacityBrush := nil;
    LayerPar.LayerOptions := D2D1_LAYER_OPTIONS_NONE;
    RenderTarget.PushLayer(LayerPar, Layer);
    SAFE_RELEASE(FClipGeom);
  end;
end;

procedure TvxCanvasD2D.IntersectClipRect(const ARect: TvxRect);
var
  Geom: ID2D1Geometry;
  LayerPar: TD2D1_LayerParameters;
begin
  if FLastState < 0 then
    Exit;
  Factory.CreateRectangleGeometry(D2Rect(ARect), ID2D1RectangleGeometry(Geom));
  if Assigned(Geom) then
  begin
    RenderTarget.CreateLayer(nil, ID2D1Layer(FSaveData[FLastState].Data));
    LayerPar.ContentBounds := D2Rect(vgRect(0, 0, 100000, 400000));
    LayerPar.GeometricMask := Geom;
    LayerPar.MaskAntialiasMode := D2D1_ANTIALIAS_MODE_ALIASED;
    LayerPar.MaskTransform := D2Matrix(IdentityMatrix);
    LayerPar.Opacity := 1;
    LayerPar.OpacityBrush := nil;
    LayerPar.LayerOptions := D2D1_LAYER_OPTIONS_NONE;
    RenderTarget.PushLayer(LayerPar, ID2D1Layer(FSaveData[FLastState].Data));
    SAFE_RELEASE(Geom);
  end;
end;

procedure TvxCanvasD2D.ExcludeClipRect(const ARect: TvxRect);
var
  i: integer;
  Geoms: array[0..3] of ID2D1Geometry;
  R: TvxRect;
  RR: array[0..3] of TvxRect;
  GeomGroup: ID2D1GeometryGroup;
  LayerPar: TD2D1_LayerParameters;
begin
  if FLastState < 0 then
    Exit;
  R := ARect;
  RR[0] := vgRect(0, 0, R.Left, FHeight);
  RR[1] := vgRect(R.Right, 0, FWidth, FHeight);
  RR[2] := vgRect(R.Left, 0, R.Right, R.Top);
  RR[3] := vgRect(R.Left, R.Bottom, R.Right, FHeight);
  for i := 0 to High(RR) do
  begin
    Factory.CreateRectangleGeometry(D2Rect(RR[i]), ID2D1RectangleGeometry(Geoms[i]));
  end;
  Factory.CreateGeometryGroup(D2D1_FILL_MODE_WINDING, @Geoms[0], Length(Geoms), GeomGroup);
  for i := 0 to High(RR) do
  begin
    SAFE_RELEASE(Geoms[i]);
  end;
  if Assigned(GeomGroup) then
  begin
    RenderTarget.CreateLayer(nil, ID2D1Layer(FSaveData[FLastState].Data));
    LayerPar.ContentBounds := D2Rect(vgRect(0, 0, FWidth, FHeight));
    LayerPar.GeometricMask := GeomGroup;
    LayerPar.MaskAntialiasMode := D2D1_ANTIALIAS_MODE_ALIASED;
    LayerPar.MaskTransform := D2Matrix(IdentityMatrix);
    LayerPar.Opacity := 1;
    LayerPar.OpacityBrush := nil;
    LayerPar.LayerOptions := D2D1_LAYER_OPTIONS_NONE;
    RenderTarget.PushLayer(LayerPar, ID2D1Layer(FSaveData[FLastState].Data));
    SAFE_RELEASE(GeomGroup);
  end;
end;

procedure TvxCanvasD2D.ResetClipRect;
begin
end;

procedure TvxCanvasD2D.ApplyFill(ARect: TvxRect; const AOpacity: single);
var
  C: TvxColor;
  i: integer;
  count: integer;
  B: TvxBitmap;
  M: TvxMatrix;
  grad: array[0..100] of TD2D1_GradientStop;
  gradcol: ID2D1GradientStopCollection;
  gradbrushprop: TD2D1_LinearGradientBrushProperties;
  rgradbrushprop: TD2D1_RadialGradientBrushProperties;
  bitmapbrushprop: TD2D1_BitmapBrushProperties;
  brushprop: TD2D1_BrushProperties;
  d2dbmp: ID2D1Bitmap;
begin
  SAFE_RELEASE(Brush);
  if (FFill.Style = vgBrushResource) and (FFill.Resource <> nil) and (FFill.Resource.Brush <> nil) then
    FFill.Assign(FFill.Resource.Brush);

  with FFill do
  begin
    case Style of
      vgBrushSolid:
        begin
          RenderTarget.CreateSolidColorBrush(D2Color(FFill.SolidColor, AOpacity), nil, ID2D1SolidColorBrush(Brush));
        end;
      vgBrushGradient:
        begin
          if Gradient.Points.Count > 1 then
          begin
            count := 0;
            if Gradient.Points[0].Offset > 0 then
            begin
              grad[count].Color := D2Color(vgOpacity(Gradient.Points[0].IntColor, AOpacity), 1);
              grad[count].Position := 0;
              count := count + 1;
            end;
            for i := 0 to Gradient.Points.Count - 1 do
            begin
              grad[i + count].Color := D2Color(vgOpacity(Gradient.Points[i].IntColor, AOpacity), 1);
              grad[i + count].Position := Gradient.Points[i].Offset;
            end;
            if Gradient.Points[Gradient.Points.Count - 1].Offset < 1 then
            begin
              count := count + 1;
              grad[Gradient.Points.Count + count - 1].Color := D2Color(vgOpacity(Gradient.Points[Gradient.Points.Count - 1].IntColor, AOpacity), 1);
              grad[Gradient.Points.Count + count - 1].Position := 1;
            end;

            if Gradient.Style = vgLinearGradient then
            begin
              { Linear }
              RenderTarget.CreateGradientStopCollection(@grad[0], Gradient.Points.Count + count, D2D1_GAMMA_2_2, D2D1_EXTEND_MODE_CLAMP, gradcol);
              gradbrushprop.StartPoint := D2Point(ARect.Left + Gradient.StartPosition.X * ARect.Right, ARect.Top + Gradient.StartPosition.Y * ARect.Bottom);
              gradbrushprop.EndPoint := D2Point(ARect.Left + Gradient.StopPosition.X * ARect.Right, ARect.Top + Gradient.StopPosition.Y * ARect.Bottom);
              RenderTarget.CreateLinearGradientBrush(
                gradbrushprop,
                nil,
                gradcol,
                ID2D1LinearGradientBrush(Brush)
                );
              gradcol := nil;
            end
            else
            begin
              { Radial }
              for i := 0 to Gradient.Points.Count + count - 1 do
                grad[i].Position := 1 - grad[i].Position;
              RenderTarget.CreateGradientStopCollection(@grad[0], Gradient.Points.Count + count, D2D1_GAMMA_2_2, D2D1_EXTEND_MODE_CLAMP, gradcol);
              rgradbrushprop.GradientOriginOffset := TD2D1_Point2F(vgPoint(0, 0));
              rgradbrushprop.Center := TD2D1_Point2F(vgPoint(Gradient.RadialTransform.RotateCenter.X * vgRectWidth(ARect),
                Gradient.RadialTransform.RotateCenter.Y * vgRectHeight(ARect)));
              rgradbrushprop.RadiusX := vgRectWidth(ARect) / 2;
              rgradbrushprop.RadiusY := vgRectHeight(ARect) / 2;
              RenderTarget.CreateRadialGradientBrush(
                rgradbrushprop,
                nil,
                gradcol,
                ID2D1RadialGradientBrush(Brush)
                );
              gradcol := nil;
            end;
          end
          else
            RenderTarget.CreateSolidColorBrush(D2Color(0, 0), nil, ID2D1SolidColorBrush(Brush));
        end;
      vgBrushResource:
        begin
        end;
      vgBrushVisual:
        begin
        end;
      vgBrushBitmap:
        begin
          B := Bitmap.Bitmap;
          if (B <> nil) and (B.ResourceBitmap <> nil) then
            B := B.ResourceBitmap;
          if (B <> nil) and (B.Width > 0) and (B.Height > 0) then
          begin
            bitmapbrushprop.InterpolationMode := D2D1_BITMAP_INTERPOLATION_MODE_LINEAR;
            brushprop.Opacity := AOpacity;
            M := IdentityMatrix;
            case Bitmap.WrapMode of
              vgWrapTile:
                begin
                  bitmapbrushprop.ExtendModeX := D2D1_EXTEND_MODE_WRAP;
                  bitmapbrushprop.ExtendModeY := D2D1_EXTEND_MODE_WRAP;
                end;
              vgWrapTileOriginal:
                begin
                  bitmapbrushprop.ExtendModeX := D2D1_EXTEND_MODE_CLAMP;
                  bitmapbrushprop.ExtendModeY := D2D1_EXTEND_MODE_CLAMP;
                end;
              vgWrapTileStretch:
                begin
                  bitmapbrushprop.ExtendModeX := D2D1_EXTEND_MODE_WRAP;
                  bitmapbrushprop.ExtendModeY := D2D1_EXTEND_MODE_WRAP;
                  M.m11 := (vgRectWidth(ARect) + (StrokeThickness / 2)) / B.Width;
                  M.m22 := (vgRectHeight(ARect) + (StrokeThickness / 2)) / B.Height;
                end;
            end;
            brushprop.Transform := D2Matrix(M);
            Res := RenderTarget.CreateBitmap(D2Size(B.Width, B.Height), B.StartLine,
              B.Width * 4, BitmapProp(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED), d2dbmp);
            RenderTarget.CreateBitmapBrush(
              d2dbmp,
              @bitmapbrushprop,
              @brushprop,
              ID2D1BitmapBrush(Brush));
          end
          else
            RenderTarget.CreateSolidColorBrush(D2Color(0, 0), nil, ID2D1SolidColorBrush(Brush));
        end;
    else
      RenderTarget.CreateSolidColorBrush(D2Color(0, 0), nil, ID2D1SolidColorBrush(Brush));
    end;
  end;
end;

procedure TvxCanvasD2D.ApplyStroke(ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  StyleProp: TD2D1_StrokeStyleProperties;
begin
  SAFE_RELEASE(StrokeBrush);
  SAFE_RELEASE(StrokeStyle);
  if (FStroke.Style = vgBrushResource) and (FStroke.Resource <> nil) and (FStroke.Resource.Brush <> nil) then
    FStroke.Assign(FStroke.Resource.Brush);

  with FStroke do
  begin
    case Style of
      vgBrushSolid, vgBrushGradient, vgBrushBitmap:
        begin
          RenderTarget.CreateSolidColorBrush(D2Color(FStroke.SolidColor, AOpacity), nil, ID2D1SolidColorBrush(StrokeBrush));
        end;
    else
      RenderTarget.CreateSolidColorBrush(D2Color(0, 0), nil, ID2D1SolidColorBrush(StrokeBrush));
    end;
  end;

  case StrokeCap of
    vgCapFlat: StyleProp.DashCap := D2D1_CAP_STYLE_SQUARE;
    vgCapRound: StyleProp.DashCap := D2D1_CAP_STYLE_ROUND;
  end;
  StyleProp.StartCap := StyleProp.DashCap;
  StyleProp.EndCap := StyleProp.DashCap;
  case StrokeJoin of
    vgJoinMiter: StyleProp.LineJoin := D2D1_LINE_JOIN_MITER;
    vgJoinRound: StyleProp.LineJoin := D2D1_LINE_JOIN_ROUND;
    vgJoinBevel: StyleProp.LineJoin := D2D1_LINE_JOIN_BEVEL;
  end;
  StyleProp.MiterLimit := 10;
  StyleProp.DashOffset := FDashOffset;
  StyleProp.DashStyle := TD2D1_DashStyle(StrokeDash);

  if StrokeDash = vgDashCustom then
    Factory.CreateStrokeStyle(StyleProp, @FDash[0], Length(FDash), StrokeStyle)
  else
    Factory.CreateStrokeStyle(StyleProp, nil, 0, StrokeStyle)
end;

procedure TvxCanvasD2D.FontChanged(Sender: TObject);
begin
end;

procedure TvxCanvasD2D.DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single);
begin
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(vgRect(APt1.X, APt1.Y, APt2.X, APt2.Y), AOpacity);
    RenderTarget.DrawLine(D2Point(APt1.X, APt1.Y), D2Point(APt2.X, APt2.Y), StrokeBrush, StrokeThickness, StrokeStyle);
  end;
end;

procedure TvxCanvasD2D.IntFillRect(R: TvxRect; Opacity: single);
begin
  if FFill.Style <> vgBrushNone then
  begin
    if FFill.Style = vgBrushVisual then
    begin
    end
    else
    begin
      ApplyFill(R, Opacity);
      RenderTarget.FillRectangle(D2Rect(R), Brush);
    end;
  end;
end;

procedure TvxCanvasD2D.IntFillPath(P: ID2D1Geometry; R: TvxRect;
  Opacity: single);
begin
  if FFill.Style <> vgBrushNone then
  begin
    if FFill.Style = vgBrushVisual then
    begin
    end
    else
    begin
      ApplyFill(R, Opacity);
      RenderTarget.FillGeometry(P, Brush);
    end;
  end;
end;

procedure TvxCanvasD2D.DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners;
  const AOpacity: single; const ACornerType: TvxCornerType = vgCornerRound);
var
  Geometry: ID2D1PathGeometry;
  Path: ID2D1GeometrySink;
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if FStroke.Style <> vgBrushNone then
  begin
    R := ARect;
    ApplyStroke(R, AOpacity);
    if (xRadius < Epsilon) and (yRadius < Epsilon) then
    begin
      RenderTarget.DrawRectangle(D2Rect(ARect), StrokeBrush, StrokeThickness, StrokeStyle);
    end
    else
    begin
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
      x2 := x1 * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
      y2 := y1 * CurveKappaInv;
      Factory.CreatePathGeometry(Geometry);
      Geometry.Open(Path);
      Path.BeginFigure(D2Point(R.Left, R.Top + y1), D2D1_FIGURE_BEGIN_FILLED);
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Left + x1, R.Top));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Left + x2, R.Top + y1));
              Path.AddLine(D2Point(R.Left + x1, R.Top + y2));
              Path.AddLine(D2Point(R.Left + x1, R.Top));
            end;
        else
          Path.AddBezier(D2Bezier(R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Left, R.Top));
        Path.AddLine(D2Point(R.Left + x1, R.Top));
      end;
      Path.AddLine(D2Point(R.Right - x1, R.Top));
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Right, R.Top + y1));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Right - x1, R.Top + y2));
              Path.AddLine(D2Point(R.Right - x2, R.Top + y1));
              Path.AddLine(D2Point(R.Right, R.Top + y1));
            end;
        else
          Path.AddBezier(D2Bezier(R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Right, R.Top));
        Path.AddLine(D2Point(R.Right, R.Top + y1));
      end;
      Path.AddLine(D2Point(R.Right, R.Bottom - y1));
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Right - x1, R.Bottom));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Right - x2, R.Bottom - y1));
              Path.AddLine(D2Point(R.Right - x1, R.Bottom - y2));
              Path.AddLine(D2Point(R.Right - x1, R.Bottom));
            end;
        else
          Path.AddBezier(D2Bezier(R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Right, R.Bottom));
        Path.AddLine(D2Point(R.Right - x1, R.Bottom));
      end;
      Path.AddLine(D2Point(R.Left + x1, R.Bottom));
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Left, R.Bottom - y1));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Left + x1, R.Bottom - y2));
              Path.AddLine(D2Point(R.Left + x2, R.Bottom - y1));
              Path.AddLine(D2Point(R.Left, R.Bottom - y1));
            end;
        else
          Path.AddBezier(D2Bezier(R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Left, R.Bottom));
        Path.AddLine(D2Point(R.Left, R.Bottom - y1));
      end;
      Path.EndFigure(D2D1_FIGURE_END_CLOSED);
      Path.Close;
      SAFE_RELEASE(Path);
      RenderTarget.DrawGeometry(Geometry, StrokeBrush, StrokeThickness, StrokeStyle);
      SAFE_RELEASE(Geometry);
    end;
  end;
end;

procedure TvxCanvasD2D.FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  Geometry: ID2D1PathGeometry;
  Path: ID2D1GeometrySink;
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if FFill.Style <> vgBrushNone then
  begin
    if ((xRadius = 0) and (yRadius = 0)) or (ACorners = []) then
    begin
      IntFillRect(ARect, AOpacity);
    end
    else
    begin
      R := ARect;
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
      x2 := x1 * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
      y2 := y1 * CurveKappaInv;
      Factory.CreatePathGeometry(Geometry);
      Geometry.Open(Path);
      Path.BeginFigure(D2Point(R.Left, R.Top + y1), D2D1_FIGURE_BEGIN_FILLED);
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Left + x1, R.Top));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Left + x2, R.Top + y1));
              Path.AddLine(D2Point(R.Left + x1, R.Top + y2));
              Path.AddLine(D2Point(R.Left + x1, R.Top));
            end;
        else
          Path.AddBezier(D2Bezier(R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Left, R.Top));
        Path.AddLine(D2Point(R.Left + x1, R.Top));
      end;
      Path.AddLine(D2Point(R.Right - x1, R.Top));
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Right, R.Top + y1));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Right - x1, R.Top + y2));
              Path.AddLine(D2Point(R.Right - x2, R.Top + y1));
              Path.AddLine(D2Point(R.Right, R.Top + y1));
            end;
        else
          Path.AddBezier(D2Bezier(R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Right, R.Top));
        Path.AddLine(D2Point(R.Right, R.Top + y1));
      end;
      Path.AddLine(D2Point(R.Right, R.Bottom - y1));
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Right - x1, R.Bottom));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Right - x2, R.Bottom - y1));
              Path.AddLine(D2Point(R.Right - x1, R.Bottom - y2));
              Path.AddLine(D2Point(R.Right - x1, R.Bottom));
            end;
        else
          Path.AddBezier(D2Bezier(R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Right, R.Bottom));
        Path.AddLine(D2Point(R.Right - x1, R.Bottom));
      end;
      Path.AddLine(D2Point(R.Left + x1, R.Bottom));
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(D2Point(R.Left, R.Bottom - y1));
          vgCornerInnerRound: Path.AddBezier(D2Bezier(R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1));
          vgCornerInnerLine:
            begin
              Path.AddLine(D2Point(R.Left + x1, R.Bottom - y2));
              Path.AddLine(D2Point(R.Left + x2, R.Bottom - y1));
              Path.AddLine(D2Point(R.Left, R.Bottom - y1));
            end;
        else
          Path.AddBezier(D2Bezier(R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1))
        end;
      end
      else
      begin
        Path.AddLine(D2Point(R.Left, R.Bottom));
        Path.AddLine(D2Point(R.Left, R.Bottom - y1));
      end;
      Path.EndFigure(D2D1_FIGURE_END_CLOSED);
      Path.Close;
      SAFE_RELEASE(Path);
      IntFillPath(Geometry, ARect, AOpacity);
      SAFE_RELEASE(Geometry);
    end;
  end;
end;

procedure TvxCanvasD2D.DrawEllipse(const ARect: TvxRect; const AOpacity: single);
var
  R: TvxRect;
begin
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(ARect, AOpacity);
    RenderTarget.DrawEllipse(D2Ellipse(ARect), StrokeBrush, StrokeThickness, StrokeStyle);
  end;
end;

procedure TvxCanvasD2D.FillEllipse(const ARect: TvxRect; const AOpacity: single);
var
  Geometry: ID2D1EllipseGeometry;
begin
  if FFill.Style <> vgBrushNone then
  begin
    if FFill.Style <> vgBrushVisual then
    begin
      ApplyFill(ARect, AOpacity);
      RenderTarget.FillEllipse(D2Ellipse(ARect), Brush);
    end
    else
    begin
      Factory.CreateEllipseGeometry(D2Ellipse(ARect), Geometry);
      IntFillPath(Geometry, ARect, AOpacity);
      SAFE_RELEASE(Geometry);
    end;
  end;
end;

procedure TvxCanvasD2D.FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter);
var
  TextRange: TDWrite_TextRange;
  TextLayout: IDWriteTextLayout;
  TextFormat: IDWriteTextFormat;
  R: TvxRect;
  S: TvxFontStyle;
  WS: WideString;
begin
  if (FFill.Style <> vgBrushNone) and (AText <> '') then
  begin
    WS := FFont.Family;
    DWriteFactory.CreateTextFormat(PWideChar(WS), nil, D2FontWeight(FFont.Style),
      D2FontStyle(FFont.Style), DWRITE_FONT_STRETCH_NORMAL, FFont.Size, 'en-us', TextFormat);
    DWriteFactory.CreateTextLayout(PWideChar(AText), Length(AText), TextFormat, vgRectWidth(ARect), vgRectHeight(ARect),
      TextLayout);

    TextRange.startPosition := 0;
    TextRange.length := Length(AText);

    if not WordWrap then
      TextLayout.SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP)
    else
      TextLayout.SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);

    if FFont.Style = vgFontStrikeout then
      TextLayout.SetStrikethrough(True, TextRange);

    if FFont.Style = vgFontUnderline then
      TextLayout.SetUnderline(True, TextRange);

    // formating
    case AVTextAlign of
      vgTextAlignCenter:
        begin
          TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        end;
      vgTextAlignNear:
        begin
          TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
        end;
      vgTextAlignFar:
        begin
          TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_FAR);
        end;
    end;
    case ATextAlign of
      vgTextAlignCenter:
        begin
          TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        end;
      vgTextAlignNear:
        begin
          TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
        end;
      vgTextAlignFar:
        begin
          TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING);
        end;
    end;
    // calc correct rect
    ApplyFill(ARect, AOpacity);
    // draw
    RenderTarget.DrawTextLayout(D2Point(ARect.Left, ARect.Top), TextLayout, Brush, D2D1_DRAW_TEXT_OPTIONS_CLIP);
    SAFE_RELEASE(TextFormat);
    SAFE_RELEASE(TextLayout);
  end;
end;

procedure TvxCanvasD2D.MeasureText(var ARect: TvxRect;
  AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const ATextAlign, AVTextAlign: TvxTextAlign);
var
  TextRange: TDWrite_TextRange;
  TextLayout: IDWriteTextLayout;
  TextMetrics: TDWrite_TextMetrics;
  TextFormat: IDWriteTextFormat;
  R: TvxRect;
  S: TvxFontStyle;
  WS: WideString;
begin
  if not WordWrap then
    ARect.Right := ARect.Left;
  if Length(AText) = 0 then
    Exit;

  WS := FFont.Family;
  DWriteFactory.CreateTextFormat(PWideChar(WS), nil, D2FontWeight(FFont.Style),
    D2FontStyle(FFont.Style), DWRITE_FONT_STRETCH_NORMAL, FFont.Size, 'en-us', TextFormat);
  DWriteFactory.CreateTextLayout(PWideChar(AText), Length(AText), TextFormat, vgRectWidth(ARect), vgRectHeight(ARect),
    TextLayout);

  TextRange.startPosition := 0;
  TextRange.length := Length(AText);

  if not WordWrap then
    TextLayout.SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP)
  else
    TextLayout.SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);

  if FFont.Style = vgFontStrikeout then
    TextLayout.SetStrikethrough(True, TextRange);

  if FFont.Style = vgFontUnderline then
    TextLayout.SetUnderline(True, TextRange);

  // formating
  case AVTextAlign of
    vgTextAlignCenter:
      begin
        TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
      end;
    vgTextAlignNear:
      begin
        TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
      end;
    vgTextAlignFar:
      begin
        TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_FAR);
      end;
  end;
  case ATextAlign of
    vgTextAlignCenter:
      begin
        TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
      end;
    vgTextAlignNear:
      begin
        TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
      end;
    vgTextAlignFar:
      begin
        TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING);
      end;
  end;
  // measure
  TextLayout.GetMetrics(TextMetrics);
  ARect := vgRect(ARect.Left + TextMetrics.Left, ARect.Top + TextMetrics.Top, ARect.Left + TextMetrics.Left + TextMetrics.widthIncludingTrailingWhitespace,
    ARect.Top + TextMetrics.Top + TextMetrics.height);

  SAFE_RELEASE(TextFormat);
  SAFE_RELEASE(TextLayout);
end;

{ Bitmaps }

procedure TvxCanvasD2D.DrawThumbnail(const ABitmap: TvxBitmap;
  const Width, Height: single);
var
  scale: single;
begin
  //  UpdateBitmap(ABitmap);
  if ABitmap.Handle = 0 then
    Exit;
  scale := Width / ABitmap.Width;
  if FBitmap <> nil then
  begin
    //    Fgraphics.ScaleTransform(scale, scale);
    //    RenderTarget.DrawBitmap(ID2D1Bitmap(ABitmap.Handle), @DR, AOpacity, IntMode, @SR);
  end;
end;

procedure TvxCanvasD2D.DrawBitmap(const ABitmap: TvxBitmap;
  const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false);
var
  SR, DR: TD2D1_RectF;
  IntMode: TD2D1_BitmapInterpolationMode;
  B: ID2D1Bitmap;
begin
  if HighSpeed then
    IntMode := D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR
  else
    IntMode := D2D1_BITMAP_INTERPOLATION_MODE_LINEAR;

  SR := D2Rect(SrcRect);
  DR := D2Rect(DstRect);

  Res := RenderTarget.CreateBitmap(D2Size(ABitmap.Width, ABitmap.Height), ABitmap.StartLine,
    ABitmap.Width * 4, BitmapProp(DXGI_FORMAT_B8G8R8A8_UNORM, D2D1_ALPHA_MODE_PREMULTIPLIED), B);
  RenderTarget.DrawBitmap(B, @DR, AOpacity, IntMode, @SR);
end;

{ Path }

procedure TvxCanvasD2D.DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
  Geometry: ID2D1PathGeometry;
  Path: ID2D1GeometrySink;
  Closed: boolean;
begin
  if FStroke.Style = vgBrushNone then
    Exit;
  if APath.IsEmpty then
    Exit;

  ApplyStroke(ARect, AOpacity);

  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);

  Factory.CreatePathGeometry(Geometry);
  Geometry.Open(Path);
  i := 0;
  Closed := false;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          if (i > 0) and (APath.PathData[i - 1].Kind <> vgPathPointClose) then
            Path.EndFigure(D2D1_FIGURE_END_OPEN);
          Path.BeginFigure(D2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH), D2D1_FIGURE_BEGIN_FILLED);
        end;
      vgPathPointLineTo:
        begin
          Path.AddLine(D2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH));
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          Path.AddBezier(D2Bezier(CP1.X,
            CP1.Y,
            CP2.X,
            CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH));
        end;
      vgPathPointClose:
        begin
          Path.EndFigure(D2D1_FIGURE_END_CLOSED);
          Closed := true;
        end;
    end;
    inc(i);
  end;

  if not Closed then
    Path.EndFigure(D2D1_FIGURE_END_OPEN);

  Res := Path.Close;
  SAFE_RELEASE(Path);
  RenderTarget.DrawGeometry(Geometry, StrokeBrush, StrokeThickness, StrokeStyle);
  SAFE_RELEASE(Geometry);
end;

procedure TvxCanvasD2D.FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
  Geometry: ID2D1PathGeometry;
  Path: ID2D1GeometrySink;
  Closed: boolean;
begin
  //exit;
  if FFill.Style = vgBrushNone then
    Exit;
  if APath.IsEmpty then
    Exit;

  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);

  Factory.CreatePathGeometry(Geometry);
  Geometry.Open(Path);
  i := 0;
  Closed := false;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          if (i > 0) and (APath.PathData[i - 1].Kind <> vgPathPointClose) then
            Path.EndFigure(D2D1_FIGURE_END_OPEN);
          Path.BeginFigure(D2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH), D2D1_FIGURE_BEGIN_FILLED);
        end;
      vgPathPointLineTo:
        begin
          Path.AddLine(D2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH));
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          Path.AddBezier(D2Bezier(CP1.X,
            CP1.Y,
            CP2.X,
            CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH));
        end;
      vgPathPointClose:
        begin
          Path.EndFigure(D2D1_FIGURE_END_CLOSED);
          Closed := true;
        end;
    end;
    inc(i);
  end;
  if not Closed then
    Path.EndFigure(D2D1_FIGURE_END_OPEN);

  Path.Close;
  SAFE_RELEASE(Path);
  IntFillPath(Geometry, ARect, AOpacity);
  SAFE_RELEASE(Geometry);
end;

function TvxCanvasD2D.PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean;
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
  Geometry: ID2D1PathGeometry;
  Path: ID2D1GeometrySink;
  Cont: LongBool;
  Closed: boolean;
begin
  Result := false;
  if not vgPtInRect(APoint, ARect) then
    Result := false
  else
  begin
    if APath.IsEmpty then
      Exit;
    B := APath.GetBounds;
    W := vgRectWidth(B);
    H := vgRectHeight(B);
    NewW := vgRectWidth(ARect);
    NewH := vgRectHeight(ARect);

    Factory.CreatePathGeometry(Geometry);
    Geometry.Open(Path);
    i := 0;
    Closed := false;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of
        vgPathPointMoveTo:
          begin
            Path.BeginFigure(D2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH), D2D1_FIGURE_BEGIN_FILLED);
          end;
        vgPathPointLineTo:
          begin
            Path.AddLine(D2Point(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH));
          end;
        vgPathPointCurveTo:
          begin
            CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            Path.AddBezier(D2Bezier(CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH));
          end;
        vgPathPointClose:
          begin
            Path.EndFigure(D2D1_FIGURE_END_CLOSED);
            Closed := true;
          end;
      end;
      inc(i);
    end;
    if not Closed then
      Path.EndFigure(D2D1_FIGURE_END_OPEN);

    Path.Close;
    SAFE_RELEASE(Path);
    Geometry.FillContainsPoint(D2Point(APoint.X, APoint.Y), nil, 1, Cont);
    SAFE_RELEASE(Geometry);

    Result := Cont;
  end;
end;

{ TvxTextRendering }

type
  TvxSink = class(TInterfacedPersistent, ID2D1SimplifiedGeometrySink)
  private
    Path: TvxPathData;
    procedure SetFillMode(FillMode: TD2D1_FillMode); stdcall;
    procedure SetSegmentFlags(VertexFlags: TD2D1_PathSegment); stdcall;
    procedure BeginFigure(StartPoint: TD2D1_Point2F; FigureBegin: TD2D1_FigureBegin); stdcall;
    procedure AddLines(Points: PTD2D1_Point2F; (* __in_ecount(pointsCount) *) PointsCount: LongWord); stdcall;
    procedure AddBeziers(Beziers: PTD2D1_BezierSegment; (* __in_ecount(beziersCount) *) BeziersCount: LongWord); stdcall;
    procedure EndFigure(FigureEnd: TD2D1_FigureEnd); stdcall;
    function Close: HResult; stdcall;
  public
  end;

  { TvxSink }

procedure TvxSink.BeginFigure(StartPoint: TD2D1_Point2F;
  FigureBegin: TD2D1_FigureBegin);
begin
  Path.MoveTo(TvxPoint(StartPoint));
end;

procedure TvxSink.AddBeziers(Beziers: PTD2D1_BezierSegment;
  BeziersCount: LongWord);
var
  i: integer;
begin
  for i := 0 to BeziersCount - 1 do
  begin
    Path.CurveTo(TvxPoint(Beziers.Point1), TvxPoint(Beziers.Point2), TvxPoint(Beziers.Point3));
    Inc(Beziers);
  end;
end;

procedure TvxSink.AddLines(Points: PTD2D1_Point2F; PointsCount: LongWord);
var
  i: integer;
begin
  for i := 0 to PointsCount - 1 do
  begin
    Path.LineTo(TvxPoint(Points^));
    Inc(Points);
  end;
end;

procedure TvxSink.EndFigure(FigureEnd: TD2D1_FigureEnd);
begin
  Path.ClosePath;
end;

function TvxSink.Close: HResult;
begin
  Result := S_OK;
end;

procedure TvxSink.SetFillMode(FillMode: TD2D1_FillMode);
begin
end;

procedure TvxSink.SetSegmentFlags(VertexFlags: TD2D1_PathSegment);
begin
end;

type

  TvxTextRendering = class(TInterfacedPersistent, IDWriteTextRenderer)
  private
    Canvas: TvxCanvasD2D;
    { TextRenderer }
    function IsPixelSnappingDisabled
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      out IsDisabled: LongBool (* __out *)
      ): HResult; stdcall;

    function GetCurrentTransform
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      out Transform: TDWrite_Matrix (* __out *)
      ): HResult; stdcall;

    function GetPixelsPerDip
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      out PixelsPerDip: Single (* __out *)
      ): HResult; stdcall;
    function DrawGlyphRun
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      BaselineOriginX: Single;
      BaselineOriginY: Single;
      MeasuringMode: TDWrite_MeasuringMode;
      const GlyphRun: TDWrite_GlyphRun; (* __in *)
      const GlyphRunDescription: TDWrite_GlyphRunDescription; (* __in *)
      ClientDrawingEffect: IUnknown (* __maybenull *)
      ): HResult; stdcall;

    function DrawUnderline
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      BaselineOriginX: Single;
      BaselineOriginY: Single;
      const Underline: TDWrite_Underline; (* __in *)
      ClientDrawingEffect: IUnknown (* __maybenull *)
      ): HResult; stdcall;

    function DrawStrikethrough
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      BaselineOriginX: Single;
      BaselineOriginY: Single;
      const Strikethrough: TDWrite_Strikethrough; (* __in *)
      ClientDrawingEffect: IUnknown (* __maybenull *)
      ): HResult; stdcall;

    function DrawInlineObject
      (
      ClientDrawingContext: Pointer; (* __maybenull *)
      OriginX: Single;
      OriginY: Single;
      InlineObject: IDWriteInlineObject;
      IsSideways: LongBool;
      IsRightToLeft: LongBool;
      ClientDrawingEffect: IUnknown (* __maybenull *)
      ): HResult; stdcall;
  public
  end;

function TvxTextRendering.DrawGlyphRun(ClientDrawingContext: Pointer;
  BaselineOriginX, BaselineOriginY: Single;
  MeasuringMode: TDWrite_MeasuringMode; const GlyphRun: TDWrite_GlyphRun;
  const GlyphRunDescription: TDWrite_GlyphRunDescription;
  ClientDrawingEffect: IInterface): HResult;
var
  pPathGeometry: ID2D1PathGeometry;
  pSink: ID2D1GeometrySink;
  pSimSink: TvxSink;
begin
  // Create the path geometry.
  Res := Factory.CreatePathGeometry(pPathGeometry);
  // Write to the path geometry using the geometry sink.
  if (SUCCEEDED(Res)) then
    Res := pPathGeometry.Open(pSink);
  // Get the glyph run outline geometries back from DirectWrite and place them within the geometry sink.
  if (SUCCEEDED(Res)) then
  begin
    Res := glyphRun.fontFace.GetGlyphRunOutline(
      glyphRun.fontEmSize,
      glyphRun.glyphIndices,
      glyphRun.glyphAdvances,
      glyphRun.glyphOffsets,
      glyphRun.glyphCount,
      glyphRun.isSideways,
      false {glyphRun.bidiLevel},
      pSink
      );
  end;
  // Close the geometry sink
  if (SUCCEEDED(Res)) then
    Res := pSink.Close();
  // Simplify
  pSimSink := TvxSink.Create;
  pSimSink.Path := TvxPathData(ClientDrawingContext);
  Res := pPathGeometry.Simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES, nil, 0, pSimSink);
  pSimSink.Close;
  pSimSink.Path.Offset(BaselineOriginX, BaselineOriginY);
  pSimSink.Free;
  // Free
  SAFE_RELEASE(pSink);
  SAFE_RELEASE(pPathGeometry);
end;

function TvxTextRendering.DrawInlineObject(ClientDrawingContext: Pointer;
  OriginX, OriginY: Single; InlineObject: IDWriteInlineObject; IsSideways,
  IsRightToLeft: LongBool; ClientDrawingEffect: IInterface): HResult;
begin
  Result := S_OK;
end;

function TvxTextRendering.DrawStrikethrough(ClientDrawingContext: Pointer;
  BaselineOriginX, BaselineOriginY: Single;
  const Strikethrough: TDWrite_Strikethrough;
  ClientDrawingEffect: IInterface): HResult;
begin
  Result := S_OK;
end;

function TvxTextRendering.DrawUnderline(ClientDrawingContext: Pointer;
  BaselineOriginX, BaselineOriginY: Single;
  const Underline: TDWrite_Underline;
  ClientDrawingEffect: IInterface): HResult;
begin
  Result := S_OK;
end;

function TvxTextRendering.GetCurrentTransform(
  ClientDrawingContext: Pointer; out Transform: TDWrite_Matrix): HResult;
begin
  Transform := TDWrite_Matrix(D2Matrix(IdentityMatrix));
  Result := S_OK;
end;

function TvxTextRendering.GetPixelsPerDip(ClientDrawingContext: Pointer;
  out PixelsPerDip: Single): HResult;
begin
  PixelsPerDip := 1;
  Result := S_OK;
end;

function TvxTextRendering.IsPixelSnappingDisabled(
  ClientDrawingContext: Pointer; out IsDisabled: LongBool): HResult;
begin
  IsDisabled := true;
  Result := S_OK;
end;

function TvxCanvasD2D.TextToPath(Path: TvxPathData; const ARect: TvxRect;
  const AText: WideString; const WordWrap: boolean; const ATextAlign,
  AVTextAlign: TvxTextAlign): boolean;
var
  TextRange: TDWrite_TextRange;
  TextLayout: IDWriteTextLayout;
  TextFormat: IDWriteTextFormat;
  R: TvxRect;
  S: TvxFontStyle;
  WS: WideString;
  MyRenderer: TvxTextRendering;
begin
  if (AText <> '') then
  begin
    Path.Clear;

    WS := FFont.Family;
    DWriteFactory.CreateTextFormat(PWideChar(WS), nil, D2FontWeight(FFont.Style),
      D2FontStyle(FFont.Style), DWRITE_FONT_STRETCH_NORMAL, FFont.Size, 'en-us', TextFormat);
    DWriteFactory.CreateTextLayout(PWideChar(AText), Length(AText), TextFormat, vgRectWidth(ARect), vgRectHeight(ARect),
      TextLayout);

    TextRange.startPosition := 0;
    TextRange.length := Length(AText);

    if not WordWrap then
      TextLayout.SetWordWrapping(DWRITE_WORD_WRAPPING_NO_WRAP)
    else
      TextLayout.SetWordWrapping(DWRITE_WORD_WRAPPING_WRAP);

    if FFont.Style = vgFontStrikeout then
      TextLayout.SetStrikethrough(True, TextRange);

    if FFont.Style = vgFontUnderline then
      TextLayout.SetUnderline(True, TextRange);

    // formating
    case AVTextAlign of
      vgTextAlignCenter:
        begin
          TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_CENTER);
        end;
      vgTextAlignNear:
        begin
          TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_NEAR);
        end;
      vgTextAlignFar:
        begin
          TextLayout.SetParagraphAlignment(DWRITE_PARAGRAPH_ALIGNMENT_FAR);
        end;
    end;
    case ATextAlign of
      vgTextAlignCenter:
        begin
          TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_CENTER);
        end;
      vgTextAlignNear:
        begin
          TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_LEADING);
        end;
      vgTextAlignFar:
        begin
          TextLayout.SetTextAlignment(DWRITE_TEXT_ALIGNMENT_TRAILING);
        end;
    end;
    // render
    MyRenderer := TvxTextRendering.Create;
    MyRenderer.Canvas := Self;
    TextLayout.Draw(Path, MyRenderer, 0, 0);
    MyRenderer.Free;
    // free
    SAFE_RELEASE(TextFormat);
    SAFE_RELEASE(TextLayout);
  end;
end;

{$ENDIF}

{$IFDEF WINDOWS}
{$I dcm_gdip.inc}

type

  TvxFilterGdiPlus = class(TvxFilter)
  private
  public
  published
    class function GetFileTypes: string; override;
    class function GetImageSize(const AFileName: string): TvxPoint; override;
    function LoadFromFile(const AFileName: string; const Rotate: single; var Bitmap: TvxBitmap): boolean; override;
    function SaveToFile(const AFileName: string; var Bitmap: TvxBitmap; const Params: string = ''): boolean; override;
    function LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single; const UseEmbedded: boolean;
      var Bitmap: TvxBitmap): boolean; override;
    function LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean; override;
    function SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
      const Params: string = ''): boolean; override;
  end;

  TvxCanvasGdiPlus = class(TvxCanvas)
  private
    FBufferHandle: cardinal;
    FBitmapInfo: TBitmapInfo;
    FGraphics: TGPGraphics;
    FGPPen: TGPPen;
    FGPPenBrush: TGPBrush;
    FGPBrush: TGPBrush;
    FGPFamily: TGPFontFamily;
    FFontCollection: TGPPrivateFontCollection;
    FFontScale: single;
  protected
    procedure UpdateBitmap(ABitmap: TvxBitmap);
    procedure DestroyBitmap(Sender: TObject);
    procedure ApplyFill(ARect: TvxRect; const AOpacity: single);
    procedure ApplyStroke(ARect: TvxRect; const AOpacity: single);
    procedure FontChanged(Sender: TObject); override;
    procedure IntFillPath(P: TGPGraphicsPath; R: TvxRect; Opacity: single);
    procedure IntFillRect(R: TvxRect; Opacity: single);
    class function GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray; override;
  public
    constructor Create(const AWidth, AHeight: integer); override;
    constructor CreateFromBitmap(const ABitmap: TvxBitmap); override;
    destructor Destroy; override;
    { buffer }
    procedure FreeBuffer; override;
    procedure ResizeBuffer(const AWidth, AHeight: integer); override;
    procedure FlushBuffer(const X, Y: integer; const DC: Cardinal); override;
    procedure FlushBufferRect(const X, Y: integer; const DC: Cardinal; const ARect: TvxRect); override;
    procedure Clear(const Color: cardinal); override;
    procedure ClearRect(const ARect: TvxRect; const AColor: TvxColor = 0); override;
    { matrix }
    procedure SetMatrix(const M: TvxMatrix); override;
    procedure MultyMatrix(const M: TvxMatrix); override;
    { cliping }
    function SaveCanvas: cardinal; override;
    procedure RestoreCanvas(const AState: cardinal); override;
    procedure SetClipRects(const ARects: array of TvxRect); override;
    procedure IntersectClipRect(const ARect: TvxRect); override;
    procedure ExcludeClipRect(const ARect: TvxRect); override;
    procedure ResetClipRect; override;
    { drawing }
    procedure DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single); override;
    procedure FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
      const ACornerType: TvxCornerType = vgCornerRound); override;
    procedure FillEllipse(const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawEllipse(const ARect: TvxRect; const AOpacity: single); override;
    function LoadFontFromStream(AStream: TStream): boolean; override;
    procedure FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
      const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    procedure MeasureText(var ARect: TvxRect; AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter); override;
    function TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
      const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean; override;
    function PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean; override;
    procedure FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single); override;
    procedure DrawBitmap(const ABitmap: TvxBitmap; const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false); override;
    procedure DrawThumbnail(const ABitmap: TvxBitmap; const Width, Height: single); override;
  published
  end;

procedure InitGDIP;
begin
  if GdipLibrary <> 0 then
    Exit;
  LoadGdiplus;
  // Initialize StartupInput structure
  StartupInput.DebugEventCallback := nil;
  StartupInput.SuppressBackgroundThread := false;
  StartupInput.SuppressExternalCodecs := false;
  StartupInput.GdiplusVersion := 1;
  // Initialize GDI+
  GdiplusStartup(gdiplusToken, @StartupInput, nil);
end;

procedure FreeGDIP;
begin
  if GdipLibrary = 0 then
    Exit;

  if assigned(GenericSansSerifFontFamily) then
    GenericSansSerifFontFamily.Free;
  if assigned(GenericSerifFontFamily) then
    GenericSerifFontFamily.Free;
  if assigned(GenericMonospaceFontFamily) then
    GenericMonospaceFontFamily.Free;

  if assigned(GenericTypographicStringFormatBuffer) then
    GenericTypographicStringFormatBuffer.free;
  if assigned(GenericDefaultStringFormatBuffer) then
    GenericDefaultStringFormatBuffer.Free;
  // Close GDI +
  GdiplusShutdown(gdiplusToken);
  FreeGdiplus;
end;

function GPRectFromRect(const R: TvxRect): TGPRectF;
begin
  Result.X := R.Left;
  Result.Y := R.Top;
  Result.Width := R.Right - R.Left;
  Result.Height := R.Bottom - R.Top;
end;

function GPRectFromRectTruncated(const R: TvxRect): TGPRectF;
begin
  Result.X := Trunc(R.Left);
  Result.Y := Trunc(R.Top);
  Result.Width := Trunc(R.Right) - Trunc(R.Left);
  Result.Height := Trunc(R.Bottom) - Trunc(R.Top);
end;

type

  TMyStreamAdapter = class(TInterfacedObject, IStream)
  public
    FStream: TStream;
    FOwnership: TStreamOwnership;
  public
    constructor Create(Stream: TStream; Ownership: TStreamOwnership = soReference);
    destructor Destroy; override;
    {$IFDEF FPC}
    function Read(pv: Pointer; cb: DWORD; pcbRead: PDWORD): HRESULT; virtual; stdcall;
    function Write(pv: Pointer; cb: DWORD; pcbWritten: PDWORD): HRESULT; virtual; stdcall;
    {$ELSE}
    function Read(pv: Pointer; cb: Longint; pcbRead: PLongint): HResult; virtual; stdcall;
    function Write(pv: Pointer; cb: Longint; pcbWritten: PLongint): HResult; virtual; stdcall;
    {$ENDIF}
    function Seek(dlibMove: Largeint; dwOrigin: Longint; out libNewPosition: Largeint): HResult; virtual; stdcall;
    function SetSize(libNewSize: Largeint): HResult; virtual; stdcall;
    function CopyTo(stm: IStream; cb: Largeint; out cbRead: Largeint; out cbWritten: Largeint): HResult; virtual; stdcall;
    function Commit(grfCommitFlags: Longint): HResult; virtual; stdcall;
    function Revert: HResult; virtual; stdcall;
    function LockRegion(libOffset: Largeint; cb: Largeint; dwLockType: Longint): HResult; virtual; stdcall;
    function UnlockRegion(libOffset: Largeint; cb: Largeint; dwLockType: Longint): HResult; virtual; stdcall;
    function Stat(out statstg: TStatStg; grfStatFlag: Longint): HResult; virtual; stdcall;
    function Clone(out stm: IStream): HResult; virtual; stdcall;
    property Stream: TStream read FStream;
    property StreamOwnership: TStreamOwnership read FOwnership write FOwnership;
  end;

  { TMyStreamAdapter }

constructor TMyStreamAdapter.Create(Stream: TStream;
  Ownership: TStreamOwnership);
begin
  inherited Create;
  FStream := Stream;
  FOwnership := Ownership;
end;

destructor TMyStreamAdapter.Destroy;
begin
  if FOwnership = soOwned then
  begin
    FStream.Free;
    FStream := nil;
  end;
  inherited Destroy;
end;

{$IFDEF FPC}

function TMyStreamAdapter.Read(pv: Pointer; cb: DWORD; pcbRead: PDWORD): HResult;
{$ELSE}

function TMyStreamAdapter.Read(pv: Pointer; cb: longint; pcbRead: PLongint): HResult;
{$ENDIF}
var
  NumRead: DWORD;
begin
  try
    if pv = nil then
    begin
      Result := STG_E_INVALIDPOINTER;
      Exit;
    end;
    NumRead := FStream.Read(pv^, cb);
    if pcbRead <> nil then
      pcbRead^ := NumRead;
    Result := S_OK;
  except
    Result := S_FALSE;
  end;
end;

function TMyStreamAdapter.LockRegion(libOffset: Largeint; cb: Largeint;
  dwLockType: Longint): HResult;
begin
  Result := STG_E_INVALIDFUNCTION;
end;

function TMyStreamAdapter.UnlockRegion(libOffset: Largeint; cb: Largeint;
  dwLockType: Longint): HResult;
begin
  Result := STG_E_INVALIDFUNCTION;
end;

function TMyStreamAdapter.Commit(grfCommitFlags: Longint): HResult;
begin
  Result := S_OK;
end;

{$IFDEF FPC}

function TMyStreamAdapter.Write(pv: Pointer; cb: DWORD; pcbWritten: PDWORD): HResult;
{$ELSE}

function TMyStreamAdapter.Write(pv: Pointer; cb: Longint; pcbWritten: PLongint): HResult;
{$ENDIF}
var
  NumWritten: DWORD;
begin
  try
    if pv = nil then
    begin
      Result := STG_E_INVALIDPOINTER;
      Exit;
    end;
    NumWritten := FStream.Write(pv^, cb);
    if pcbWritten <> nil then
      pcbWritten^ := NumWritten;
    Result := S_OK;
  except
    Result := STG_E_CANTSAVE;
  end;
end;

function TMyStreamAdapter.Seek(dlibMove: Largeint; dwOrigin: longint;
  out libNewPosition: Largeint): HResult;
var
  NewPos: LargeInt;
begin
  try
    if (dwOrigin < STREAM_SEEK_SET) or (dwOrigin > STREAM_SEEK_END) then
    begin
      Result := STG_E_INVALIDFUNCTION;
      Exit;
    end;
    NewPos := FStream.Seek(dlibMove, dwOrigin);
    if @libNewPosition <> nil then
      libNewPosition := NewPos;
    Result := S_OK;
  except
    Result := STG_E_INVALIDPOINTER;
  end;
end;

function TMyStreamAdapter.SetSize(libNewSize: Largeint): HResult;
begin
  try
    FStream.Size := libNewSize;
    if libNewSize <> FStream.Size then
      Result := E_FAIL
    else
      Result := S_OK;
  except
    Result := E_UNEXPECTED;
  end;
end;

function TMyStreamAdapter.CopyTo(stm: IStream; cb: Largeint; out cbRead: Largeint;
  out cbWritten: Largeint): HResult;
const
  MaxBufSize = 1024 * 1024; // 1mb
var
  Buffer: Pointer;
  BufSize, N, I, R: Integer;
  BytesRead, BytesWritten, W: LargeInt;
begin
  Result := S_OK;
  BytesRead := 0;
  BytesWritten := 0;
  try
    if cb > MaxBufSize then
      BufSize := MaxBufSize
    else
      BufSize := Integer(cb);
    GetMem(Buffer, BufSize);
    try
      while cb > 0 do
      begin
        if cb > MaxInt then
          I := MaxInt
        else
          I := cb;
        while I > 0 do
        begin
          if I > BufSize then
            N := BufSize
          else
            N := I;
          R := FStream.Read(Buffer^, N);
          if R = 0 then
            Exit; // The end of the stream was hit.
          Inc(BytesRead, R);
          W := 0;
          Result := stm.Write(Buffer, R, @W);
          Inc(BytesWritten, W);
          if (Result = S_OK) and (Integer(W) <> R) then
            Result := E_FAIL;
          if Result <> S_OK then
            Exit;
          Dec(I, R);
          Dec(cb, R);
        end;
      end;
    finally
      FreeMem(Buffer);
      if (@cbWritten <> nil) then
        cbWritten := BytesWritten;
      if (@cbRead <> nil) then
        cbRead := BytesRead;
    end;
  except
    Result := E_UNEXPECTED;
  end;
end;

function TMyStreamAdapter.Revert: HResult;
begin
  Result := STG_E_REVERTED;
end;

function DateTimeToFileTime(FileTime: TDateTime): TFileTime;
var
  LocalFileTime, Ft: TFileTime;
  SystemTime: TSystemTime;
begin
  Result.dwLowDateTime := 0;
  Result.dwHighDateTime := 0;
  DateTimeToSystemTime(FileTime, SystemTime);
  SystemTimeToFileTime(SystemTime, LocalFileTime);
  LocalFileTimeToFileTime(LocalFileTime, Ft);
  Result := Ft;
end;

function TMyStreamAdapter.Stat(out statstg: TStatStg; grfStatFlag: Longint): HResult;
begin
  Result := S_OK;
  try
    if (@statstg <> nil) then
    begin
      FillChar(statstg, SizeOf(statstg), 0);
      with statstg do
      begin
        dwType := STGTY_STREAM;
        cbSize := Stream.Size;
        mTime := DateTimeToFileTime(now);
        cTime := DateTimeToFileTime(now);
        aTime := DateTimeToFileTime(now);
        grfLocksSupported := LOCK_WRITE;
      end;
    end;
  except
    Result := E_UNEXPECTED;
  end;
end;

function TMyStreamAdapter.Clone(out stm: IStream): HResult;
begin
  Result := E_NOTIMPL;
end;

{ TvxFilterGdiPlus }

class function TvxFilterGdiPlus.GetFileTypes: string;
begin
  Result := '*.bmp;*.jpg;*.jpeg;*.png;*.tif;*.tiff;*.gif;*.ico'
end;

class function TvxFilterGdiPlus.GetImageSize(const AFileName: string): TvxPoint;
var
  img: TGPImage;
  S: TStream;
  adapter: TMyStreamAdapter;
begin
  S := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  adapter := TMyStreamAdapter.Create(S);
  try
    img := TGPImage.Create(adapter, true);
    Result := vgPoint(img.GetWidth, img.GetHeight);
    img.Free;
  finally
    S.Free;
  end;
end;

function TvxFilterGdiPlus.LoadFromFile(const AFileName: string;
  const Rotate: single; var Bitmap: TvxBitmap): boolean;
var
  img: TGPImage;
  bmp: TGPBitmap;
  graphics: TGPGraphics;
  M, M2: TvxMatrix;
  Pts: array[1..4] of TvxPoint;
  GM: TGPMatrix;
  R: TvxRect;
  BD: TBitmapData;
  S: TStream;
  adapter: TMyStreamAdapter;
begin
  Result := false;
  S := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  adapter := TMyStreamAdapter.Create(S);
  try
    img := TGPImage.Create(adapter, true);
    if img.GetWidth * img.GetHeight <> 0 then
    begin
      if (frac(Rotate) = 0) and (Trunc(rotate) mod 90 = 0) then
      begin
        // create bitmap and copy to TvxBitmap
        if (Trunc(rotate) mod 360 = 90) or (Trunc(rotate) mod 360 = 270) then
          Bitmap.SetSize(img.GetHeight, img.GetWidth)
        else
          Bitmap.SetSize(img.GetWidth, img.GetHeight);

        bmp := TGPBitmap.Create(adapter, true);
        if Trunc(rotate) mod 360 = 90 then
          bmp.RotateFlip(Rotate90FlipNone);
        if Trunc(rotate) mod 360 = 180 then
          bmp.RotateFlip(Rotate180FlipNone);
        if Trunc(rotate) mod 360 = 270 then
          bmp.RotateFlip(Rotate270FlipNone);
        if bmp.LockBits(MakeRect(0, 0, Bitmap.Width, Bitmap.Height), ImageLockModeRead, PixelFormat32bppPARGB, BD) = OK then
        begin
          vgMoveLongword(BD.Scan0, Bitmap.StartLine, Bitmap.Width * Bitmap.Height);
          bmp.UnlockBits(BD)
        end;
        bmp.Free;
      end
      else
      begin
        M := IdentityMatrix;
        M.m31 := -(img.GetWidth / 2);
        M.m32 := -(img.GetHeight / 2);
        M := vgMatrixMultiply(M, vgCreateRotationMatrix(vgDegToRad(Rotate)));
        { calc new size }
        Pts[1] := vgPointFromVector(vgVectorTransform(vgVector(0, 0), M));
        Pts[2] := vgPointFromVector(vgVectorTransform(vgVector(img.GetWidth, 0), M));
        Pts[3] := vgPointFromVector(vgVectorTransform(vgVector(img.GetWidth, img.GetHeight), M));
        Pts[4] := vgPointFromVector(vgVectorTransform(vgVector(0, img.GetHeight), M));
        R := vgNormalizeRect(Pts);
        { translate }
        M2 := IdentityMatrix;
        M2.m31 := vgRectWidth(R) / 2;
        M2.m32 := vgRectHeight(R) / 2;
        M := vgMatrixMultiply(M, M2);
        { rotate }
        Bitmap.SetSize(Trunc(vgRectWidth(R)), Trunc(vgRectHeight(R)));

        bmp := TGPBitmap.Create(Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(Bitmap.StartLine));
        graphics := TGPGraphics.Create(bmp);
        with M do
          GM := TGPMatrix.Create(m11, m12, m21, m22, m31, m32);
        graphics.SetTransform(GM);
        GM.Free;
        graphics.DrawImage(img, 0, 0, img.GetWidth, img.GetHeight);
        graphics.Free;
        bmp.Free;
      end;
      Result := true;
    end;
    img.Free;
  finally
    S.Free;
  end;
end;

function TvxFilterGdiPlus.LoadThumbnailFromFile(const AFileName: string;
  const AFitWidth, AFitHeight: single; const UseEmbedded: boolean; var Bitmap: TvxBitmap): boolean;
var
  R: TvxRect;
  thumb, img: TGPImage;
  bmp: TGPBitmap;
  graphics: TGPGraphics;
  bits: PvgColorArray;
  scale: single;
  S: TStream;
  adapter: TMyStreamAdapter;
begin
  Result := false;
  S := TFileStream.Create(AFileName, fmOpenRead or fmShareDenyNone);
  adapter := TMyStreamAdapter.Create(S);
  try
    img := TGPImage.Create(adapter, true);
    if img.GetWidth * img.GetHeight <> 0 then
    begin
      { calc thumb size }
      R := vgRect(0, 0, img.GetWidth, img.GetHeight);
      scale := vgFitRect(R, vgRect(0, 0, AFitWidth, AFitHeight));
      if scale = 0 then
        scale := 0.001;
      if scale < 1 then
        scale := 1;
      { create thumb }
      if UseEmbedded then
      begin
        thumb := img.GetThumbnailImage(trunc(img.GetWidth / scale), trunc(img.GetHeight / scale));
        if thumb <> nil then
        begin
          { create bitmap and copy to TvxBitmap }
          Bitmap.SetSize(thumb.GetWidth, thumb.GetHeight);
          bmp := TGPBitmap.Create(Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(bitmap.Scanline[0]));
          graphics := TGPGraphics.Create(bmp);
          graphics.DrawImage(thumb, 0, 0, Bitmap.Width, Bitmap.Height);
          graphics.Free;
          bmp.Free;
          thumb.Free;
        end;
      end
      else
      begin
        { create from original }
        Bitmap.SetSize(trunc(vgRectWidth(R)), trunc(vgRectHeight(R)));
        bmp := TGPBitmap.Create(Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(bitmap.Scanline[0]));
        bmp.SetResolution(img.GetHorizontalResolution / scale, img.GetVerticalResolution / scale);
        graphics := TGPGraphics.Create(bmp);
        graphics.SetInterpolationMode(QualityModeHigh);
        graphics.DrawImage(img, 0, 0);
        graphics.Free;
        bmp.Free;
      end;
      Result := true;
    end;
    img.Free;
  finally
    S.Free;
  end;
end;

function TvxFilterGdiPlus.LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean;
var
  img: TGPImage;
  bmp: TGPBitmap;
  graphics: TGPGraphics;
  adapter: TMyStreamAdapter;
begin
  Result := false;
  adapter := TMyStreamAdapter.Create(AStream);
  img := TGPImage.Create(adapter, true);
  if img.GetWidth * img.GetHeight <> 0 then
  begin
    { create bitmap and copy to TvxBitmap }
    Bitmap.SetSize(img.GetWidth, img.GetHeight);
    bmp := TGPBitmap.Create(Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(bitmap.Scanline[0]));
    graphics := TGPGraphics.Create(bmp);
    graphics.DrawImage(img, 0, 0, Bitmap.Width, Bitmap.Height);
    graphics.Free;
    bmp.Free;
    Result := true;
  end;
  img.Free;
end;

function TvxFilterGdiPlus.SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
  const Params: string = ''): boolean;
var
  bmp: TGPBitmap;
  adapter: TMyStreamAdapter;
  encoderClsid: TGUID;
  encoderParameters: TEncoderParameters;
  IntValue: integer;
  S, param, name, value: ansistring;
  encoder: ansistring;
  i: integer;
begin
  encoder := 'image/png';
  if LowerCase(Format) = 'jpeg' then
    encoder := 'image/jpeg';
  if LowerCase(Format) = 'jpg' then
    encoder := 'image/jpeg';
  if LowerCase(Format) = 'png' then
    encoder := 'image/png';
  if LowerCase(Format) = 'bmp' then
    encoder := 'image/bmp';
  if LowerCase(Format) = 'tif' then
    encoder := 'image/tiff';
  if LowerCase(Format) = 'tiff' then
    encoder := 'image/tiff';
  if LowerCase(Format) = 'gif' then
    encoder := 'image/gif';
  if GetEncoderClsid(encoder, encoderClsid) >= 0 then
  begin
    adapter := TMyStreamAdapter.Create(AStream);
    bmp := TGPBitmap.Create(Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(bitmap.Scanline[0]));
    { set params }
    if Params <> '' then
    begin
      S := Params;
      i := 0;
      while S <> '' do
      begin
        param := vgGetToken(S, ' ');
        name := vgGetToken(param, '=');
        value := vgGetToken(param, '');
        if CompareText(name, 'quality') = 0 then
        begin
          encoderParameters.Parameter[i].Guid := EncoderQuality;
          encoderParameters.Parameter[i].NumberOfValues := 1;
          encoderParameters.Parameter[i].Type_ := EncoderParameterValueTypeLong;
          IntValue := strToInt(value);
          encoderParameters.Parameter[i].Value := @IntValue;
        end;
        Inc(i);
      end;
      encoderParameters.Count := i;
      { save }
      bmp.Save(adapter, encoderClsid, @encoderParameters);
    end
    else
      bmp.Save(adapter, encoderClsid);
    bmp.Free;
  end;
end;

function TvxFilterGdiPlus.SaveToFile(const AFileName: string;
  var Bitmap: TvxBitmap; const Params: string = ''): boolean;
var
  S, param, name, value: ansistring;
  bmp: TGPBitmap;
  adapter: TMyStreamAdapter;
  encoderClsid: TGUID;
  encoderType: ansistring;
  i, IntValue: integer;
  encoderParameters: TEncoderParameters;
begin
  encoderType := '';
  if (LowerCase(ExtractFileExt(AFileName)) = '.jpg') or (LowerCase(ExtractFileExt(AFileName)) = '.jpeg') then
    encoderType := 'image/jpeg';
  if (LowerCase(ExtractFileExt(AFileName)) = '.bmp') then
    encoderType := 'image/bmp';
  if (LowerCase(ExtractFileExt(AFileName)) = '.png') then
    encoderType := 'image/png';
  if (LowerCase(ExtractFileExt(AFileName)) = '.tif') or (LowerCase(ExtractFileExt(AFileName)) = '.tiff') then
    encoderType := 'image/tiff';
  if (LowerCase(ExtractFileExt(AFileName)) = '.gif') then
    encoderType := 'image/gif';
  if GetEncoderClsid(encoderType, encoderClsid) >= 0 then
  begin
    bmp := TGPBitmap.Create(Bitmap.Width, Bitmap.Height, Bitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(bitmap.Scanline[0]));
    { set params }
    if Params <> '' then
    begin
      S := Params;
      i := 0;
      while S <> '' do
      begin
        param := vgGetToken(S, ' ');
        name := vgGetToken(param, '=');
        value := vgGetToken(param, '');
        if CompareText(name, 'quality') = 0 then
        begin
          encoderParameters.Parameter[i].Guid := EncoderQuality;
          encoderParameters.Parameter[i].NumberOfValues := 1;
          encoderParameters.Parameter[i].Type_ := EncoderParameterValueTypeLong;
          IntValue := strToInt(value);
          encoderParameters.Parameter[i].Value := @IntValue;
        end;
        Inc(i);
      end;
      encoderParameters.Count := i;
      { save }
      bmp.Save(AFileName, encoderClsid, @encoderParameters);
    end
    else
      bmp.Save(AFileName, encoderClsid);
    bmp.Free;
  end;
end;

{ TvxCanvasGdiPlus }

const
  imgColorMatrix: TColorMatrix =
  ((1, 0.0, 0.0, 0.0, 0.0),
    (0.0, 1.0, 0.0, 0.0, 0.0),
    (0.0, 0.0, 1.0, 0.0, 0.0),
    (0.0, 0.0, 0.0, 0.1, 0.0),
    (0.0, 0.0, 0.0, 0.0, 1.0));
var
  ColorArray: array[0..100] of TGPColor;
  OffsetArray: array[0..100] of single;

function vgStyleToGPStyle(S: TvxFontStyle): integer;
begin
  case S of
    vgFontRegular: Result := FontStyleRegular;
    vgFontBold: Result := FontStyleBold;
    vgFontItalic: Result := FontStyleItalic;
    vgFontBoldItalic: Result := FontStyleBoldItalic;
    vgFontUnderline: Result := FontStyleUnderline;
    vgFontStrikeout: Result := FontStyleStrikeout;
  end;
end;

constructor TvxCanvasGdiPlus.Create(const AWidth, AHeight: integer);
begin
  FBuffered := true;
  inherited;
  FGPPen := TGPPen.Create($FF000000);
  FGPPenBrush := TGPSolidBrush.Create($FF000000);
  FGPBrush := TGPSolidBrush.Create(InvalideCanvasState);
  FGPFamily := TGPFontFamily.Create('Tahoma');
  FFontScale := 1;
end;

constructor TvxCanvasGdiPlus.CreateFromBitmap(const ABitmap: TvxBitmap);
begin
  inherited;
  FBitmap := ABitmap;
  UpdateBitmap(FBitmap);
  FGraphics := TGPGraphics.Create(TGPBitmap(FBitmap.Handle));
  FGraphics.SetSmoothingMode(SmoothingModeHighQuality);
  FGraphics.SetPixelOffsetMode(PixelOffsetModeHalf);
  FGraphics.SetTextContrast(2);
  FGPPen := TGPPen.Create($FF000000);
  FGPPenBrush := TGPSolidBrush.Create($FF000000);
  FGPBrush := TGPSolidBrush.Create(InvalideCanvasState);
  FGPFamily := TGPFontFamily.Create('Tahoma');
  FFontScale := 96 / FGraphics.GetDpiX;
end;

destructor TvxCanvasGdiPlus.Destroy;
begin
  FreeAndNil(FFontCollection);
  FreeAndNil(FGraphics);
  FreeAndNil(FGPFamily);
  FreeAndNil(FGPBrush);
  FreeAndNil(FGPPenBrush);
  FreeAndNil(FGPPen);
  inherited;
end;

procedure TvxCanvasGdiPlus.FreeBuffer;
begin
  FreeAndNil(FGraphics);
  if FBuffered then
  begin
    if FBufferHandle = 0 then
      Exit;
    if FHandle <> 0 then
      DeleteDC(FHandle);
    FHandle := 0;
    if FBufferHandle <> 0 then
      DeleteObject(FBufferHandle);
    FBufferHandle := 0;
  end;
end;

procedure TvxCanvasGdiPlus.ResizeBuffer(const AWidth, AHeight: integer);
begin
  if (AWidth = FWidth) and (AHeight = FHeight) then
    Exit;
  FreeBuffer;
  FWidth := AWidth;
  FHeight := AHeight;
  if FWidth <= 0 then
    FWidth := 1;
  if FHeight <= 0 then
    FHeight := 1;
  FResized := true;
  if FBuffered then
  begin
    { Initialization }
    with FBitmapInfo.bmiHeader do
    begin
      biSize := SizeOf(TBitmapInfoHeader);
      biPlanes := 1;
      biBitCount := 32;
      biCompression := BI_RGB;
      biWidth := AWidth;
      if biWidth <= 0 then
        biWidth := 1;
      biHeight := -AHeight;
      if biHeight >= 0 then
        biHeight := -1;
    end;
    { Create new DIB }
    FBufferHandle := CreateDIBSection(0, FBitmapInfo, DIB_RGB_COLORS, Pointer(FBufferBits), 0, 0);
    if FBufferBits = nil then
      raise Exception.Create('Can''t allocate the DIB handle');

    FHandle := CreateCompatibleDC(0);
    if FHandle = 0 then
    begin
      DeleteObject(FBufferHandle);
      FHandle := 0;
      FBufferBits := nil;
      raise Exception.Create('Can''t create compatible DC');
    end;

    if SelectObject(FHandle, FBufferHandle) = 0 then
    begin
      DeleteDC(FHandle);
      DeleteObject(FBufferHandle);
      FHandle := 0;
      FBufferHandle := 0;
      FBufferBits := nil;
      raise Exception.Create('Can''t select an object into DC');
    end;
  end;
  FGraphics := TGPGraphics.Create(FHandle, 0, 0);
  FGraphics.SetSmoothingMode(QualityModeHigh);
  FGraphics.SetInterpolationMode(InterpolationModeHighQuality);
  FGraphics.SetPixelOffsetMode(PixelOffsetModeHalf);
  FGraphics.SetCompositingMode(CompositingModeSourceOver);
  FGraphics.SetTextContrast(2);
  FFontScale := 96 / FGraphics.GetDpiX;
end;

procedure TvxCanvasGdiPlus.FlushBuffer(const X, Y: integer; const DC: Cardinal);
begin
  if FBufferHandle = 0 then
    Exit;
  if DC = 0 then
    Exit;
  Windows.BitBlt(DC, X, Y, FWidth, FHeight, FHandle, 0, 0, SRCCOPY);
end;

procedure TvxCanvasGdiPlus.FlushBufferRect(const X, Y: integer; const DC: Cardinal;
  const ARect: TvxRect);
var
  R: TRect;
begin
  if FBufferHandle = 0 then
    Exit;
  if DC = 0 then
    Exit;
  R := Rect(trunc(ARect.left), trunc(ARect.top), trunc(ARect.right) + 1, trunc(ARect.bottom) + 1);
  with R do
  begin
    Windows.BitBlt(DC, X + R.left, Y + R.top, R.right - R.left, R.bottom - R.top, FHandle, R.left, R.top, SRCCOPY);
  end;
end;

procedure TvxCanvasGdiPlus.Clear(const Color: cardinal);
begin
  if not (FBuffered or (FBitmap <> nil)) then
    Exit;
  FGraphics.Clear(Color)
end;

procedure TvxCanvasGdiPlus.ClearRect(const ARect: TvxRect; const AColor: TvxColor);
var
  R: TRect;
begin
  if not (FBuffered or (FBitmap <> nil)) then
    Exit;
  R := Rect(Trunc(ARect.Left), Trunc(ARect.Top), Round(ARect.Right), Round(ARect.Bottom));
  if R.Left < 0 then
    R.Left := 0;
  if R.Top < 0 then
    R.Top := 0;
  if R.Top < 0 then
    R.Top := 0;
  if R.Right > FWidth then
    R.Right := FWidth;
  if R.Bottom > FHeight then
    R.Bottom := FHeight;
  if R.Bottom < R.Top then
    R.Bottom := R.Top;
  if R.Right < R.Left then
    R.Right := R.Left;
  if (R.Right < 0) or (R.Top < 0) or (R.Left > FWidth) or (R.Top > FHeight) then
    Exit;
  vgFillLongwordRect(FBufferBits, FWidth, FHeight, R.Left, R.Top, R.Right, R.Bottom, AColor);
end;

class function TvxCanvasGdiPlus.GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray;
begin
  if (y >= 0) and (y < Bitmap.Height) and (Bitmap.StartLine <> nil) then
    Result := @PvgColorArray(Bitmap.StartLine)[(y) * Bitmap.Width]
  else
    Result := nil;
end;

procedure TvxCanvasGdiPlus.SetMatrix(const M: TvxMatrix);
var
  GM: TGPMatrix;
begin
  FMatrix := M;
  with FMatrix do
  begin
    GM := TGPMatrix.Create(m11, m12, m21, m22, m31, m32);
    GM.Shear(m13, m23);
  end;
  FGraphics.SetTransform(GM);
  GM.Free;
end;

procedure TvxCanvasGdiPlus.MultyMatrix(const M: TvxMatrix);
var
  GM: TGPMatrix;
begin
  inherited;
  with M do
  begin
    GM := TGPMatrix.Create(m11, m12, m21, m22, m31, m32);
    GM.Shear(m13, m23);
  end;
  FGraphics.MultiplyTransform(GM);
  GM.Free;
end;

function TvxCanvasGdiPlus.SaveCanvas: cardinal;
var
  i: integer;
begin
  Result := InvalideCanvasState;
  if FGraphics = nil then
    Exit;

  // find exists
  if Length(FSaveData) > 0 then
    for i := 0 to High(FSaveData) do
      if FSaveData[i].Index = InvalideCanvasState then
      begin
        Result := i;
        Break;
      end;
  if Result = InvalideCanvasState then
  begin
    SetLength(FSaveData, Length(FSaveData) + 1);
    Result := High(FSaveData);
  end;
  FSaveData[Result].Index := FGraphics.Save;
  FSaveData[Result].Matrix := FMatrix;
  FSaveData[Result].Stroke := TvxBrush.Create(vgBrushSolid, InvalideCanvasState);
  FSaveData[Result].Stroke.Assign(Stroke);
  FSaveData[Result].Fill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FSaveData[Result].Fill.Assign(Fill);
  FSaveData[Result].StrokeThickness := FStrokeThickness;
  FSaveData[Result].StrokeCap := StrokeCap;
  FSaveData[Result].StrokeJoin := StrokeJoin;
  FSaveData[Result].StrokeDash := StrokeDash;
  if StrokeDash <> vgDashSolid then
  begin
    SetLength(FSaveData[Result].Dash, Length(FDash));
    Move(FDash[0], FSaveData[Result].Dash[0], SizeOf(FDash[0]) * Length(FDash));
  end;
  FSaveData[Result].DashOffset := FDashOffset;
  FSaveData[Result].Font := TvxFont.Create;
  FSaveData[Result].Font.Assign(Font);
end;

procedure TvxCanvasGdiPlus.RestoreCanvas(const AState: cardinal);
begin
  if FGraphics = nil then
    Exit;

  if (AState >= 0) and (AState < Length(FSaveData)) then
  begin
    FGraphics.Restore(FSaveData[AState].Index);

    FSaveData[AState].Index := InvalideCanvasState;

    FMatrix := FSaveData[AState].Matrix;
    Stroke.Assign(FSaveData[AState].Stroke);
    FSaveData[AState].Stroke.Free;
    Fill.Assign(FSaveData[AState].Fill);
    FSaveData[AState].Fill.Free;
    SetMatrix(FMatrix);
    FStrokeThickness := FSaveData[AState].StrokeThickness;
    FStrokeCap := FSaveData[AState].StrokeCap;
    FStrokeJoin := FSaveData[AState].StrokeJoin;
    FStrokeDash := FSaveData[AState].StrokeDash;
    if StrokeDash <> vgDashSolid then
    begin
      SetLength(FDash, Length(FSaveData[AState].Dash));
      Move(FSaveData[AState].Dash[0], FDash[0], SizeOf(FDash[0]) * Length(FDash));
    end;
    FDashOffset := FSaveData[AState].DashOffset;
    Font.Assign(FSaveData[AState].Font);
    FSaveData[AState].Font.Free;
  end
end;

procedure TvxCanvasGdiPlus.SetClipRects(const ARects: array of TvxRect);
var
  i: integer;
  R: TGPRegion;
  GM: TGPMatrix;
begin
  R := TGPRegion.Create;
  R.MakeEmpty;
  for i := 0 to High(ARects) do
  begin
    R.Union(GPRectFromRect(ARects[i]));
  end;
  FGraphics.SetClip(R);
  R.Free;
end;

procedure TvxCanvasGdiPlus.IntersectClipRect(const ARect: TvxRect);
begin
  FGraphics.IntersectClip(MakeRect(ARect.Left, ARect.Top, ARect.Right - ARect.Left, ARect.Bottom - ARect.Top));
end;

procedure TvxCanvasGdiPlus.ExcludeClipRect(const ARect: TvxRect);
begin
  FGraphics.ExcludeClip(GPRectFromRect(ARect));
end;

procedure TvxCanvasGdiPlus.ResetClipRect;
begin
  FGraphics.ResetClip;
end;

procedure TvxCanvasGdiPlus.ApplyFill(ARect: TvxRect; const AOpacity: single);
var
  C: TvxColor;
  i: integer;
  count: integer;
  B: TvxBitmap;
  P: TGPGraphicsPath;
  M: TGPMatrix;
  CM: TColorMatrix;
  ImageAttributes: TGPImageAttributes;
begin
  if FGPBrush <> nil then
    FreeAndNil(FGPBrush);
  if (FFill.Style = vgBrushResource) and (FFill.Resource <> nil) and (FFill.Resource.Brush <> nil) then
    FFill.Assign(FFill.Resource.Brush);

  with FFill do
  begin
    case Style of
      vgBrushSolid:
        begin
          FGPBrush := TGPSolidBrush.Create(vgOpacity(SolidColor, AOpacity));
        end;
      vgBrushGradient:
        begin
          if Gradient.Points.Count > 1 then
          begin
            count := 0;

            if Gradient.Points[0].Offset > 0 then
            begin
              ColorArray[count] := vgOpacity(Gradient.Points[0].IntColor, AOpacity);
              OffsetArray[count] := 0;
              count := count + 1;
            end;
            for i := 0 to Gradient.Points.Count - 1 do
            begin
              ColorArray[i + count] := vgOpacity(Gradient.Points[i].IntColor, AOpacity);
              OffsetArray[i + count] := Gradient.Points[i].Offset;
            end;
            if Gradient.Points[Gradient.Points.Count - 1].Offset < 1 then
            begin
              count := count + 1;
              ColorArray[Gradient.Points.Count + count - 1] := vgOpacity(Gradient.Points[Gradient.Points.Count - 1].IntColor, AOpacity);
              OffsetArray[Gradient.Points.Count + count - 1] := 1;
            end;

            if Gradient.Style = vgLinearGradient then
            begin
              { Linear }
              FGPBrush := TGPLinearGradientBrush.Create(MakePoint(ARect.Left + Gradient.StartPosition.X * ARect.Right, ARect.Top + Gradient.StartPosition.Y * ARect.Bottom),
                MakePoint(ARect.Left + Gradient.StopPosition.X * ARect.Right, ARect.Top + Gradient.StopPosition.Y * ARect.Bottom), SolidColor, SolidColor);
              TGPLinearGradientBrush(FGPBrush).SetWrapMode(WrapModeTileFlipX);
              TGPLinearGradientBrush(FGPBrush).SetInterpolationColors(PGPColor(@ColorArray), PSingle(@OffsetArray), Gradient.Points.Count + count);
            end
            else
            begin
              { Radial }
              P := TGPGraphicsPath.Create;
              P.AddEllipse(GPRectFromRect(ARect));
              FGPBrush := TGPPathGradientBrush.Create(P);
              P.Free;
              with Gradient.RadialTransform do
                M := TGPMatrix.Create(Matrix.m11, Matrix.m12, Matrix.m21, Matrix.m22, Matrix.m31, Matrix.m32);
              TGPPathGradientBrush(FGPBrush).SetTransform(M);
              M.Free;
              TGPPathGradientBrush(FGPBrush).SetWrapMode(WrapModeClamp);
              TGPPathGradientBrush(FGPBrush).SetInterpolationColors(PARGB(@ColorArray), PSingle(@OffsetArray), Gradient.Points.Count + count);
            end;
          end
          else
            FGPBrush := TGPSolidBrush.Create(vgOpacity(SolidColor, AOpacity));
        end;
      vgBrushResource:
        begin
          FGPBrush := TGPSolidBrush.Create($00000000);
        end;
      vgBrushVisual:
        begin
          FGPBrush := TGPSolidBrush.Create($00000000);
        end;
      vgBrushBitmap:
        begin
          B := Bitmap.Bitmap;
          if (B <> nil) and (B.ResourceBitmap <> nil) then
            B := B.ResourceBitmap;
          if (B <> nil) and (B.Width > 0) and (B.Height > 0) then
          begin
            UpdateBitmap(B);
            if (B.Handle <> 0) then
            begin
              CM := imgColorMatrix;
              CM[3][3] := AOpacity;
              if Aopacity <> 1 then
              begin
                ImageAttributes := TGPImageAttributes.Create;
                ImageAttributes.SetColorMatrix(CM, ColorMatrixFlagsDefault, ColorAdjustTypeBitmap);
              end
              else
                ImageAttributes := nil;
              if Bitmap.WrapMode <> vgWrapTileStretch then
              begin
                FGPBrush := TGPTextureBrush.Create(TGPBitmap(B.Handle),
                  GPRectFromRect(vgRect(0, 0, B.Width, B.Height)), ImageAttributes);
                TGPTextureBrush(FGPBrush).SetWrapMode(TWrapMode(Bitmap.WrapMode));
              end
              else
              begin
                FGPBrush := TGPTextureBrush.Create(TGPBitmap(B.Handle),
                  GPRectFromRect(vgRect(0, 0, B.Width, B.Height)), ImageAttributes);
                TGPTextureBrush(FGPBrush).SetWrapMode(WrapModeClamp);
                TGPTextureBrush(FGPBrush).ScaleTransform((vgRectWidth(ARect) + (StrokeThickness / 2)) / B.Width,
                  (vgRectHeight(ARect) + (StrokeThickness / 2)) / B.Height);
              end;
              if Aopacity <> 1 then
                ImageAttributes.Free;
            end
            else
              FGPBrush := TGPSolidBrush.Create($00000000);
          end
          else
            FGPBrush := TGPSolidBrush.Create($00000000);
        end;
    else
      FGPBrush := TGPSolidBrush.Create($00000000);
    end;
  end;
end;

procedure TvxCanvasGdiPlus.ApplyStroke(ARect: TvxRect; const AOpacity: single);
var
  i: integer;
begin
  if FGPPen <> nil then
    FreeAndNil(FGPPen);
  if FGPPenBrush <> nil then
    FreeAndNil(FGPPenBrush);
  if (FStroke.Style = vgBrushResource) and (FStroke.Resource <> nil) and (FStroke.Resource.Brush <> nil) then
    FStroke.Assign(FStroke.Resource.Brush);

  with FStroke do
  begin
    case Style of
      vgBrushSolid:
        begin
          FGPPenBrush := TGPSolidBrush.Create(vgOpacity(SolidColor, AOpacity));
        end;
      vgBrushGradient:
        begin
          if Gradient.Points.Count > 1 then
          begin
            for i := 0 to Gradient.Points.Count - 1 do
            begin
              ColorArray[i] := vgOpacity(Gradient.Points[i].IntColor, AOpacity);
              OffsetArray[i] := Gradient.Points[i].Offset;
            end;
            FGPPenBrush := TGPLinearGradientBrush.Create(MakePoint(ARect.Left + Gradient.StartPosition.X * ARect.Right, ARect.Top + Gradient.StartPosition.Y * ARect.Bottom),
              MakePoint(ARect.Left + Gradient.StopPosition.X * ARect.Right, ARect.Top + Gradient.StopPosition.Y * ARect.Bottom), SolidColor, SolidColor);
            TGPLinearGradientBrush(FGPPenBrush).SetInterpolationColors(PGPColor(@ColorArray), PSingle(@OffsetArray), Gradient.Points.Count);
            if Abs(FStroke.Gradient.StartPosition.X - FStroke.Gradient.StopPosition.X) < Abs(FStroke.Gradient.StartPosition.Y - FStroke.Gradient.StopPosition.Y) then
              TGPLinearGradientBrush(FGPPenBrush).ScaleTransform(vgRectHeight(ARect), vgRectWidth(ARect))
            else
              TGPLinearGradientBrush(FGPPenBrush).ScaleTransform(vgRectWidth(ARect), vgRectHeight(ARect));
          end
          else
            FGPPenBrush := TGPSolidBrush.Create(vgOpacity(SolidColor, AOpacity));
        end;
      vgBrushVisual:
        begin
          FGPPenBrush := TGPSolidBrush.Create($00000000);
        end;
      vgBrushBitmap:
        begin
          if (Bitmap.Bitmap <> nil) and (Bitmap.Bitmap.Width > 0) and (Bitmap.Bitmap.Height > 0) then
          begin
            UpdateBitmap(Bitmap.Bitmap);
            if (Bitmap.Bitmap.Handle <> 0) then
            begin
              if Bitmap.WrapMode <> vgWrapTileStretch then
                FGPPenBrush := TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle), TWrapMode(Bitmap.WrapMode))
              else
              begin
                FGPPenBrush := TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle), WrapModeClamp);
                TGPTextureBrush(FGPPenBrush).ScaleTransform(vgRectWidth(ARect) / Bitmap.Bitmap.Width, vgRectHeight(ARect) / Bitmap.Bitmap.Height);
              end;
            end
            else
              FGPPenBrush := TGPSolidBrush.Create($00000000);
          end
          else
            FGPPenBrush := TGPSolidBrush.Create($00000000);
        end;
    else
      FGPPenBrush := TGPSolidBrush.Create($00000000);
    end;
  end;

  FGPPen := TGPPen.Create(FGPPenBrush);
  case StrokeCap of
    vgCapFlat: FGPPen.SetLineCap(LineCapFlat, LineCapFlat, LineCapFlat);
    vgCapRound: FGPPen.SetLineCap(LineCapRound, LineCapRound, LineCapRound);
  end;
  if Length(FDash) > 0 then
  begin
    FGPPen.SetDashOffset(FDashOffset);
    FGPPen.SetDashPattern(@FDash[0], Length(FDash));
  end
  else
    FGPPen.SetDashStyle(DashStyleSolid);
  case StrokeJoin of
    vgJoinMiter: FGPPen.SetLineJoin(LineJoinMiter);
    vgJoinRound: FGPPen.SetLineJoin(LineJoinRound);
    vgJoinBevel: FGPPen.SetLineJoin(LineJoinBevel);
  end;
  FGPPen.SetWidth(StrokeThickness);
end;

procedure TvxCanvasGdiPlus.FontChanged(Sender: TObject);
begin
  FreeAndNil(FGPFamily);
  FGPFamily := TGPFontFamily.Create(FFont.Family, FFontCollection);
  if not FGPFamily.IsAvailable then
  begin
    FGPFamily.Free;
    FGPFamily := TGPFontFamily.Create(FFont.Family);
    if not FGPFamily.IsAvailable then
    begin
      FGPFamily.Free;
      FGPFamily := TGPFontFamily.GenericSansSerif.Clone;
    end
  end;
  if FGraphics <> nil then
  begin
    if FFont.ClearType then
      FGraphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit)
    else
      FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
  end;
end;

procedure TvxCanvasGdiPlus.DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single);
begin
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(vgRect(APt1.X, APt1.Y, APt2.X, APt2.Y), AOpacity);
    FGraphics.DrawLine(FGPPen, APt1.X, APt1.Y, APt2.X, APt2.Y);
  end;
end;

procedure TvxCanvasGdiPlus.IntFillRect(R: TvxRect;
  Opacity: single);
var
  Save: cardinal;
  GPR: TGPRectF;
  Visual: TvxVisualObject;
  M: TvxMatrix;
  SaveOpacity: single;
  SaveStroke: TvxBrush;
  SaveStrokeThickness: single;
begin
  if FFill.Style <> vgBrushNone then
  begin
    if FFill.Style = vgBrushVisual then
    begin
      Save := SaveCanvas;
      FGraphics.IntersectClip(GPRectFromRect(R));
      if FFill.Visual.VisualObject <> nil then
      begin
        Visual := FFill.Visual.VisualObject;
        SaveOpacity := Visual.Opacity;
        SaveStroke := TvxBrush.Create(vgBrushSolid, $FF000000);
        SaveStroke.Assign(Stroke);
        SaveStrokeThickness := StrokeThickness;
        Visual.Opacity := Opacity;

        Visual.PaintTo(Self, R);

        Visual.Opacity := SaveOpacity;
        Stroke.Assign(SaveStroke);
        SaveStroke.Free;
        StrokeThickness := SaveStrokeThickness;
      end;
      RestoreCanvas(Save);
    end
    else
    begin
      ApplyFill(R, Opacity);
      FGraphics.FillRectangle(FGPBrush, GPRectFromRect(R));
    end;
  end;
end;

procedure TvxCanvasGdiPlus.IntFillPath(P: TGPGraphicsPath; R: TvxRect;
  Opacity: single);
var
  Save: cardinal;
  Rg: TGPRegion;
  Visual: TvxVisualObject;
  M: TvxMatrix;
  SaveOpacity: single;
  SaveStroke: TvxBrush;
  SaveStrokeThickness: single;
begin
  if FFill.Style <> vgBrushNone then
  begin
    if FFill.Style = vgBrushVisual then
    begin
      Save := SaveCanvas;
      Rg := TGPRegion.Create(P);
      FGraphics.IntersectClip(Rg);
      Rg.Free;
      if FFill.Visual.VisualObject <> nil then
      begin
        Visual := FFill.Visual.VisualObject;
        SaveOpacity := Visual.Opacity;
        SaveStroke := TvxBrush.Create(vgBrushSolid, $FF000000);
        SaveStroke.Assign(Stroke);
        SaveStrokeThickness := StrokeThickness;
        Visual.Opacity := Opacity;

        Visual.PaintTo(Self, R);

        Visual.Opacity := SaveOpacity;
        Stroke.Assign(SaveStroke);
        SaveStroke.Free;
        StrokeThickness := SaveStrokeThickness;
      end;
      RestoreCanvas(Save);
    end
    else
    begin
      ApplyFill(R, Opacity);
      FGraphics.FillPath(FGPBrush, P);
    end;
  end;
end;

procedure TvxCanvasGdiPlus.DrawRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners;
  const AOpacity: single; const ACornerType: TvxCornerType = vgCornerRound);
var
  Path: TGPGraphicsPath;
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if FStroke.Style <> vgBrushNone then
  begin
    R := ARect;
    ApplyStroke(R, AOpacity);
    if (xRadius < Epsilon) and (yRadius < Epsilon) then
    begin
      FGraphics.DrawRectangle(FGPPen, GPRectFromRect(R));
    end
    else
    begin
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
      x2 := x1 * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
      y2 := y1 * CurveKappaInv;
      Path := TGPGraphicsPath.Create;
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Left, R.Top + y1, R.Left + x1, R.Top);
          vgCornerInnerRound: Path.AddBezier(R.Left, R.Top + y1, R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Left, R.Top + y1, R.Left + x2, R.Top + y1);
              Path.AddLine(R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2);
              Path.AddLine(R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
            end;
        else
          Path.AddBezier(R.Left, R.Top + y1, R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top)
        end;
      end
      else
      begin
        Path.AddLine(R.Left, R.Top + y1, R.Left, R.Top);
        Path.AddLine(R.Left, R.Top, R.Left + x1, R.Top);
      end;
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Right - x1, R.Top, R.Right, R.Top + y1);
          vgCornerInnerRound: Path.AddBezier(R.Right - x1, R.Top, R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Right - x1, R.Top, R.Right - x1, R.Top + y2);
              Path.AddLine(R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1);
              Path.AddLine(R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
            end;
        else
          Path.AddBezier(R.Right - x1, R.Top, R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Right - x1, R.Top, R.Right, R.Top);
        Path.AddLine(R.Right, R.Top, R.Right, R.Top + y1);
      end;
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Right, R.Bottom - y1, R.Right - x1, R.Bottom);
          vgCornerInnerRound: Path.AddBezier(R.Right, R.Bottom - y1, R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Right, R.Bottom - y1, R.Right - x2, R.Bottom - y1);
              Path.AddLine(R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2);
              Path.AddLine(R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
            end;
        else
          Path.AddBezier(R.Right, R.Bottom - y1, R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom)
        end;
      end
      else
      begin
        Path.AddLine(R.Right, R.Bottom - y1, R.Right, R.Bottom);
        Path.AddLine(R.Right, R.Bottom, R.Right - x1, R.Bottom);
      end;
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Left + x1, R.Bottom, R.Left, R.Bottom - y1);
          vgCornerInnerRound: Path.AddBezier(R.Left + x1, R.Bottom, R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Left + x1, R.Bottom, R.Left + x1, R.Bottom - y2);
              Path.AddLine(R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1);
              Path.AddLine(R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
            end;
        else
          Path.AddBezier(R.Left + x1, R.Bottom, R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Left + x1, R.Bottom, R.Left, R.Bottom);
        Path.AddLine(R.Left, R.Bottom, R.Left, R.Bottom - y1);
      end;
      {$IFDEF FLATTEN}
      Path.Flatten();
      {$ENDIF}
      Path.CloseFigure;
      FGraphics.DrawPath(FGPPen, Path);
      Path.Free;
    end;
  end;
end;

procedure TvxCanvasGdiPlus.FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  Path: TGPGraphicsPath;
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if FFill.Style <> vgBrushNone then
  begin
    R := ARect;
    if ((xRadius = 0) and (yRadius = 0)) or (ACorners = []) then
    begin
      IntFillRect(R, AOpacity);
    end
    else
    begin
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
      x2 := x1 * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
      y2 := y1 * CurveKappaInv;
      Path := TGPGraphicsPath.Create;
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Left, R.Top + y1, R.Left + x1, R.Top);
          vgCornerInnerRound: Path.AddBezier(R.Left, R.Top + y1, R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Left, R.Top + y1, R.Left + x2, R.Top + y1);
              Path.AddLine(R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2);
              Path.AddLine(R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
            end;
        else
          Path.AddBezier(R.Left, R.Top + y1, R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top)
        end;
      end
      else
      begin
        Path.AddLine(R.Left, R.Top + y1, R.Left, R.Top);
        Path.AddLine(R.Left, R.Top, R.Left + x1, R.Top);
      end;
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Right - x1, R.Top, R.Right, R.Top + y1);
          vgCornerInnerRound: Path.AddBezier(R.Right - x1, R.Top, R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Right - x1, R.Top, R.Right - x1, R.Top + y2);
              Path.AddLine(R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1);
              Path.AddLine(R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
            end;
        else
          Path.AddBezier(R.Right - x1, R.Top, R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Right - x1, R.Top, R.Right, R.Top);
        Path.AddLine(R.Right, R.Top, R.Right, R.Top + y1);
      end;
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Right, R.Bottom - y1, R.Right - x1, R.Bottom);
          vgCornerInnerRound: Path.AddBezier(R.Right, R.Bottom - y1, R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Right, R.Bottom - y1, R.Right - x2, R.Bottom - y1);
              Path.AddLine(R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2);
              Path.AddLine(R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
            end;
        else
          Path.AddBezier(R.Right, R.Bottom - y1, R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom)
        end;
      end
      else
      begin
        Path.AddLine(R.Right, R.Bottom - y1, R.Right, R.Bottom);
        Path.AddLine(R.Right, R.Bottom, R.Right - x1, R.Bottom);
      end;
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: Path.AddLine(R.Left + x1, R.Bottom, R.Left, R.Bottom - y1);
          vgCornerInnerRound: Path.AddBezier(R.Left + x1, R.Bottom, R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
          vgCornerInnerLine:
            begin
              Path.AddLine(R.Left + x1, R.Bottom, R.Left + x1, R.Bottom - y2);
              Path.AddLine(R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1);
              Path.AddLine(R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
            end;
        else
          Path.AddBezier(R.Left + x1, R.Bottom, R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1)
        end;
      end
      else
      begin
        Path.AddLine(R.Left + x1, R.Bottom, R.Left, R.Bottom);
        Path.AddLine(R.Left, R.Bottom, R.Left, R.Bottom - y1);
      end;
      {$IFDEF FLATTEN}
      Path.Flatten();
      {$ENDIF}
      Path.CloseFigure;
      IntFillPath(Path, ARect, AOpacity);
      Path.Free;
    end;
  end;
end;

procedure TvxCanvasGdiPlus.DrawEllipse(const ARect: TvxRect; const AOpacity: single);
var
  R: TvxRect;
  P: TGPGraphicsPath;
begin
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(ARect, AOpacity);
    R := vgRect(ARect.left, ARect.Top, ARect.Right, ARect.Bottom);
    FGraphics.DrawEllipse(FGPPen, GPRectFromRect(R));
  end;
end;

procedure TvxCanvasGdiPlus.FillEllipse(const ARect: TvxRect; const AOpacity: single);
var
  R: TvxRect;
  P: TGPGraphicsPath;
begin
  if FFill.Style <> vgBrushNone then
  begin
    P := TGPGraphicsPath.Create();
    R := vgRect(ARect.left, ARect.Top, ARect.Right - ARect.Left, ARect.Bottom - ARect.Top);
    P.AddEllipse(R.Left, R.Top, R.Right, R.Bottom);
    IntFillPath(P, R, AOpacity);
    P.Free;
  end;
end;

function TvxCanvasGdiPlus.LoadFontFromStream(AStream: TStream): boolean;
var
  Stream: TMemoryStream;
begin
  if FFontCollection = nil then
    FFontCollection := TGPPrivateFontCollection.Create;
  Stream := TMemoryStream.Create;
  Stream.CopyFrom(AStream, AStream.Size);
  FFontCollection.AddMemoryFont(Stream.Memory, Stream.Size);
  Stream.Free;
end;

procedure TvxCanvasGdiPlus.FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter);
var
  StringFormat: TGPStringFormat;
  Font: TGPFont;
  R: TvxRect;
  S: TvxFontStyle;
begin
  if (FFill.Style <> vgBrushNone) and (AText <> '') then
  begin
    StringFormat := TGPStringFormat.Create(StringFormatFlagsNoClip);
    if not WordWrap then
      StringFormat.SetFormatFlags(StringFormat.GetFormatFlags or StringFormatFlagsNoWrap);
    if not FGPFamily.IsStyleAvailable(vgStyleToGPStyle(FFont.Style)) then
    begin
      Font := nil;
      for S := vgFontRegular to vgFontStrikeout do
      begin
        if FGPFamily.IsStyleAvailable(vgStyleToGPStyle(S)) then
        begin
          Font := TGPFont.Create(FGPFamily, (FFont.Size * 0.75 * FFontScale), vgStyleToGPStyle(S));
          Break;
        end;
      end;
      if Font = nil then
        Font := TGPFont.Create(FGPFamily, (FFont.Size * 0.75 * FFontScale), vgStyleToGPStyle(FFont.Style));
    end
    else
      Font := TGPFont.Create(FGPFamily, (FFont.Size * 0.75 * FFontScale), vgStyleToGPStyle(FFont.Style), UnitPoint);
    // formating
    case ATextAlign of
      vgTextAlignCenter:
        begin
          stringFormat.SetAlignment(StringAlignmentCenter);
        end;
      vgTextAlignNear:
        begin
          stringFormat.SetAlignment(StringAlignmentNear);
        end;
      vgTextAlignFar:
        begin
          stringFormat.SetAlignment(StringAlignmentFar);
        end;
    end;
    case AVTextAlign of
      vgTextAlignCenter:
        begin
          stringFormat.SetLineAlignment(StringAlignmentCenter);
        end;
      vgTextAlignNear:
        begin
          stringFormat.SetLineAlignment(StringAlignmentNear);
        end;
      vgTextAlignFar:
        begin
          stringFormat.SetLineAlignment(StringAlignmentFar);
        end;
    end;
    // calc correct rect
    if AOpacity = 1 then
      ApplyFill(ARect, AOpacity * 0.99)
    else
      ApplyFill(ARect, AOpacity);
    if (frac(FMatrix.m11) <> 0) or (frac(FMatrix.m22) <> 0) then
    begin
      FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
      FGraphics.DrawString(AText, -1, Font, GPRectFromRect(ARect), StringFormat, FGPBrush);
      if FFont.ClearType then
        FGraphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit)
      else
        FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
    end
    else
    begin
      FGraphics.DrawString(AText, -1, Font, GPRectFromRect(ARect), StringFormat, FGPBrush);
    end;

    Font.Free;
    StringFormat.Free;
  end;
end;

procedure TvxCanvasGdiPlus.MeasureText(var ARect: TvxRect;
  AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const ATextAlign, AVTextAlign: TvxTextAlign);
var
  StringFormat: TGPStringFormat;
  Font: TGPFont;
  GR: TGPRectF;
  charRanges: array[0..2] of TCharacterRange;
  pCharRangeRegions: array of TGPRegion;
  i, count: Integer;
  S: TvxFontStyle;
  B: TGPBitmap;
  G: TGPGraphics;
begin
  if not WordWrap then
    ARect.Right := ARect.Left;
  if Length(AText) = 0 then
    Exit;

  if FGraphics = nil then
  begin
    B := TGPBitmap.Create(1, 1, PixelFormat32bppARGB);
    G := TGPGraphics.Create(B);
    G.SetSmoothingMode(QualityModeHigh);
    G.SetInterpolationMode(InterpolationModeHighQuality);
    G.SetPixelOffsetMode(PixelOffsetModeHalf);
    if FFont.ClearType then
      G.SetTextRenderingHint(TextRenderingHintClearTypeGridFit)
    else
      G.SetTextRenderingHint(TextRenderingHintAntiAlias);
    FGraphics := G;
  end
  else
  begin
    G := nil;
  end;

  if (frac(FMatrix.m11) <> 0) or (frac(FMatrix.m22) <> 0) then
    FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);

  StringFormat := TGPStringFormat.Create(StringFormatFlagsMeasureTrailingSpaces or StringFormatFlagsNoClip);
  if not WordWrap then
    StringFormat.SetFormatFlags(StringFormat.GetFormatFlags or StringFormatFlagsNoWrap);
  { measure rect height}
  if not FGPFamily.IsStyleAvailable(vgStyleToGPStyle(FFont.Style)) then
  begin
    Font := nil;
    for S := vgFontRegular to vgFontStrikeout do
    begin
      if FGPFamily.IsStyleAvailable(vgStyleToGPStyle(S)) then
      begin
        Font := TGPFont.Create(FGPFamily, (FFont.Size * 0.75 * FFontScale), vgStyleToGPStyle(S));
        Break;
      end;
    end;
    if Font = nil then
      Font := TGPFont.Create(FGPFamily, (FFont.Size * 0.75 * FFontScale), vgStyleToGPStyle(FFont.Style));
  end
  else
    Font := TGPFont.Create(FGPFamily, (FFont.Size * 0.75 * FFontScale), vgStyleToGPStyle(FFont.Style));
  // formating
  case ATextAlign of
    vgTextAlignCenter:
      begin
        stringFormat.SetAlignment(StringAlignmentCenter);
      end;
    vgTextAlignNear:
      begin
        stringFormat.SetAlignment(StringAlignmentNear);
      end;
    vgTextAlignFar:
      begin
        stringFormat.SetAlignment(StringAlignmentFar);
      end;
  end;
  case AVTextAlign of
    vgTextAlignCenter:
      begin
        stringFormat.SetLineAlignment(StringAlignmentCenter);
      end;
    vgTextAlignNear:
      begin
        stringFormat.SetLineAlignment(StringAlignmentNear);
      end;
    vgTextAlignFar:
      begin
        stringFormat.SetLineAlignment(StringAlignmentFar);
      end;
  end;
  // set char range
  charRanges[0] := MakeCharacterRange(0, Length(AText));
  StringFormat.SetMeasurableCharacterRanges(1, @charRanges);
  count := StringFormat.GetMeasurableCharacterRangeCount;
  SetLength(pCharRangeRegions, count);
  if count > 0 then
    for i := 0 to count - 1 do
      pCharRangeRegions[i] := TGPRegion.Create;
  // measure
  FGraphics.MeasureCharacterRanges(AText, -1, Font, GPRectFromRect(ARect), StringFormat, count, pCharRangeRegions);
  for i := 0 to count - 1 do
  begin
    pCharRangeRegions[i].GetBounds(GR, FGraphics);
    if i = 0 then
      ARect := vgRect(GR.X, GR.Y, GR.X + GR.Width, GR.Y + GR.Height)
    else
      ARect := vgUnionRect(ARect, vgRect(GR.X, GR.Y, GR.X + GR.Width, GR.Y + GR.Height));
  end;

  if count > 0 then
    for i := 0 to count - 1 do
      pCharRangeRegions[i].Free;
  SetLength(pCharRangeRegions, 0);
  // free
  Font.Free;
  StringFormat.Free;

  if G <> nil then
  begin
    G.Free;
    B.Free;
    FGraphics := nil;
  end
  else
  begin
    if FFont.ClearType then
      FGraphics.SetTextRenderingHint(TextRenderingHintClearTypeGridFit)
    else
      FGraphics.SetTextRenderingHint(TextRenderingHintAntiAlias);
  end;
end;

function TvxCanvasGdiPlus.TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
  const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean;
var
  StringFormat: TGPStringFormat;
  GPPath: TGPGraphicsPath;
  Bmp: TGPBitmap;
  FGraphics: TGPGraphics;
  Bits: Cardinal;
  i: integer;
  SP, CP1, CP2: TvxPoint;
  Data: TPathData;
  SavePoints: PGPPointF;
begin
  Result := false;
  if (AText <> '') then
  begin
    if not FGPFamily.IsStyleAvailable(vgStyleToGPStyle(FFont.Style)) then
      Exit;

    Path.Clear;
    Bmp := TGPBitmap.Create(1, 1, 1 * 4, PixelFormat32bppARGB, @Bits);
    FGraphics := TGPGraphics.Create(Bmp);

    StringFormat := TGPStringFormat.Create(0);
    if not WordWrap then
      StringFormat.SetFormatFlags(StringFormat.GetFormatFlags or StringFormatFlagsNoWrap or StringFormatFlagsMeasureTrailingSpaces);
    GPPath := TGPGraphicsPath.Create;
    // formating
    case ATextAlign of
      vgTextAlignCenter:
        begin
          stringFormat.SetAlignment(StringAlignmentCenter);
        end;
      vgTextAlignNear:
        begin
          stringFormat.SetAlignment(StringAlignmentNear);
        end;
      vgTextAlignFar:
        begin
          stringFormat.SetAlignment(StringAlignmentFar);
        end;
    end;
    case AVTextAlign of
      vgTextAlignCenter:
        begin
          stringFormat.SetLineAlignment(StringAlignmentCenter);
        end;
      vgTextAlignNear:
        begin
          stringFormat.SetLineAlignment(StringAlignmentNear);
        end;
      vgTextAlignFar:
        begin
          stringFormat.SetLineAlignment(StringAlignmentFar);
        end;
    end;
    // path
    GPPath.AddString(AText, -1, FGPFamily, vgStyleToGPStyle(FFont.Style), FFont.Size, GPRectFromRect(ARect), StringFormat);
    // expand path
    Data := TPathData.Create;
    GPPath.GetPathData(Data);
    SavePoints := Data.Points;
    // calc size
    i := 0;
    while i < Data.Count do
    begin
      if PByteArray(Data.Types)[i] = PathPointTypeStart then
      begin
        SP := vgPoint(Data.Points^.X, Data.Points^.Y);
        Path.MoveTo(vgPoint(Data.Points^.X, Data.Points^.Y));
      end;
      if PByteArray(Data.Types)[i] and PathPointTypeBezier = PathPointTypeBezier then
      begin
        CP1 := vgPoint(Data.Points^.X, Data.Points^.Y);
        Inc(i);
        Inc(Data.Points);
        CP2 := vgPoint(Data.Points^.X, Data.Points^.Y);
        Inc(i);
        Inc(Data.Points);
        Path.CurveTo(CP1, CP2, vgPoint(Data.Points^.X, Data.Points^.Y));
      end;
      if PByteArray(Data.Types)[i] and PathPointTypeLine = PathPointTypeLine then
      begin
        Path.LineTo(vgPoint(Data.Points^.X, Data.Points^.Y));
      end;
      if PByteArray(Data.Types)[i] and PathPointTypeCloseSubpath = PathPointTypeCloseSubpath then
      begin
        Path.ClosePath;
      end;
      Inc(i);
      Inc(Data.Points);
    end;
    Result := true;
    //
    Data.Points := SavePoints;
    Data.Free;
    StringFormat.Free;
    GPPath.Free;

    // free
    FGraphics.Free;
    Bmp.Free;
  end
  else
    Result := false;
end;

{ Bitmaps }

procedure TvxCanvasGdiPlus.DrawThumbnail(const ABitmap: TvxBitmap;
  const Width, Height: single);
var
  scale: single;
  graphics: TGPGraphics;
begin
  UpdateBitmap(ABitmap);
  if ABitmap.Handle = 0 then
    Exit;
  scale := Width / ABitmap.Width;
  if FBitmap <> nil then
  begin
    Fgraphics.ScaleTransform(scale, scale);
    Fgraphics.DrawImage(TGPBitmap(ABitmap.Handle), 0, 0, ABitmap.Width, ABitmap.Height);
  end;
end;

procedure TvxCanvasGdiPlus.DrawBitmap(const ABitmap: TvxBitmap;
  const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false);
var
  CM: TColorMatrix;
  ImageAttributes: TGPImageAttributes;
  Pts: array[1..4] of TvxPoint;
begin
  if HighSpeed then
    FGraphics.SetInterpolationMode(InterpolationModeNearestNeighbor)
  else
    FGraphics.SetInterpolationMode(QualityModeHigh);
  if (AOpacity < 1) then
  begin
    if (AOpacity = 0) then
      Exit;
    CM := ImgColorMatrix;
    CM[3][3] := AOpacity;
    UpdateBitmap(ABitmap);
    if ABitmap.Handle = 0 then
      Exit;
    ImageAttributes := TGPImageAttributes.Create;
    ImageAttributes.SetColorMatrix(
      CM,
      ColorMatrixFlagsDefault,
      ColorAdjustTypeBitmap);
    FGraphics.DrawImage(TGPBitmap(ABitmap.Handle), MakeRect(DstRect.Left, DstRect.Top, DstRect.Right - DstRect.Left, DstRect.Bottom - DstRect.Top),
      SrcRect.Left, SrcRect.Top, SrcRect.Right - SrcRect.Left, SrcRect.Bottom - SrcRect.Top,
      UnitPixel, ImageAttributes);
    ImageAttributes.Free;
  end
  else
  begin
    UpdateBitmap(ABitmap);
    if ABitmap.Handle = 0 then
      Exit;
    FGraphics.DrawImage(TGPBitmap(ABitmap.Handle), MakeRect(DstRect.Left, DstRect.Top, DstRect.Right - DstRect.Left, DstRect.Bottom - DstRect.Top),
      SrcRect.Left, SrcRect.Top, SrcRect.Right - SrcRect.Left, SrcRect.Bottom - SrcRect.Top,
      UnitPixel);
  end;
end;

procedure TvxCanvasGdiPlus.UpdateBitmap(ABitmap: TvxBitmap);
var
  BD: TBitmapData;
  j: integer;
begin
  { update bitmap to GDI+ bitmap }
  if ABitmap = nil then
    Exit;
  if ABitmap.IsEmpty then
    Exit;
  { create - if need }
  if ABitmap.Handle = 0 then
  begin
    ABitmap.Handle := Cardinal(TGPBitmap.Create(ABitmap.Width, ABitmap.Height,
      ABitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(ABitmap.StartLine)));
    ABitmap.NeedUpdate := true;
    ABitmap.OnDestroyHandle := DestroyBitmap;
  end;
  { resize if need }
  if (ABitmap.Width <> TGPBitmap(ABitmap.Handle).GetWidth) or
    (ABitmap.Height <> TGPBitmap(ABitmap.Handle).GetHeight) then
  begin
    TGPBitmap(ABitmap.Handle).Destroy;
    ABitmap.Handle := Cardinal(TGPBitmap.Create(ABitmap.Width, ABitmap.Height,
      ABitmap.Width * 4, PixelFormat32bppPARGB, PBYTE(ABitmap.StartLine)));
    ABitmap.NeedUpdate := true;
  end;
  { clear flag }
  ABitmap.NeedUpdate := false;
end;

procedure TvxCanvasGdiPlus.DestroyBitmap(Sender: TObject);
begin
  if (Sender <> nil) then
  begin
    if (TvxBitmap(Sender).Handle <> 0) then
      TGPBitmap(TvxBitmap(Sender).Handle).Free;
    TvxBitmap(Sender).Handle := 0;
  end;
end;

{ Path }

procedure TvxCanvasGdiPlus.DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  B: TvxRect;
  i: integer;
  W, H, NewW, NewH: single;
  CP1, CP2, CP, SP: TvxPoint;
begin
  if not APath.IsEmpty then
  begin
    B := APath.GetBounds;
    W := vgRectWidth(B);
    H := vgRectHeight(B);
    if W * H = 0 then
      Exit;
    ApplyStroke(APath.GetBounds, AOpacity);
    NewW := vgRectWidth(ARect);
    NewH := vgRectHeight(ARect);
    i := 0;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of
        vgPathPointMoveTo:
          begin
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
            SP := CP;
          end;
        vgPathPointLineTo:
          begin
            FGraphics.DrawLine(FGPPen, CP.X, CP.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;
        vgPathPointCurveTo:
          begin
            CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW, ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW, ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            FGraphics.DrawBezier(FGPPen, CP.X, CP.Y,
              CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH
              );
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;
        vgPathPointClose:
          begin
            FGraphics.DrawLine(FGPPen, CP.X, CP.Y, SP.X, SP.Y);
          end;
      end;
      Inc(i);
    end;
  end;
end;

procedure TvxCanvasGdiPlus.FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  B: TvxRect;
  i: integer;
  W, H, NewW, NewH: single;
  CP, CP1, CP2: TvxPoint;
  P: TGPGraphicsPath;
begin
  if not APath.IsEmpty then
  begin
    B := APath.GetBounds;
    W := vgRectWidth(B);
    H := vgRectHeight(B);
    if W * H = 0 then
      Exit;
    NewW := vgRectWidth(ARect);
    NewH := vgRectHeight(ARect);
    P := TGPGraphicsPath.Create;
    i := 0;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of
        vgPathPointMoveTo:
          begin
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
            P.StartFigure;
          end;
        vgPathPointLineTo:
          begin
            P.AddLine(CP.X, CP.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;
        vgPathPointCurveTo:
          begin
            CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW, ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW, ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            P.AddBezier(CP.X, CP.Y,
              CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH
              );
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;
        vgPathPointClose:
          begin
            P.CloseFigure;
          end;
      end;
      Inc(i);
    end;

    IntFillPath(P, ARect, AOpacity);
    P.Free;
  end;
end;

function TvxCanvasGdiPlus.PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean;
var
  B: TvxRect;
  i: integer;
  W, H, NewW, NewH: single;
  CP, CP1, CP2: TvxPoint;
  P: TGPGraphicsPath;
begin
  Result := false;
  if not vgPtInRect(APoint, ARect) then
    Result := false
  else
  begin
    B := APath.GetBounds;
    W := vgRectWidth(B);
    H := vgRectHeight(B);
    if W * H = 0 then
      Exit;
    NewW := vgRectWidth(ARect);
    NewH := vgRectHeight(ARect);
    P := TGPGraphicsPath.Create;
    i := 0;
    while i < Length(APath.PathData) do
    begin
      case APath.PathData[i].Kind of
        vgPathPointMoveTo:
          begin
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
            P.StartFigure;
          end;
        vgPathPointLineTo:
          begin
            P.AddLine(CP.X, CP.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;
        vgPathPointCurveTo:
          begin
            CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW, ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW, ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
            Inc(i);
            P.AddBezier(CP.X, CP.Y,
              CP1.X,
              CP1.Y,
              CP2.X,
              CP2.Y,
              ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
              ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH
              );
            CP.X := ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW;
            CP.Y := ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH;
          end;
        vgPathPointClose:
          begin
            P.CloseFigure;
          end;
      end;
      Inc(i);
    end;

    Result := P.IsVisible(APoint.X, APoint.Y);

    P.Free;
  end;
end;
{$ENDIF}

{$IFDEF DARWIN}

{ TvxFilterQuartz }

class function TvxFilterQuartz.GetFileTypes: string;
begin
  Result := '*.jpg;*.jpeg;*.gif;*.tif;*.tiff;*.psd;*.jp2;*.png;*.bmp;*.tga;*.icns';
end;

class function TvxFilterQuartz.GetImageSize(const AFileName: string): TvxPoint;
var
  path: CFStringRef;
  url: CFURLRef;
  imgSourceRef: CGImageSourceRef;
  imgRef: CGImageRef;
  ctxRef: CGContextRef;
  bits: PvgColorArray;
begin
  Result := vgPoint(0, 0);
  path := CFStringCreateWithCString(nil, PChar(AFileName), kCFStringEncodingUTF8);
  url := CFURLCreateWithFileSystemPath(nil, path, kCFURLPOSIXPathStyle, false);
  CFRelease(path);
  imgSourceRef := CGImageSourceCreateWithURL(url, nil);
  CFRelease(url);
  if imgSourceRef <> nil then
  begin
    ImgRef := CGImageSourceCreateImageAtIndex(imgSourceRef, 0, nil);
    if ImgRef <> nil then
    begin
      Result := vgPoint(CGImageGetWidth(ImgRef), CGImageGetHeight(ImgRef));
      CGImageRelease(imgRef);
    end;
    CFRelease(imgSourceRef);
  end;
end;

function TvxFilterQuartz.LoadFromStream(const AStream: TStream; var Bitmap: TvxBitmap): boolean;
var
  provider: CGDataProviderRef;
  memStream: TMemoryStream;
  imgSourceRef: CGImageSourceRef;
  imgRef: CGImageRef;
  ctxRef: CGContextRef;
  bits: PvgColorArray;
  colorspace: CGColorSpaceRef;
begin
  memStream := TMemoryStream.Create;
  memStream.CopyFrom(AStream, AStream.Size);
  memStream.Position := 0;
  provider := CGDataProviderCreateWithData(nil, memStream.Memory, memStream.Size, nil);
  if provider <> nil then
  begin
    imgSourceRef := CGImageSourceCreateWithDataProvider(provider, nil);
    if imgSourceRef <> nil then
    begin
      ImgRef := CGImageSourceCreateImageAtIndex(imgSourceRef, 0, nil);
      if ImgRef <> nil then
      begin
        Bitmap.SetSize(CGImageGetWidth(ImgRef), CGImageGetHeight(ImgRef));
        colorspace := CGColorSpaceCreateDeviceRGB;
        ctxRef := CGBitmapContextCreate(Bitmap.StartLine, Bitmap.Width, Bitmap.Height, 8,
          Bitmap.Width * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast);
        CGContextDrawImage(ctxRef, CGRectFromRect(vgRect(0, 0, Bitmap.Width, Bitmap.Height)), imgRef);
        CGContextRelease(ctxRef);
        CGColorSpaceRelease(colorspace);
        CGImageRelease(imgRef);
      end;
      CFRelease(imgSourceRef);
    end;
    CGDataProviderRelease(provider);
  end;
  memStream.Free;
end;

function streamPutBytesCallback(info: Pointer; buffer: {const} Pointer; count: size_t): size_t; cdecl;
begin
  TStream(info).Write(buffer^, count);
end;

procedure streamReleaseInfoCallback(info: Pointer);
begin
  //  TMemoryStream(info).Free;
end;

function TvxFilterQuartz.SaveToStream(const AStream: TStream; var Bitmap: TvxBitmap; const Format: string;
  const Params: string = ''): boolean;
var
  consumer: CGDataConsumerRef;
  imgDestRef: CGImageDestinationRef;
  imgRef: CGImageRef;
  ctxRef: CGContextRef;
  bits: PvgColorArray;
  encoderType: CFStringRef;
  callback: CGDataConsumerCallbacks;
  colorspace: CGColorSpaceRef;
  keys: array[0..10] of pointer;
  value: array[0..10] of pointer;
  floatVal: single;
  S, param, name, val: string;
  dict: CFDictionaryRef;
begin
  callback.putBytes := @streamPutBytesCallback;
  callback.releaseConsumer := @streamReleaseInfoCallback;
  consumer := CGDataConsumerCreate(AStream, callback);

  encoderType := kUTTypePng;
  if (LowerCase(Format) = 'jpg') or (LowerCase(Format) = 'jpeg') then
    encoderType := kUTTypeJpeg;
  if (LowerCase(Format) = 'jp2') then
    encoderType := kUTTypeJPEG2000;
  if (LowerCase(Format) = 'bmp') then
    encoderType := kUTTypeBmp;
  if (LowerCase(Format) = 'png') then
    encoderType := kUTTypePng;
  if (LowerCase(Format) = 'tif') or (LowerCase(Format) = 'tiff') then
    encoderType := kUTTypeTiff;
  if (LowerCase(Format) = 'gif') then
    encoderType := kUTTypeGif;

  imgDestRef := CGImageDestinationCreateWithDataConsumer(consumer, encoderType, 1, nil);
  if imgDestRef <> nil then
  begin
    colorSpace := CGColorSpaceCreateDeviceRGB;
    ctxRef := CGBitmapContextCreate(Bitmap.StartLine, Bitmap.Width, Bitmap.Height, 8,
      Bitmap.Width * 4, colorSpace, kCGImageAlphaPremultipliedLast);
    imgRef := CGBitmapContextCreateImage(ctxRef);
    if imgRef <> nil then
    begin
      dict := nil;
      { set params }
      if Params <> '' then
      begin
        S := Params;
        while S <> '' do
        begin
          param := vgGetToken(S, ' ');
          name := vgGetToken(param, '=');
          val := vgGetToken(param, '');
          if sysutils.CompareText(name, 'quality') = 0 then
          begin
            floatVal := strToFloat(val) / 100;
            keys[0] := kCGImageDestinationLossyCompressionQuality;
            value[0] := CFNumberCreate(nil, kCFNumberFloat32Type, @floatVal);
            dict := CFDictionaryCreate(nil, @keys[0], @value[0], 1, nil, nil);
            CGImageDestinationSetProperties(imgDestRef, dict);
          end;
        end;
      end;
      CGImageDestinationAddImage(imgDestRef, imgRef, dict);
      CGImageDestinationFinalize(imgDestRef);
      if dict <> nil then
        CFRelease(dict);
    end;
    CGImageRelease(imgRef);
    CGContextRelease(ctxRef);
    CGColorSpaceRelease(colorspace);

    CFRelease(imgDestRef);
  end;
end;

function TvxFilterQuartz.LoadFromFile(const AFileName: string; const Rotate: single;
  var Bitmap: TvxBitmap): boolean;
var
  path: CFStringRef;
  url: CFURLRef;
  imgSourceRef: CGImageSourceRef;
  imgRef: CGImageRef;
  ctxRef: CGContextRef;
  bits: PvgColorArray;
  M, M2: TvxMatrix;
  R: TvxRect;
  Pts: array[1..4] of TvxPoint;
begin
  Result := false;
  path := CFStringCreateWithCString(nil, PChar(AFileName), kCFStringEncodingUTF8);
  url := CFURLCreateWithFileSystemPath(nil, path, kCFURLPOSIXPathStyle, false);
  CFRelease(path);
  imgSourceRef := CGImageSourceCreateWithURL(url, nil);
  CFRelease(url);
  if imgSourceRef <> nil then
  begin
    ImgRef := CGImageSourceCreateImageAtIndex(imgSourceRef, 0, nil);
    if ImgRef <> nil then
    begin
      if Rotate <> 0.0 then
      begin
        M := IdentityMatrix;
        M.m31 := -(CGImageGetWidth(ImgRef) / 2);
        M.m32 := -(CGImageGetHeight(ImgRef) / 2);
        M := vgMatrixMultiply(M, vgCreateRotationMatrix(vgDegToRad(-Rotate)));
        { calc new size }
        Pts[1] := vgPointFromVector(vgVectorTransform(vgVector(0, 0), M));
        Pts[2] := vgPointFromVector(vgVectorTransform(vgVector(CGImageGetWidth(ImgRef), 0), M));
        Pts[3] := vgPointFromVector(vgVectorTransform(vgVector(CGImageGetWidth(ImgRef), CGImageGetHeight(ImgRef)), M));
        Pts[4] := vgPointFromVector(vgVectorTransform(vgVector(0, CGImageGetHeight(ImgRef)), M));
        R := vgNormalizeRect(Pts);
        { translate }
        M2 := IdentityMatrix;
        M2.m31 := vgRectWidth(R) / 2;
        M2.m32 := vgRectHeight(R) / 2;
        M := vgMatrixMultiply(M, M2);
        { rotate }
        Bitmap.SetSize(Trunc(vgRectWidth(R)), Trunc(vgRectHeight(R)));
        ctxRef := CGBitmapContextCreate(Bitmap.StartLine, Bitmap.Width, Bitmap.Height, 8,
          Bitmap.Width * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast);
        with M do
          CGContextConcatCTM(CtxRef, CGAffineTransformMake(m11, m12, m21, m22, m31, m32));
        CGContextDrawImage(ctxRef, CGRectFromRect(vgRect(0, 0, CGImageGetWidth(ImgRef), CGImageGetHeight(ImgRef))), imgRef);
        CGContextRelease(ctxRef);
      end
      else
      begin
        Bitmap.SetSize(CGImageGetWidth(ImgRef), CGImageGetHeight(ImgRef));
        ctxRef := CGBitmapContextCreate(Bitmap.StartLine, Bitmap.Width, Bitmap.Height, 8,
          Bitmap.Width * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast);
        CGContextDrawImage(ctxRef, CGRectFromRect(vgRect(0, 0, Bitmap.Width, Bitmap.Height)), imgRef);
        CGContextRelease(ctxRef);
      end;
      Result := true;
      CGImageRelease(imgRef);
    end;
    CFRelease(imgSourceRef);
  end;
end;

function TvxFilterQuartz.LoadThumbnailFromFile(const AFileName: string;
  const AFitWidth, AFitHeight: single; const UseEmbedded: boolean; var Bitmap: TvxBitmap): boolean;
var
  path: CFStringRef;
  url: CFURLRef;
  imgSourceRef: CGImageSourceRef;
  imgRef: CGImageRef;
  ctxRef: CGContextRef;
  bits: PvgColorArray;
  dict: CFDictionaryRef;
  keys: array[0..10] of pointer;
  value: array[0..10] of pointer;
  intValue: cardinal;
begin
  Result := false;
  path := CFStringCreateWithCString(nil, PChar(AFileName), kCFStringEncodingUTF8);
  url := CFURLCreateWithFileSystemPath(nil, path, kCFURLPOSIXPathStyle, false);
  CFRelease(path);
  imgSourceRef := CGImageSourceCreateWithURL(url, nil);
  CFRelease(url);
  if imgSourceRef <> nil then
  begin
    keys[0] := kCGImageSourceCreateThumbnailFromImageAlways;
    value[0] := kCFBooleanTrue;
    keys[1] := kCGImageSourceThumbnailMaxPixelSize;
    if AFitWidth > AFitHeight then
      intValue := trunc(AFitWidth)
    else
      intValue := trunc(AFitHeight);
    value[1] := CFNumberCreate(nil, kCFNumberSInt32Type, @intValue);
    dict := CFDictionaryCreate(nil, @keys[0], @value[0], 2, nil, nil);
    ImgRef := CGImageSourceCreateThumbnailAtIndex(imgSourceRef, 0, dict);
    CFRelease(dict);
    if ImgRef <> nil then
    begin
      Bitmap.SetSize(CGImageGetWidth(ImgRef), CGImageGetHeight(ImgRef));
      ctxRef := CGBitmapContextCreate(Bitmap.StartLine, Bitmap.Width, Bitmap.Height, 8,
        Bitmap.Width * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast);
      CGContextDrawImage(ctxRef, CGRectFromRect(vgRect(0, 0, Bitmap.Width, Bitmap.Height)), imgRef);
      CGContextRelease(ctxRef);
      CGImageRelease(imgRef);
      Result := true;
    end;
    CFRelease(imgSourceRef);
  end;
end;

function TvxFilterQuartz.SaveToFile(const AFileName: string;
  var Bitmap: TvxBitmap; const Params: string = ''): boolean;
var
  path: CFStringRef;
  url: CFURLRef;
  imgDestRef: CGImageDestinationRef;
  imgRef: CGImageRef;
  ctxRef: CGContextRef;
  bits: PvgColorArray;
  encoderType: CFStringRef;
  keys: array[0..10] of pointer;
  value: array[0..10] of pointer;
  floatVal: single;
  S, param, name, val: string;
  dict: CFDictionaryRef;
begin
  path := CFStringCreateWithCString(nil, PChar(AFileName), kCFStringEncodingUTF8);
  url := CFURLCreateWithFileSystemPath(nil, path, kCFURLPOSIXPathStyle, false);
  CFRelease(path);
  encoderType := nil;
  if (LowerCase(ExtractFileExt(AFileName)) = '.jpg') or (LowerCase(ExtractFileExt(AFileName)) = '.jpeg') then
    encoderType := kUTTypeJpeg;
  if (LowerCase(ExtractFileExt(AFileName)) = '.jp2') then
    encoderType := kUTTypeJPEG2000;
  if (LowerCase(ExtractFileExt(AFileName)) = '.bmp') then
    encoderType := kUTTypeBmp;
  if (LowerCase(ExtractFileExt(AFileName)) = '.png') then
    encoderType := kUTTypePng;
  if (LowerCase(ExtractFileExt(AFileName)) = '.tif') or (LowerCase(ExtractFileExt(AFileName)) = '.tiff') then
    encoderType := kUTTypeTiff;
  if (LowerCase(ExtractFileExt(AFileName)) = '.gif') then
    encoderType := kUTTypeGif;
  if encoderType <> nil then
  begin
    imgDestRef := CGImageDestinationCreateWithURL(url, encoderType, 1, nil);

    CFRelease(url);
    if imgDestRef <> nil then
    begin
      ctxRef := CGBitmapContextCreate(Bitmap.StartLine, Bitmap.Width, Bitmap.Height, 8,
        Bitmap.Width * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast);
      imgRef := CGBitmapContextCreateImage(ctxRef);
      if imgRef <> nil then
      begin
        dict := nil;
        { set params }
        if Params <> '' then
        begin
          S := Params;
          while S <> '' do
          begin
            param := vgGetToken(S, ' ');
            name := vgGetToken(param, '=');
            val := vgGetToken(param, '');
            if sysutils.CompareText(name, 'quality') = 0 then
            begin
              floatVal := strToFloat(val) / 100;
              keys[0] := kCGImageDestinationLossyCompressionQuality;
              value[0] := CFNumberCreate(nil, kCFNumberFloat32Type, @floatVal);
              dict := CFDictionaryCreate(nil, @keys[0], @value[0], 1, nil, nil);
              CGImageDestinationSetProperties(imgDestRef, dict);
            end;
          end;
        end;
        CGImageDestinationAddImage(imgDestRef, imgRef, dict);
        CGImageDestinationFinalize(imgDestRef);
        if dict <> nil then
          CFRelease(dict);
      end;
      CGImageRelease(imgRef);
      CGContextRelease(ctxRef);
      CFRelease(imgDestRef);
    end;
  end;
end;

{ TvxCanvasQuartz }

const
  inputRange: array[1..2] of single = (0, 1);

type

  TRGBFloat = packed record
    r, g, b, a: single;
  end;

function CGColor(const C: TvxColor; Opacity: single = 1): TRGBFloat;
var
  cc: TvxColor;
begin
  cc := vgOpacity(C, Opacity);
  Result.a := TvxColorRec(cc).a / $FF;
  Result.r := TvxColorRec(cc).r / $FF;
  Result.g := TvxColorRec(cc).g / $FF;
  Result.b := TvxColorRec(cc).b / $FF;
end;

function CGRectFromRect(const R: TvxRect): CGRect;
begin
  Result.origin.x := R.Left;
  Result.origin.Y := R.Top;
  Result.size.Width := R.Right - R.Left;
  Result.size.Height := R.Bottom - R.Top;
end;

procedure CGContextDrawTiledImage(CtxRef: CGContextRef; ARect: TvxRect; Img: CGImageRef; Bitmap: TvxBitmap);
var
  x, y: integer;
  CR: CGRect;
begin
  if Bitmap.Width * Bitmap.Height = 0 then
    Exit;
  for x := 0 to Trunc(vgRectWidth(ARect) / Bitmap.Width) do
    for y := 0 to Trunc(vgRectHeight(ARect) / Bitmap.Height) do
    begin
      CR := CGRectFromRect(vgRect(ARect.Left + (Bitmap.Width * x), ARect.Top + (Bitmap.Height * y),
        ARect.Left + (Bitmap.Width * (x + 1)), ARect.Top + (Bitmap.Height * (y + 1))));
      CR.origin.y := -ARect.Top - (Bitmap.Height * (y + 1));
      CGContextDrawImage(CtxRef, CR, Img);
    end;
end;

var
  ColorArray: array[0..100] of cardinal;
  OffsetArray: array[0..100] of single;

const
  SavedCount = 2000;

constructor TvxCanvasQuartz.Create(const AWidth, AHeight: integer);
begin
  inherited;
end;

constructor TvxCanvasQuartz.CreateFromBitmap(const ABitmap: TvxBitmap);
var
  B: PvgColorArray;
begin
  inherited;
  FBitmap := ABitmap;
  UpdateBitmap(FBitmap);
  FHandle := FBitmap.Handle;
end;

destructor TvxCanvasQuartz.Destroy;
begin
  inherited;
end;

procedure TvxCanvasQuartz.FreeBuffer;
begin
  if (FBitmap = nil) then
  begin
    if FBuffered then
    begin
      if FHandle <> 0 then
        CGContextRelease(CGContextRef(FHandle));
    end
    else
    begin
    end;
    if FBufferBits <> nil then
      System.FreeMem(FBufferBits);
  end;
end;

procedure TvxCanvasQuartz.ResizeBuffer(const AWidth, AHeight: integer);
begin
  if (AWidth = FWidth) and (AHeight = FHeight) then
    Exit;
  FreeBuffer;
  FWidth := AWidth;
  FHeight := AHeight;
  if FWidth <= 0 then
    FWidth := 1;
  if FHeight <= 0 then
    FHeight := 1;
  FResized := true;

  if FWidth * FHeight = 0 then
    Exit;
  if FBuffered then
  begin
    GetMem(FBufferBits, FWidth * FHeight * 4);
    FHandle := cardinal(CGBitmapContextCreate(FBufferBits, FWidth, FHeight, 8,
      FWidth * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast));
    CGContextTranslateCTM(CGContextRef(Handle), 0, FHeight);
    CGContextScaleCTM(CGContextRef(Handle), 1, -1);
  end
  else
  begin
    GetMem(FBufferBits, 4);
  end;
end;

procedure TvxCanvasQuartz.FlushBuffer(const X, Y: integer; const DC: Cardinal);
var
  CGR: CGRect;
  ImgRef: CGImageRef;
begin
  if FBuffered then
  begin
    if (CGContextRef(Handle) <> nil) and (DC <> 0) then
    begin
      CGR.origin.x := X;
      CGR.origin.y := -Y + FHeight;
      CGR.size.width := FWidth;
      CGR.size.height := FHeight;
      ImgRef := CGBitmapContextCreateImage(CGContextRef(Handle));
      CGContextDrawImage(CGContextRef(DC), CGR, ImgRef);
      CFRelease(ImgRef);
    end;
  end;
end;

procedure TvxCanvasQuartz.FlushBufferRect(const X, Y: integer;
  const DC: Cardinal; const ARect: TvxRect);
var
  NewR: TvxRect;
  R, SubR: CGRect;
  SubImgRef, ImgRef: CGImageRef;
begin
  if FBuffered and (DC <> 0) and (CGContextRef(Handle) <> nil) then
  begin
    vgIntersectRect(NewR, ARect, vgRect(0, 0, FWidth, FHeight));
    R.origin.x := X + NewR.Left;
    R.origin.y := -(Y + NewR.Bottom);
    R.size.width := vgRectWidth(NewR);
    R.size.height := vgRectHeight(NewR);
    SubR.origin.x := NewR.Left;
    SubR.origin.y := NewR.Top;
    SubR.size.width := vgRectWidth(NewR);
    SubR.size.height := vgRectHeight(NewR);

    ImgRef := CGBitmapContextCreateImage(CGContextRef(Handle));
    SubImgRef := CGImageCreateWithImageInRect(ImgRef, SubR);
    if SubImgRef <> nil then
    begin
      CGContextSaveGState(CGContextRef(DC));
      CGContextScaleCTM(CGContextRef(DC), 1, -1);
      CGContextDrawImage(CGContextRef(DC), R, SubImgRef);
      CFRelease(SubImgRef);
      CGContextRestoreGState(CGContextRef(DC));
    end;
    CFRelease(ImgRef);
  end;
end;

procedure TvxCanvasQuartz.Clear(const Color: cardinal);
begin
  if not FBuffered then
  begin
    CGContextClearRect(CGContextRef(Handle), CGRectFromRect(vgRect(0, 0, FWidth, FHeight)));
  end
  else
    vgFillLongword(FBufferBits, FWidth * FHeight, Color);
end;

procedure TvxCanvasQuartz.ClearRect(const ARect: TvxRect; const AColor: TvxColor);
var
  R: TRect;
begin
  if FBufferBits = nil then
    Exit;
  R := Rect(Trunc(ARect.Left), Trunc(ARect.Top), Round(ARect.Right), Round(ARect.Bottom));
  if R.Left < 0 then
    R.Left := 0;
  if R.Top < 0 then
    R.Top := 0;
  if R.Top < 0 then
    R.Top := 0;
  if R.Right > FWidth then
    R.Right := FWidth;
  if R.Bottom > FHeight then
    R.Bottom := FHeight;
  if R.Bottom < R.Top then
    R.Bottom := R.Top;
  if R.Right < R.Left then
    R.Right := R.Left;
  if (R.Right < 0) or (R.Top < 0) or (R.Left > FWidth) or (R.Top > FHeight) then
    Exit;
  if not FBuffered then
  begin
    CGContextClearRect(CGContextRef(Handle), CGRectFromRect(ARect));
  end
  else
    vgFillLongwordRect(FBufferBits, FWidth, FHeight, R.Left, R.Top, R.Right, R.Bottom, AColor);
end;

class function TvxCanvasQuartz.GetBitmapScanline(Bitmap: TvxBitmap; y: integer): PvgColorArray;
begin
  if (y >= 0) and (y < Bitmap.Height) and (Bitmap.StartLine <> nil) then
    Result := @PvgColorArray(Bitmap.StartLine)[(y) * Bitmap.Width]
  else
    Result := nil;
end;

procedure TvxCanvasQuartz.SetMatrix(const M: TvxMatrix);
var
  IM: TvxMatrix;
  CurM: CGAffineTransform;
begin
  FMatrix := M;
  { restore CTM }
  CurM := CGContextGetCTM(CGContextRef(Handle));
  IM := IdentityMatrix;
  with IM do
  begin
    m11 := CurM.a;
    m12 := CurM.b;
    m21 := CurM.c;
    m22 := CurM.d;
    m31 := CurM.tx;
    m32 := CurM.ty;
  end;
  vgInvertMatrix(IM);

  if CGContextRef(Handle) = nil then
    Exit;
  with IM do
    CGContextConcatCTM(CGContextRef(Handle), CGAffineTransformMake(m11, m12, m21, m22, m31, m32));

  // Quartz inverse
  if FBitmap <> nil then
    CGContextTranslateCTM(CGContextRef(Handle), 0, FBitmap.Height)
  else
    CGContextTranslateCTM(CGContextRef(Handle), 0, FHeight);
  CGContextScaleCTM(CGContextRef(Handle), 1, -1);
  { Set new }
  with FMatrix do
    CGContextConcatCTM(CGContextRef(Handle), CGAffineTransformMake(m11, m12, m21, m22, m31, m32));
end;

procedure TvxCanvasQuartz.MultyMatrix(const M: TvxMatrix);
var
  IM: TvxMatrix;
  CurM: CGAffineTransform;
begin
  FMatrix := M;
  { restore CTM }
  CurM := CGContextGetCTM(CGContextRef(Handle));
  IM := IdentityMatrix;
  with IM do
  begin
    m11 := CurM.a;
    m12 := CurM.b;
    m21 := CurM.c;
    m22 := CurM.d;
    m31 := CurM.tx;
    m32 := CurM.ty;
  end;
  vgInvertMatrix(IM);

  if CGContextRef(Handle) = nil then
    Exit;
  with IM do
    CGContextConcatCTM(CGContextRef(Handle), CGAffineTransformMake(m11, m12, m21, m22, m31, m32));
  if not FBuffered and (FBitmap = nil) then
  begin
    CGContextTranslateCTM(CGContextRef(Handle), 0, FHeight);
    CGContextScaleCTM(CGContextRef(Handle), 1, -1);
  end;
  { Set new }
  with FMatrix do
    CGContextConcatCTM(CGContextRef(Handle), CGAffineTransformMake(m11, m12, m21, m22, m31, m32));
end;

function TvxCanvasQuartz.SaveCanvas: cardinal;
var
  i: integer;
begin
  Result := InvalideCanvasState;
  if CGContextRef(Handle) = nil then
    Exit;

  CGContextSaveGState(CGContextRef(Handle));

  // find exists
  if Length(FSaveData) > 0 then
    for i := 0 to High(FSaveData) do
      if FSaveData[i].Index = InvalideCanvasState then
      begin
        Result := i;
        Break;
      end;
  if Result = InvalideCanvasState then
  begin
    SetLength(FSaveData, Length(FSaveData) + 1);
    Result := High(FSaveData);
  end;
  FSaveData[Result].Index := Result;
  FSaveData[Result].Matrix := FMatrix;
  FSaveData[Result].Stroke := TvxBrush.Create(vgBrushSolid, InvalideCanvasState);
  FSaveData[Result].Stroke.Assign(Stroke);
  FSaveData[Result].Fill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FSaveData[Result].Fill.Assign(Fill);
  FSaveData[Result].StrokeThickness := FStrokeThickness;
  FSaveData[Result].StrokeCap := StrokeCap;
  FSaveData[Result].StrokeJoin := StrokeJoin;
  FSaveData[Result].StrokeDash := StrokeDash;
  if StrokeDash <> vgDashSolid then
  begin
    SetLength(FSaveData[Result].Dash, Length(FDash));
    System.Move(FDash[0], FSaveData[Result].Dash[0], SizeOf(FDash[0]) * Length(FDash));
  end;
  FSaveData[Result].DashOffset := FDashOffset;
  FSaveData[Result].Font := TvxFont.Create;
  FSaveData[Result].Font.Assign(Font);
end;

procedure TvxCanvasQuartz.RestoreCanvas(const AState: cardinal);
begin
  if CGContextRef(Handle) = nil then
    Exit;

  if (AState >= 0) and (AState < Length(FSaveData)) then
  begin
    CGContextRestoreGState(CGContextRef(Handle));
    FSaveData[AState].Index := InvalideCanvasState;

    FMatrix := FSaveData[AState].Matrix;
    Stroke.Assign(FSaveData[AState].Stroke);
    FSaveData[AState].Stroke.Free;
    Fill.Assign(FSaveData[AState].Fill);
    FSaveData[AState].Fill.Free;
    SetMatrix(FMatrix);
    FStrokeThickness := FSaveData[AState].StrokeThickness;
    FStrokeCap := FSaveData[AState].StrokeCap;
    FStrokeJoin := FSaveData[AState].StrokeJoin;
    FStrokeDash := FSaveData[AState].StrokeDash;
    if StrokeDash <> vgDashSolid then
    begin
      SetLength(FDash, Length(FSaveData[AState].Dash));
      System.Move(FSaveData[AState].Dash[0], FDash[0], SizeOf(FDash[0]) * Length(FDash));
    end;
    FDashOffset := FSaveData[AState].DashOffset;
    Font.Assign(FSaveData[AState].Font);
    FSaveData[AState].Font.Free;
  end
end;

procedure TvxCanvasQuartz.SetClipRects(const ARects: array of TvxRect);
var
  i: integer;
  Rcts: array of CGRect;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if not FBuffered then
    Exit;

  SetLength(Rcts, Length(ARects));
  for i := 0 to High(ARects) do
  begin
    Rcts[i] := CGRectFromRect(ARects[i]);
  end;
  CGContextClipToRects(CGContextRef(Handle), @Rcts[0], Length(Rcts));
end;

procedure TvxCanvasQuartz.IntersectClipRect(const ARect: TvxRect);
begin
  if CGContextRef(Handle) = nil then
    Exit;
  CGContextClipToRect(CGContextRef(Handle), CGRectFromRect(ARect));
end;

procedure TvxCanvasQuartz.ExcludeClipRect(const ARect: TvxRect);
var
  R: TvxRect;
  RR: array[0..3] of CGRect;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  R := ARect;
  RR[0] := CGRectFromRect(vgRect(0, 0, R.Left, FHeight));
  RR[1] := CGRectFromRect(vgRect(R.Right, 0, FWidth, FHeight));
  RR[2] := CGRectFromRect(vgRect(R.Left, 0, R.Right, R.Top));
  RR[3] := CGRectFromRect(vgRect(R.Left, R.Bottom, R.Right, FHeight));
  CGContextClipToRects(CGContextRef(Handle), @RR[0], 4);
end;

procedure TvxCanvasQuartz.ResetClipRect;
begin
  if not FBuffered then
    Exit;
  if CGContextRef(Handle) = nil then
    Exit;
  if CGContextRef(Handle) <> nil then
    CGContextRelease(CGContextRef(Handle));
  if FBitmap <> nil then
  begin
    UpdateBitmap(FBitmap);
    Handle := FBitmap.Handle;
  end
  else
  begin
    Handle := THandle(CGBitmapContextCreate(FBufferBits, FWidth, FHeight, 8,
      FWidth * 4, CGColorSpaceCreateDeviceRGB, kCGImageAlphaPremultipliedLast));
  end;
end;

var
  ShadeOpacity: single;

procedure myLinearShadingValues(info: Pointer; inp: {const} Float32Ptr; val: Float32Ptr); cdecl;
var
  c: TvxColor;
begin
  if info <> nil then
  begin
    c := vgOpacity(TvxGradient(info).InterpolateColor(inp^), ShadeOpacity);
    val^ := TvxColorRec(c).R / $FF;
    Inc(val);
    val^ := TvxColorRec(c).G / $FF;
    Inc(val);
    val^ := TvxColorRec(c).B / $FF;
    Inc(val);
    val^ := TvxColorRec(c).A / $FF;
    Inc(val);
  end;
end;

procedure TvxCanvasQuartz.ApplyFill(ARect: TvxRect; const AOpacity: single);
begin
  if CGContextRef(Handle) = nil then
    Exit;

  if (FFill.Style = vgBrushResource) and (FFill.Resource <> nil) and (FFill.Resource.Brush <> nil) then
    FFill.Assign(FFill.Resource.Brush);

  with FFill do
  begin
    case Style of
      vgBrushSolid:
        begin
          with CGColor(SolidColor, AOpacity) do
            CGContextSetRGBFillColor(CGContextRef(Handle), r, g, b, a);
        end;
      vgBrushGradient:
        begin
          Callback.version := 0;
          Callback.evaluate := @myLinearShadingValues;
          Callback.releaseInfo := nil;
          ShadeOpacity := AOpacity;
          Func := CGFunctionCreate(FFill.Gradient, 1, @inputRange, 4, nil, Callback);
          ColorSpace := CGColorSpaceCreateDeviceRGB();
          Shading := CGShadingCreateAxial(ColorSpace,
            CGPoint(vgPoint(ARect.Left + Gradient.StartPosition.X * ARect.Right, ARect.Top + Gradient.StartPosition.Y * ARect.Bottom)),
            CGPoint(vgPoint(ARect.Left + Gradient.StopPosition.X * ARect.Right, ARect.Top + Gradient.StopPosition.Y * ARect.Bottom)),
            Func,
            1, 1);
        end;
      vgBrushResource:
        begin
        end;
      vgBrushVisual:
        begin
        end;
      vgBrushBitmap:
        begin
          if (Bitmap.Bitmap <> nil) and (Bitmap.Bitmap.Width > 0) and (Bitmap.Bitmap.Height > 0) then
          begin
            UpdateBitmap(Bitmap.Bitmap);
            if (Bitmap.Bitmap.Handle <> 0) then
            begin
              CGContextSetAlpha(CGContextRef(Handle), AOpacity);
              BitmapRef := CGBitmapContextCreateImage(CGContextRef(Bitmap.Bitmap.Handle));
            end;
          end;
        end;
    else
      CGContextSetRGBFillColor(CGContextRef(Handle), 0, 0, 0, 0);
    end;
  end;
end;

procedure TvxCanvasQuartz.DeApplyFill(ARect: TvxRect; const AOpacity: single);
begin
  if CGContextRef(Handle) = nil then
    Exit;

  with FFill do
  begin
    case Style of
      vgBrushSolid:
        begin
        end;
      vgBrushGradient:
        begin
          CGShadingRelease(Shading);
          CGColorSpaceRelease(ColorSpace);
          CGFunctionRelease(Func);
        end;
      vgBrushResource:
        begin
        end;
      vgBrushVisual:
        begin
        end;
      vgBrushBitmap:
        begin
          CGContextSetAlpha(CGContextRef(Handle), 1);
          CFRelease(BitmapRef);
        end;
    end;
  end;
  Shading := nil;
  BitmapRef := nil;
end;

procedure TvxCanvasQuartz.ApplyStroke(ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  dash: array of single;
begin
  if CGContextRef(Handle) = nil then
    Exit;

  if (FStroke.Style = vgBrushResource) and (FStroke.Resource <> nil) and (FStroke.Resource.Brush <> nil) then
    FStroke.Assign(FStroke.Resource.Brush);

  with FStroke do
  begin
    case Style of
      vgBrushSolid:
        begin
          with CGColor(SolidColor, AOpacity) do
            CGContextSetRGBStrokeColor(CGContextRef(Handle), r, g, b, a);
        end;
      vgBrushGradient:
        begin
        end;
      vgBrushBitmap:
        begin
          {          if (Bitmap.Bitmap <> nil) and (Bitmap.Bitmap.Width > 0) and (Bitmap.Bitmap.Height > 0) then
                    begin
                      UpdateBitmap(Bitmap.Bitmap);
                      if (Bitmap.Bitmap.Handle <> 0) then
                      begin
                        if Bitmap.WrapMode <> vgWrapTileStretch then
                          FGPPenBrush := TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle), TWrapMode(Bitmap.WrapMode))
                        else
                        begin
                          FGPPenBrush := TGPTextureBrush.Create(TGPBitmap(Bitmap.Bitmap.Handle), WrapModeClamp);
                          TGPTextureBrush(FGPPenBrush).ScaleTransform(vgRectWidth(ARect) / Bitmap.Bitmap.Width, vgRectHeight(ARect) / Bitmap.Bitmap.Height);
                        end;
                      end
                      else
                        FGPPenBrush := TGPSolidBrush.Create($00000000);
                    end
                    else
                      FGPPenBrush := TGPSolidBrush.Create($00000000);}
        end;
    else
      CGContextSetRGBStrokeColor(CGContextRef(Handle), 0, 0, 0, 0);
    end;
  end;
  case StrokeCap of
    vgCapFlat: CGContextSetLineCap(CGContextRef(Handle), kCGLineCapButt);
    vgCapRound: CGContextSetLineCap(CGContextRef(Handle), kCGLineCapRound);
  end;
  if Length(FDash) > 0 then
  begin
    SetLength(dash, Length(FDash));
    for i := 0 to High(FDash) do
    begin
      dash[i] := FDash[i] * StrokeThickness;
      if (StrokeCap = vgCapRound) then
      begin
        if odd(i) then
          dash[i] := (FDash[i] + 1) * StrokeThickness
        else
          dash[i] := (FDash[i] - 1) * StrokeThickness;
      end;
    end;
    CGContextSetLineDash(CGContextRef(Handle), FDashOffset, @dash[0], Length(FDash));
  end
  else
    CGContextSetLineDash(CGContextRef(Handle), 0, nil, 0);
  case StrokeJoin of
    vgJoinMiter: CGContextSetLineJoin(CGContextRef(Handle), kCGLineJoinMiter);
    vgJoinRound: CGContextSetLineJoin(CGContextRef(Handle), kCGLineJoinRound);
    vgJoinBevel: CGContextSetLineJoin(CGContextRef(Handle), kCGLineJoinBevel);
  end;
  CGContextSetLineWidth(CGContextRef(Handle), StrokeThickness);
end;

procedure TvxCanvasQuartz.FontChanged(Sender: TObject);
begin
end;

procedure TvxCanvasQuartz.DrawLine(const APt1, APt2: TvxPoint; const AOpacity: single);
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(vgRect(APt1.X, APt1.Y, APt2.X, APt2.Y), AOpacity);
    CGContextBeginPath(CGContextRef(Handle));
    CGContextMoveToPoint(CGContextRef(Handle), APt1.X, APt1.Y);
    CGContextAddLineToPoint(CGContextRef(Handle), APt2.X, APt2.Y);
    CGContextClosePath(CGContextRef(Handle));
    CGContextStrokePath(CGContextRef(Handle));
  end;
end;

procedure TvxCanvasQuartz.DrawRect(const ARect: TvxRect;
  const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(ARect, AOpacity);
    if (xRadius < Epsilon) and (yRadius < Epsilon) then
    begin
      CGContextStrokeRect(CGContextRef(Handle), CGRectFromRect(ARect));
    end
    else
    begin
      R := ARect;
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := vgRectWidth(R) / 2;
      x2 := xRadius * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := vgRectHeight(R) / 2;
      y2 := yRadius * CurveKappaInv;
      CGContextBeginPath(CGContextRef(Handle));
      CGContextMoveToPoint(CGContextRef(Handle), R.Left, R.Top + y1);
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x2, R.Top + y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top + y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Top);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top);
      end;
      CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Top);
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top + y1);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Top + y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x2, R.Top + y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top + y1);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top + y1);
      end;
      CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Bottom - y1);
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x2, R.Bottom - y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom - y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Bottom);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom);
      end;
      CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Bottom);
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom - y1);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Bottom - y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x2, R.Bottom - y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom - y1);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom - y1);
      end;
      CGContextClosePath(CGContextRef(Handle));
      CGContextStrokePath(CGContextRef(Handle));
    end;
  end;
end;

procedure TvxCanvasQuartz.FillRect(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FFill.Style <> vgBrushNone then
  begin
    CGContextSaveGState(CGContextRef(Handle));
    ApplyFill(ARect, AOpacity);

    CGContextBeginPath(CGContextRef(Handle));
    if (xRadius < Epsilon) and (yRadius < Epsilon) then
    begin
      CGContextAddRect(CGContextRef(Handle), CGRectFromRect(ARect));
    end
    else
    begin
      R := ARect;
      x1 := xRadius;
      if vgRectWidth(R) - (x1 * 2) < 0 then
        x1 := vgRectWidth(R) / 2;
      x2 := xRadius * CurveKappaInv;
      y1 := yRadius;
      if vgRectHeight(R) - (y1 * 2) < 0 then
        y1 := vgRectHeight(R) / 2;
      y2 := yRadius * CurveKappaInv;
      CGContextMoveToPoint(CGContextRef(Handle), R.Left, R.Top + y1);
      if vgCornerTopLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Left + x2, R.Top + y1, R.Left + x1, R.Top + y2, R.Left + x1, R.Top);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x2, R.Top + y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top + y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Left, R.Top + (y2), R.Left + x2, R.Top, R.Left + x1, R.Top)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Top);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Top);
      end;
      CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Top);
      if vgCornerTopRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top + y1);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Right - x1, R.Top + y2, R.Right - x2, R.Top + y1, R.Right, R.Top + y1);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Top + y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x2, R.Top + y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top + y1);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Right - x2, R.Top, R.Right, R.Top + (y2), R.Right, R.Top + y1)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Top + y1);
      end;
      CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Bottom - y1);
      if vgCornerBottomRight in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Right - x2, R.Bottom - y1, R.Right - x1, R.Bottom - y2, R.Right - x1, R.Bottom);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x2, R.Bottom - y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom - y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Right, R.Bottom - (y2), R.Right - x2, R.Bottom, R.Right - x1, R.Bottom)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right, R.Bottom);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Right - x1, R.Bottom);
      end;
      CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Bottom);
      if vgCornerBottomLeft in ACorners then
      begin
        case ACornerType of
          // vgCornetRound - default
          vgCornerBevel: CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom - y1);
          vgCornerInnerRound: CGContextAddCurveToPoint(CGContextRef(Handle), R.Left + x1, R.Bottom - y2, R.Left + x2, R.Bottom - y1, R.Left, R.Bottom - y1);
          vgCornerInnerLine:
            begin
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x1, R.Bottom - y2);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left + x2, R.Bottom - y1);
              CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom - y1);
            end;
        else
          CGContextAddCurveToPoint(CGContextRef(Handle), R.Left + x2, R.Bottom, R.Left, R.Bottom - (y2), R.Left, R.Bottom - y1)
        end;
      end
      else
      begin
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom);
        CGContextAddLineToPoint(CGContextRef(Handle), R.Left, R.Bottom - y1);
      end;
    end;
    CGContextClosePath(CGContextRef(Handle));

    if (BitmapRef <> nil) and (FFill.Bitmap.Bitmap.Handle <> 0) then
    begin
      CGContextClip(CGContextRef(Handle));
      case FFill.Bitmap.WrapMode of
        vgWrapTile:
          begin
            CGContextScaleCTM(CGContextRef(Handle), 1, -1);
            CGContextDrawTiledImage(CGContextRef(Handle), ARect, BitmapRef, FFill.Bitmap.Bitmap);
          end;
        vgWrapTileOriginal:
          begin
            CGContextScaleCTM(CGContextRef(Handle), 1, -1);
            CGContextDrawImage(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left, ARect.Top, ARect.Left + FFill.Bitmap.Bitmap.Width, -ARect.Top - FFill.Bitmap.Bitmap.Height)), BitmapRef);
          end;
        vgWrapTileStretch:
          begin
            CGContextScaleCTM(CGContextRef(Handle), 1, -1);
            CGContextDrawImage(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left, ARect.Top, ARect.Right, -ARect.Bottom)), BitmapRef);
          end;
      end;
    end
    else
      if Shading <> nil then
    begin
      CGContextClip(CGContextRef(Handle));
      CGContextDrawShading(CGContextRef(Handle), Shading)
    end
    else
      CGContextFillPath(CGContextRef(Handle));

    DeApplyFill(ARect, AOpacity);
    CGContextRestoreGState(CGContextRef(Handle));
  end;
end;

procedure TvxCanvasQuartz.DrawEllipse(const ARect: TvxRect; const AOpacity: single);
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FStroke.Style <> vgBrushNone then
  begin
    ApplyStroke(ARect, AOpacity);
    CGContextStrokeEllipseInRect(CGContextRef(Handle), CGRectFromRect(ARect));
  end;
end;

procedure TvxCanvasQuartz.FillEllipse(const ARect: TvxRect; const AOpacity: single);
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FFill.Style <> vgBrushNone then
  begin
    CGContextSaveGState(CGContextRef(Handle));
    ApplyFill(ARect, AOpacity);

    CGContextBeginPath(CGContextRef(Handle));
    CGContextAddEllipseInRect(CGContextRef(Handle), CGRectFromRect(ARect));
    CGContextClosePath(CGContextRef(Handle));

    if (BitmapRef <> nil) and (FFill.Bitmap.Bitmap.Handle <> 0) then
    begin
      CGContextClip(CGContextRef(Handle));
      case FFill.Bitmap.WrapMode of
        vgWrapTile:
          begin
            CGContextScaleCTM(CGContextRef(Handle), 1, -1);
            CGContextDrawTiledImage(CGContextRef(Handle), ARect, BitmapRef, FFill.Bitmap.Bitmap);
          end;
        vgWrapTileOriginal:
          begin
            CGContextScaleCTM(CGContextRef(Handle), 1, -1);
            CGContextDrawImage(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left, ARect.Top, ARect.Left + FFill.Bitmap.Bitmap.Width, -ARect.Top - FFill.Bitmap.Bitmap.Height)), BitmapRef);
          end;
        vgWrapTileStretch:
          begin
            CGContextScaleCTM(CGContextRef(Handle), 1, -1);
            CGContextDrawImage(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left, ARect.Top, ARect.Right, -ARect.Bottom)), BitmapRef);
          end;
      end;
    end
    else
      if Shading <> nil then
    begin
      CGContextClip(CGContextRef(Handle));
      CGContextDrawShading(CGContextRef(Handle), Shading)
    end
    else
      CGContextFillPath(CGContextRef(Handle));

    DeApplyFill(ARect, AOpacity);
    CGContextRestoreGState(CGContextRef(Handle));
  end;
end;

{ Bitmaps }

procedure TvxCanvasQuartz.DrawBitmap(const ABitmap: TvxBitmap;
  const SrcRect, DstRect: TvxRect; const AOpacity: single; const HighSpeed: boolean = false);
var
  R, SubR: CGRect;
  ImgRef, SubImgRef: CGImageRef;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if ABitmap = nil then
    Exit;

  UpdateBitmap(ABitmap);
  if (ABitmap.Handle <> 0) then
  begin
    R := CGRectFromRect(DstRect);
    if (SrcRect.Left = 0) and (SrcRect.Top = 0) and (SrcRect.Right = ABitmap.Width) and (SrcRect.Bottom = ABitmap.Height) then
    begin
      ImgRef := CGBitmapContextCreateImage(CGContextRef(ABitmap.Handle));
      if ImgRef <> nil then
      begin
        CGContextSaveGState(CGContextRef(Handle));
        CGContextSetAlpha(CGContextRef(Handle), AOpacity);

        if HighSpeed then
          CGContextSetInterpolationQuality(CGContextRef(Handle), kCGInterpolationNone)
        else
          CGContextSetInterpolationQuality(CGContextRef(Handle), kCGInterpolationDefault);

        // flip
        R.origin.y := -DstRect.Bottom;
        CGContextScaleCTM(CGContextRef(Handle), 1, -1);
        //

        CGContextDrawImage(CGContextRef(Handle), R, ImgRef);

        CGContextRestoreGState(CGContextRef(Handle));

        CGImageRelease(ImgRef);
      end;
    end
    else
    begin
      SubR := CGRectFromRect(SrcRect);

      ImgRef := CGBitmapContextCreateImage(CGContextRef(ABitmap.Handle));
      if ImgRef <> nil then
      begin
        SubImgRef := CGImageCreateWithImageInRect(ImgRef, SubR);
        if SubImgRef <> nil then
        begin
          CGContextSaveGState(CGContextRef(Handle));
          CGContextSetAlpha(CGContextRef(Handle), AOpacity);
          if HighSpeed then
            CGContextSetInterpolationQuality(CGContextRef(Handle), kCGInterpolationNone)
          else
            CGContextSetInterpolationQuality(CGContextRef(Handle), kCGInterpolationDefault);

          // flip
          R.origin.y := -DstRect.Bottom;
          CGContextScaleCTM(CGContextRef(Handle), 1, -1);
          //
          CGContextDrawImage(CGContextRef(Handle), R, SubImgRef);
          CGImageRelease(SubImgRef);
          CGContextRestoreGState(CGContextRef(Handle));
        end;
        CGImageRelease(ImgRef);
      end;
    end;
  end;
end;

procedure TvxCanvasQuartz.UpdateBitmap(ABitmap: TvxBitmap);
var
  colorspace: CGColorSpaceRef;
begin
  { update bitmap to Quartz bitmap }
  if ABitmap = nil then
    Exit;
  { create - if need }
  if ABitmap.Handle = 0 then
  begin
    colorspace := CGColorSpaceCreateDeviceRGB;
    ABitmap.Handle := Cardinal(CGBitmapContextCreate(ABitmap.StartLine, ABitmap.Width, ABitmap.Height, 8,
      ABitmap.Width * 4, colorspace, kCGImageAlphaPremultipliedLast));
    CGColorSpaceRelease(colorspace);
  end;
  { clear flag }
  ABitmap.NeedUpdate := false;
  ABitmap.OnDestroyHandle := DoDestroyBitmap;
end;

procedure TvxCanvasQuartz.DoDestroyBitmap(Sender: TObject);
begin
  if (Sender <> nil) then
  begin
    if (TvxBitmap(Sender).Handle <> 0) then
      CGContextRelease(CGContextRef(TvxBitmap(Sender).Handle));
    TvxBitmap(Sender).Handle := 0;
  end;
end;
{ Path }

procedure TvxCanvasQuartz.DrawPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FStroke.Style = vgBrushNone then
    Exit;
  if APath.IsEmpty then
    Exit;
  ApplyStroke(ARect, AOpacity);
  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);
  { draw }
  CGContextSaveGState(CGContextRef(Handle));
  CGContextBeginPath(CGContextRef(Handle));
  i := 0;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          CGContextMoveToPoint(CGContextRef(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointLineTo:
        begin
          CGContextAddLineToPoint(CGContextRef(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CGContextAddCurveToPoint(CGContextRef(Handle), CP1.X,
            CP1.Y,
            CP2.X,
            CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointClose:
        begin
          CGContextClosePath(CGContextRef(Handle));
        end;
    end;
    inc(i);
  end;
  CGContextStrokePath(CGContextRef(Handle));
  CGContextRestoreGState(CGContextRef(Handle));
end;

procedure TvxCanvasQuartz.FillPath(const APath: TvxPathData; const ARect: TvxRect; const AOpacity: single);
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FFill.Style = vgBrushNone then
    Exit;
  if APath.IsEmpty then
    Exit;

  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);

  ApplyFill(ARect, AOpacity);
  CGContextSaveGState(CGContextRef(Handle));
  i := 0;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          CGContextMoveToPoint(CGContextRef(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointLineTo:
        begin
          CGContextAddLineToPoint(CGContextRef(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CGContextAddCurveToPoint(CGContextRef(Handle), CP1.X,
            CP1.Y,
            CP2.X,
            CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointClose:
        begin
          CGContextClosePath(CGContextRef(Handle));
        end;
    end;
    inc(i);
  end;

  if (BitmapRef <> nil) and (FFill.Bitmap.Bitmap.Handle <> 0) then
  begin
    CGContextClip(CGContextRef(Handle));
    case FFill.Bitmap.WrapMode of
      vgWrapTile:
        begin
          CGContextScaleCTM(CGContextRef(Handle), 1, -1);
          CGContextDrawTiledImage(CGContextRef(Handle), ARect, BitmapRef, FFill.Bitmap.Bitmap);
        end;
      vgWrapTileOriginal:
        begin
          CGContextScaleCTM(CGContextRef(Handle), 1, -1);
          CGContextDrawImage(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left, ARect.Top, ARect.Left + FFill.Bitmap.Bitmap.Width, -ARect.Top - FFill.Bitmap.Bitmap.Height)), BitmapRef);
        end;
      vgWrapTileStretch:
        begin
          CGContextScaleCTM(CGContextRef(Handle), 1, -1);
          CGContextDrawImage(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left, ARect.Top, ARect.Right, -ARect.Bottom)), BitmapRef);
        end;
    end;
  end
  else
    if Shading <> nil then
  begin
    CGContextClip(CGContextRef(Handle));
    CGContextDrawShading(CGContextRef(Handle), Shading)
  end
  else
    CGContextFillPath(CGContextRef(Handle));

  DeApplyFill(ARect, AOpacity);
  CGContextRestoreGState(CGContextRef(Handle));
end;

function TvxCanvasQuartz.PtInPath(const APoint: TvxPoint; const ARect: TvxRect; const APath: TvxPathData): boolean;
var
  i: integer;
  B: TvxRect;
  W, H, NewW, NewH: single;
  CP1, CP2: TvxPoint;
begin
  Result := false;
  if CGContextRef(Handle) = nil then
    Exit;
  if APath.IsEmpty then
    Exit;
  B := APath.GetBounds;
  W := vgRectWidth(B);
  H := vgRectHeight(B);
  NewW := vgRectWidth(ARect);
  NewH := vgRectHeight(ARect);
  { draw }
  CGContextSaveGState(CGContextRef(Handle));
  CGContextTranslateCTM(CGContextRef(Handle), ARect.Left, ARect.Top);
  CGContextBeginPath(CGContextRef(Handle));
  i := 0;
  while i < Length(APath.PathData) do
  begin
    case APath.PathData[i].Kind of
      vgPathPointMoveTo:
        begin
          CGContextMoveToPoint(CGContextRef(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointLineTo:
        begin
          CGContextAddLineToPoint(CGContextRef(Handle), ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointCurveTo:
        begin
          CP1 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CP2 := vgPoint(ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
          Inc(i);
          CGContextAddCurveToPoint(CGContextRef(Handle), CP1.X,
            CP1.Y,
            CP2.X,
            CP2.Y,
            ARect.Left + (APath.PathData[i].Point.X - B.Left) / W * NewW,
            ARect.Top + (APath.PathData[i].Point.Y - B.Top) / H * NewH);
        end;
      vgPathPointClose:
        begin
          CGContextClosePath(CGContextRef(Handle));
        end;
    end;
    inc(i);
  end;
  CGContextRestoreGState(CGContextRef(Handle));
  Result := CGContextPathContainsPoint(CGContextRef(Handle), CGPoint(APoint), kCGPathFillStroke) > 0;
end;

procedure TvxCanvasQuartz.FillText(const ARect, AClipRect: TvxRect; const AText: WideString; const WordWrap: boolean;
  const AOpacity: single; const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign = vgTextAlignCenter);
var
  TextR: TvxRect;
  Values: array[0..10] of ATSUAttributeValuePtr;
  Tags: array[0..10] of ATSUAttributeTag;
  Sizes: array[0..10] of ByteCount;
  myStyles: ATSUStyle;
  myTextLayout: ATSUTextLayout;
  myFont: ATSUFontID;
  atsuSize: Fixed;
  atsuItalic, atsuBold: boolean;
  lineTrunc: ATSULineTruncation;
  i, lineWidth: cardinal;
  textAlign: fract;
  CLeft, CRight, CTop, CBottom: Fixed;
  numSoftBreaks: integer;
  currentStart, currentEnd, layoutStart, layoutLength: UniCharArrayOffset;
  softBreaks: array[0..100] of UniCharArrayOffset;
  HorizontalOffset, VerticalOffset: single;
  S: string;
begin
  if CGContextRef(Handle) = nil then
    Exit;
  if FFill.Style = vgBrushNone then
    Exit;
  if Length(AText) = 0 then
    Exit;

  {  TextR := ARect;
    MeasureText(TextR, ARect, AText, WordWrap, ATextAlign, AVTextAlign);
    Stroke.Style := vgBrushSolid;
    Stroke.SolidColor := $A0FF0000;
    DrawRect(TextR, 2, 2, AllCorners, 1);}

  ApplyFill(ARect, AOpacity);
  { Create ATSU }
  ATSUCreateStyle(myStyles);
  // font
  S := Font.Family;
  if ATSUFindFontFromName(@S[1], Length(S), kFontFamilyName, kFontNoPlatform, kFontNoScript, kFontNoLanguage, myFont) = noErr then
  begin
    Tags[0] := kATSUFontTag;
    Sizes[0] := sizeof(ATSUFontId);
    Values[0] := @myFont;
    ATSUSetAttributes(myStyles, 1, Tags, Sizes, Values);
  end;
  // style
  atsuSize := Round(Font.Size * $FFFF);
  atsuBold := Font.Style in [vgFontBold, vgFontBoldItalic];
  atsuItalic := Font.Style in [vgFontItalic, vgFontBoldItalic];

  Tags[0] := kATSUSizeTag;
  Sizes[0] := sizeof(Fixed);
  Values[0] := @atsuSize;
  Tags[1] := kATSUQDBoldFaceTag;
  Sizes[1] := sizeof(boolean);
  Values[1] := @atsuBold;
  Tags[2] := kATSUQDItalicTag;
  Sizes[2] := sizeof(boolean);
  Values[2] := @atsuItalic;
  ATSUSetAttributes(myStyles, 3, Tags, Sizes, Values);
  // layout
  myTextLayout := nil;
  ATSUCreateTextLayout(myTextLayout);
  // set context
  Tags[0] := kATSUCGContextTag;
  Sizes[0] := SizeOf(CGContextRef);
  Values[0] := @CGContextRef(Handle);
  // set align
  Tags[1] := kATSULineFlushFactorTag;
  Sizes[1] := SizeOf(textAlign);
  if WordWrap then
  begin
    case ATextAlign of
      vgTextAlignCenter:
        begin
          textAlign := kATSUCenterAlignment;
        end;
      vgTextAlignNear:
        begin
          textAlign := kATSUStartAlignment;
        end;
      vgTextAlignFar:
        begin
          textAlign := kATSUEndAlignment;
        end;
    end;
  end
  else
    textAlign := kATSUStartAlignment;
  Values[1] := @textAlign;
  // line width
  if WordWrap then
    lineWidth := Trunc(vgRectWidth(ARect) * $FFFF)
  else
    lineWidth := 5000 * $FFFF;
  if lineWidth <= 0 then
    lineWidth := 1;
  Tags[2] := kATSULineWidthTag;
  Sizes[2] := SizeOf(lineWidth);
  Values[2] := @lineWidth;
  // line trunk - set ...
  lineTrunc := kATSUTruncateNone;
  Tags[3] := kATSULineTruncationTag;
  Sizes[3] := SizeOf(lineTrunc);
  Values[3] := @lineTrunc;
  ATSUSetLayoutControls(myTextLayout, 4, Tags, Sizes, Values);
  // set text
  ATSUSetTextPointerLocation(myTextLayout,
    ConstUniCharArrayPtr(PWideChar(AText)),
    kATSUFromTextBeginning,
    kATSUToTextEnd,
    Length(AText));
  ATSUSetRunStyle(myTextLayout,
    myStyles,
    kATSUFromTextBeginning,
    kATSUToTextEnd);
  ATSUSetTransientFontMatching(myTextLayout, true);
  // set breacks
  ATSUBatchBreakLines(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, lineWidth, @numSoftBreaks);
  // calc size
  CGContextSaveGState(CGContextRef(Handle));
  // Intersect
  CGContextClipToRect(CGContextRef(Handle), CGRectFromRect(vgRect(ARect.Left - 1, ARect.Top - 1, ARect.Right + 1, ARect.Bottom + 3)));
  // Scale
  CGContextScaleCTM(CGContextRef(Handle), 1, -1);
  // vertical aligning using numSoftBreaks
  case AVTextAlign of
    vgTextAlignCenter:
      VerticalOffset := (vgRectHeight(ARect) - ((numSoftBreaks + 0.5) * Font.Size * 1.33)) / 2;
    vgTextAlignNear:
      VerticalOffset := vgRectHeight(ARect) - ((numSoftBreaks + 0.75) * Font.Size * 1.33);
    vgTextAlignFar:
      VerticalOffset := 0.25 * Font.Size * 1.33;
  end;
  // final draw
  if numSoftBreaks = 0 then
  begin
    if not WordWrap then
    begin
      CLeft := 0;
      CTop := 0;
      Cright := 0;
      CBottom := 0;
      ATSUGetUnjustifiedBounds(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, CLeft, CRight, CTop, CBottom);
      case ATextAlign of
        vgTextAlignCenter:
          HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect)) / 2;
        vgTextAlignFar:
          HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect));
      else
        HorizontalOffset := 0;
      end;
    end
    else
      HorizontalOffset := 0;
    ATSUDrawText(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, (Trunc(ARect.Left + HorizontalOffset) * $FFFF), (Trunc(-ARect.Bottom + VerticalOffset) * $FFFF));
  end
  else
  begin
    ATSUGetSoftLineBreaks(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, numSoftBreaks, @softBreaks[0], @numSoftBreaks);
    ATSUGetTextLocation(myTextLayout, nil, nil, @layoutStart, @layoutLength, nil);
    currentStart := layoutStart;
    for i := 0 to numSoftBreaks do
    begin
      if (numSoftBreaks > i) then
        currentEnd := softBreaks[i]
      else
        currentEnd := layoutStart + layoutLength;
      if not WordWrap then
      begin
        CLeft := 0;
        CTop := 0;
        Cright := 0;
        CBottom := 0;
        ATSUGetUnjustifiedBounds(myTextLayout, currentStart, currentEnd - currentStart, CLeft, CRight, CTop, CBottom);
        case ATextAlign of
          vgTextAlignCenter:
            HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect)) / 2;
          vgTextAlignFar:
            HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect));
        else
          HorizontalOffset := 0;
        end;
      end
      else
        HorizontalOffset := 0;
      ATSUDrawText(myTextLayout, currentStart, currentEnd - currentStart, Round((ARect.Left + HorizontalOffset) * $FFFF), Round((-ARect.Bottom + VerticalOffset + ((numSoftBreaks - i) * Font.Size * 1.33)) * $FFFF));
      currentStart := currentEnd;
    end;
  end;
  // restore
  CGContextRestoreGState(CGContextRef(Handle));
  // dispose
  ATSUDisposeTextLayout(myTextLayout);
  ATSUDisposeStyle(myStyles);
  DeApplyFill(ARect, AOpacity);
end;

procedure TvxCanvasQuartz.MeasureText(var ARect: TvxRect; AClipRect: TvxRect;
  const AText: WideString; const WordWrap: boolean;
  const ATextAlign: TvxTextAlign; const AVTextAlign: TvxTextAlign);
var
  curR, TextR: TvxRect;
  Values: array[0..10] of ATSUAttributeValuePtr;
  Tags: array[0..10] of ATSUAttributeTag;
  Sizes: array[0..10] of ByteCount;
  myStyles: ATSUStyle;
  myTextLayout: ATSUTextLayout;
  myFont: ATSUFontID;
  atsuSize: Fixed;
  atsuItalic, atsuBold: boolean;
  lineTrunc: ATSULineTruncation;
  i, lineWidth: cardinal;
  textAlign: fract;
  CLeft, CRight, CTop, CBottom: Fixed;
  numSoftBreaks: integer;
  currentStart, currentEnd, layoutStart, layoutLength: UniCharArrayOffset;
  softBreaks: array[0..100] of UniCharArrayOffset;
  HorizontalOffset, VerticalOffset: single;
  S: string;
begin
  if Length(AText) = 0 then
  begin
    ARect.Right := ARect.Left;
    Exit;
  end;
  { Create ATSU }
  ATSUCreateStyle(myStyles);
  // font
  S := Font.Family;
  if ATSUFindFontFromName(@S[1], Length(S), kFontFamilyName, kFontNoPlatform, kFontNoScript, kFontNoLanguage, myFont) = noErr then
  begin
    Tags[0] := kATSUFontTag;
    Sizes[0] := sizeof(ATSUFontId);
    Values[0] := @myFont;
    ATSUSetAttributes(myStyles, 1, Tags, Sizes, Values);
  end;
  // style
  atsuSize := Round(Font.Size * $FFFF);
  atsuBold := Font.Style in [vgFontBold, vgFontBoldItalic];
  atsuItalic := Font.Style in [vgFontItalic, vgFontBoldItalic];
  Tags[0] := kATSUSizeTag;
  Sizes[0] := sizeof(Fixed);
  Values[0] := @atsuSize;
  Tags[1] := kATSUQDBoldfaceTag;
  Sizes[1] := sizeof(boolean);
  Values[1] := @atsuBold;
  Tags[2] := kATSUQDItalicTag;
  Sizes[2] := sizeof(boolean);
  Values[2] := @atsuItalic;
  ATSUSetAttributes(myStyles, 3, Tags, Sizes, Values);
  // layout
  myTextLayout := nil;
  ATSUCreateTextLayout(myTextLayout);
  // set context
  Tags[0] := kATSUCGContextTag;
  Sizes[0] := SizeOf(CGContextRef);
  Values[0] := @CGContextRef(Handle);
  // set align
  Tags[1] := kATSULineFlushFactorTag;
  Sizes[1] := SizeOf(textAlign);
  if WordWrap then
  begin
    case ATextAlign of
      vgTextAlignCenter:
        begin
          textAlign := kATSUCenterAlignment;
        end;
      vgTextAlignNear:
        begin
          textAlign := kATSUStartAlignment;
        end;
      vgTextAlignFar:
        begin
          textAlign := kATSUEndAlignment;
        end;
    end;
  end
  else
    textAlign := kATSUStartAlignment;
  Values[1] := @textAlign;
  // line width
  if WordWrap then
    lineWidth := Trunc(vgRectWidth(ARect) * $FFFF)
  else
    lineWidth := 5000 * $FFFF;
  if lineWidth <= 0 then
    lineWidth := 1;
  Tags[2] := kATSULineWidthTag;
  Sizes[2] := SizeOf(lineWidth);
  Values[2] := @lineWidth;
  // line trunk - set ...
  lineTrunc := kATSUTruncateNone;
  Tags[3] := kATSULineTruncationTag;
  Sizes[3] := SizeOf(lineTrunc);
  Values[3] := @lineTrunc;
  ATSUSetLayoutControls(myTextLayout, 4, Tags, Sizes, Values);
  // set text
  ATSUSetTextPointerLocation(myTextLayout,
    ConstUniCharArrayPtr(PWideChar(AText)),
    kATSUFromTextBeginning,
    kATSUToTextEnd,
    Length(AText));
  ATSUSetRunStyle(myTextLayout,
    myStyles,
    kATSUFromTextBeginning,
    kATSUToTextEnd);
  ATSUSetTransientFontMatching(myTextLayout, true);
  // set breacks
  ATSUBatchBreakLines(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, lineWidth, @numSoftBreaks);
  // vertical aligning using numSoftBreaks
  case AVTextAlign of
    vgTextAlignCenter:
      VerticalOffset := (vgRectHeight(ARect) - ((numSoftBreaks + 0.5) * Font.Size * 1.33)) / 2;
    vgTextAlignNear:
      VerticalOffset := vgRectHeight(ARect) - ((numSoftBreaks + 1) * Font.Size * 1.33);
    vgTextAlignFar:
      VerticalOffset := 0;
  end;
  // final draw
  if numSoftBreaks = 0 then
  begin
    ATSUGetUnjustifiedBounds(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, CLeft, CRight, CTop, CBottom);
    curR := vgRect(CLeft / $FFFF, CBottom / $FFFF, CRight / $FFFF, CTop / $FFFF);
    curR.Bottom := curR.Top + (Font.Size * 1.33);
    vgRectCenter(curR, curR);
    textR := curR;
  end
  else
  begin
    ATSUGetSoftLineBreaks(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, numSoftBreaks, @softBreaks[0], @numSoftBreaks);
    ATSUGetTextLocation(myTextLayout, nil, nil, @layoutStart, @layoutLength, nil);
    currentStart := layoutStart;
    for i := 0 to numSoftBreaks do
    begin
      if (numSoftBreaks > i) then
        currentEnd := softBreaks[i]
      else
        currentEnd := layoutStart + layoutLength;
      ATSUGetUnjustifiedBounds(myTextLayout, currentStart, currentEnd - currentStart, CLeft, CRight, CTop, CBottom);
      curR := vgRect(CLeft / $FFFF, CBottom / $FFFF, CRight / $FFFF, CTop / $FFFF);
      curR.Bottom := curR.Top + (Font.Size * 1.33);
      //      vgRectCenter(curR, curR);
      vgOffsetRect(CurR, 0, i * Font.Size * 1.33);
      if i = 0 then
        TextR := curR
      else
        TextR := vgUnionRect(TextR, curR);
      currentStart := currentEnd;
    end;
  end;
  // align
  case ATextAlign of
    vgTextAlignCenter:
      begin
        vgOffsetRect(TextR, -TextR.Left, 0);
        vgOffsetRect(TextR, Trunc((vgRectWidth(ARect) - vgRectWidth(TextR)) / 2), 0);
        vgOffsetRect(TextR, ARect.Left, 0);
      end;
    vgTextAlignNear:
      begin
        vgOffsetRect(TextR, -TextR.Left, 0);
        vgOffsetRect(TextR, ARect.Left, 0);
      end;
    vgTextAlignFar:
      begin
        vgOffsetRect(TextR, -TextR.Left, 0);
        vgOffsetRect(TextR, Trunc((vgRectWidth(ARect) - vgRectWidth(TextR))), 0);
        vgOffsetRect(TextR, ARect.Left, 0);
      end;
  end;
  case AVTextAlign of
    vgTextAlignCenter:
      begin
        vgOffsetRect(TextR, 0, -TextR.Top);
        vgOffsetRect(TextR, 0, Trunc((vgRectHeight(ARect) - vgRectHeight(TextR)) / 2));
        vgOffsetRect(TextR, 0, ARect.Top);
      end;
    vgTextAlignNear:
      begin
        vgOffsetRect(TextR, 0, -TextR.Top);
        vgOffsetRect(TextR, 0, ARect.Top);
      end;
    vgTextAlignFar:
      begin
        vgOffsetRect(TextR, 0, -TextR.Top);
        vgOffsetRect(TextR, 0, Trunc((vgRectHeight(ARect) - vgRectHeight(TextR))));
        vgOffsetRect(TextR, 0, ARect.Top);
      end;
  end;
  // result
  ARect := TextR;
  // dispose
  ATSUDisposeTextLayout(myTextLayout);
  ATSUDisposeStyle(myStyles);
end;

type

  ATSLayoutRecord = packed record
    // The glyph ID reference.
    glyphID: ATSGlyphRef;
    // These flags describe the individual state of the glyph (see above).
    flags: ATSGlyphInfoFlags;
    // The byte offset of the original character that spawned this glyph.
    originalOffset: ByteCount;
    // This is the real position that the glyph sits.
    realPos: Fixed;
  end;

  ATSLayoutRecordArray = array of ATSLayoutRecord;
  ATSLayoutRecordArray2 = array[0..0] of ATSLayoutRecord;
  PATSLayoutRecordArray2 = ^ATSLayoutRecordArray2;
  TYOffsets = array[0..0] of Fixed;
  PYOffsets = ^TYOffsets;

  Text3DCallback = packed record
    Path: TvxPathData;
    SP: ^TvxPoint;
    GlyphLayouts: ATSLayoutRecord;
    Height: single;
    XOffset, YOffset: single;
  end;

function MyCubicMoveToProc(const (*var*) pt: Float32Point; callBackDataPtr: Pointer): OSStatus; stdcall;
var
  G: Text3DCallback;
begin
  G := Text3DCallback(callBackDataPtr^);
  G.SP^ := vgPoint(G.XOffset + (G.GlyphLayouts.realPos / $FFFF) + pt.x, G.YOffset + pt.y);
  G.Path.MoveTo(vgPoint(G.XOffset + (G.GlyphLayouts.realPos / $FFFF) + pt.x, G.YOffset + pt.y));
  Result := noErr;
end;

function MyCubicLineToProc(const (*var*) pt: Float32Point; callBackDataPtr: Pointer): OSStatus; stdcall;
var
  G: Text3DCallback;
begin
  G := Text3DCallback(callBackDataPtr^);
  G.Path.LineTo(vgPoint(G.XOffset + (G.GlyphLayouts.realPos / $FFFF) + pt.x, G.YOffset + pt.y));
  Result := noErr;
end;

function MyCubicCurveToProc(const (*var*) pt, pt2, pt3: Float32Point; callBackDataPtr: Pointer): OSStatus; stdcall;
var
  G: Text3DCallback;
begin
  G := Text3DCallback(callBackDataPtr^);
  G.Path.CurveTo(vgPoint(G.XOffset + (G.GlyphLayouts.realPos / $FFFF) + pt.x, G.YOffset + pt.y),
    vgPoint(G.XOffset + (G.GlyphLayouts.realPos / $FFFF) + pt2.x, G.YOffset + pt2.y),
    vgPoint(G.XOffset + (G.GlyphLayouts.realPos / $FFFF) + pt3.x, G.YOffset + pt3.y));
  Result := noErr;
end;

function MyCubicClosePathProc(callBackDataPtr: Pointer): OSStatus; stdcall;
var
  G: Text3DCallback;
begin
  G := Text3DCallback(callBackDataPtr^);
  G.Path.ClosePath;
  Result := noErr;
end;

procedure GetGlyphIDsAndPositions(iLayout: ATSUTextLayout; iStart: UniCharArrayOffset; iLength: UniCharCount;
  var oGlyphRecordArray: ATSLayoutRecordArray; var oNumGlyphs: ItemCount);
var
  numDeltaYs: ItemCount;
  deltaYs: PYOffsets;
  MyGlyphRecordArray: PATSLayoutRecordArray2;
  i: integer;
begin
  // This block of code uses the new Direct Access APIs, which are only available on Mac OS X 10.2 and later systems
  // Get the arrays of glyph information
  ATSUDirectGetLayoutDataArrayPtrFromTextLayout(iLayout, iStart, kATSUDirectDataLayoutRecordATSLayoutRecordCurrent, @MyGlyphRecordArray, oNumGlyphs);
  ATSUDirectGetLayoutDataArrayPtrFromTextLayout(iLayout, iStart, kATSUDirectDataBaselineDeltaFixedArray, @deltaYs, numDeltaYs);
  // Build the array of MyGlyphRecords
  SetLength(oGlyphRecordArray, oNumGlyphs);
  for i := 0 to oNumGlyphs - 1 do
  begin
    // Fill in the glyphID
    oGlyphRecordArray[i] := MyGlyphRecordArray[i];
  end;
  // Free the arrays of glyph information
  if (deltaYs <> nil) then
    ATSUDirectReleaseLayoutDataArrayPtr(nil, kATSUDirectDataBaselineDeltaFixedArray, @deltaYs);
  ATSUDirectReleaseLayoutDataArrayPtr(nil, kATSUDirectDataLayoutRecordATSLayoutRecordCurrent, @MyGlyphRecordArray);
end;

function TvxCanvasQuartz.TextToPath(Path: TvxPathData; const ARect: TvxRect; const AText: WideString; const WordWrap: boolean; const ATextAlign: TvxTextAlign;
  const AVTextAlign: TvxTextAlign = vgTextAlignCenter): boolean;
var
  Values: array[0..10] of ATSUAttributeValuePtr;
  Tags: array[0..10] of ATSUAttributeTag;
  Sizes: array[0..10] of ByteCount;
  myStyles: ATSUStyle;
  myTextLayout: ATSUTextLayout;
  myFont: ATSUFontID;
  atsuSize: Fixed;
  atsuItalic, atsuBold: boolean;
  lineTrunc: ATSULineTruncation;
  i, j, lineWidth: cardinal;
  textAlign: fract;
  CLeft, CRight, CTop, CBottom: Fixed;
  numSoftBreaks: integer;
  currentStart, currentEnd, layoutStart, layoutLength: UniCharArrayOffset;
  softBreaks: array[0..100] of UniCharArrayOffset;
  S: string;
  Status: OSStatus;
  numGlyphs: cardinal;
  glyphArray: ATSLayoutRecordArray;
  moveToProc: ATSCubicMoveToUPP;
  lineToProc: ATSCubicLineToUPP;
  curveToProc: ATSCubicCurveToUPP;
  closePathProc: ATSCubicClosePathUPP;
  Data: Text3DCallback;
  VerticalOffset, HorizontalOffset, lineStep: single;
  Size: TvxPoint;
  SP: TvxPoint;
begin
  Result := false;
  if Length(AText) = 0 then
    Exit;
  Path.Clear;

  { Create ATSU }
  ATSUCreateStyle(myStyles);
  // font
  S := Font.Family;
  if ATSUFindFontFromName(@S[1], Length(S), kFontFamilyName, kFontNoPlatform, kFontNoScript, kFontNoLanguage, myFont) = noErr then
  begin
    Tags[0] := kATSUFontTag;
    Sizes[0] := sizeof(ATSUFontId);
    Values[0] := @myFont;
    ATSUSetAttributes(myStyles, 1, Tags, Sizes, Values);
  end;
  // style
  atsuSize := Round(Font.Size * $FFFF);
  atsuBold := Font.Style in [vgFontBold, vgFontBoldItalic];
  atsuItalic := Font.Style in [vgFontItalic, vgFontBoldItalic];

  Tags[0] := kATSUSizeTag;
  Sizes[0] := sizeof(Fixed);
  Values[0] := @atsuSize;
  Tags[1] := kATSUQDBoldFaceTag;
  Sizes[1] := sizeof(boolean);
  Values[1] := @atsuBold;
  Tags[2] := kATSUQDItalicTag;
  Sizes[2] := sizeof(boolean);
  Values[2] := @atsuItalic;
  ATSUSetAttributes(myStyles, 3, Tags, Sizes, Values);
  // layout
  myTextLayout := nil;
  ATSUCreateTextLayout(myTextLayout);
  // set align
  Tags[1] := kATSULineFlushFactorTag;
  Sizes[1] := SizeOf(textAlign);
  if WordWrap then
  begin
    case ATextAlign of
      vgTextAlignCenter:
        begin
          textAlign := kATSUCenterAlignment;
        end;
      vgTextAlignNear:
        begin
          textAlign := kATSUStartAlignment;
        end;
      vgTextAlignFar:
        begin
          textAlign := kATSUEndAlignment;
        end;
    end;
  end
  else
    textAlign := kATSUStartAlignment;
  Values[1] := @textAlign;
  // line width
  if WordWrap then
    lineWidth := Trunc(vgRectWidth(ARect) * $FFFF)
  else
    lineWidth := 5000 * $FFFF;
  if lineWidth <= 0 then
    lineWidth := 1;
  Tags[2] := kATSULineWidthTag;
  Sizes[2] := SizeOf(lineWidth);
  Values[2] := @lineWidth;
  // line trunk - set ...
  lineTrunc := kATSUTruncateNone;
  Tags[3] := kATSULineTruncationTag;
  Sizes[3] := SizeOf(lineTrunc);
  Values[3] := @lineTrunc;
  ATSUSetLayoutControls(myTextLayout, 4, Tags, Sizes, Values);
  // set text
  ATSUSetTextPointerLocation(myTextLayout,
    ConstUniCharArrayPtr(PWideChar(AText)),
    kATSUFromTextBeginning,
    kATSUToTextEnd,
    Length(AText));
  ATSUSetRunStyle(myTextLayout,
    myStyles,
    kATSUFromTextBeginning,
    kATSUToTextEnd);
  ATSUSetTransientFontMatching(myTextLayout, true);
  // set breacks
  ATSUBatchBreakLines(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, lineWidth, @numSoftBreaks);
  // procs
  moveToProc := NewATSCubicMoveToUPP(@MyCubicMoveToProc);
  lineToProc := NewATSCubicLineToUPP(@MyCubicLineToProc);
  curveToProc := NewATSCubicCurveToUPP(@MyCubicCurveToProc);
  closePathProc := NewATSCubicClosePathUPP(@MyCubicClosePathProc);
  // vertical aligning using numSoftBreaks
  case AVTextAlign of
    vgTextAlignCenter:
      VerticalOffset := (vgRectHeight(ARect) - (((numSoftBreaks - 0.5) * Font.Size * 1.33))) / 2;
    vgTextAlignNear:
      VerticalOffset := (0.75 * Font.Size * 1.33);
    vgTextAlignFar:
      VerticalOffset := vgRectHeight(ARect) - (Font.Size * 1.33 * (numSoftBreaks + 0.25));
  end;
  // final draw
  if numSoftBreaks = 0 then
  begin
    ATSUGetUnjustifiedBounds(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, CLeft, CRight, CTop, CBottom);
    case ATextAlign of
      vgTextAlignCenter:
        HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect)) / 2;
      vgTextAlignFar:
        HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect));
    else
      HorizontalOffset := 0;
    end;

    GetGlyphIDsAndPositions(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, GlyphArray, numGlyphs);
    for i := 0 to numGlyphs - 1 do
    begin
      SP := vgPoint(0, 0);
      Data.Path := Path;
      Data.SP := @SP;
      Data.GlyphLayouts := GlyphArray[i];
      Data.Height := (Font.Size * 1.33);
      Data.XOffset := ARect.Left + HorizontalOffset;
      Data.YOffset := VerticalOffset;
      ATSUGlyphGetCubicPaths(myStyles, GlyphArray[i].glyphID, moveToProc, lineToProc, curveToProc, closePathProc, @Data, Status);
    end;
  end
  else
  begin
    ATSUGetSoftLineBreaks(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, numSoftBreaks, @softBreaks[0], @numSoftBreaks);
    ATSUGetTextLocation(myTextLayout, nil, nil, @layoutStart, @layoutLength, nil);
    currentStart := layoutStart;
    for i := 0 to numSoftBreaks do
    begin
      if (numSoftBreaks > i) then
        currentEnd := softBreaks[i]
      else
        currentEnd := layoutStart + layoutLength;

      ATSUGetUnjustifiedBounds(myTextLayout, currentStart, currentEnd - currentStart, CLeft, CRight, CTop, CBottom);
      case ATextAlign of
        vgTextAlignCenter:
          HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect)) / 2;
        vgTextAlignFar:
          HorizontalOffset := -(((CRight - CLeft) / $FFFF) - vgRectWidth(ARect));
      else
        HorizontalOffset := 0;
      end;
      GetGlyphIDsAndPositions(myTextLayout, currentStart, currentEnd - currentStart, GlyphArray, numGlyphs);
      for j := 0 to numGlyphs - 1 do
      begin
        SP := vgPoint(0, 0);
        Data.Path := Path;
        Data.SP := @SP;
        Data.GlyphLayouts := GlyphArray[j];
        Data.Height := (Font.Size * 1.33);
        if i > 0 then
          Data.YOffset := i * Data.Height
        else
          Data.YOffset := 0;
        Data.YOffset := Data.YOffset + VerticalOffset;
        Data.XOffset := HorizontalOffset;
        ATSUGlyphGetCubicPaths(myStyles, GlyphArray[j].glyphID, moveToProc, lineToProc, curveToProc, closePathProc, @Data, Status);
      end;

      currentStart := currentEnd;
    end;
    ATSUGetUnjustifiedBounds(myTextLayout, kATSUFromTextBeginning, kATSUToTextEnd, CLeft, CRight, CTop, CBottom);
  end;
  // restore
  Result := true;
  // dispose
  DisposeATSCubicMoveToUPP(moveToProc);
  DisposeATSCubicLineToUPP(lineToProc);
  DisposeATSCubicCurveToUPP(curveToProc);
  DisposeATSCubicClosePathUPP(closePathProc);
  ATSUDisposeTextLayout(myTextLayout);
  ATSUDisposeStyle(myStyles);
end;

{$ENDIF}

{ TvxBitmapTrackBar }

constructor TvxBitmapTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'trackbarstyle';
end;

destructor TvxBitmapTrackBar.Destroy;
begin
  if FBitmap <> nil then
    FreeAndNil(FBitmap);
  inherited;
end;

procedure TvxBitmapTrackBar.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('background');
  if (T <> nil) and (T is TvxShape) then
  begin
    FBackground := TvxShape(T);
    UpdateBitmap;
  end;
end;

procedure TvxBitmapTrackBar.FreeStyle;
begin
  FBackground := nil;
  inherited;
end;

procedure TvxBitmapTrackBar.Realign;
begin
  inherited;
  UpdateBitmap;
end;

procedure TvxBitmapTrackBar.UpdateBitmap;
begin
  if FBackground = nil then
    Exit;

  if FBitmap <> nil then
    if (FBitmap.Width <> Trunc(FBackground.Width)) or (FBitmap.Height <> Trunc(FBackground.Height)) then
    begin
      FreeAndNil(FBitmap);
    end;

  if FBitmap = nil then
  begin
    FBitmap := TvxBitmap.Create(Trunc(FBackground.Width), Trunc(FBackground.Height));
    FillBitmap;
  end;
  FBackground.Fill.Style := vgBrushBitmap;
  FBackground.Fill.Bitmap.Bitmap := FBitmap;

  Repaint;
end;

procedure TvxBitmapTrackBar.FillBitmap;
begin
end;

{ TvxHueTrackBar }

constructor TvxHueTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  Max := 1;
  Value := 0.5;
end;

procedure TvxHueTrackBar.FillBitmap;
var
  i, j: integer;
begin
  for j := 0 to FBitmap.Height - 1 do
  begin
    for i := 0 to FBitmap.Width - 1 do
    begin
      if Orientation = vgHorizontal then
        FBitmap.Scanline[j][i] := vgCorrectColor(vgHSLtoRGB(i / FBitmap.Width, 0.9, 0.5))
      else
        FBitmap.Scanline[j][i] := vgCorrectColor(vgHSLtoRGB(j / FBitmap.Height, 0.9, 0.5));
    end;
  end;
end;

{ TvxAlphaTrackBar }

constructor TvxAlphaTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  Max := 1;
  Value := 1;
end;

procedure TvxAlphaTrackBar.FillBitmap;
var
  i, j: integer;
begin
  for j := 0 to FBitmap.Height - 1 do
  begin
    for i := 0 to FBitmap.Width - 1 do
    begin
      if odd(i div 3) and not odd(j div 3) then
        FBitmap.Scanline[j][i] := vgCorrectColor($FFA0A0A0)
      else
        if not odd(i div 3) and odd(j div 3) then
        FBitmap.Scanline[j][i] := vgCorrectColor($FFA0A0A0)
      else
        FBitmap.Scanline[j][i] := vgCorrectColor($FFFFFFFF)
    end;
  end;
  if FBitmap.Canvas.BeginScene then
  begin
    FBitmap.Canvas.Fill.Style := vgBrushGradient;
    FBitmap.Canvas.Fill.Gradient.Points[0].Color := '$00FFFFFF';
    FBitmap.Canvas.Fill.Gradient.Points[1].Color := '$FFFFFFFF';
    FBitmap.Canvas.Fill.Gradient.StopPosition.Point := vgPoint(1, 0);
    FBitmap.Canvas.FillRect(vgRect(0, 0, FBitmap.Width, FBitmap.Height), 0, 0, [], 1);
    FBitmap.Canvas.EndScene;
  end;
end;

{ TvxBWTrackBar }

constructor TvxBWTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  Max := 1;
  Value := 0.5;
end;

procedure TvxBWTrackBar.FillBitmap;
var
  i, j: integer;
  a: byte;
begin
  for j := 0 to FBitmap.Height - 1 do
  begin
    for i := 0 to FBitmap.Width - 1 do
    begin
      if Orientation = vgHorizontal then
        a := round((i / FBitmap.Width) * $FF)
      else
        a := round((j / FBitmap.Height) * $FF);
      FBitmap.Scanline[j][i] := vgCorrectColor(vgColor(a, a, a));
    end;
  end;
end;

{ TvxColorBox }

constructor TvxColorBox.Create(AOwner: TComponent);
begin
  inherited;
end;

procedure TvxColorBox.Paint;
var
  i, j: integer;
  SaveIndex: integer;
begin
  SaveIndex := Canvas.SaveCanvas;
  Canvas.IntersectClipRect(LocalRect);
  Canvas.Stroke.Style := vgBrushNone;
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.FillRect(LocalRect, 0, 0, AllCorners, AbsoluteOpacity);
  Canvas.Fill.SolidColor := $FFD3D3D3;
  for i := 0 to Trunc(Width / 5) + 1 do
    for j := 0 to Trunc(Height / 5) + 1 do
    begin
      if Odd(i + j) then
      begin
        Canvas.FillRect(vgRect(i * 5, j * 5, (i + 1) * 5, (j + 1) * 5), 0, 0, AllCorners, AbsoluteOpacity);
      end;
    end;
  Canvas.RestoreCanvas(SaveIndex);

  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := FColor;
  Canvas.FillRect(LocalRect, 0, 0, AllCorners, AbsoluteOpacity);
end;

procedure TvxColorBox.SetColor(const Value: TvxColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    Repaint;
  end;
end;

{ TvxColorQuad }

constructor TvxColorQuad.Create(AOwner: TComponent);
begin
  inherited;
  FAlpha := 1;
  AutoCapture := true;
end;

destructor TvxColorQuad.Destroy;
begin
  if (FColorBitmap <> nil) then
    FColorBitmap.Free;
  inherited;
end;

function TvxColorQuad.GetAbsoluteRect: TvxRect;
begin
  Result := inherited GetAbsoluteRect;
  vgInflateRect(Result, colorPickSize + 1, colorPickSize + 1);
end;

function TvxColorQuad.pointInObject(X, Y: single): boolean;
var
  P: TvxPoint;
begin
  Result := false;
  P := AbsoluteToLocal(vgPoint(X, Y));
  if (P.X > -colorPickSize / 2) and (P.X < Width + colorPickSize / 2) and
    (P.Y > -colorPickSize / 2) and (P.Y < Height + colorPickSize / 2) then
  begin
    Result := true;
  end;
end;

procedure TvxColorQuad.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if FPressed then
  begin
    if Height <> 0 then
      Lum := 1 - ((Y) / (Height));
    if Width <> 0 then
      Sat := ((X) / (Width));
  end;
end;

procedure TvxColorQuad.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  if FPressed then
    MouseMove([ssLeft], X, Y, 0, 0);
  inherited;
end;

procedure TvxColorQuad.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FColorBox) then
    ColorBox := nil;
end;

procedure TvxColorQuad.Paint;
var
  i, j: integer;
  R: TvxRect;
begin
  if FColorBitmap = nil then
  begin
    FColorBitmap := TvxBitmap.Create(Trunc(Width), Trunc(Height));
    if FColorBitmap <> nil then
    begin
      for i := 0 to FColorBitmap.Width - 1 do
      begin
        for j := 0 to FColorBitmap.Height - 1 do
        begin
          FColorBitmap.Scanline[j][i] := vgCorrectColor(vgHSLtoRGB(FHue, i / FColorBitmap.Width, (1 - (j / FColorBitmap.Height))));
          {$IFDEF FPC_BIG_ENDIAN}
          ReverseBytes(@FColorBitmap.Scanline[j][i], 4);
          {$ENDIF}
        end;
      end;
    end;
  end;
  if FColorBitmap <> nil then
    Canvas.DrawBitmap(FColorBitmap, vgRect(0, 0, FColorBitmap.Width, FColorBitmap.Height),
      vgRect(0, 0, Width, Height), AbsoluteOpacity);
  { current }
  R := vgRect(FSat * (Width), (1 - FLum) * (Height),
    FSat * (Width), (1 - FLum) * (Height));
  vgInflateRect(R, colorPickSize / 2, colorPickSize / 2);
  Canvas.Stroke.Style := vgBrushSolid;
  Canvas.StrokeThickness := 1;
  Canvas.Stroke.SolidColor := $FF000000;
  Canvas.DrawEllipse(R, AbsoluteOpacity);
  vgInflateRect(R, -1, -1);
  Canvas.Stroke.SolidColor := $FFFFFFFF;
  Canvas.DrawEllipse(R, AbsoluteOpacity);
  vgInflateRect(R, -1, -1);
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := vgHSLtoRGB(Hue, sat, Lum);
  Canvas.FillEllipse(R, AbsoluteOpacity);
end;

procedure TvxColorQuad.SetAlpha(const Value: single);
begin
  if FAlpha <> Value then
  begin
    FAlpha := Value;
    if FAlpha < 0 then
      FAlpha := 0;
    if FAlpha > 1 then
      FAlpha := 1;
    if FColorBox <> nil then
      FColorBox.Color := vgHSLtoRGB(Hue, Sat, Lum) and $FFFFFF or (Round(Alpha * $FF) shl 24);
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxColorQuad.SetHue(const Value: single);
begin
  if FHue <> Value then
  begin
    FHue := Value;
    if FHue < 0 then
      FHue := 0;
    if FHue > 1 then
      FHue := 1;
    if FColorBitmap <> nil then
      FreeAndNil(FColorBitmap);
    if FColorBox <> nil then
      FColorBox.Color := vgHSLtoRGB(Hue, Sat, Lum) and $FFFFFF or (Round(Alpha * $FF) shl 24);
    if Assigned(FOnChange) then
      FOnChange(Self);
    Repaint;
  end;
end;

procedure TvxColorQuad.SetLum(const Value: single);
begin
  if FLum <> Value then
  begin
    FLum := Value;
    if FLum < 0 then
      FLum := 0;
    if FLum > 1 then
      FLum := 1;
    if FColorBox <> nil then
      FColorBox.Color := vgHSLtoRGB(Hue, Sat, Lum) and $FFFFFF or (Round(Alpha * $FF) shl 24);
    if Assigned(FOnChange) then
      FOnChange(Self);
    Repaint;
  end;
end;

procedure TvxColorQuad.SetSat(const Value: single);
begin
  if FSat <> Value then
  begin
    FSat := Value;
    if FSat < 0 then
      FSat := 0;
    if FSat > 1 then
      FSat := 1;
    if FColorBox <> nil then
      FColorBox.Color := vgHSLtoRGB(Hue, Sat, Lum) and $FFFFFF or (Round(Alpha * $FF) shl 24);
    if Assigned(FOnChange) then
      FOnChange(Self);
    Repaint;
  end;
end;

procedure TvxColorQuad.SetColorBox(const Value: TvxColorBox);
begin
  if FColorBox <> Value then
  begin
    FColorBox := Value;
    if FColorBox <> nil then
      FColorBox.Color := vgHSLtoRGB(Hue, Sat, Lum) and $FFFFFF or (Round(Alpha * $FF) shl 24);
  end;
end;

{ TvxColorPicker ==============================================================}

constructor TvxColorPicker.Create(AOwner: TComponent);
begin
  inherited;
  AutoCapture := true;
end;

destructor TvxColorPicker.Destroy;
begin
  if (FHueBitmap <> nil) then
    FreeAndNil(FHueBitmap);
  inherited;
end;

procedure TvxColorPicker.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FColorQuad) then
    ColorQuad := nil;
end;

function TvxColorPicker.GetAbsoluteRect: TvxRect;
begin
  Result := inherited GetAbsoluteRect;
  vgInflateRect(Result, 0, colorPickSize / 2);
end;

function TvxColorPicker.pointInObject(X, Y: single): boolean;
var
  P: TvxPoint;
begin
  Result := false;
  P := AbsoluteToLocal(vgPoint(X, Y));
  if (P.X > 0) and (P.X < Width) and
    (P.Y > -colorPickSize / 2) and (P.Y < Height + colorPickSize / 2) then
  begin
    Result := true;
  end;
end;

procedure TvxColorPicker.MouseMove(Shift: TShiftState; X, Y, Dx,
  Dy: single);
begin
  inherited;
  if FPressed then
  begin
    if Height <> 0 then
      Hue := ((Y) / (Height));
  end;
end;

procedure TvxColorPicker.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  if FPressed then
    MouseMove([ssLeft], X, Y, 0, 0);
  inherited;
end;

procedure TvxColorPicker.Paint;
var
  i, j: integer;
  R: TvxRect;
begin
  if FHueBitmap = nil then
  begin
    FHueBitmap := TvxBitmap.Create(Trunc(Width), Trunc(Height));
    if FHueBitmap <> nil then
    begin
      for j := 0 to FHueBitmap.Height - 1 do
      begin
        for i := 0 to FHueBitmap.Width - 1 do
        begin
          FHueBitmap.Scanline[j][i] := vgCorrectColor(vgHSLtoRGB(j / FHueBitmap.Height, 0.9, 0.5));
          {$IFDEF FPC_BIG_ENDIAN}
          ReverseBytes(@FHueBitmap.Scanline[j][i], 4);
          {$ENDIF}
        end;
      end;
    end;
  end;

  if FHueBitmap <> nil then
    Canvas.DrawBitmap(FHueBitmap, vgRect(0, 0, FHueBitmap.Width, FHueBitmap.Height),
      vgRect(0, 0, Width, Height), AbsoluteOpacity);

  { hue pos }
  R := vgRect(Width / 2, FHue * (Height),
    Width / 2, FHue * (Height));
  vgInflateRect(R, colorPickSize / 2, colorPickSize / 2);
  //  vgOffsetRect(R, 01, StrokeThickness);
  Canvas.Stroke.Style := vgBrushSolid;
  Canvas.StrokeThickness := 1;
  Canvas.Stroke.SolidColor := $FF000000;
  Canvas.DrawEllipse(R, AbsoluteOpacity);
  vgInflateRect(R, -1, -1);
  Canvas.Stroke.SolidColor := $FFFFFFFF;
  Canvas.DrawEllipse(R, AbsoluteOpacity);
  vgInflateRect(R, -1, -1);
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := vgHSLtoRGB(Hue, 0.9, 0.5);
  Canvas.FillEllipse(R, AbsoluteOpacity);
end;

function TvxColorPicker.GetColor: TvxColor;
begin
  Result := vgHSLToRGB(Hue, 1, 0.5)
end;

procedure TvxColorPicker.SetColor(const Value: TvxColor);
var
  H, S, L: single;
  SaveChange: TNotifyEvent;
begin
  vgRGBtoHSL(Value, H, S, L);
  Hue := H;
  if FColorQuad <> nil then
  begin
    FColorQuad.Alpha := TvxColorRec(Value).A / $FF;
    FColorQuad.Hue := H;
    FColorQuad.Sat := S;
    FColorQuad.Lum := L;
  end;
end;

procedure TvxColorPicker.SetHue(const Value: single);
begin
  if FHue <> Value then
  begin
    FHue := Value;
    if FHue < 0 then
      FHue := 0;
    if FHue > 1 then
      FHue := 1;
    if FColorQuad <> nil then
      FColorQuad.Hue := FHue;
    Repaint;
  end;
end;

{ TvxGradientEdit ==============================================================}

constructor TvxGradientEdit.Create(AOwner: TComponent);
begin
  inherited;
  FGradient := TvxGradient.Create;
  FGradient.OnChanged := DoChanged;
  Width := 200;
  Height := 20;
  AutoCapture := true;
end;

destructor TvxGradientEdit.Destroy;
begin
  if FBitmap <> nil then
    FreeAndNil(FBitmap);
  FGradient.Free;
  inherited;
end;

function TvxGradientEdit.GetPointRect(const Point: integer): TvxRect;
begin
  if (Point >= 0) and (Point < FGradient.Points.Count) then
    with FGradient do
    begin
      Result := vgRect(0 + colorPickSize + (Points[Point].Offset * (Width - ((0 + colorPickSize) * 2))), Height - 0 - colorPickSize,
        0 + colorPickSize + (Points[Point].Offset * (Width - ((0 + colorPickSize) * 2))), Height - 0);
      vgInflateRect(Result, colorPickSize / 2, 0);
    end
  else
    Result := vgRect(0, 0, 0, 0);
end;

procedure TvxGradientEdit.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
var
  NewOffset: single;
  NewColor: TvxColor;
  i: integer;
begin
  inherited;
  FMoving := false;
  if Button = mbLeft then
  begin
    { select point }
    for i := 0 to FGradient.Points.Count - 1 do
      if vgPtInRect(vgPoint(X, Y), GetPointRect(i)) then
      begin
        CurrentPoint := i;
        if Assigned(OnSelectPoint) then
          OnSelectPoint(Self);
        FMoving := true;
        Repaint;
        Exit;
      end;
    { add new point }
    if (Y > 0) and (Y < Height - 0 - colorPickSize) then
    begin
      NewOffset := ((X - 0 - colorPickSize) / (Width - ((0 + colorPickSize) * 2)));
      if NewOffset < 0 then
        NewOffset := 0;
      if NewOffset > 1 then
        NewOffset := 1;
      NewColor := FGradient.InterpolateColor(NewOffset);
      for i := 1 to FGradient.Points.Count - 1 do
        if NewOffset < FGradient.Points[i].Offset then
          with TvxGradientPoint(FGradient.Points.Add) do
          begin
            Index := i;
            CurrentPoint := Index;
            IntColor := NewColor;
            Offset := NewOffset;
            Repaint;
            DoChanged(Self);
            Break;
          end;
    end;
  end;
end;

procedure TvxGradientEdit.MouseMove(Shift: TShiftState; X, Y, Dx,
  Dy: single);
begin
  inherited;
  if ssLeft in Shift then
  begin
    if FMoving then
    begin
      FCurrentPointInvisible := ((Y < -10) or (Y > Height + 10)) and (FGradient.Points.Count > 1) and
        (CurrentPoint <> 0) and (CurrentPoint <> FGradient.Points.Count - 1);
      { move }
      FGradient.Points[CurrentPoint].Offset := ((X - 0 - colorPickSize) / (Width - ((0 + colorPickSize) * 2)));
      if FGradient.Points[CurrentPoint].Offset < 0 then
        FGradient.Points[CurrentPoint].Offset := 0;
      if FGradient.Points[CurrentPoint].Offset > 1 then
        FGradient.Points[CurrentPoint].Offset := 1;
      { move right }
      if CurrentPoint < FGradient.Points.Count - 1 then
        if FGradient.Points[CurrentPoint].Offset > FGradient.Points[CurrentPoint + 1].Offset then
        begin
          FGradient.Points[CurrentPoint].Index := FGradient.Points[CurrentPoint].Index + 1;
          CurrentPoint := CurrentPoint + 1;
        end;
      { move left }
      if CurrentPoint > 0 then
        if FGradient.Points[CurrentPoint].Offset < FGradient.Points[CurrentPoint - 1].Offset then
        begin
          FGradient.Points[CurrentPoint].Index := FGradient.Points[CurrentPoint].Index - 1;
          CurrentPoint := CurrentPoint - 1;
        end;
      Repaint;
      DoChanged(Self);
    end;
  end;
end;

procedure TvxGradientEdit.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  inherited;
  FCurrentPointInvisible := false;
  if FMoving then
  begin
    { delete }
    if (Y > Height + 10) and (FGradient.Points.Count > 1) then
    begin
      FGradient.Points.Delete(CurrentPoint);
      CurrentPoint := CurrentPoint - 1;
      if CurrentPoint < 0 then
        CurrentPoint := 0;
      Repaint;
      DoChanged(Self);
      FMoving := false;
      Exit;
    end;
  end;
  FMoving := false;
end;

procedure TvxGradientEdit.Paint;
var
  i, j: integer;
  R: TvxRect;
  SaveIndex: integer;
begin
  //  Canvas.DrawRect(vgRect(0, 0, Width, Height));
  if FBitmap = nil then
  begin
    FBitmap := TvxBitmap.Create(Trunc(Width - (0 * 2)), Trunc(Height - (0 * 2) - colorPickSize));
  end;
  if FBitmap <> nil then
  begin
    for j := 0 to FBitmap.Height - 1 do
    begin
      for i := 0 to FBitmap.Width - 1 do
      begin
        FBitmap.Scanline[j][i] := vgCorrectColor(FGradient.InterpolateColor(i / FBitmap.Width));
        {$IFDEF FPC_BIG_ENDIAN}
        ReverseBytes(@FBitmap.Scanline[j][i], 4);
        {$ENDIF}
      end;
    end;
  end;

  { draw back }
  R := vgRect(0 + colorPickSize, 0, Width - 0 - colorPickSize, Height - 0 - colorPickSize);
  SaveIndex := Canvas.SaveCanvas;
  Canvas.IntersectClipRect(R);
  Canvas.Stroke.Style := vgBrushNone;
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.FillRect(R, 0, 0, AllCorners, AbsoluteOpacity);
  Canvas.Fill.SolidColor := $FFD3D3D3;
  for i := 0 to Trunc(Width / 10) + 1 do
    for j := 0 to Trunc(Height / 10) + 1 do
    begin
      if Odd(i + j) then
      begin
        Canvas.FillRect(vgRect(i * 10, j * 10, (i + 1) * 10, (j + 1) * 10), 0, 0, AllCorners, AbsoluteOpacity);
      end;
    end;
  Canvas.RestoreCanvas(SaveIndex);
  { draw gradient }
  Canvas.Stroke.Style := vgBrushSolid;
  Canvas.StrokeThickness := 0;
  if FBitmap <> nil then
  begin
    Canvas.DrawBitmap(FBitmap, vgRect(0, 0, FBitmap.Width, FBitmap.Height),
      vgRect(0 + colorPickSize, 0, Width - 0 - colorPickSize, Height - 0 - colorPickSize), AbsoluteOpacity);
  end;
  { points }
  for i := 0 to FGradient.Points.Count - 1 do
  begin
    if FCurrentPointInvisible and (i = CurrentPoint) then
      Continue;
    R := GetPointRect(i);
    vgInflateRect(R, -1, -1);
    Canvas.Stroke.SolidColor := $FF757575;
    Canvas.Fill.SolidColor := FGradient.Points[i].IntColor;
    Canvas.FillEllipse(R, AbsoluteOpacity);
    Canvas.DrawEllipse(R, AbsoluteOpacity);
    { color }
    if CurrentPoint = i then
    begin
      vgInflateRect(R, 1, 1);
      Canvas.Stroke.SolidColor := $FF000000;
      Canvas.Stroke.SolidColor := $FFFFFFFF;
      Canvas.DrawEllipse(R, AbsoluteOpacity);
    end;
  end;
end;

procedure TvxGradientEdit.SetGradient(const Value: TvxGradient);
begin
  FGradient.Assign(Value);
end;

procedure TvxGradientEdit.DoChanged(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Self);
  UpdateGradient;
end;

procedure TvxGradientEdit.SetCurrentPoint(const Value: integer);
begin
  if FCurrentPoint <> Value then
  begin
    FCurrentPoint := Value;
    if Assigned(OnSelectPoint) then
      OnSelectPoint(Self);
    if (FColorPicker <> nil) and (CurrentPoint >= 0) then
      FColorPicker.Color := Gradient.Points[CurrentPoint].IntColor;
  end;
end;

procedure TvxGradientEdit.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FColorPicker) then
    ColorPicker := nil;
end;

procedure TvxGradientEdit.SetColorPicker(const Value: TvxColorPicker);
begin
  FColorPicker := Value;
  if (FColorPicker <> nil) and (CurrentPoint >= 0) then
    FColorPicker.Color := Gradient.Points[CurrentPoint].IntColor;
end;

procedure TvxGradientEdit.UpdateGradient;
begin
  if (FColorPicker <> nil) and (CurrentPoint >= 0) then
    FColorPicker.Color := Gradient.Points[CurrentPoint].IntColor;
end;

{ TvxColorPanel }

constructor TvxColorPanel.Create(AOwner: TComponent);
begin
  inherited;
  FUseAlpha := true;
  Width := 150;
  Height := 150;
  FAlphaTrack := TvxAlphaTrackBar.Create(Self);
  FAlphaTrack.Parent := Self;
  FAlphaTrack.Align := vaBottom;
  FAlphaTrack.Stored := false;
  FAlphaTrack.Locked := true;
  FAlphaTrack.Padding.Rect := vgRect(0, 0, 15, 0);
  FAlphaTrack.Height := 15;
  FAlphaTrack.DisableFocusEffect := true;
  FAlphaTrack.OnChange := DoAlphaChange;

  FHueTrack := TvxHueTrackBar.Create(Self);
  FHueTrack.Parent := Self;
  FHueTrack.Align := vaRight;
  FHueTrack.Stored := false;
  FHueTrack.Locked := true;
  FHueTrack.Padding.Rect := vgRect(0, 0, 0, 0);
  FHueTrack.Orientation := vgVertical;
  FHueTrack.Width := 15;
  FHueTrack.DisableFocusEffect := true;
  FHueTrack.OnChange := DoHueChange;

  FColorQuad := TvxColorQuad.Create(Self);
  FColorQuad.Parent := Self;
  FColorQuad.Align := vaClient;
  FColorQuad.Stored := false;
  FColorQuad.Locked := true;
  FColorQuad.Padding.Rect := vgRect(5, 5, 3, 3);
  FColorQuad.OnChange := DoQuadChange;

  Color := vcWhite;
end;

destructor TvxColorPanel.Destroy;
begin
  inherited;
end;

procedure TvxColorPanel.DoAlphaChange(Sender: TObject);
begin
  FColorQuad.Alpha := FAlphaTrack.Value;
end;

procedure TvxColorPanel.DoHueChange(Sender: TObject);
begin
  FColorQuad.Hue := FHueTrack.Value;
end;

procedure TvxColorPanel.DoQuadChange(Sender: TObject);
begin
  if FColorBox <> nil then
    FColorBox.Color := vgStrToColor(Color);
  if Assigned(OnChange) then
    OnChange(Self);
end;

function TvxColorPanel.GetColor: string;
begin
  Result := vgColorToStr(vgOpacity(vgHSLtoRGB(FColorQuad.Hue, FColorQuad.Sat, FColorQuad.Lum), FColorQuad.Alpha));
end;

procedure TvxColorPanel.Loaded;
begin
  inherited;
  Color := Color;
end;

procedure TvxColorPanel.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FColorBox) then
    ColorBox := nil;
end;

procedure TvxColorPanel.SetColor(const Value: string);
var
  H, S, L: single;
  C: TvxColor;
  SaveOnChange: TNotifyEvent;
begin
  SaveOnChange := FOnChange;
  FOnChange := nil;

  C := vgStrToColor(Value);
  vgRGBtoHSL(C, H, S, L);
  FColorQuad.Lum := L;
  FColorQuad.Sat := S;
  FHueTrack.Value := H;
  FAlphaTrack.Value := TvxColorRec(C).A / $FF;

  FOnChange := SaveOnChange;

  if not (csLoading in ComponentState) then
    DoQuadChange(Self);
end;

procedure TvxColorPanel.SetColorBox(const Value: TvxColorBox);
begin
  if FColorBox <> Value then
  begin
    FColorBox := Value;
    if FColorBox <> nil then
      FColorBox.Color := vgStrToColor(Color);
  end;
end;

procedure TvxColorPanel.SetUseAlpha(const Value: boolean);
begin
  if FUseAlpha <> Value then
  begin
    FUseAlpha := Value;
    FAlphaTrack.Visible := FUseAlpha;
  end;
end;

{ TvxComboColorBox }

constructor TvxComboColorBox.Create(AOwner: TComponent);
begin
  inherited;
  Width := 60;
  Height := 22;
  CanFocused := true;
  AutoCapture := true;
  FResource := 'comboboxstyle';
  FPopup := TvxPopup.Create(Self);
  FPopup.FResource := 'combopopupstyle';
  FPopup.PlacementTarget := Self;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FPopup.Width := 240;
  FPopup.Height := 160;
  FPopup.Margins.Rect := vgRect(5, 5, 5, 5);
  FColorBox := TvxColorBox.Create(Self);
  FColorBox.Width := 50;
  FColorBox.Parent := FPopup;
  FColorBox.Stored := false;
  FColorBox.Align := vaRight;
  FColorBox.Padding.Rect := vgRect(15, 70, 15, 30);
  FColorText := TvxTextBox.Create(Self);
  FColorText.Parent := FPopup;
  FColorText.Stored := false;
  FColorText.Locked := true;
  FColorText.FilterChar := '#0123456789abcdefABCDEF';
  FColorText.SetBounds(160, 20, 70, 22);
  FColorText.Align := vaTopRight;
  FColorText.DisableFocusEffect := true;
  FColorText.OnChange := DoTextChange;
  FColorPanel := TvxColorPanel.Create(Self);
  FColorPanel.Parent := FPopup;
  FColorPanel.Stored := false;
  FColorPanel.DisableFocusEffect := true;
  FColorPanel.Align := vaClient;
  FColorPanel.OnChange := DoColorChange;
  FColorPanel.ColorBox := FColorBox;
end;

destructor TvxComboColorBox.Destroy;
begin
  inherited;
end;

procedure TvxComboColorBox.DoTextChange(Sender: TObject);
var
  S: string;
begin
  try
    S := Color;
    Color := FColorText.Text;
  except
    Color := S;
  end;
end;

procedure TvxComboColorBox.DoColorChange(Sender: TObject);
begin
  FColorText.Text := Color;
  Repaint;
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

procedure TvxComboColorBox.DropDown;
var
  i: integer;
begin
  if not FPopup.IsOpen then
  begin
    FPopup.Placement := FPlacement;
    FColorPanel.ApplyResource;
    FPopup.IsOpen := true;
  end
  else
  begin
    FPopup.IsOpen := false;
  end;
end;

procedure TvxComboColorBox.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if (Button = mbLeft) then
  begin
    DropDown;
  end;
end;

procedure TvxComboColorBox.ChangeParent;
begin
  inherited;
end;

function TvxComboColorBox.GetValue: string;
begin
  Result := FColorPanel.Color
end;

procedure TvxComboColorBox.SetValue(const Value: string);
begin
  FColorPanel.Color := Value;
end;

procedure TvxComboColorBox.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('Content');
  if (T <> nil) and (T is TvxContent) then
  begin
    TvxContent(T).OnPaint := DoContentPaint;
  end;
end;

procedure TvxComboColorBox.DoContentPaint(Sender: TObject;
  const Canvas: TvxCanvas; const ARect: TvxRect);
var
  R: TvxRect;
  i, j, SaveIndex: integer;
begin
  R := ARect;
  vgInflateRect(R, -0.5 - 2, -0.5 - 2);
  { draw back }
  SaveIndex := Canvas.SaveCanvas;
  Canvas.IntersectClipRect(R);
  Canvas.Stroke.Style := vgBrushNone;
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.FillRect(R, 0, 0, AllCorners, AbsoluteOpacity);
  Canvas.Fill.SolidColor := $FFD3D3D3;
  for i := 0 to Trunc(vgRectWidth(R) / 5) + 1 do
    for j := 0 to Trunc(vgRectHeight(R) / 5) + 1 do
    begin
      if Odd(i + j) then
      begin
        Canvas.FillRect(vgRect(i * 5, j * 5, (i + 1) * 5, (j + 1) * 5), 0, 0, AllCorners, AbsoluteOpacity);
      end;
    end;
  { color }
  Canvas.RestoreCanvas(SaveIndex);
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.Color := Color;
  Canvas.FillRect(R, 0, 0, AllCorners, AbsoluteOpacity);
  Canvas.Stroke.Color := vcBlack;
  Canvas.Stroke.Style := vgBrushSolid;
  Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
end;

function TvxComboColorBox.GetUseAlpha: boolean;
begin
  Result := FColorPanel.UseAlpha;
end;

procedure TvxComboColorBox.SetUseAlpha(const Value: boolean);
begin
  FColorPanel.UseAlpha := Value;
end;

function TvxComboColorBox.GetData: Variant;
begin
  Result := Color;
end;

procedure TvxComboColorBox.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    Onchange := VariantToEvent(Value)
  else
    if VarIsStr(Value) then
    Color := Value
  else
    if VarIsOrdinal(Value) then
    Color := vgColorToStr(Value);
end;

{ TvxHudHueTrackBar }

constructor TvxHudHueTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'hudtrackbarstyle';
end;

{ TvxHudAlphaTrackBar }

constructor TvxHudAlphaTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'hudtrackbarstyle';
end;

{ TvxHudBWTrackBar }

constructor TvxHudBWTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'hudtrackbarstyle';
end;

{ TvxHudComboColorBox }

constructor TvxHudComboColorBox.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'hudcomboboxstyle';
  FPopup.FResource := 'hudcombopopupstyle';
end;

{ TvxSelectionItem }

constructor TvxSelectionItem.Create(AOwner: TComponent);
begin
  inherited;
  HitTest := false;
end;

procedure TvxSelectionItem.Paint;
begin
  inherited;
end;

procedure TvxSelectionItem.PaintChildren;
begin
  if csDesigning in ComponentState then
    Exit;
  inherited;
end;

{ TvxPanel ====================================================================}

constructor TvxPanel.Create(AOwner: TComponent);
begin
  inherited;
  Width := 120;
  Height := 100;
end;

{ TvxCalloutPanel }

constructor TvxCalloutPanel.Create(AOwner: TComponent);
begin
  inherited;
  FCalloutWidth := 23;
  FCalloutLength := 11;
end;

procedure TvxCalloutPanel.ApplyStyle;
var
  Back: TvxObject;
begin
  inherited;
  Back := FindResource('Backgound');
  if (Back = nil) and (FResourceLink is TvxCalloutRectangle) then
    Back := FResourceLink;
  if (Back <> nil) and (Back is TvxCalloutRectangle) then
  begin
    TvxCalloutRectangle(Back).CalloutWidth := FCalloutWidth;
    TvxCalloutRectangle(Back).CalloutLength := FCalloutLength;
    TvxCalloutRectangle(Back).CalloutPosition := FCalloutPosition;
    TvxCalloutRectangle(Back).CalloutOffset := FCalloutOffset;
  end;
end;

procedure TvxCalloutPanel.SetCalloutLength(const Value: single);
begin
  if FCalloutLength <> Value then
  begin
    FCalloutLength := Value;
    ApplyStyle;
  end;
end;

procedure TvxCalloutPanel.SetCalloutPosition(
  const Value: TvxCalloutPosition);
begin
  if FCalloutPosition <> Value then
  begin
    FCalloutPosition := Value;
    ApplyStyle;
  end;
end;

procedure TvxCalloutPanel.SetCalloutWidth(const Value: single);
begin
  if FCalloutWidth <> Value then
  begin
    FCalloutWidth := Value;
    ApplyStyle;
  end;
end;

procedure TvxCalloutPanel.SetCalloutOffset(const Value: single);
begin
  if FCalloutOffset <> Value then
  begin
    FCalloutOffset := Value;
    ApplyStyle;
  end;
end;

{ TvxStatusBar }

constructor TvxStatusBar.Create(AOwner: TComponent);
begin
  inherited;
  FShowSizeGrip := true;
  Height := 22;
  Align := vaBottom;
end;

procedure TvxStatusBar.ApplyStyle;
var
  sizeGrip: TvxObject;
begin
  inherited;
  sizeGrip := FindResource('sizegrip');
  if (sizeGrip <> nil) and (sizeGrip is TvxVisualObject) then
  begin
    TvxVisualObject(sizeGrip).visible := FShowSizeGrip;
    if (Scene <> nil) and not (Scene.GetDesignTime) then
    begin
      TvxVisualObject(sizeGrip).Locked := false;
      TvxVisualObject(sizeGrip).HitTest := true;
    end;
  end;
end;

procedure TvxStatusBar.SetShowSizeGrip(const Value: boolean);
begin
  if FShowSizeGrip <> Value then
  begin
    FShowSizeGrip := Value;
    Resource := FResource;
  end;
end;

{ TvxToolBar }

constructor TvxToolBar.Create(AOwner: TComponent);
begin
  inherited;
  Height := 40;
  Align := vaTop;
end;

{ TvxTextControl ===================================================================}

constructor TvxTextControl.Create(AOwner: TComponent);
begin
  inherited;
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
  FFontFill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FFontFill.OnChanged := FontFillChanged;
  FWordWrap := false;
end;

destructor TvxTextControl.Destroy;
begin
  FFontFill.Free;
  FFont.Free;
  inherited;
end;

function TvxTextControl.GetData: Variant;
begin
  Result := Text;
end;

procedure TvxTextControl.SetData(const Value: Variant);
begin
  if VarIsNull(Value) then
    Text := ''
  else
    if VarIsType(Value, varDate) then
    Text := DateTimeToStr(VarToDateTime(Value))
  else
    Text := VarToWideStr(Value);
end;

procedure TvxTextControl.ApplyStyle;
var
  S: TvxObject;
  NewT: WideString;
begin
  inherited;
  { from style }
  S := FindResource('foreground');
  if (S <> nil) and (S is TvxBrushObject) then
    FontFill.Assign(TvxBrushObject(S).Brush);
  { to style }
  S := FindResource('text');
  if (S <> nil) and (S is TvxText) then
  begin
    TvxText(S).Text := FText;
    TvxText(S).HorzTextAlign := FTextAlign;
    TvxText(S).VertTextAlign := FVertTextAlign;
    TvxText(S).WordWrap := FWordWrap;
    TvxText(S).Font.Assign(FFont);
  end;
  { translate }
  if FAutoTranslate then
  begin
    NewT := Translate(Text); // need for collection texts
    if (FScene <> nil) and not (FScene.GetDesignTime) then
      Text := NewT;
  end;
end;

procedure TvxTextControl.FontChanged(Sender: TObject);
var
  T: TvxObject;
begin
  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
    TvxText(T).Font.Assign(FFont);
end;

procedure TvxTextControl.FontFillChanged(Sender: TObject);
var
  T: TvxObject;
begin
  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
    TvxText(T).Fill.Assign(FontFill);
end;

function TvxTextControl.GetText: WideString;
begin
  Result := FText;
end;

procedure TvxTextControl.SetText(const Value: WideString);
var
  T: TvxObject;
begin
  if FText <> Value then
  begin
    FText := Value;
    T := FindResource('text');
    if (T <> nil) and (T is TvxText) then
    begin
      TvxText(T).Text := FText;
      TvxText(T).UpdateEffects;
    end
    else
      if (FResourceLink <> nil) and (FResourceLink is TvxText) then
      TvxText(FResourceLink).Text := FText
    else
      Repaint;
    UpdateEffects;
  end;
end;

procedure TvxTextControl.SetFontFill(const Value: TvxBrush);
begin
  FFontFill := Value;
end;

procedure TvxTextControl.SetFont(const Value: TvxFont);
begin
  FFont.Assign(Value);
end;

procedure TvxTextControl.SetTextAlign(const Value: TvxTextAlign);
var
  T: TvxObject;
begin
  FTextAlign := Value;
  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
    TvxText(T).HorzTextAlign := FTextAlign
  else
    Repaint;
end;

procedure TvxTextControl.SetVertTextAlign(const Value: TvxTextAlign);
var
  T: TvxObject;
begin
  FVertTextAlign := Value;
  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
    TvxText(T).VertTextAlign := FVertTextAlign
  else
    Repaint;
end;

procedure TvxTextControl.SetWordWrap(const Value: boolean);
var
  T: TvxObject;
begin
  FWordWrap := Value;
  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
    TvxText(T).WordWrap := Value;
end;

{ TvxLabel }

constructor TvxLabel.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  Width := 120;
  Height := 15;
  FWordWrap := true;
  HitTest := false;
end;

procedure TvxLabel.ApplyStyle;
var
  T: TvxObject;
  S: TvxAlign;
begin
  inherited;
  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
  begin
    TvxText(T).WordWrap := WordWrap;
    if AutoSize then
    begin
      FWordWrap := false;
      TvxText(T).WordWrap := false;
      TvxText(T).VertTextAlign := vgTextAlignNear;
      TvxText(T).HorzTextAlign := vgTextAlignNear;

      S := TvxText(T).Align;
      TvxText(T).Align := vaNone;
      TvxText(T).AutoSize := true;
      Width := TvxText(T).Width;
      Height := TvxText(T).Height;
      TvxText(T).AutoSize := false;
      TvxText(T).Align := S;
      TvxText(T).Fill.Assign(FontFill);
    end;
  end;
end;

procedure TvxLabel.SetWordWrap(const Value: boolean);
var
  T: TvxObject;
begin
  if FWordWrap <> Value then
  begin
    FWordWrap := Value;
    T := FindResource('text');
    if (T <> nil) and (T is TvxText) then
      TvxText(T).WordWrap := Value;
  end;
end;

procedure TvxLabel.SetAutoSize(const Value: boolean);
begin
  if FAutoSize <> Value then
  begin
    FAutoSize := Value;
    if FAutoSize then
    begin
      ApplyStyle;
    end;
  end;
end;

procedure TvxLabel.SetText(const Value: WideString);
begin
  if Value <> FText then
  begin
    inherited;
    if FAutoSize then
      ApplyStyle;
  end
  else
    inherited;
end;

{ TvxValueLabel }

constructor TvxValueLabel.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := false;
  FWordWrap := false;
end;

{ TvxCustomButton ===================================================================}

procedure TvxCustomButton.ApplyStyle;
begin
  inherited;
  StartTriggerAnimation(Self, 'IsPressed');
  ApplyTriggerEffect(Self, 'IsPressed');
end;

constructor TvxCustomButton.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  FWordWrap := false;
  Width := 80;
  Height := 22;
  AutoCapture := true;
  CanFocused := true;
  fChecked := false;
end;

destructor TvxCustomButton.Destroy;
begin
  if FRepeatTimer <> nil then
    FRepeatTimer.Free;
  inherited;
end;

procedure TvxCustomButton.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
  if (Key = VK_RETURN) or (Key = VK_SPACE) then
  begin
    Click;
  end;
end;

procedure TvxCustomButton.DoRepeatTimer(Sender: TObject);
begin
  Click;
end;

procedure TvxCustomButton.DoRepeatDelayTimer(Sender: TObject);
begin
  FRepeatTimer.OnTimer := DoRepeatTimer;
  FRepeatTimer.Interval := 100;
end;

procedure TvxCustomButton.DblClick;
begin
  inherited;
  Click;
end;

procedure TvxCustomButton.Click;
var
  O: TComponent;
begin
  if Assigned(Self) and (ModalResult <> mrNone) then
  begin
    O := Scene.GetComponent;
    while O <> nil do
    begin
      if (O is TCustomForm) then
      begin
        TCustomForm(O).ModalResult := FModalResult;
        Break;
      end;
      O := O.Owner;
    end;
  end;
  inherited;
end;

procedure TvxCustomButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    FPressing := true;
    if FStaysPressed then
      FIsPressed := not FIsPressed
    else
    begin
      FIsPressed := true;
      if FRepeat then
      begin
        if FRepeatTimer = nil then
        begin
          FRepeatTimer := TvxTimer.Create(Self);
          FRepeatTimer.Interval := 500;
        end;
        FRepeatTimer.OnTimer := DoRepeatDelayTimer;
        FRepeatTimer.Enabled := true;
      end;
    end;
    StartTriggerAnimation(Self, 'IsPressed');
    ApplyTriggerEffect(Self, 'IsPressed');
  end;
end;

procedure TvxCustomButton.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if (ssLeft in Shift) and (FPressing) then
  begin
    if FIsPressed <> vgPtInRect(vgPoint(X, Y), LocalRect) then
    begin
      if not FStaysPressed then
      begin
        FIsPressed := vgPtInRect(vgPoint(X, Y), LocalRect);
        StartTriggerAnimation(Self, 'IsPressed');
        ApplyTriggerEffect(Self, 'IsPressed');
      end;
    end;
  end;
end;

procedure TvxCustomButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  if FPressing then
  begin
    if FRepeatTimer <> nil then
      FRepeatTimer.Enabled := false;
    FPressing := false;
    if not FStaysPressed then
    begin
      FIsPressed := false;
      StartTriggerAnimation(Self, 'IsPressed');
      ApplyTriggerEffect(Self, 'IsPressed');
    end;
  end;
  inherited;
end;

procedure TvxCustomButton.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnClick := VariantToEvent(Value);
end;

procedure TvxCustomButton.SetChecked(const Value: boolean);
begin
  fChecked := Value;
end;

procedure TvxCustomButton.SetIsPressed(const Value: boolean);
begin
  if FStaysPressed then
  begin
    if Value <> FIsPressed then
    begin
      FIsPressed := Value;
      StartTriggerAnimation(Self, 'IsPressed');
      ApplyTriggerEffect(Self, 'IsPressed');
    end;
  end;
end;

{ TvxButton }

procedure TvxButton.DialogKey(var Key: Word; Shift: TShiftState);
begin
  inherited;
  if Default and (Key = VK_RETURN) then
  begin
    Click;
    Key := 0;
  end;
  if Cancel and (Key = VK_ESCAPE) then
  begin
    Click;
    Key := 0;
  end;
end;

{ TvxCircleButton }

constructor TvxCircleButton.Create(AOwner: TComponent);
begin
  inherited;
  Width := 21;
  Height := 21;
end;

{ TvxPopupButton }

constructor TvxPopupButton.Create(AOwner: TComponent);
begin
  inherited;
end;

procedure TvxPopupButton.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  {$IFNDEF NOVCL}
  if (Operation = opRemove) and (AComponent = FPopupMenu) then
    FPopupMenu := nil;
  {$ENDIF}
end;

procedure TvxPopupButton.Click;
var
  VP: TvxPoint;
begin
  inherited;
  {$IFNDEF NOVCL}
  if FPopupMenu = nil then
    Exit;
  if Scene <> nil then
  begin
    VP := LocalToAbsolute(vgPoint(0, Height));
    VP := Scene.LocalToScreen(VP);
    FPopupMenu.Popup(round(VP.X), round(VP.Y));
  end;
  {$ENDIF}
end;

{ TvxBitmapButton }

constructor TvxBitmapButton.Create(AOwner: TComponent);
begin
  inherited;
  FBitmap := TvxBitmap.Create(1, 1);
  FBitmap.OnChange := DoBitmapChanged;
  FBitmapLayout := vgGlyphLeft;
  FBitmapSize := 32;
  FBitmapPadding := 2;
  Width := 50;
  Height := 60;
end;

destructor TvxBitmapButton.Destroy;
begin
  FreeAndNil(FBitmap);
  inherited;
end;

{$IFNDEF NOVCL}

procedure TvxBitmapButton.ActionChange(Sender: TObject; CheckDefaults: Boolean);

  procedure CopyImage(ImageList: TCustomImageList; Index: Integer);
  begin
    BitmapSize := ImageList.Width;
    if ImageList is TvxImageList then
      Bitmap.Assign(TvxImageList(ImageList).Images[Index]);
  end;

begin
  inherited ActionChange(Sender, CheckDefaults);
  if Sender is TCustomAction then
    with TCustomAction(Sender) do
    begin
      { Copy image from action's imagelist }
      if (Bitmap.Width <= 1) and (ActionList <> nil) and (ActionList.Images <> nil) and (ActionList.Images is TvxImageList) and
        (ImageIndex >= 0) and (ImageIndex < TvxImageList(ActionList.Images).Count) then
        CopyImage(ActionList.Images, ImageIndex);
    end;
end;
{$ENDIF}

procedure TvxBitmapButton.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  DoBitmapChanged(Self);
  T := FindResource('text');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    TvxVisualObject(T).Padding.Rect := vgRect(FBitmapPadding, FBitmapPadding, FBitmapPadding, FBitmapPadding);
  end;

  T := FindResource('image');
  if (T <> nil) and (T is TvxImage) then
  begin
    TvxImage(T).Selected := IsPressed;
  end;
end;

procedure TvxBitmapButton.DoBitmapChanged(Sender: TObject);
var
  T: TvxObject;
begin
  T := FindResource('image');
  if (T <> nil) and (T is TvxImage) then
  begin
    TvxImage(T).Bitmap.Assign(FBitmap);
    TvxVisualObject(T).Padding.Rect := vgRect(FBitmapPadding, FBitmapPadding, FBitmapPadding, FBitmapPadding);
    if ((TvxImage(T).Bitmap.Width = 1) or (TvxImage(T).Bitmap.Height = 1)) and (TvxImage(T).Bitmap.ResourceName = '') then
    begin
      TvxVisualObject(T).Align := vaNone;
    end
    else
      case FBitmapLayout of
        vgGlyphLeft:
          begin
            TvxVisualObject(T).Align := vaLeft;
            TvxVisualObject(T).Width := FBitmapSize;
            TvxVisualObject(T).Padding.right := FBitmapSpacing;
          end;
        vgGlyphRight:
          begin
            TvxVisualObject(T).Align := vaRight;
            TvxVisualObject(T).Width := FBitmapSize;
            TvxVisualObject(T).Padding.left := FBitmapSpacing;
          end;
        vgGlyphTop:
          begin
            TvxVisualObject(T).Align := vaTop;
            TvxVisualObject(T).Height := FBitmapSize;
            TvxVisualObject(T).Padding.bottom := FBitmapSpacing;
          end;
        vgGlyphBottom:
          begin
            TvxVisualObject(T).Align := vaBottom;
            TvxVisualObject(T).Height := FBitmapSize;
            TvxVisualObject(T).Padding.top := FBitmapSpacing;
          end;
        vgGlyphCenter:
          begin
            TvxVisualObject(T).Align := vaCenter;
            TvxVisualObject(T).Width := FBitmapSize;
            TvxVisualObject(T).Height := FBitmapSize;
            TvxVisualObject(T).Padding.Rect := vgRect(FBitmapSpacing, FBitmapSpacing, FBitmapSpacing, FBitmapSpacing);
          end;
      end;
  end;
end;

procedure TvxBitmapButton.SetBitmap(const Value: TvxBitmap);
begin
  FBitmap.Assign(Value);
end;

procedure TvxBitmapButton.SetBitmapLayout(const Value: TvxButtonLayout);
begin
  if FBitmapLayout <> Value then
  begin
    FBitmapLayout := Value;
    ApplyStyle;
  end;
end;

procedure TvxBitmapButton.SetBitmapSpacing(const Value: single);
begin
  if FBitmapSpacing <> Value then
  begin
    FBitmapSpacing := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxBitmapButton.SetBitmapSize(const Value: single);
begin
  if FBitmapSize <> Value then
  begin
    FBitmapSize := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxBitmapButton.SetBitmapPadding(const Value: single);
begin
  if FBitmapPadding <> Value then
  begin
    FBitmapPadding := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

{ TvxPathButton }

constructor TvxPathButton.Create(AOwner: TComponent);
begin
  inherited;
  FPath := TvxPathData.Create;
  FPath.OnChanged := DoPathChanged;
  FPathLayout := vgGlyphLeft;
  FPathSize := 32;
  FPathPadding := 2;
  FFill := TvxBrush.Create(vgBrushSolid, $FFFFFFFF);
  FFill.OnChanged := DoPathChanged;
  FStroke := TvxBrush.Create(vgBrushSolid, $FF000000);
  FStroke.SolidColor := $FF000000;
  FStroke.OnChanged := DoPathChanged;
  FStrokeThickness := 1;
  Width := 50;
  Height := 60;
end;

destructor TvxPathButton.Destroy;
begin
  FFill.Free;
  FStroke.Free;
  FPath.Free;
  inherited;
end;

procedure TvxPathButton.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('path');
  if (T <> nil) and (T is TvxPath) then
  begin
    TvxPath(T).Data.Assign(FPath);
    TvxPath(T).Fill.Assign(FFill);
    TvxPath(T).Stroke.Assign(FStroke);
    TvxPath(T).StrokeThickness := FStrokeThickness;
    TvxPath(T).StrokeCap := FStrokeCap;
    TvxPath(T).StrokeJoin := FStrokeJoin;
    TvxPath(T).StrokeDash := FStrokeDash;
  end;
  T := FindResource('pathowner');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    TvxVisualObject(T).Padding.Rect := vgRect(FPathPadding, FPathPadding, FPathPadding, FPathPadding);
    if (Length(FPath.PathData) = 0) then
    begin
      TvxVisualObject(T).Align := vaNone;
    end
    else
      case FPathLayout of
        vgGlyphLeft:
          begin
            TvxVisualObject(T).Align := vaLeft;
            TvxVisualObject(T).Width := FPathSize;
            TvxVisualObject(T).Padding.right := FPathSpacing;
          end;
        vgGlyphRight:
          begin
            TvxVisualObject(T).Align := vaRight;
            TvxVisualObject(T).Width := FPathSize;
            TvxVisualObject(T).Padding.left := FPathSpacing;
          end;
        vgGlyphTop:
          begin
            TvxVisualObject(T).Align := vaTop;
            TvxVisualObject(T).Height := FPathSize;
            TvxVisualObject(T).Padding.bottom := FPathSpacing;
          end;
        vgGlyphBottom:
          begin
            TvxVisualObject(T).Align := vaBottom;
            TvxVisualObject(T).Height := FPathSize;
            TvxVisualObject(T).Padding.top := FPathSpacing;
          end;
        vgGlyphCenter:
          begin
            TvxVisualObject(T).Align := vaCenter;
            TvxVisualObject(T).Width := FPathSize;
            TvxVisualObject(T).Height := FPathSize;
            TvxVisualObject(T).Padding.Rect := vgRect(FPathSpacing, FPathSpacing, FPathSpacing, FPathSpacing);
          end;
      end;
  end;
  T := FindResource('text');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    TvxVisualObject(T).Padding.Rect := vgRect(FPathPadding, FPathPadding, FPathPadding, FPathPadding);
  end;
end;

procedure TvxPathButton.DoPathChanged(Sender: TObject);
begin
  Repaint;
  ApplyStyle;
end;

procedure TvxPathButton.SetPath(const Value: TvxPathData);
begin
  FPath.Assign(Value);
end;

procedure TvxPathButton.SetPathLayout(const Value: TvxButtonLayout);
begin
  if FPathLayout <> Value then
  begin
    FPathLayout := Value;
    ApplyStyle;
  end;
end;

procedure TvxPathButton.SetPathPadding(const Value: single);
begin
  if FPathPadding <> Value then
  begin
    FPathPadding := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxPathButton.SetPathSize(const Value: single);
begin
  if FPathSize <> Value then
  begin
    FPathSize := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxPathButton.SetPathSpacing(const Value: single);
begin
  if FPathSpacing <> Value then
  begin
    FPathSpacing := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

function TvxPathButton.isStrokeThicknessStored: Boolean;
begin
  Result := FStrokeThickness <> 1;
end;

procedure TvxPathButton.SetFill(const Value: TvxBrush);
begin
  FFill := Value;
end;

procedure TvxPathButton.SetStroke(const Value: TvxBrush);
begin
  FStroke := Value;
end;

procedure TvxPathButton.SetStrokeCap(const Value: TvxStrokeCap);
begin
  if FStrokeCap <> Value then
  begin
    FStrokeCap := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxPathButton.SetStrokeDash(const Value: TvxStrokeDash);
begin
  if FStrokeDash <> Value then
  begin
    FStrokeDash := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxPathButton.SetStrokeJoin(const Value: TvxStrokeJoin);
begin
  if FStrokeJoin <> Value then
  begin
    FStrokeJoin := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxPathButton.SetStrokeThickness(const Value: single);
begin
  if FStrokeThickness <> Value then
  begin
    FStrokeThickness := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

{ TvxToolButton }

constructor TvxToolButton.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  FBitmapLayout := vgGlyphTop;

  FRepeat := true;
end;

procedure TvxToolButton.Paint;
begin

  if Checked then
  begin
    //Canvas.DrawLine(vgPoint(0, 0), vgPoint(30, 30), 1);

    Canvas.Stroke.Style := vgBrushNone;
    Canvas.Fill.Style := vgBrushSolid;
    Canvas.Fill.SolidColor := $FF00FF00;
    Canvas.FillRect(vgRect(0, 0, Width, Height), 0, 0, [], 1);
  end;
  inherited;
end;

procedure TvxToolButton.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('image');
  if (T <> nil) and (T is TvxImage) then
  begin
    if IsPressed then
      TvxImage(T).Bitmap.Canvas.DrawLine(vgPoint(0, 0), vgPoint(30, 30), 1)
    else
      TvxImage(T).Bitmap.Assign(FBitmap);
  end;
end;
{ TvxToolPathButton }

constructor TvxToolPathButton.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  FPathLayout := vgGlyphTop;
end;

{ TvxSpeedButton }

constructor TvxSpeedButton.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  FRepeat := true;
  Width := 23;
  Height := 23;
  Text := '';
end;

destructor TvxSpeedButton.Destroy;
begin
  inherited;
end;

{ TvxColorButton }

constructor TvxColorButton.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := false;
  FColor := vcBlack;
  FUseStandardDialog := true;
end;

destructor TvxColorButton.Destroy;
begin
  inherited;
end;

procedure TvxColorButton.ApplyStyle;
var
  O: TvxObject;
begin
  inherited;
  O := FindResource('fill');
  if (O <> nil) and (O is TvxShape) then
  begin
    FFill := TvxShape(O);
    FFill.Fill.Color := FColor;
  end;
end;

procedure TvxColorButton.FreeStyle;
begin
  inherited;
  FFill := nil;
end;

procedure TvxColorButton.SetColor(const Value: string);
begin
  FColor := Value;
  if FFill <> nil then
    FFill.Fill.Color := FColor;
  if not (csLoading in ComponentState) then
    if Assigned(FOnChange) then
      FOnChange(Self);
end;

function SwapColor(const C: TvxColor): TvxColor;
begin
  Result := C;
  TvxColorRec(Result).R := TvxColorRec(C).B;
  TvxColorRec(Result).B := TvxColorRec(C).R;
end;

procedure TvxColorButton.Click;
{$IFNDEF NOVCL}
var
  C: TColorDialog;
  V: TvxBrushDialog;
  {$ENDIF}
begin
  inherited;
  {$IFNDEF NOVCL}
  if FUseStandardDialog then
  begin
    C := TColorDialog.Create(nil);
    C.Color := SwapColor(vgStrToColor(FColor)) and $FFFFFF;
    if C.Execute then
    begin
      Color := vgColorToStr($FF000000 or SwapColor(C.Color));
    end;
    C.Free;
  end
  else
  begin
    V := TvxBrushDialog.Create(nil);
    V.Brush.Style := vgBrushSolid;
    V.Brush.Color := FColor;
    V.ShowStyles := [vgBrushSolid];
    if V.Execute then
    begin
      Color := V.Brush.Color;
    end;
    V.Free;
  end;
  {$ENDIF}
end;

{ TvxCornerButton }

constructor TvxCornerButton.Create(AOwner: TComponent);
begin
  inherited;
  FCorners := AllCorners;
  FxRadius := 3;
  FyRadius := 3;
  FSides := AllSides;
end;

destructor TvxCornerButton.Destroy;
begin

  inherited;
end;

procedure TvxCornerButton.ApplyStyle;
var
  Background: TvxObject;
begin
  inherited;
  Background := FindResource('Background');
  if (Background <> nil) and (Background is TvxRectangle) then
  begin
    TvxRectangle(Background).CornerType := FCornerType;
    TvxRectangle(Background).Corners := FCorners;
    TvxRectangle(Background).xRadius := xRadius;
    TvxRectangle(Background).yRadius := yRadius;
    TvxRectangle(Background).Sides := FSides;
  end;
end;

function TvxCornerButton.IsCornersStored: Boolean;
begin
  Result := FCorners <> AllCorners;
end;

function TvxCornerButton.IsSidesStored: Boolean;
begin
  Result := FSides * AllSides <> []
end;

procedure TvxCornerButton.SetCorners(const Value: TvxCorners);
begin
  if FCorners <> Value then
  begin
    FCorners := Value;
    ApplyStyle;
  end;
end;

procedure TvxCornerButton.SetCornerType(const Value: TvxCornerType);
begin
  if FCornerType <> Value then
  begin
    FCornerType := Value;
    ApplyStyle;
  end;
end;

procedure TvxCornerButton.SetxRadius(const Value: single);
begin
  if FxRadius <> Value then
  begin
    FxRadius := Value;
    ApplyStyle;
  end;
end;

procedure TvxCornerButton.SetyRadius(const Value: single);
begin
  if FyRadius <> Value then
  begin
    FyRadius := Value;
    ApplyStyle;
  end;
end;

procedure TvxCornerButton.SetSides(const Value: TvxSides);
begin
  if FSides <> Value then
  begin
    FSides := Value;
    ApplyStyle;
  end;
end;

{ TvxCheckBox ===================================================================}

constructor TvxCheckBox.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  AutoCapture := true;
  CanFocused := true;
  TextAlign := vgTextAlignNear;
  Width := 120;
  Height := 19;
end;

destructor TvxCheckBox.Destroy;
begin
  inherited;
end;

function TvxCheckBox.GetData: Variant;
begin
  Result := IsChecked;
end;

procedure TvxCheckBox.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    if VarIsType(Value, varBoolean) then
    IsChecked := Value
  else
    IsChecked := false;
end;

procedure TvxCheckBox.ApplyStyle;
begin
  inherited;
  StartTriggerAnimation(Self, 'IsChecked');
end;

procedure TvxCheckBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    FPressing := true;
    FIsPressed := true;
    StartTriggerAnimation(Self, 'IsPressed');
  end;
end;

procedure TvxCheckBox.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if (ssLeft in Shift) and (FPressing) then
  begin
    if FIsPressed <> vgPtInRect(vgPoint(X, Y), LocalRect) then
    begin
      FIsPressed := vgPtInRect(vgPoint(X, Y), LocalRect);
      StartTriggerAnimation(Self, 'IsPressed');
    end;
  end;
end;

procedure TvxCheckBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if FPressing then
  begin
    FPressing := false;
    FIsPressed := false;
    if vgPtInRect(vgPoint(X, Y), LocalRect) then
    begin
      IsChecked := not IsChecked;
    end
  end;
end;

procedure TvxCheckBox.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
  if (Key = VK_RETURN) or (Key = VK_SPACE) then
  begin
    IsChecked := not IsChecked;
  end;
end;

procedure TvxCheckBox.SetIsChecked(const Value: boolean);
begin
  if FIsChecked <> Value then
  begin
    FIsChecked := Value;
    StartTriggerAnimation(Self, 'IsChecked');
    if Assigned(FOnChange) then
    begin
      FOnChange(Self);
    end;
  end;
end;

{ TvxPathCheckBox =============================================================}

constructor TvxPathCheckBox.Create(AOwner: TComponent);
begin
  inherited;
  FPath := TvxPathData.Create;
  FPath.OnChanged := DoPathChange;
  FPath.Data := 'M 341.236,311.738 L 309.372,342.676 L 291.667,325.488 L 291.667,304.863 L 309.372,321.997 L 341.236,291.113 Z';
end;

destructor TvxPathCheckBox.Destroy;
begin
  FPath.Free;
  inherited;
end;

procedure TvxPathCheckBox.ApplyStyle;
var
  Checkmark: TvxObject;
begin
  inherited;
  Checkmark := FindResource('checkmark');
  if (Checkmark <> nil) and (Checkmark is TvxPath) then
  begin
    TvxPath(Checkmark).Data.Assign(FPath);
  end;
end;

procedure TvxPathCheckBox.DoPathChange(Sender: TObject);
begin
  ApplyStyle;
end;

procedure TvxPathCheckBox.SetPath(const Value: TvxPathData);
begin
  FPath.Assign(Value);
end;

{ TvxRadioButton ===================================================================}

constructor TvxRadioButton.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  AutoCapture := true;
  CanFocused := true;
  TextAlign := vgTextAlignNear;
  Width := 120;
  Height := 19;
end;

destructor TvxRadioButton.Destroy;
begin
  inherited;
end;

function TvxRadioButton.GetData: Variant;
begin
  Result := IsChecked;
end;

procedure TvxRadioButton.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    if VarIsType(Value, varBoolean) then
    IsChecked := Value
  else
    IsChecked := false;
end;

procedure TvxRadioButton.ApplyStyle;
begin
  inherited;
  StartTriggerAnimation(Self, 'IsChecked');
end;

procedure TvxRadioButton.EnterFocus;
begin
  inherited;
end;

procedure TvxRadioButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    FPressing := true;
    FIsPressed := true;
    StartTriggerAnimation(Self, 'IsPressed');
  end;
end;

procedure TvxRadioButton.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if (ssLeft in Shift) and (FPressing) then
  begin
    if FIsPressed <> vgPtInRect(vgPoint(X, Y), LocalRect) then
    begin
      FIsPressed := vgPtInRect(vgPoint(X, Y), LocalRect);
      StartTriggerAnimation(Self, 'IsPressed');
    end;
  end;
end;

procedure TvxRadioButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if FPressing then
  begin
    FPressing := false;
    FIsPressed := false;
    if vgPtInRect(vgPoint(X, Y), LocalRect) then
    begin
      IsChecked := not IsChecked;
    end
  end;
end;

procedure TvxRadioButton.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
  if (Key = VK_RETURN) or (Key = VK_SPACE) then
  begin
    IsChecked := not IsChecked;
  end;
end;

procedure TvxRadioButton.SetIsChecked(const Value: boolean);
var
  List: TList;
  i, c, cc: integer;
begin
  if FIsChecked <> Value then
  begin
    if Value then
      FIsChecked := Value;
    { group }
    c := 0;
    cc := 0;
    if Assigned(FScene) and (FScene.GetRoot <> nil) then
    begin
      List := TList.Create;
      FScene.GetRoot.AddControlsToList(List);
      for i := 0 to List.Count - 1 do
        if (TvxObject(List[i]) is TvxRadioButton) and (TvxObject(List[i]) <> Self) and
          (TvxRadioButton(List[i]).GroupName = GroupName) then
        begin
          if TvxRadioButton(List[i]).IsChecked then
            cc := cc + 1;
          if Value then
            TvxRadioButton(List[i]).IsChecked := false;
          c := c + 1;
        end;
      List.Free;
    end;
    { check }
    if not Value and (c = 0) then
      Exit;
    if not Value and (cc = 0) then
      Exit;
    FIsChecked := Value;
    StartTriggerAnimation(Self, 'IsChecked');
    { event }
    if Assigned(FOnChange) then
    begin
      FOnChange(Self);
    end;
  end;
end;

{ TvxCloseButton }

constructor TvxCloseButton.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  CloseForm := true;
  Width := 20;
  Height := 20;
end;

destructor TvxCloseButton.Destroy;
begin

  inherited;
end;

procedure TvxCloseButton.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if Button = mbLeft then
    FPressing := true;
end;

procedure TvxCloseButton.MouseMove(Shift: TShiftState; X, Y, Dx,
  Dy: single);
begin
  inherited;
end;

procedure TvxCloseButton.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
var
  O: TComponent;
begin
  inherited;
  if FPressing then
  begin
    if FCloseForm and (Scene <> nil) then
    begin
      O := Scene.GetComponent;
      while O <> nil do
      begin
        if (O is TCustomForm) then
        begin
          TCustomForm(O).Close;
          Break;
        end;
        O := O.Owner;
      end;
    end;
    FPressing := false;
    if Assigned(FOnClick) then
      FOnClick(Self);
  end;
end;

{ TvxSizeGrip }

constructor TvxSizeGrip.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxSizeGrip.Destroy;
begin
  inherited;
end;

{ TvxGroupBox =================================================================}

constructor TvxGroupBox.Create(AOwner: TComponent);
begin
  inherited;
  FautoTranslate := true;
  CanFocused := false;
  Width := 120;
  Height := 100;
end;

destructor TvxGroupBox.Destroy;
begin
  inherited;
end;

procedure TvxGroupBox.ApplyStyle;
begin
  inherited;
end;

{ TvxSplitter ===================================================================}

constructor TvxSplitter.Create(AOwner: TComponent);
begin
  inherited;
  FMinSize := 20;
  FShowGrip := true;
  AutoCapture := true;
  Width := 5;
  Align := vaLeft;
  Cursor := crHSplit;
end;

destructor TvxSplitter.Destroy;
begin
  inherited;
end;

procedure TvxSplitter.ApplyStyle;
var
  grip: TvxObject;
begin
  inherited;
  grip := FindResource('grip');
  if (grip <> nil) and (grip is TvxVisualObject) then
  begin
    TvxVisualObject(grip).visible := FShowGrip;
  end;
end;

procedure TvxSplitter.Paint;
var
  R: TvxRect;
begin
  inherited;
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
end;

procedure TvxSplitter.SetAlign(const Value: TvxAlign);
begin
  inherited;
  if Align in [vaTop, vaBottom] then
    Cursor := crVSplit
  else
    Cursor := crHSplit;
end;

function TvxSplitter.FindObject: TvxVisualObject;
var
  P: TvxPoint;
  I: Integer;
  R: TvxRect;
begin
  Result := nil;
  P := Position.Point;
  case Align of
    vaLeft, vaMostLeft: P.X := P.X - 1;
    vaRight, vaMostRight: P.X := P.X + Width + 1;
    vaTop: P.Y := P.Y - 1;
    vaBottom: P.Y := P.Y + Height + 1;
  else
    Exit;
  end;
  if Parent <> nil then
    for I := 0 to Parent.ChildrenCount - 1 do
    begin
      if not Parent.Children[I].IsVisual then
        Continue;
      if TvxVisualObject(Parent.Children[I]).Locked then
        Continue;
      if (Align in [vaLeft, vaMostLeft, vaRight, vaMostRight]) and not ((TvxVisualObject(Parent.Children[I]).Align in [vaLeft, vaMostLeft, vaRight, vaMostRight])) then
        Continue;
      if (Align in [vaTop, vaBottom, vaMostTop, vaMostBottom]) and not ((TvxVisualObject(Parent.Children[I]).Align in [vaTop, vaBottom, vaMostTop, vaMostBottom])) then
        Continue;

      Result := Parent.Children[I].Visual;
      if Result.Visible then
      begin
        R := Result.LocalRect;
        vgOffsetRect(R, Result.Position.X, Result.Position.Y);
        if (R.Right - R.Left) = 0 then
          if Align in [vaTop, vaLeft, vaMostLeft] then
            R.Left := R.Left - 1
          else
            R.Right := R.Right + 1;
        if (R.Bottom - R.Top) = 0 then
          if Align in [vaTop, vaLeft, vaMostLeft] then
            R.Top := R.Top - 1
          else
            R.Bottom := R.Bottom + 1;
        if vgPtInRect(P, R) then
          Exit;
      end;
    end;
  Result := nil;
end;

procedure TvxSplitter.UpdateSize(X, Y: single);
begin
  CalcSplitSize(X, Y, FNewSize, FSplit);
end;

procedure TvxSplitter.CalcSplitSize(X, Y: single; var NewSize, Split: single);
var
  S: single;
begin
  if Align in [vaLeft, vaRight, vaMostLeft, vaMostRight] then
    Split := X - FDownPos.X
  else
    Split := Y - FDownPos.Y;
  S := 0;
  case Align of
    vaLeft, vaMostLeft: S := FControl.Width + Split;
    vaRight, vaMostRight: S := FControl.Width - Split;
    vaTop: S := FControl.Height + Split;
    vaBottom: S := FControl.Height - Split;
  end;
  NewSize := S;
  if S < FMinSize then
    NewSize := FMinSize
  else
    if S > FMaxSize then
    NewSize := FMaxSize;
  if S <> NewSize then
  begin
    if Align in [vaRight, vaMostRight, vaBottom] then
      S := S - NewSize
    else
      S := NewSize - S;
    Split := Split + S;
  end;
end;

function TvxSplitter.DoCanResize(var NewSize: single): Boolean;
begin
  Result := true;
  if (NewSize <= FMinSize) {and FAutoSnap } then
    NewSize := FMinSize;
end;

procedure TvxSplitter.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  i: integer;
begin
  inherited;
  if Button = mbLeft then
  begin
    FPressed := true;
    FDownPos := vgPoint(X, Y);
    FControl := FindObject;
    if Assigned(FControl) then
    begin
      if Align in [vaLeft, vaMostLeft, vaRight, vaMostRight] then
      begin
        FMaxSize := Parent.Visual.Width - FMinSize - Parent.Visual.Margins.left - Parent.Visual.Margins.right;
        for I := 0 to Parent.ChildrenCount - 1 do
        begin
          if not Parent.Children[I].IsVisual then
            Continue;
          with Parent.Children[I].Visual do
            if (Align in [vaLeft, vaRight, vaMostLeft, vaMostRight]) then
              FMaxSize := FMaxSize - Width - Padding.Left - Padding.Right;
        end;
        FMaxSize := FMaxSize + FControl.Width;
      end
      else
      begin
        FMaxSize := Parent.Visual.Height - FMinSize - Parent.Visual.Margins.top - Parent.Visual.Margins.bottom;
        for I := 0 to Parent.ChildrenCount - 1 do
        begin
          if not Parent.Children[I].IsVisual then
            Continue;
          with Parent.Children[I].Visual do
            if Align in [vaTop, vaBottom] then
              FMaxSize := FMaxSize - Height - Padding.top - Padding.bottom;
        end;
        FMaxSize := FMaxSize + FControl.Height;
      end;
      UpdateSize(X, Y);
    end;
  end;
end;

procedure TvxSplitter.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  NewSize, Split: single;
begin
  inherited;
  if FPressed and Assigned(FControl) then
  begin
    CalcSplitSize(X, Y, NewSize, Split);
    if DoCanResize(NewSize) then
    begin
      FNewSize := NewSize;
      FSplit := Split;
      UpdateControlSize;
    end;
  end;
end;

procedure TvxSplitter.UpdateControlSize;
begin
  if FNewSize <> FOldSize then
  begin
    case Align of
      vaLeft, vaMostLeft: FControl.Width := FNewSize;
      vaTop: FControl.Height := FNewSize;
      vaRight, vaMostRight:
        begin
          FControl.Position.X := FControl.Position.X + (FControl.Width - FNewSize);
          FControl.Width := FNewSize;
        end;
      vaBottom:
        begin
          FControl.Position.Y := FControl.Position.Y + (FControl.Height - FNewSize);
          FControl.Height := FNewSize;
        end;
    end;
    //    if Assigned(FOnMoved) then FOnMoved(Self);
    FOldSize := FNewSize;
  end;
end;

procedure TvxSplitter.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  FPressed := false;
  FControl := nil;
end;

procedure TvxSplitter.SetShowGrip(const Value: boolean);
begin
  if FShowGrip <> Value then
  begin
    FShowGrip := Value;
    ApplyStyle;
  end;
end;

{ TvxProgressBar ==============================================================}

constructor TvxProgressBar.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  FMax := 100;
  Width := 100;
  Height := 20;
end;

destructor TvxProgressBar.Destroy;
begin
  inherited;
end;

function TvxProgressBar.GetData: Variant;
begin
  Result := Value;
end;

procedure TvxProgressBar.SetData(const Value: Variant);
begin
  if VarIsNumeric(Value) then
    Self.Value := Value
  else
    Self.Value := Min
end;

procedure TvxProgressBar.ApplyStyle;
var
  I: TvxObject;
begin
  inherited;
  if Orientation = vgHorizontal then
  begin
    I := FindResource('hindicator');
    if (I <> nil) and (I is TvxVisualObject) then
      TvxVisualObject(I).StartTriggerAnimation(Self, 'IsVisible');
  end
  else
  begin
    I := FindResource('vindicator');
    if (I <> nil) and (I is TvxVisualObject) then
      TvxVisualObject(I).StartTriggerAnimation(Self, 'IsVisible');
  end;
  Realign;
end;

procedure TvxProgressBar.Realign;
var
  hI, vI, T: TvxObject;
begin
  if not FDisableAlign then
  begin
    FDisableAlign := true;
    T := nil;
    if Orientation = vgHorizontal then
    begin
      T := FindResource('vtrack');
      if T <> nil then
        T.Visual.Visible := false;
      T := FindResource('htrack')
    end
    else
    begin
      T := FindResource('htrack');
      if T <> nil then
        T.Visual.Visible := false;
      T := FindResource('vtrack');
    end;
    if T = nil then
      T := FindResource('track');
    if (T <> nil) and (T is TvxVisualObject) and (Max > Min) then
    begin
      hI := FindResource('hindicator');
      vI := FindResource('vindicator');
      if Orientation = vgHorizontal then
      begin
        if (hI <> nil) and (hI is TvxVisualObject) then
        begin
          TvxVisualObject(hI).Width := ((Value - Min) / (Max - Min)) * (TvxVisualObject(T).Width - TvxVisualObject(T).Margins.Left - TvxVisualObject(T).Margins.Right -
            TvxVisualObject(hI).Padding.Left - TvxVisualObject(hI).Padding.Right);
          TvxVisualObject(hI).Visible := TvxVisualObject(hI).Width > 2;
        end;
        if (vI <> nil) and (vI is TvxVisualObject) then
          TvxVisualObject(vI).Visible := false;
      end
      else
      begin
        if (vI <> nil) and (vI is TvxVisualObject) then
        begin
          TvxVisualObject(vI).Height := ((Value - Min) / (Max - Min)) * (TvxVisualObject(T).Height - TvxVisualObject(T).Margins.Top - TvxVisualObject(T).Margins.Bottom -
            TvxVisualObject(hI).Padding.Top - TvxVisualObject(hI).Padding.Bottom);
          TvxVisualObject(vI).Visible := TvxVisualObject(vI).Height > 2;
        end;
        if (hI <> nil) and (hI is TvxVisualObject) then
          TvxVisualObject(hI).Visible := false;
      end;
    end;
    FDisableAlign := false;
  end;
  inherited;
end;

procedure TvxProgressBar.SetMax(const Value: single);
begin
  FMax := Value;
end;

procedure TvxProgressBar.SetMin(const Value: single);
begin
  FMin := Value;
end;

procedure TvxProgressBar.SetOrientation(const Value: TvxOrientation);
var
  T: single;
begin
  if FOrientation <> Value then
  begin
    FOrientation := Value;
    // swap
    if Assigned(FScene) and (FScene.GetDesignTime) and not (csLoading in ComponentState) then
    begin
      T := Width;
      Width := Height;
      Height := T;
    end;
    Realign;
  end;
end;

procedure TvxProgressBar.SetValue(const Value: single);
begin
  if FValue <> Value then
  begin
    FValue := Value;
    Realign;
  end;
end;

{ TvxThumb ====================================================================}

constructor TvxThumb.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  AutoCapture := true;
end;

destructor TvxThumb.Destroy;
begin
  inherited;
end;

procedure TvxThumb.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if (Button = mbLeft) and Enabled then
  begin
    FPressed := true;
    FDownOffset := vgPoint(X, Y);

    if FTrack <> nil then
      FTrack.SetFocus;
  end;
end;

procedure TvxThumb.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  P: TvxPoint;
begin
  inherited;
  if FPressed and (FTrack <> nil) and (Enabled) and (Parent <> nil) and (Parent.IsVisual) then
  begin
    if FTrack.Orientation = vgHorizontal then
    begin
      P := FTrack.AbsoluteToLocal(LocalToAbsolute(vgPoint(X, 0)));
      if FTrack.ViewportSize = 0 then
        FTrack.Value := FTrack.Min + (((P.X) / FTrack.Width) * (FTrack.FMax - FTrack.FMin))
      else
        FTrack.Value := FTrack.Min + (((P.X - FDownOffset.X) / FTrack.Width) * (FTrack.FMax - FTrack.FMin))
    end
    else
    begin
      P := FTrack.AbsoluteToLocal(LocalToAbsolute(vgPoint(0, Y)));
      if FTrack.ViewportSize = 0 then
        FTrack.Value := FTrack.Min + (((P.Y) / FTrack.Height) * (FTrack.FMax - FTrack.FMin))
      else
        FTrack.Value := FTrack.Min + (((P.Y - FDownOffset.Y) / FTrack.Height) * (FTrack.FMax - FTrack.FMin))
    end;
  end;
end;

procedure TvxThumb.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  V: single;
begin
  inherited;
  if FPressed then
  begin
    if not FTrack.Tracking and Assigned(FTrack.FOnChange) then
    begin
      FTrack.FTracking := true;
      V := FTrack.FValue;
      FTrack.FValue := $FFFF;
      FTrack.Value := V;
      FTrack.FTracking := false;
    end;
    FPressed := false;
  end;
end;

{ TvxCustomTrack ====================================================================}

constructor TvxCustomTrack.Create(AOwner: TComponent);
begin
  inherited;
  FViewportSize := 0;
  FMax := 100;
  FTracking := true;
  Width := 100;
  Height := 15;
end;

destructor TvxCustomTrack.Destroy;
begin
  inherited;
end;

function TvxCustomTrack.GetData: Variant;
begin
  Result := Value;
end;

procedure TvxCustomTrack.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    if VarIsNumeric(Value) then
    Self.Value := Value
  else
    Self.Value := Min
end;

function TvxCustomTrack.GetThumbRect: TvxRect;
begin
  Result := LocalRect;
  if (FMax - FMin) > 0 then
  begin
    if Orientation = vgHorizontal then
    begin
      Result := vgRect(0, 0, (FViewportSize / (FMax - FMin)) * Width, Height);
      vgOffsetRect(Result, Round((((FValue - FMin) / (FMax - FMin))) * Width), 0);
      if Result.Right - Result.Left < Height then
      begin
        Result.Right := Result.Left + trunc(Height / 2);
        Result.Left := Result.Left - trunc(Height / 2);
      end;
      if Result.Right > Width then
        vgOffsetRect(Result, Width - Result.Right, 0);
      if Result.Left < 0 then
        vgOffsetRect(Result, -Result.Left, 0);
    end
    else
    begin
      Result := vgRect(0, 0, Width, (FViewportSize / (FMax - FMin)) * Height);
      if Result.Bottom - Result.Top < Width then
      begin
        Result.Bottom := Result.Top + trunc(Width / 2);
        Result.Top := Result.Top - trunc(Width / 2);
      end;
      vgOffsetRect(Result, 0, Round((((FValue - FMin) / (FMax - FMin))) * Height));
      if Result.Bottom > Height then
        vgOffsetRect(Result, 0, Height - Result.Bottom);
      if Result.Top < 0 then
        vgOffsetRect(Result, 0, -Result.Top);
    end;
  end;
  if (Thumb <> nil) and (Thumb.Parent <> nil) and (Thumb.Parent.IsVisual) then
  begin
    if vgRectWidth(Result) > TvxVisualObject(Thumb.Parent).Margins.Left + Thumb.Padding.Left + TvxVisualObject(Thumb.Parent).Margins.Right - Thumb.Padding.Right then
    begin
      Result.Left := Result.Left + TvxVisualObject(Thumb.Parent).Margins.Left + Thumb.Padding.Left;
      Result.Right := Result.Right - TvxVisualObject(Thumb.Parent).Margins.Right - Thumb.Padding.Right;
    end;
    Result.Top := Result.Top + TvxVisualObject(Thumb.Parent).Margins.Top + Thumb.Padding.Top;
    Result.Bottom := Result.Bottom - TvxVisualObject(Thumb.Parent).Margins.Bottom - Thumb.Padding.Bottom;
  end;
end;

function TvxCustomTrack.GetThumb: TvxThumb;
var
  T: TvxObject;
begin
  T := FindResource('thumb');
  if (T <> nil) and (T is TvxThumb) then
  begin
    Result := TvxThumb(T);
    Result.FTrack := Self;
  end
  else
    Result := nil;
end;

procedure TvxCustomTrack.Realign;
begin
  inherited;
  if Thumb <> nil then
  begin
    with GetThumbRect do
    begin
      Thumb.Position.X := Left;
      Thumb.Position.Y := Top;
      if Round(Right - Left) > 0 then
        Thumb.Width := Round(Right - Left);
      if Round(Bottom - Top) > 0 then
        Thumb.Height := Round(Bottom - Top);
    end;
  end;
end;

procedure TvxCustomTrack.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    if Orientation = vgHorizontal then
    begin
      if FViewportSize = 0 then
        Value := Min + ((X / Width) * (FMax - FMin))
      else
      begin
        if Min + ((X / Width) * (FMax - FMin)) > Value then
          Value := Value + FViewportSize
        else
          Value := Value - FViewportSize
      end;
    end
    else
    begin
      if FViewportSize = 0 then
        Value := Min + ((Y / Height) * (FMax - FMin))
      else
      begin
        if Min + ((Y / Height) * (FMax - FMin)) > Value then
          Value := Value + FViewportSize
        else
          Value := Value - FViewportSize
      end;
    end;
  end;
end;

procedure TvxCustomTrack.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
end;

procedure TvxCustomTrack.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
end;

procedure TvxCustomTrack.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
var
  inc: single;
begin
  inc := Frequency;
  if inc = 0 then
    inc := 1;
  inherited;
  case Key of
    VK_HOME: Value := Min;
    VK_END: Value := Max;
    VK_UP: Value := Value - inc;
    VK_DOWN: Value := Value + inc;
    VK_LEFT: Value := Value - inc;
    VK_RIGHT: Value := Value + inc;
  else
    Exit;
  end;
  if not Tracking and Assigned(FOnChange) then
    FOnChange(Self);
  Key := 0;
end;

procedure TvxCustomTrack.SetMax(const Value: single);
begin
  if FMax <> Value then
  begin
    FMax := Value;
    if FMax < FMin then
      FMax := FMin + 0.001;
    if FViewportSize > (FMax - FMin) then
      FViewportSize := FMax - FMin;
    if FValue > FMax - FViewportSize then
      FValue := FMax - FViewportSize;
    Realign;
  end;
end;

procedure TvxCustomTrack.SetMin(const Value: single);
begin
  if FMin <> Value then
  begin
    FMin := Value;
    Realign;
  end;
end;

procedure TvxCustomTrack.SetOrientation(const Value: TvxOrientation);
var
  T: single;
begin
  if FOrientation <> Value then
  begin
    FOrientation := Value;
    // swap
    if Assigned(FScene) and (FScene.GetDesignTime) and not (csLoading in ComponentState) then
    begin
      T := Width;
      Width := Height;
      Height := T;
    end;
    Realign;
  end;
end;

function TvxCustomTrack.GetIsTracking: boolean;
begin
  Result := (Thumb <> nil) and Thumb.FPressed;
end;

procedure TvxCustomTrack.SetFrequency(const Value: single);
begin
  if FFrequency <> Value then
  begin
    FFrequency := Value;
    if FFrequency <> 0 then
      Self.Value := Round(Self.Value / Frequency) * Frequency;
  end;
end;

procedure TvxCustomTrack.SetValue(Value: single);
begin
  if FFrequency <> 0 then
    Value := Round(Value / Frequency) * Frequency;
  if FValue <> Value then
  begin
    FValue := Value;
    if FValue > FMax - FViewportSize then
      FValue := FMax - FViewportSize;
    if FValue < FMin then
      FValue := FMin;
    if GetIsTracking and Assigned(FOnTracking) then
      FOnTracking(Self);
    if Tracking and Assigned(FBindingObjects) then
      ToBindingObjects;
    if GetIsTracking and Tracking and Assigned(FOnChange) then
      FOnChange(Self)
    else
      if not GetIsTracking and Assigned(FOnChange) then
      FOnChange(Self);
    Realign;
  end;
end;

procedure TvxCustomTrack.SetViewportSize(const Value: single);
begin
  if FViewportSize <> Value then
  begin
    FViewportSize := Value;
    if FViewportSize > (FMax - FMin) then
      FViewportSize := FMax - FMin;
    if FValue > FMax - FViewportSize then
      Self.Value := FMax - FViewportSize;
    Realign;
  end;
end;

{ TvxTrackBar }

constructor TvxTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FViewportSize := 0;
  CanFocused := true;
end;

{ TvxScrollBar ================================================================}

constructor TvxScrollBar.Create(AOwner: TComponent);
begin
  inherited;
  FMax := 100;
  FViewportSize := 0;
  FSmallChange := 1;
  Width := 150;
  Height := 18;
end;

destructor TvxScrollBar.Destroy;
begin
  inherited;
end;

function TvxScrollBar.GetData: Variant;
begin
  Result := Value;
end;

procedure TvxScrollBar.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    if VarIsNumeric(Value) then
    Self.Value := Value
  else
    Self.Value := Min
end;

function TvxScrollBar.Track: TvxCustomTrack;
var
  T: TvxObject;
  HT, VT: TvxCustomTrack;
begin
  HT := nil;
  VT := nil;
  T := FindResource('htrack');
  if (T <> nil) and (T is TvxCustomTrack) then
  begin
    HT := TvxCustomTrack(T);
    HT.FOrientation := vgHorizontal;
    HT.FMax := Max;
    HT.FMin := Min;
    HT.FValue := Value;
    HT.ViewportSize := ViewportSize;
    HT.Visible := Orientation = vgHorizontal;
    HT.OnChange := DoTrackChanged;
    HT.CanFocused := false;
    if HT.visible then
      HT.Realign;
  end;
  T := FindResource('vtrack');
  if (T <> nil) and (T is TvxCustomTrack) then
  begin
    VT := TvxCustomTrack(T);
    VT.FOrientation := vgVertical;
    VT.FMax := Max;
    VT.FMin := Min;
    VT.FValue := Value;
    VT.ViewportSize := ViewportSize;
    VT.Visible := Orientation = vgVertical;
    VT.OnChange := DoTrackChanged;
    VT.CanFocused := false;
    if VT.visible then
      VT.Realign;
  end;
  if Orientation = vgVertical then
    Result := VT
  else
    Result := HT;
end;

function TvxScrollBar.MinButton: TvxCustomButton;
var
  T: TvxObject;
  LB, TB: TvxCustomButton;
begin
  TB := nil;
  LB := nil;
  T := FindResource('leftbutton');
  if (T <> nil) and (T is TvxCustomButton) then
  begin
    LB := TvxCustomButton(T);
    LB.OnClick := DoMinButtonClick;
    LB.Visible := Orientation = vgHorizontal;
    LB.CanFocused := false;
  end;

  T := FindResource('topbutton');
  if (T <> nil) and (T is TvxCustomButton) then
  begin
    TB := TvxCustomButton(T);
    TB.OnClick := DoMinButtonClick;
    TB.Visible := Orientation = vgVertical;
    TB.CanFocused := false;
  end;

  if Orientation = vgVertical then
    Result := TB
  else
    Result := LB;
end;

function TvxScrollBar.MaxButton: TvxCustomButton;
var
  T: TvxObject;
  RB, BB: TvxCustomButton;
begin
  RB := nil;
  BB := nil;
  T := FindResource('rightbutton');
  if (T <> nil) and (T is TvxCustomButton) then
  begin
    RB := TvxCustomButton(T);
    RB.OnClick := DoMaxButtonClick;
    RB.Visible := Orientation = vgHorizontal;
    RB.CanFocused := false;
  end;

  T := FindResource('bottombutton');
  if (T <> nil) and (T is TvxCustomButton) then
  begin
    BB := TvxCustomButton(T);
    BB.OnClick := DoMaxButtonClick;
    BB.Visible := Orientation = vgVertical;
    RB.CanFocused := false;
  end;

  if Orientation = vgVertical then
    Result := BB
  else
    Result := RB;
end;

procedure TvxScrollBar.DoTrackChanged(Sender: TObject);
begin
  Value := TvxCustomTrack(Sender).Value;
end;

procedure TvxScrollBar.DoMinButtonClick(Sender: TObject);
begin
  Value := Value - SmallChange;
end;

procedure TvxScrollBar.DoMaxButtonClick(Sender: TObject);
begin
  Value := Value + SmallChange;
end;

procedure TvxScrollBar.Realign;
begin
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  Track;
  MinButton;
  MaxButton;
  FDisableAlign := false;
  inherited;
end;

procedure TvxScrollBar.SetMax(const Value: single);
begin
  if FMax <> Value then
  begin
    FMax := Value;
    if FMax < FMin then
      FMax := FMin + 0.001;
    if FValue > FMax - FViewportSize then
      Self.Value := FMax - FViewportSize;
    if FViewportSize > (FMax - FMin) then
      FViewportSize := FMax - FMin;
    Realign;
  end;
end;

procedure TvxScrollBar.SetMin(const Value: single);
begin
  if FMin <> Value then
  begin
    FMin := Value;
    if FValue < FMin then
      Self.Value := FMin;
    Realign;
  end;
end;

procedure TvxScrollBar.SetOrientation(const Value: TvxOrientation);
var
  T: single;
begin
  if FOrientation <> Value then
  begin
    FOrientation := Value;
    // swap
    if Assigned(FScene) and (FScene.GetDesignTime) and not (csLoading in ComponentState) then
    begin
      T := Width;
      Width := Height;
      Height := T;
    end;
    Realign;
  end;
end;

procedure TvxScrollBar.SetValue(const Value: single);
begin
  if FValue <> Value then
  begin
    FValue := Value;
    if FValue > FMax - FViewportSize then
      FValue := FMax - FViewportSize;
    if FValue < FMin then
      FValue := FMin;
    if Assigned(FBindingObjects) then
      ToBindingObjects;
    if Assigned(FOnChange) then
      FOnChange(Self);
    Realign;
  end;
end;

procedure TvxScrollBar.SetViewportSize(const Value: single);
begin
  if FViewportSize <> Value then
  begin
    FViewportSize := Value;
    if FViewportSize > (FMax - FMin) then
      FViewportSize := FMax - FMin;
    if FValue > FMax - FViewportSize then
      Self.Value := FMax - FViewportSize;
    Realign;
  end;
end;

{ TvxSmallScrollBar }

constructor TvxSmallScrollBar.Create(AOwner: TComponent);
begin
  inherited;
  Height := 8;
end;

{ TvxAniIndicator =============================================================}

constructor TvxAniIndicator.Create(AOwner: TComponent);
begin
  inherited;
  FLayout := TvxVisualObject.Create(Self);
  FLayout.Parent := Self;
  FLayout.Align := vaContents;
  FLayout.Locked := true;
  FLayout.Stored := false;
  FAni := TvxFloatAnimation.Create(Self);
  FAni.Parent := FLayout;
  FAni.Loop := true;
  FAni.StartValue := 0;
  FAni.StopValue := 360;
  FAni.Duration := 10;
  FAni.PropertyName := 'RotateAngle';
end;

destructor TvxAniIndicator.Destroy;
begin
  inherited;
end;

procedure TvxAniIndicator.Paint;
var
  a: integer;
  P, P2: TvxPoint;
  wSize, eSize: single;
  V: single;
begin
  if Width < Height then
    wSize := Width / 2
  else
    wSize := Height / 2;
  eSize := wSize / 3.7;
  wSize := wSize - eSize;

  case FStyle of
    vgAniIndicatorLine:
      begin
        Canvas.Stroke.Style := vgBrushsolid;
        Canvas.StrokeThickness := eSize / 2;
        for a := 0 to 11 do
        begin
          P := vgPoint(Width / 2 + (cos(vgDegToRad(a * 30)) * wSize), Height / 2 + (sin(vgDegToRad(a * 30)) * wSize));
          P2 := vgPoint(Width / 2 + (cos(vgDegToRad(a * 30)) * (wSize / 2)), Height / 2 + (sin(vgDegToRad(a * 30)) * (wSize / 2)));
          Canvas.Fill.SolidColor := $FFBABABA;
          Canvas.Stroke.SolidColor := $FFBABABA;
          Canvas.DrawLine(P, P2, Opacity);
          if FEnabled then
          begin
            V := ((Trunc(FLayout.RotateAngle) + (30 - Trunc((a / 12) * 30))) mod 30) / 30;
            if V > 1 then
              V := Abs(V - 2);
            V := 1 - V;
            Canvas.Stroke.SolidColor := $FF000000;
            Canvas.DrawLine(P, P2, V * Opacity);
          end;
        end;
      end;
    vgAniIndicatorCircle:
      begin
        Canvas.Stroke.Style := vgBrushNone;
        for a := 0 to 7 do
        begin
          P := vgPoint(Width / 2 + (cos(vgDegToRad(a * 45)) * wSize), Height / 2 + (sin(vgDegToRad(a * 45)) * wSize));
          Canvas.Fill.SolidColor := $FFBABABA;
          Canvas.FillEllipse(vgRect(P.X - eSize, P.Y - eSize, P.X + eSize, P.Y + eSize), Opacity);
          if FEnabled then
          begin
            V := ((Trunc(FLayout.RotateAngle) + (30 - Trunc((a / 7) * 30))) mod 30) / 30;
            if V > 1 then
              V := Abs(V - 2);
            V := 1 - V;
            Canvas.Fill.SolidColor := $FF000000;
            Canvas.FillEllipse(vgRect(P.X - eSize, P.Y - eSize, P.X + eSize, P.Y + eSize), V * Opacity);
          end;
        end;
      end;
  end;
end;

procedure TvxAniIndicator.SetEnabled(const Value: boolean);
begin
  if FEnabled <> Value then
  begin
    FEnabled := Value;
    if FEnabled then
    begin
      FAni.Start;
    end
    else
      FAni.Stop;
  end;
end;

procedure TvxAniIndicator.SetStyle(const Value: TvxAniIndicatorStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    Repaint;
  end;
end;

{ TvxAngleButton ===================================================================}

constructor TvxAngleButton.Create(AOwner: TComponent);
begin
  inherited;
  Width := 30;
  Height := 30;
  FFrequency := 0;
  FTracking := true;
  AutoCapture := true;
end;

destructor TvxAngleButton.Destroy;
begin
  inherited;
end;

function TvxAngleButton.GetData: Variant;
begin
  Result := Value;
end;

procedure TvxAngleButton.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    if VarIsNumeric(Value) then
    Self.Value := Value
  else
    Self.Value := 0
end;

procedure TvxAngleButton.ApplyStyle;
begin
  inherited;
  Tick;
  Text;
end;

function TvxAngleButton.Tick: TvxVisualObject;
var
  T: TvxObject;
begin
  T := FindResource('tick');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    Result := TvxVisualObject(T);
    Result.RotateAngle := -FValue;
  end
  else
    Result := nil;
end;

function TvxAngleButton.Text: TvxText;
var
  T: TvxObject;
begin
  T := FindResource('tracktext');
  if (T <> nil) and (T is TvxText) then
  begin
    TvxText(T).Visible := false; //FPressing;
    TvxText(T).Text := IntToStr(Round(Value)) + System.WideChar($B0);
    if FPressing and not FTracking then
      TvxText(T).Opacity := 1
    else
      TvxText(T).Opacity := 0;
  end;

  T := FindResource('text');
  if (T <> nil) and (T is TvxText) then
  begin
    Result := TvxText(T);
    Result.Visible := FShowValue;
    Result.Text := IntToStr(Round(Value)) + System.WideChar($B0);
    if not FShowValue then
      Result.Opacity := 0
    else
      Result.Opacity := 1;
  end
  else
    Result := nil;
end;

procedure TvxAngleButton.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    FPressing := true;
    FOldPos := vgPoint(X, Y);
    FSaveValue := Value;
    Text;
  end;
end;

procedure TvxAngleButton.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if (ssLeft in Shift) and (FPressing) then
  begin
    Value := vgVectorAngle(vgVector(1, 0), vgVector(X - (Width / 2), Y - (Height / 2)));
    FOldPos := vgPoint(X, Y);
    Text;
  end;
end;

procedure TvxAngleButton.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if FPressing then
  begin
    FPressing := false;
    Text;
    if Value <> FSaveValue then
      if Assigned(FOnChange) then
        FOnChange(Self);
  end;
end;

procedure TvxAngleButton.Paint;
begin
  inherited;
end;

procedure TvxAngleButton.SetValue(const Value: single);
begin
  if (FFrequency = 0) then
  begin
    if (FValue <> Value) then
    begin
      FValue := Value;
      if Tick <> nil then
        Tick.RotateAngle := -FValue
      else
        Repaint;
      Text;
      if Assigned(FOnChange) and (not FPressing or FTracking) then
        FOnChange(Self);
    end;
  end
  else
  begin
    if FValue <> Round(Value / FFrequency) * FFrequency then
    begin
      FValue := Round(Value / FFrequency) * FFrequency;
      if Tick <> nil then
        Tick.RotateAngle := -FValue
      else
        Repaint;
      Text;
      if Assigned(FOnChange) and (not FPressing or FTracking) then
        FOnChange(Self);
    end;
  end;
end;

procedure TvxAngleButton.SetShowValue(const Value: boolean);
begin
  if FShowValue <> Value then
  begin
    FShowValue := Value;
    Text;
    Repaint;
  end;
end;

procedure TvxTrackBar.Loaded;
begin
  inherited;
end;

procedure TvxTrackBar.SetMax(const Value: single);
begin
  if FMax <> Value then
  begin
    inherited;
  end;
end;

procedure TvxTrackBar.SetMin(const Value: single);
begin
  inherited;
  if FMin <> Value then
  begin
    inherited;
  end;
end;

{ TvxExpanderButton }

constructor TvxExpanderButton.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
end;

destructor TvxExpanderButton.Destroy;
begin
  inherited;
end;

{ TvxExpander =================================================================}

constructor TvxExpander.Create(AOwner: TComponent);
begin
  inherited;
  Width := 130;
  Height := 130;

  FAutoTranslate := true;

  FIsExpanded := true;
  FIsChecked := true;

  FContent := TvxContent.Create(Self);
  FContent.Parent := Self;
  FContent.ClipChildren := false;
  FContent.HitTest := false;
  FContent.Locked := true;
  FContent.Stored := false;
  FContent.Padding.Top := 25;
  FContent.Width := Width;
  FContent.Height := Height;
end;

procedure TvxExpander.AddObject(AObject: TvxObject);
begin
  if (FContent <> nil) and (AObject <> FContent) and (AObject <> FResourceLink) then
  begin
    FContent.AddObject(AObject);
  end
  else
    inherited;
end;

procedure TvxExpander.ApplyStyle;
var
  O: TvxObject;
begin
  inherited;
  O := FindResource('checkbox');
  if (O <> nil) and (O is TvxCheckBox) then
  begin
    FCheck := TvxCheckBox(O);
    FCheck.Visible := FShowCheck;
    FCheck.IsChecked := FIsChecked;
    FCheck.OnChange := DoCheckChange;
  end;
  O := FindResource('button');
  if (O <> nil) and (O is TvxCustomButton) then
  begin
    FButton := TvxCustomButton(O);
    FButton.OnClick := DoButtonClick;
    FButton.ApplyResource;
    FButton.StartTriggerAnimation(Self, 'IsExpanded');
    FButton.CanFocused := false;
  end;
  StartTriggerAnimation(Self, 'IsExpanded');
end;

procedure TvxExpander.FreeStyle;
begin
  inherited;
  FCheck := nil;
  FButton := nil;
end;

destructor TvxExpander.Destroy;
begin
  inherited;
end;

procedure TvxExpander.DoButtonClick(Sender: TObject);
begin
  IsExpanded := not FIsExpanded;
end;

procedure TvxExpander.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('ContentSize', ReadContentSize, WriteContentSize, true);
end;

procedure TvxExpander.ReadContentSize(Reader: TReader);
begin
  if FContent <> nil then
    FContent.Height := vgStrToFloat(Reader.ReadString);
end;

procedure TvxExpander.WriteContentSize(Writer: TWriter);
begin
  if FContent <> nil then
    Writer.WriteString(vgFloatToStr(FContent.Height));
end;

procedure TvxExpander.Realign;
begin
  inherited;
  if csLoading in ComponentState then
    Exit;
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  { content }
  if (FContent <> nil) and (IsExpanded) then
  begin
    FContent.Position.X := 0;
    FContent.Position.Y := FContent.Padding.Top;
    FContent.Width := Width;
    FContent.Height := Height - FContent.Padding.Top;
  end;
  FDisableAlign := false;
end;

procedure TvxExpander.SetIsExpanded(const Value: boolean);
begin
  if FIsExpanded <> Value then
  begin
    if FResourceLink = nil then
      ApplyResource;
    FIsExpanded := Value;
    if FIsExpanded then
    begin
      FContent.Visible := FIsExpanded;
      if FButton <> nil then
        Height := FButton.Height + FContent.Height;
      Repaint;
    end
    else
    begin
      Repaint;
      FContent.Visible := FIsExpanded;
      if FButton <> nil then
        Height := FButton.Height;
    end;
    StartTriggerAnimation(Self, 'IsExpanded');
    if FButton <> nil then
      FButton.StartTriggerAnimation(Self, 'IsExpanded');
  end;
end;

procedure TvxExpander.DoCheckChange(Sender: TObject);
begin
  if (FCheck <> nil) then
  begin
    FIsChecked := FCheck.IsChecked;
    FContent.Enabled := FIsChecked;
    if Assigned(OnCheckChange) then
      OnCheckChange(Self);
  end;
end;

procedure TvxExpander.SetIsChecked(const Value: boolean);
begin
  if FIsChecked <> Value then
  begin
    FIsChecked := Value;
    FContent.Enabled := FIsChecked;
    if FCheck <> nil then
      FCheck.IsChecked := FIsChecked;
  end;
end;

procedure TvxExpander.SetShowCheck(const Value: boolean);
begin
  if FShowCheck <> Value then
  begin
    FShowCheck := Value;
    if FCheck <> nil then
      FCheck.Visible := FShowCheck;
  end;
end;

procedure TvxExpander.DesignClick;
begin
  inherited;
  IsExpanded := not IsExpanded;
end;

{ TvxPopupBox =================================================================}

constructor TvxPopupBox.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := true;
  Height := 21;
  FItems := TvxWideStringList.Create;
  ;
  TvxWideStringList(FItems).OnChange := DoItemsChanged;
  {$IFNDEF NOVCL}
  FPopup := TPopupMenu.Create(nil);
  {$ENDIF}
  FItemIndex := -1;
  FText := '';
end;

destructor TvxPopupBox.Destroy;
begin
  {$IFNDEF NOVCL}
  FreeAndNil(FPopup);
  {$ENDIF}
  FreeAndNil(FItems);
  inherited;
end;

function TvxPopupBox.GetData: Variant;
begin
  Result := Text;
end;

procedure TvxPopupBox.SetData(const Value: Variant);
var
  S: WideString;
begin
  if VarIsNull(Value) then
    ItemIndex := -1
  else
    if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    if VarIsNumeric(Value) then
    ItemIndex := Value
  else
    if VarIsStr(Value) then
  begin
    S := VarToWideStr(Value);
    if FItems.IndexOf(S) < 0 then
      Text := S
    else
      ItemIndex := FItems.IndexOf(S);
  end;
end;

procedure TvxPopupBox.ApplyStyle;
begin
  inherited;
end;

procedure TvxPopupBox.Click;
begin
  inherited;
  DoPopup;
end;

procedure TvxPopupBox.DoPopup;
{$IFNDEF NOVCL}
var
  Item: TMenuItem;
  VP: TvxPoint;
  i: integer;
  {$ENDIF}
begin
  {$IFNDEF NOVCL}
  FPopup.Items.Clear;
  for i := 0 to FItems.Count - 1 do
  begin
    Item := NewItem({$IFDEF FPC}UTF8Encode{$ENDIF}(FItems[i]), 0, i = FItemIndex, true, DoItemClick, 0, '');
    FPopup.Items.Add(Item);
  end;
  if Scene <> nil then
  begin
    VP := LocalToAbsolute(vgPoint(0, Trunc((Height / 2) - ((FItems.Count * 20) div 2))));
    VP := Scene.LocalToScreen(VP);
    FPopup.Popup(round(VP.X), round(VP.Y));
  end;
  {$ENDIF}
end;

procedure TvxPopupBox.DoItemClick(Sender: TObject);
begin
  {$IFNDEF NOVCL}
  ItemIndex := TMenuItem(Sender).MenuIndex;
  {$ENDIF}
end;

procedure TvxPopupBox.DoItemsChanged(Sender: TObject);
begin
  Repaint;
end;

procedure TvxPopupBox.SetItemIndex(const Value: integer);
begin
  if FItemIndex <> Value then
  begin
    FItemIndex := Value;
    if (FItemIndex >= 0) and (Items.Count > 0) then
      Text := Items[FItemIndex]
    else
    begin
      Text := '';
      FItemIndex := -1;
    end;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxPopupBox.SetText(const Value: WideString);
begin
  if FItems.Count > 0 then
  begin
    FItemIndex := Items.IndexOf(Value);
    if FItemIndex >= 0 then
      inherited SetText(Value)
    else
      inherited SetText('')
  end
  else
  begin
    FItemIndex := -1;
    inherited SetText('')
  end;
end;

procedure TvxPopupBox.SetItems(const Value: TvxWideStrings);
begin
  FItems.Assign(Value);
end;

{ TvxWindow ===================================================================}

constructor TvxWindow.Create(AOwner: TComponent);
begin
  inherited;
  FautoTranslate := true;
  FShowCloseButton := true;
  FShowSizeGrip := true;
  HitTest := false;
  TextAlign := vgTextalignNear;
  Width := 200;
  Height := 200;
end;

procedure TvxWindow.ApplyStyle;
var
  sizeGrip, closeBtn: TvxObject;
begin
  inherited;
  closeBtn := FindResource('close');
  if (closeBtn <> nil) and (closeBtn is TvxVisualObject) then
  begin
    TvxVisualObject(closeBtn).visible := FShowCloseButton;
    if (closeBtn is TvxCloseButton) and (Assigned(FOnCloseClick)) then
    begin
      TvxCloseButton(closeBtn).CloseForm := false;
      TvxCloseButton(closeBtn).OnClick := FOnCloseClick;
    end;
  end;
  sizeGrip := FindResource('sizegrip');
  if (sizeGrip <> nil) and (sizeGrip is TvxVisualObject) then
  begin
    TvxVisualObject(sizeGrip).visible := FShowSizeGrip;
  end;
end;

destructor TvxWindow.Destroy;
begin
  inherited;
end;

procedure TvxWindow.SetShowCloseButton(const Value: boolean);
begin
  if FShowCloseButton <> Value then
  begin
    FShowCloseButton := Value;
    Resource := FResource;
  end;
end;

procedure TvxWindow.SetShowSizeGrip(const Value: boolean);
begin
  if FShowSizeGrip <> Value then
  begin
    FShowSizeGrip := Value;
    Resource := FResource;
  end;
end;

{ TvxLayerWindow }

constructor TvxLayerWindow.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxLayerWindow.Destroy;
begin
  inherited;
end;

{ TvxHudWindow }

constructor TvxHudWindow.Create(AOwner: TComponent);
begin
  inherited;
  FFill := TvxBrush.Create(vgBrushSolid, $EA2F2F2F);
  FFill.OnChanged := DoFillChanged;
  FStroke := TvxBrush.Create(vgBrushSolid, $5B000000);
  FStroke.OnChanged := DoFillChanged;
  FStrokeThickness := 1;
  FDisableShadowOnOSX := true;
  FShowCaption := true;
  Font.Style := vgFontBold;
end;

destructor TvxHudWindow.Destroy;
begin
  FStroke.Free;
  FFill.Free;
  inherited;
end;

procedure TvxHudWindow.ApplyStyle;
var
  {$IFDEF DARWIN}
  shadow: TvxObject;
  {$ENDIF}
  back: TvxObject;
begin
  inherited;
  {$IFDEF DARWIN}
  shadow := FindResource('shadow');
  if (shadow <> nil) and (shadow is TvxVisualObject) and (FDisableShadowOnOSX) then
  begin
    TvxVisualObject(shadow).visible := false;
  end;
  {$ENDIF}
  back := FindResource('close');
  if (back <> nil) and (back is TvxCloseButton) then
  begin
    if FCloseAlign = vgButtonAlignLeft then
      TvxCloseButton(back).Align := vaLeft
    else
      TvxCloseButton(back).Align := vaRight;
    if TvxVisualObject(back).Visible then
    begin
      TvxVisualObject(back).Visible := FShowCaption;
      TvxVisualObject(back).DesignHide := not FShowCaption;
    end;
  end;
  back := FindResource('back');
  if (back <> nil) and (back is TvxShape) then
  begin
    TvxShape(back).Fill.Assign(FFill);
  end;
  back := FindResource('stroke');
  if (back <> nil) and (back is TvxShape) then
  begin
    TvxShape(back).Stroke.Assign(FStroke);
    TvxShape(back).StrokeThickness := FStrokeThickness;
    TvxShape(back).StrokeCap := FStrokeCap;
    TvxShape(back).StrokeDash := FStrokeDash;
    TvxShape(back).StrokeJoin := FStrokeJoin;
    TvxVisualObject(back).Margins.Rect := vgRect(FStrokeThickness, FStrokeThickness, FStrokeThickness, FStrokeThickness);
  end;
  back := FindResource('caption');
  if (back <> nil) and (back is TvxVisualObject) then
  begin
    TvxVisualObject(back).Height := 20 + FStrokeThickness;
    TvxVisualObject(back).Padding.Rect := vgRect(FStrokeThickness, FStrokeThickness, FStrokeThickness, 0);
    TvxVisualObject(back).Visible := FShowCaption;
    TvxVisualObject(back).DesignHide := not FShowCaption;
  end;
  back := FindResource('text');
  if (back <> nil) and (back is TvxVisualObject) then
  begin
    TvxVisualObject(back).Visible := FShowCaption;
    TvxVisualObject(back).DesignHide := not FShowCaption;
  end;
end;

procedure TvxHudWindow.SetDisableShadowOnOSX(const Value: boolean);
begin
  if FDisableShadowOnOSX <> Value then
  begin
    FDisableShadowOnOSX := Value;
    Resource := FResource;
  end;
end;

procedure TvxHudWindow.SetFill(const Value: TvxBrush);
begin
  FFill.Assign(Value);
end;

procedure TvxHudWindow.DoFillChanged(Sender: TObject);
begin
  if not (csLoading in ComponentState) then
    ApplyStyle;
end;

function TvxHudWindow.isStrokeThicknessStored: Boolean;
begin
  Result := StrokeThickness <> 1;
end;

procedure TvxHudWindow.SetStroke(const Value: TvxBrush);
begin
  if FStroke <> Value then
  begin
    FStroke := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxHudWindow.SetStrokeCap(const Value: TvxStrokeCap);
begin
  if FStrokeCap <> Value then
  begin
    FStrokeCap := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxHudWindow.SetStrokeDash(const Value: TvxStrokeDash);
begin
  if FStrokeDash <> Value then
  begin
    FStrokeDash := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxHudWindow.SetStrokeJoin(const Value: TvxStrokeJoin);
begin
  if FStrokeJoin <> Value then
  begin
    FStrokeJoin := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxHudWindow.SetStrokeThickness(const Value: single);
begin
  if FStrokeThickness <> Value then
  begin
    FStrokeThickness := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxHudWindow.SetCloseAlign(const Value: TvxCloseAlign);
begin
  if FCloseAlign <> Value then
  begin
    FCloseAlign := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

procedure TvxHudWindow.SetShowCaption(const Value: boolean);
begin
  if FShowCaption <> Value then
  begin
    FShowCaption := Value;
    if not (csLoading in ComponentState) then
      ApplyStyle;
  end;
end;

{ TvxBitmapStateButton }

constructor TvxBitmapStateButton.Create(AOwner: TComponent);
begin
  inherited;
  FBitmap := TvxBitmap.Create(1, 1);
  FBitmap.OnChange := DoBitmapChanged;
  FBitmapHot := TvxBitmap.Create(1, 1);
  FBitmapDown := TvxBitmap.Create(1, 1);
  Width := 64;
  Height := 64;
end;

destructor TvxBitmapStateButton.Destroy;
begin
  FBitmap.Free;
  FBitmapHot.Free;
  FBitmapDown.Free;
  inherited;
end;

procedure TvxBitmapStateButton.ApplyStyle;
begin
  inherited;
end;

procedure TvxBitmapStateButton.DoBitmapChanged(Sender: TObject);
begin
  Repaint;
end;

procedure TvxBitmapStateButton.SetBitmap(const Value: TvxBitmap);
begin
end;

procedure TvxBitmapStateButton.SetBitmapDown(const Value: TvxBitmap);
begin
end;

procedure TvxBitmapStateButton.SetBitmapHot(const Value: TvxBitmap);
begin
end;

procedure TvxBitmapStateButton.Paint;
var
  scale: single;
  R: TvxRect;
  B: TvxBitmap;
begin
  if IsPressed then
    B := FBitmapDown
  else
    if IsMouseOver then
    B := FBitmapHot
  else
    B := FBitmap;

  R := vgRect(0, 0, B.Width, B.Height);
  scale := vgFitRect(R, LocalRect);
  if scale > 1 then
    Canvas.DrawBitmap(B, vgRect(0, 0, B.Width, B.Height), R, AbsoluteOpacity)
  else
  begin
    R := vgRect(0, 0, B.Width, B.Height);
    vgRectCenter(R, LocalRect);
    Canvas.DrawBitmap(B, vgRect(0, 0, B.Width, B.Height), R, AbsoluteOpacity)
  end;
end;

procedure TvxBitmapStateButton.MouseEnter;
begin
  inherited;
  Repaint;
end;

procedure TvxBitmapStateButton.MouseLeave;
begin
  inherited;
  Repaint;
end;

procedure TvxBitmapStateButton.StartTriggerAnimation(AInstance: TvxObject;
  ATrigger: string);
begin
  inherited;
  if Pos('IsPressed', ATrigger) > 0 then
  begin
    Repaint;
  end;
end;

{ TvxImageControl }

constructor TvxImageControl.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := true;
  FEnableOpenDialog := true;
  FBitmap := TvxBitmap.Create(1, 1);
  FBitmap.OnChange := DoBitmapChanged;
end;

destructor TvxImageControl.Destroy;
begin
  FBitmap.Free;
  inherited;
end;

procedure TvxImageControl.ApplyStyle;
var
  O: TvxObject;
begin
  inherited;
  O := FindResource('image');
  if (O <> nil) and (O is TvxImage) then
  begin
    FImage := TvxImage(O);
    FImage.Bitmap.Assign(FBitmap);
  end;
end;

procedure TvxImageControl.FreeStyle;
begin
  inherited;
  FImage := nil;
end;

procedure TvxImageControl.Click;
{$IFNDEF NOVCL}
var
  D: TOpenDialog;
  {$ENDIF}
begin
  inherited;
  if not FEnableOpenDialog then
    Exit;
  {$IFNDEF NOVCL}
  D := TOpenDialog.Create(nil);
  D.Filter := DefaultFilterClass.GetFileTypes;
  if D.Execute then
  begin
    Bitmap.LoadFromFile(D.FileName);
  end;
  D.Free;
  {$ENDIF}
end;

procedure TvxImageControl.DragOver(const Data: TvxDragObject;
  const Point: TvxPoint; var Accept: Boolean);
begin
  inherited;
  // accept correct image file or TvxImage
  Accept :=
    ((Length(Data.Files) > 0) and FileExists(Data.Files[0]) and (Pos(ExtractFileExt(Data.Files[0]), DefaultFilterClass.GetFileTypes) > 0))
    or
    (Data.Source is TvxImage);
end;

procedure TvxImageControl.DragDrop(const Data: TvxDragObject;
  const Point: TvxPoint);
begin
  inherited;
  if Data.Source is TvxImage then
  begin
    Bitmap.Assign(TvxImage(Data.Source).Bitmap);
  end
  else
    if Length(Data.Files) > 0 then
  begin
    Bitmap.LoadFromFile(Data.Files[0]);
  end;
end;

procedure TvxImageControl.SetBitmap(const Value: TvxBitmap);
begin
  FBitmap.Assign(Value);
end;

procedure TvxImageControl.DoBitmapChanged(Sender: TObject);
var
  R: TvxRect;
begin
  if FImage <> nil then
  begin
    { create thumbnail }
    R := vgRect(0, 0, FBitmap.Width, FBitmap.Height);
    vgFitRect(R, vgRect(0, 0, FImage.Width, FImage.Height));
    FImage.Bitmap.SetSize(round(vgRectWidth(R)), round(vgRectHeight(R)));
    if FImage.Bitmap.Canvas.BeginScene then
    begin
      FImage.Bitmap.Canvas.Clear(0);
      FImage.Bitmap.Canvas.DrawBitmap(FBitmap, vgRect(0, 0, FBitmap.Width, FBitmap.Height),
        vgRect(0, 0, FImage.Bitmap.Width, FImage.Bitmap.Height), 1);
      FImage.Bitmap.Canvas.EndScene;
    end;
    FImage.Repaint;

    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

function TvxImageControl.GetData: Variant;
begin
  Result := ObjectToVariant(Bitmap);
end;

procedure TvxImageControl.SetData(const Value: Variant);
begin
  if VarIsNull(Value) then
    Bitmap.SetSize(1, 1)
  else
    if VarIsObject(Value) then
  begin
    if VariantToObject(Value) is TPersistent then
      Bitmap.Assign(TPersistent(VariantToObject(Value)));
  end
  else
    if VarIsStr(Value) then
    Bitmap.LoadFromFile(Value)
end;

{$IFNDEF FPC}
{$ELSE}
{$ENDIF}

procedure SelectInDesign(AObject: TObject; AComp: TPersistent);
begin
  if vgDesign = nil then
  begin
    vgDesign := TvxBrushDesign.Create(Application);
    try
    except
      vgDesign.Free;
      vgDesign := nil;
      raise;
    end;
  end;

  if AObject = nil then
  begin
    vgDesign.Comp := nil;
    vgDesign.Brush := nil;
  end;
  if AObject is TvxBrush then
  begin
    vgDesign.Comp := AComp;
    vgDesign.Brush := TvxBrush(AObject);
  end;
  if AObject is TvxObject then
  begin
    vgDesign.Comp := TPersistent(AObject);
    vgDesign.Brush := nil;
  end;

  vgDesign.Show;
end;

{ TvxBrushDesign ==============================================================}

procedure TvxBrushDesign.FormCreate(Sender: TObject);
begin
  { creeate }
end;

procedure TvxBrushDesign.FormClose(Sender: TObject;
  var Action: TCloseAction);
begin
  Action := caFree;
  vgDesign := nil;
end;

procedure TvxBrushDesign.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FComp) then
  begin
    Brush := nil;
    Comp := nil;
  end;
  {  if (Operation = opRemove) and (AComponent = IScene) then
    begin
      IScene := nil;
    end;}
end;

procedure TvxBrushDesign.SetBrush(const Value: TvxBrush);
var
  i: integer;
begin
  FBrush := Value;
  if FBrush <> nil then
  begin
    case FBrush.Style of
      vgBrushNone:
        begin
          brushTabControl.ItemIndex := tabNone.Index;
        end;
      vgBrushSolid:
        begin
          solidPicker.Color := FBrush.SolidColor;
          gradEditor.Gradient.Assign(FBrush.Gradient);
          brushTabControl.ItemIndex := tabSolid.Index;
        end;
      vgBrushGradient:
        begin
          solidPicker.Color := FBrush.SolidColor;
          gradEditor.Gradient.Assign(FBrush.Gradient);
          gradKind.ItemIndex := Integer(gradEditor.Gradient.Style);
          if gradEditor.Gradient.StopPosition.X - gradEditor.Gradient.StartPosition.X <> 0 then
          begin
            if gradEditor.Gradient.StopPosition.X - gradEditor.Gradient.StartPosition.X > 0 then
              gradAngle.Value := -vgRadToDeg(ArcTan((gradEditor.Gradient.StopPosition.Y - gradEditor.Gradient.StartPosition.Y) / (gradEditor.Gradient.StopPosition.X - gradEditor.Gradient.StartPosition.X)))
            else
              gradAngle.Value := -vgRadToDeg(ArcTan((gradEditor.Gradient.StopPosition.Y - gradEditor.Gradient.StartPosition.Y) / (gradEditor.Gradient.StopPosition.X - gradEditor.Gradient.StartPosition.X))) - 180;
          end;
          gradAngle.Visible := gradEditor.Gradient.Style = vgLinearGradient;
          gradQuadChange(Self);
          brushTabControl.ItemIndex := tabGradient.Index;
        end;
      vgBrushVisual: ;
      vgBrushBitmap:
        begin
          brushTabControl.ItemIndex := tabBitmap.Index;
          bitmapImage.Bitmap.Assign(FBrush.Bitmap.Bitmap);
          tileModeList.ItemIndex := Integer(FBrush.Bitmap.WrapMode);
        end;
      vgBrushResource:
        begin
          brushTabControl.ItemIndex := tabRes.Index;
          rebuilResList;
        end;
    end;
    for i := 0 to brushList.Count - 1 do
      if (brushList.ItemByIndex(i) <> nil) and (TvxBrush(brushList.ItemByIndex(i).Tag) = Brush) then
        brushList.ItemIndex := i;
  end;
end;

procedure TvxBrushDesign.SetComp(const Value: TPersistent);
var
  i: integer;
  BrushButton: TvxListBoxItem;
  BrushText: TvxTextControl;
  PropCount: integer;
  PropList: PPropList;
  PropType: PTypeData;
begin
  FComp := Value;
  {$IFNDEF NOVCL}
  if (FComp <> nil) and (FComp is TDicomScene) then
    FScene := TDicomScene(FComp);
  {$ENDIF}
  if (FComp <> nil) and (FComp is TvxObject) then
    FScene := TvxObject(FComp).Scene;
  { find all brushes }
  Brush := nil;
  brushList.Clear;
  brushList.Height := 4;
  {$IFDEF KS_COMPILER5}
  PropCount := GetPropList(FComp.ClassInfo, [tkClass], nil);
  GetMem(PropList, SizeOf(PPropInfo) * PropCount);
  PropCount := GetPropList(FComp.ClassInfo, [tkClass], PropList);
  {$ELSE}
  PropCount := GetPropList(FComp.ClassInfo, PropList);
  {$ENDIF}
  for i := 0 to PropCount - 1 do
  begin
    if PropList[i].PropType^.Kind <> tkClass then
      Continue;
    PropType := GetTypeData(PropList[i].PropType{$IFNDEF FPC}^{$ENDIF});
    if PropType = nil then
      Continue;
    if not (PropType.ClassType.ClassName = 'TvxBrush') then
      Continue;
    BrushButton := TvxListBoxItem.Create(Self);
    BrushButton.Parent := brushList;
    BrushButton.Height := 23;
    BrushButton.Tag := Integer(GetObjectProp(FComp, PropList[i].Name));
    BrushText := TvxLabel.Create(Self);
    BrushText.Parent := BrushButton;
    BrushText.Align := vaClient;
    BrushText.HitTest := false;
    BrushText.Text := PropList[i].Name;
    brushList.Height := brushList.Height + BrushButton.Height;
    if Brush = nil then
      Brush := TvxBrush(GetObjectProp(FComp, PropList[i].Name));
  end;
  brushList.ItemIndex := 0;
  FreeMem(PropList, SizeOf(PPropInfo) * PropCount);
end;

function TvxBrushDesign.UniqueName(S: string): string;
begin
  if (FComp <> nil) and (FComp is TComponent) and (TComponent(FComp).Owner <> nil) and (TComponent(FComp).Owner is TCustomForm) then
    Result := TCustomForm(TComponent(FComp).Owner).Designer.UniqueName(S)
  else
    if Designer <> nil then
    Result := Designer.UniqueName(S)
  else
  begin
    Tag := Tag + 1;
    Result := S + IntToStr(Tag);
  end;
end;

procedure TvxBrushDesign.solidQuadChange(Sender: TObject);
begin
  if FBrush = nil then
    Exit;
  solidQuad.Alpha := ((FBrush.SolidColor and $FF000000) shr 24) / $FF;
  FBrush.SolidColor := (FBrush.SolidColor and not $FFFFFF) or ($00FFFFFF and vgHSLtoRGB(solidQuad.Hue, solidQuad.Sat, solidQuad.Lum));
  textSolidR.Value := TvxColorRec(FBrush.SolidColor).R;
  textSolidG.Value := TvxColorRec(FBrush.SolidColor).G;
  textSolidB.Value := TvxColorRec(FBrush.SolidColor).B;
  textSolidA.Value := TvxColorRec(FBrush.SolidColor).A;
  textSolidHex.Text := vgColorToStr(FBrush.SolidColor);
end;

procedure TvxBrushDesign.textSolidHexChange(Sender: TObject);
begin
  { change solid hex }
  if FBrush = nil then
    Exit;
  FBrush.SolidColor := vgStrToColor(textSolidHex.Text);
  solidPicker.Color := FBrush.SolidColor;
end;

procedure TvxBrushDesign.textSolidRChange(Sender: TObject);
var
  Color: TvxColor;
begin
  { solid textbox change }
  if FBrush = nil then
    Exit;
  Color := FBrush.SolidColor;
  TvxColorRec(Color).R := trunc(textSolidR.Value);
  TvxColorRec(Color).G := trunc(textSolidG.Value);
  TvxColorRec(Color).B := trunc(textSolidB.Value);
  TvxColorRec(Color).A := trunc(textSolidA.Value);
  FBrush.SolidColor := Color;
  solidPicker.Color := FBrush.SolidColor;
end;

procedure TvxBrushDesign.gradEditorChange(Sender: TObject);
begin
  { change gradient }
  if FBrush = nil then
    Exit;
  FBrush.Gradient.Assign(gradEditor.Gradient);
end;

procedure TvxBrushDesign.gradQuadChange(Sender: TObject);
begin
  { chage color in current point }
  if FBrush = nil then
    Exit;
  gradEditor.Gradient.Points[gradEditor.CurrentPoint].IntColor :=
    (gradEditor.Gradient.Points[gradEditor.CurrentPoint].IntColor and $FF000000) or ($00FFFFFF and vgHSLtoRGB(gradQuad.Hue, gradQuad.Sat, gradQuad.Lum));
  FBrush.Gradient.Assign(gradEditor.Gradient);
  textGradR.Value := TvxColorRec(gradColorRect.Color).R;
  textGradG.Value := TvxColorRec(gradColorRect.Color).G;
  textGradB.Value := TvxColorRec(gradColorRect.Color).B;
  textGradA.Value := TvxColorRec(gradColorRect.Color).A;
  textGradHex.Text := vgColorToStr(gradColorRect.Color);
  gradEditor.Repaint;
end;

procedure TvxBrushDesign.brushListChange(Sender: TObject);
begin
  if FScene = nil then
    Exit;
  if FComp = nil then
    Exit;
  if Sender <> nil then
    Brush := TvxBrush(TvxListBoxItem(Sender).Tag);
end;

procedure TvxBrushDesign.brushTabControlChange(Sender: TObject);
begin
  if FBrush = nil then
    Exit;
  if brushTabControl.ItemIndex = tabNone.Index then
    FBrush.Style := vgBrushNone;
  if brushTabControl.ItemIndex = tabSolid.Index then
    FBrush.Style := vgBrushSolid;
  if brushTabControl.ItemIndex = tabGradient.Index then
  begin
    FBrush.Style := vgBrushGradient;
    gradQuadChange(Sender);
    gradAngleLabel.Text := InttoStr(Trunc(gradAngle.Value));
  end;
  if brushTabControl.ItemIndex = tabBitmap.Index then
    FBrush.Style := vgBrushBitmap;
  if brushTabControl.ItemIndex = tabRes.Index then
    FBrush.Style := vgBrushResource;

  btnMakeRes.Visible := (brushTabControl.ItemIndex <> tabRes.Index) and (brushTabControl.ItemIndex <> tabNone.Index);
  if not btnMakeRes.Visible then
    rebuilResList;
end;

procedure TvxBrushDesign.textGradRChange(Sender: TObject);
var
  Color: TvxColor;
begin
  { change grad brush alpha }
  if FBrush = nil then
    Exit;
  Color := gradEditor.Gradient.Points[gradEditor.CurrentPoint].IntColor;
  TvxColorRec(Color).R := trunc(textGradR.Value);
  TvxColorRec(Color).G := trunc(textGradG.Value);
  TvxColorRec(Color).B := trunc(textGradB.Value);
  TvxColorRec(Color).A := trunc(textGradA.Value);
  gradEditor.Gradient.Points[gradEditor.CurrentPoint].IntColor := Color;
  gradEditor.UpdateGradient;
end;

procedure TvxBrushDesign.gradKindChange(Sender: TObject);
begin
  { change grad type }
  if FBrush = nil then
    Exit;
  gradEditor.Gradient.Style := TvxGradientStyle(gradKind.ItemIndex);
  gradEditor.UpdateGradient;
  gradAngle.Visible := gradEditor.Gradient.Style = vgLinearGradient;
end;

procedure TvxBrushDesign.gradAngleChange(Sender: TObject);
var
  Color: TvxColor;
  X, Y, Koef: single;
begin
  { change grad brush alpha }
  if FBrush = nil then
    Exit;
  if (Cos(vgDegToRad(gradAngle.Value)) <> 0) and (Abs(1 / Cos(vgDegToRad(gradAngle.Value))) >= 1) and (Abs(1 / Cos(vgDegToRad(gradAngle.Value))) <= 1.42) then
    X := Abs(1 / Cos(vgDegToRad(gradAngle.Value)))
  else
    X := 1;
  if (Sin(vgDegToRad(gradAngle.Value)) <> 0) and (Abs(1 / Sin(vgDegToRad(gradAngle.Value))) >= 1) and (Abs(1 / Sin(vgDegToRad(gradAngle.Value))) <= 1.42) then
    Y := Abs(1 / Sin(vgDegToRad(gradAngle.Value)))
  else
    Y := 1;
  Koef := vgMaxFloat(X, Y);
  Koef := Koef * 0.5;
  gradEditor.Gradient.StartPosition.Point := vgPoint(0.5 - (Cos(vgDegToRad(gradAngle.Value)) * Koef), 0.5 + (Sin(vgDegToRad(gradAngle.Value)) * Koef));
  gradEditor.Gradient.StopPosition.Point := vgPoint(0.5 + (Cos(vgDegToRad(gradAngle.Value)) * Koef), 0.5 - (Sin(vgDegToRad(gradAngle.Value)) * Koef));
  gradEditor.UpdateGradient;
  gradAngleLabel.Text := InttoStr(Trunc(gradAngle.Value));
end;

procedure TvxBrushDesign.textGradHexChange(Sender: TObject);
begin
  { change gradient hex }
  if FBrush = nil then
    Exit;
  gradEditor.Gradient.Points[gradEditor.CurrentPoint].IntColor := vgStrToColor(textGradHex.Text);
  gradEditor.UpdateGradient;
end;

procedure TvxBrushDesign.btnSelectBitmapClick(Sender: TObject);
begin
  if FBrush = nil then
    Exit;
  vgBitmapEditor := TvxBitmapEditor.Create(nil);
  vgBitmapEditor.AssignFromBitmap(bitmapImage.Bitmap);
  if vgBitmapEditor.ShowModal = mrOk then
  begin
    vgBitmapEditor.AssignToBitmap(bitmapImage.Bitmap);
    FBrush.Bitmap.Bitmap.Assign(bitmapImage.Bitmap);
    if (FComp <> nil) and (FComp is TvxVisualObject) then
      TvxVisualObject(FComp).Repaint;
    bitmapImage.Repaint;
  end;
  vgBitmapEditor.Free;
end;

procedure TvxBrushDesign.rebuilResList;
var
  i: integer;
  L: TList;
  item: TvxListBoxItem;
  itemText: TvxTextControl;
  rect: TvxRectangle;
begin
  if FScene = nil then
    Exit;
  if FScene.GetRoot = nil then
    Exit;
  if FBrush = nil then
    Exit;

  resList.Clear;

  L := TList.Create;
  FScene.GetRoot.AddObjectsToList(L);
  for i := 0 to L.Count - 1 do
    if TvxObject(L[i]) is TvxBrushObject then
    begin
      item := TvxListBoxItem.Create(Self);
      item.Tag := Integer(L[i]);
      item.Parent := resList;
      itemText := TvxLabel.Create(Self);
      itemText.Parent := item;
      itemText.Align := vaClient;
      itemText.HitTest := false;
      itemText.Text := TvxObject(L[i]).ResourceName;
      rect := TvxRectangle.Create(Self);
      rect.Parent := item;
      rect.Align := vaLeft;
      rect.HitTest := false;
      rect.Padding.Rect := vgRect(2, 2, 2, 2);
      rect.Fill.Style := vgBrushResource;
      rect.Fill.Resource.Resource := TvxBrushObject(L[i]);
      rect.Stroke.Color := '#80FFFFFF';
      if FBrush.Resource.Resource = TvxBrushObject(L[i]) then
        resList.ItemIndex := resList.Count - 1;
    end;
  L.Free;
end;

procedure TvxBrushDesign.resListChange(Sender: TObject);
begin
  if FScene = nil then
    Exit;
  if FScene.GetRoot = nil then
    Exit;
  if FBrush = nil then
    Exit;
  if Sender = nil then
    Exit;

  FBrush.Assign(TvxBrushObject(TvxListBoxItem(Sender).Tag).Brush);
  FBrush.Resource.Resource := TvxBrushObject(TvxListBoxItem(Sender).Tag);
  FBrush.Style := vgBrushResource;
end;

procedure TvxBrushDesign.btnMakeResClick(Sender: TObject);
var
  S: string;
  B: TvxBrushObject;
begin
  if FBrush = nil then
    Exit;
  if FScene = nil then
    Exit;
  if FScene.GetRoot = nil then
    Exit;

  { make res }
  S := UniqueName('Brush');
  if InputQuery('New TvxBrushObject', 'Enter resource name:', S) then
  begin
    B := TvxBrushObject.Create(FScene.GetOwner);
    B.Parent := FScene.GetRoot;
    B.ResourceName := S;
    B.Name := B.ResourceName;
    B.ResourceName := S;
    B.Brush.Assign(FBrush);

    rebuilResList;
  end;
end;

procedure TvxBrushDesign.tileModeListChange(Sender: TObject);
begin
  if FBrush = nil then
    Exit;
  FBrush.Bitmap.WrapMode := TvxWrapMode(tileModeList.ItemIndex);
  if (FComp <> nil) and (FComp is TvxVisualObject) then
    TvxVisualObject(FComp).Repaint;
end;

procedure TvxBrushDesign.btnOKClick(Sender: TObject);
begin
  ModalResult := mrOk;
end;

procedure TvxBrushDesign.btnCancelClick(Sender: TObject);
begin
  ModalResult := mrCancel;
end;

{ TvxBrushDialog }

procedure ShowBrushDialog(const Brush: TvxBrush; const ShowStyles: TvxBrushStyles; const ShowBrushList: boolean);
var
  Dlg: TvxBrushDialog;
begin
  Dlg := TvxBrushDialog.Create(nil);
  Dlg.Brush := Brush;
  Dlg.ShowStyles := ShowStyles;
  Dlg.ShowBrushList := ShowBrushList;
  if Dlg.Execute then
    Brush.Assign(Dlg.Brush);
  Dlg.Free;
end;

procedure ShowGradientDialog(const Gradient: TvxGradient);
var
  Dlg: TvxBrushDialog;
begin
  Dlg := TvxBrushDialog.Create(nil);
  Dlg.Brush.Style := vgBrushGradient;
  Dlg.Brush.Gradient := Gradient;
  Dlg.ShowStyles := [vgBrushGradient];
  Dlg.ShowBrushList := false;
  if Dlg.Execute then
    Gradient.Assign(Dlg.Brush.Gradient);
  Dlg.Free;
end;

function ShowColorDialog(const Color: string): string;
var
  Dlg: TvxBrushDialog;
begin
  Dlg := TvxBrushDialog.Create(nil);
  Dlg.Brush.Style := vgBrushSolid;
  Dlg.Brush.Color := Color;
  Dlg.ShowStyles := [vgBrushSolid];
  Dlg.ShowBrushList := false;
  if Dlg.Execute then
  begin
    Result := Dlg.Brush.Color;
  end;
  Dlg.Free;
end;

constructor TvxBrushDialog.Create(AOwner: TComponent);
begin
  inherited;
  FBrush := TvxBrush.Create(vgBrushSolid, $FF808080);
  FShowStyles := [vgBrushNone, vgBrushSolid, vgBrushGradient, vgBrushBitmap, vgBrushResource];
  FShowBrushList := true;
  FShowMakeResource := false;
  FTitle := 'Brush';
end;

destructor TvxBrushDialog.Destroy;
begin
  FBrush.Free;
  inherited;
end;

function TvxBrushDialog.Execute: boolean;
var
  Dialog: TvxBrushDesign;
  EditBrush: TvxBrush;
begin
  Dialog := TvxBrushDesign.Create(Application);
  Dialog.brushList.Visible := ShowBrushList;
  if FComponent <> nil then
    Dialog.Comp := FComponent
  else
    Dialog.brushList.Visible := false;

  Dialog.HudWindow1.Text := FTitle;
  Dialog.brushTabControl.ItemIndex := -1;
  Dialog.tabNone.Visible := vgBrushNone in ShowStyles;
  Dialog.tabSolid.Visible := vgBrushSolid in ShowStyles;
  Dialog.tabGradient.Visible := vgBrushGradient in ShowStyles;
  Dialog.tabBitmap.Visible := vgBrushBitmap in ShowStyles;
  Dialog.tabRes.Visible := vgBrushResource in ShowStyles;
  Dialog.brushTabControl.Realign;
  Dialog.btnOK.Visible := true;
  Dialog.btnCancel.Visible := true;

  Dialog.Brush := FBrush;
  Dialog.makeResLayout.Visible := ShowMakeResource;
  Dialog.dsgnRoot.Height := Dialog.dsgnRoot.Height - 1; // realign
  Dialog.ClientHeight := Trunc(Dialog.Layout6.Position.Y + Dialog.Layout6.Height + Dialog.HudWindow1.Margins.Top + Dialog.HudWindow1.Margins.Bottom);
  Result := Dialog.ShowModal = mrOk;
  Dialog.Free;
end;

procedure TvxBrushDialog.SetBrush(const Value: TvxBrush);
begin
  FBrush.Assign(Value);
  ;
end;

{$IFNDEF FPC}
{$ELSE}
{$ENDIF}

procedure TvxBitmapEditor.FormCreate(Sender: TObject);
begin
  resizeLayout.Visible := false;
  FBitmap := TvxBitmap.Create(1, 1);
  FOldScale := 1;
end;

procedure TvxBitmapEditor.FormDestroy(Sender: TObject);
begin
  FreeAndNil(FBitmap);
end;

procedure TvxBitmapEditor.Button1Click(Sender: TObject);
var
  D: TOpenDialog;
begin
  D := TOpenDialog.Create(Application);
  try
    D.Filter := 'Images|' + DefaultFilterClass.GetFileTypes;
    if D.Execute then
    begin
      FileName := D.FileName;
      FBitmap.LoadFromFile(D.FileName);
      Preview.Repaint;
      FSourceRect := vgRect(0, 0, FBitmap.Width, FBitmap.Height);
      Preview.Width := FBitmap.Width * trackScale.Value;
      Preview.Height := FBitmap.Height * trackScale.Value;
      ScrollBox1.Realign;

      editControl.Enabled := true;
      btnOk.Enabled := true;
    end;
  finally
    D.Free;
  end;
end;

procedure TvxBitmapEditor.PreviewPaint(Sender: TObject; const Canvas: TvxCanvas);
begin
  Canvas.DrawBitmap(FBitmap, FSourceRect, vgRect(0, 0, vgRectWidth(FSourceRect) * trackScale.Value, vgRectHeight(FSourceRect) * trackScale.Value), 1);
end;

procedure TvxBitmapEditor.trackScaleChange(Sender: TObject);
begin
  Preview.Width := FBitmap.Width * trackScale.Value;
  Preview.Height := FBitmap.Height * trackScale.Value;
  ScrollBox1.Realign;

  if FCropRect <> nil then
  begin
    FCropRect.Position.X := (FCropRect.Position.X / FOldScale) * trackScale.Value;
    FCropRect.Position.Y := (FCropRect.Position.Y / FOldScale) * trackScale.Value;
    FCropRect.Width := (FCropRect.Width / FOldScale) * trackScale.Value;
    FCropRect.Height := (FCropRect.Height / FOldScale) * trackScale.Value;
  end;

  FOldScale := trackScale.Value;
  labelScale.Text := 'Scale: ' + IntToStr(Round(trackScale.Value * 100)) + '%';
end;

procedure TvxBitmapEditor.cropButtonClick(Sender: TObject);
begin
  if FCropRect = nil then
  begin
    btnFitClick(Self);

    FCropRect := TvxSelection.Create(Self);
    FCropRect.Parent := Preview;
    cropButton.Text := 'Full';
    FCropRect.SetBounds(Trunc(FBitmap.Width * 0.1 * trackScale.Value), Trunc(FBitmap.Height * 0.1 * trackScale.Value),
      (FBitmap.Width * 0.8 * trackScale.Value), Trunc(FBitmap.Height * 0.8 * trackScale.Value));
  end
  else
  begin
    FreeAndNil(FCropRect);
    Preview.Repaint;
    cropButton.Text := 'Crop';
  end;
end;

procedure TvxBitmapEditor.btnOkClick(Sender: TObject);
begin
  ModalResult := mrOk;
end;

procedure TvxBitmapEditor.AssignFromBitmap(B: TvxBitmap);
begin
  FileName := '';
  if B <> nil then
    FBitmap.Assign(B);
  FSourceRect := vgRect(0, 0, FBitmap.Width, FBitmap.Height);
  Preview.Width := FBitmap.Width * trackScale.Value;
  Preview.Height := FBitmap.Height * trackScale.Value;
  ScrollBox1.Realign;
  if B.Width > 1 then
  begin
    editControl.Enabled := true;
    btnOk.Enabled := true;
  end;
end;

procedure TvxBitmapEditor.AssignToBitmap(B: TvxBitmap);
var
  j: integer;
  CR: TvxRect;
begin
  if B <> nil then
  begin
    if (FCropRect <> nil) and (FCropRect.Width > 0) and (FCropRect.Height > 0) then
    begin
      CR := vgRect(FCropRect.Position.X / trackScale.Value, FCropRect.Position.Y / trackScale.Value,
        (FCropRect.Position.X + FCropRect.Width) / trackScale.Value, (FCropRect.Position.Y + FCropRect.Height) / trackScale.Value);
      B.SetSize(Trunc(vgRectWidth(CR)), Trunc(vgRectHeight(CR)));
      for j := 0 to B.Height - 1 do
        vgMoveLongword(@FBitmap.Scanline[(Trunc(CR.Top) + j)][Trunc(CR.Left)], @B.Scanline[j][0], B.Width);
      B.BitmapChanged;
    end
    else
    begin
      B.Assign(FBitmap);
    end;
  end;
end;

procedure TvxBitmapEditor.Button2Click(Sender: TObject);
begin
  ModalResult := mrCancel;
end;

procedure TvxBitmapEditor.trackScaleMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Single);
begin
  if ssDouble in Shift then
    trackScale.Value := 1;
end;

procedure TvxBitmapEditor.btnPasteClick(Sender: TObject);
var
  B: TBitmap;
begin
  B := TBitmap.Create;
  B.PixelFormat := pf32bit;
  B.HandleType := bmDIB;
  B.Assign(Clipboard);
  FBitmap.Assign(B);
  B.Free;
end;

procedure TvxBitmapEditor.btnFitClick(Sender: TObject);
var
  R: TvxRect;
begin
  R := vgRect(0, 0, FBitmap.Width, FBitmap.Height);
  trackScale.Value := 1 / vgFitRect(R, ScrollBox1.LocalRect);
end;

procedure TvxBitmapEditor.btnOriginalClick(Sender: TObject);
begin
  trackScale.Value := 1;
end;

procedure TvxBitmapEditor.Button3Click(Sender: TObject);
begin
  editControl.Enabled := false;
  btnOk.Enabled := true;
  if FCropRect <> nil then
    cropButtonClick(Self);

  trackScale.Value := 1;
  FBitmap.SetSize(1, 1);
  FSourceRect := vgRect(0, 0, FBitmap.Width, FBitmap.Height);
  Preview.Width := FBitmap.Width * trackScale.Value;
  Preview.Height := FBitmap.Height * trackScale.Value;
  ScrollBox1.Realign;
end;

procedure TvxBitmapEditor.btnResizeClick(Sender: TObject);
begin
  newWidth.Value := FBitmap.Width;
  newHeight.Value := FBitmap.Height;

  resizeLayout.Visible := true;
  resizeLayout.Position.Y := -resizeLayout.Height;
  resizeLayout.AnimateFloat('Position.Y', 0, 0.3);
end;

procedure TvxBitmapEditor.Button4Click(Sender: TObject);
var
  tmp: TvxBitmap;
  SaveFileName: string;
begin
  { resize }
  SaveFileName := FileName;
  tmp := TvxBitmap.Create(trunc(newWidth.Value), trunc(newHeight.Value));
  tmp.Canvas.DrawBitmap(FBitmap, vgRect(0, 0, FBitmap.Width, FBitmap.Height), vgRect(0, 0, tmp.Width, tmp.Height), 1);
  AssignFromBitmap(tmp);
  tmp.Free;
  FileName := SaveFileName;
  { }
  resizeLayout.AnimateFloatWait('Position.Y', -resizeLayout.Height, 0.3);
  resizeLayout.Visible := false;
end;

procedure TvxBitmapEditor.Button5Click(Sender: TObject);
begin
  resizeLayout.AnimateFloatWait('Position.Y', -resizeLayout.Height, 0.3);
  resizeLayout.Visible := false;
end;

procedure TvxBitmapEditor.newWidthChange(Sender: TObject);
begin
  newHeight.Value := Round(newWidth.Value * (FBitmap.Height / FBitmap.Width));
end;

procedure TvxBitmapEditor.newHeightChange(Sender: TObject);
begin
  newWidth.Value := Round(newHeight.Value * (FBitmap.Width / FBitmap.Height));
end;

procedure TvxBitmapEditor.btnSaveClick(Sender: TObject);
begin
  SaveDialog1.FileName := FFileName;
  if SaveDialog1.Execute then
    FBitmap.SaveToFile(SaveDialog1.FileName);
end;

procedure ShowDsgnImageList(ImgList: TvxImageList);
var
  i: integer;
begin
  frmDsgnImageList := TfrmDsgnImageList.Create(Application);
  with frmDsgnImageList do
  begin
    for i := 0 to ImgList.Count - 1 do
      ImageList.AddBitmap('', ImgList.Images[i]);
    ImageList.ItemWidth := ImgList.Width;
    ImageList.ItemHeight := ImgList.Height;
    if ShowModal = mrOK then
    begin
      ImgList.Clear;
      for i := 0 to ImageList.Count - 1 do
        if ImageList.Images[i] <> nil then
        begin
          ImgList.Add(ImageList.Images[i].Bitmap);
        end;
    end;
  end;
  frmDsgnImageList.Free;
end;

procedure TfrmDsgnImageList.btnAddFilesClick(Sender: TObject);
var
  i: integer;
begin
  OpenDialog1.Filter := DefaultFilterClass.GetFileTypes;
  if OpenDialog1.Execute then
  begin
    for i := 0 to OpenDialog1.Files.Count - 1 do
      ImageList.AddFile(OpenDialog1.Files[i]);
  end;
end;

procedure TfrmDsgnImageList.btnClearClick(Sender: TObject);
begin
  ImageList.Clear;
end;

procedure TfrmDsgnImageList.btnDeleteClick(Sender: TObject);
begin
  if ImageList.Selected <> nil then
    ImageList.Selected.Free;
end;

procedure ShowDsgnLang(Lang: TvxLang);
begin
  vgLangDesigner := TvxLangDesigner.Create(Application);
  with vgLangDesigner do
  begin
    FLang := Lang;
    langList.Items.Assign(Lang.Resources);
    if langList.Items.Count > 0 then
      langList.ItemIndex := Lang.Resources.IndexOf(Lang.Lang);

    layoutAdd.Visible := langList.Items.Count = 0;
    layoutSelect.Visible := langList.Items.Count > 0;

    RebuildOriginalList;
    if ShowModal = mrOk then
    begin
      FLang.Lang := langList.Text;
    end;
  end;
  vgLangDesigner.Free;
end;

procedure TvxLangDesigner.RebuildOriginalList;
var
  i: integer;
  Str: TvxWideStrings;
  Item: TvxListboxItem;
begin
  OriginalList.Clear;
  if FLang.Original.Count = 0 then
  begin
    // create original from Collection
    CollectLangStart;
    UpdateLang;
    FLang.Original.Assign(CollectLangStrings);
    CollectLangFinish;
  end;
  Str := FLang.Original;
  for i := 0 to Str.Count - 1 do
  begin
    Item := TvxListboxItem.Create(Self);
    Item.AutoTranslate := false;
    Item.Resource := 'langitem';
    Item.Text := Str[i];
    Item.TextAlign := vgTextAlignCenter;
    Item.Height := 22;
    Item.Parent := OriginalList;
    if (FLang.Resources.Count > 0) and (langList.ItemIndex >= 0) then
    begin
      if FLang.LangStr[langList.Text] <> nil then
      begin
        Item.Binding['translate'] := FLang.LangStr[langList.Text].Values[Str[i]];
        Item.Binding['translate'] := EventToVariant(DoTranslateChanged);
      end;
    end
    else
      Item.FindBinding('translate').Visual.Visible := false;
  end;
end;

procedure TvxLangDesigner.btnAddClick(Sender: TObject);
var
  List: TvxListBox;
begin
  { add new lang }
  List := TvxListBox.Create(Self);
end;

procedure TvxLangDesigner.DoTranslateChanged(Sender: TObject);
begin
  if (FLang.LangStr[langList.Text] <> nil) and (OriginalList.Selected <> nil) then
    with FLang.LangStr[langList.Text] do
    begin
      Values[OriginalList.Selected.Text] := TvxTextBox(Sender).Text;
    end;
end;

procedure TvxLangDesigner.btnAddLangClick(Sender: TObject);
var
  S: string;
begin
  if inputLang.Text = '' then
    Exit;
  S := inputLang.Text;
  if Length(S) > 2 then
    Delete(S, 3, MaxInt);
  FLang.AddLang(S);
  langList.Items := FLang.Resources;
  langList.ItemIndex := langList.Items.IndexOf(S);
  RebuildOriginalList;

  layoutAdd.Visible := false;
  layoutSelect.Visible := true;
end;

procedure TvxLangDesigner.langListChange(Sender: TObject);
begin
  RebuildOriginalList;
end;

procedure TvxLangDesigner.btnAddNewLangClick(Sender: TObject);
begin
  layoutAdd.Visible := true;
  layoutSelect.Visible := false;
  btnCancalAdd.Visible := langList.Items.Count > 0;

  inputLang.Text := '';
  inputLang.SetFocus;
end;

procedure TvxLangDesigner.btnCancalAddClick(Sender: TObject);
begin
  if langList.Items.Count > 0 then
  begin
    layoutAdd.Visible := false;
    layoutSelect.Visible := true;
  end;
end;

procedure TvxLangDesigner.btnAddItemClick(Sender: TObject);
begin
  { Add Word }
  layoutAdd.Visible := false;
  layoutSelect.Visible := false;
  layoutAddText.Visible := true;
  inputAddText.Text := '';
  inputAddText.SetFocus;
  RebuildOriginalList;
end;

procedure TvxLangDesigner.btnRemoveItemClick(Sender: TObject);
begin
  { Remove Word }
  if OriginalList.ItemIndex >= 0 then
  begin
    FLang.Original.Delete(OriginalList.ItemIndex);
    RebuildOriginalList;
  end;
end;

procedure TvxLangDesigner.btnCancelAddTextClick(Sender: TObject);
begin
  layoutAdd.Visible := langList.Items.Count = 0;
  layoutSelect.Visible := langList.Items.Count > 0;
  layoutAddText.Visible := false;
end;

procedure TvxLangDesigner.btnAddTextClick(Sender: TObject);
begin
  btnCancelAddTextClick(Sender);
  FLang.Original.Add(inputAddText.Text);
  RebuildOriginalList;
  OriginalList.ItemIndex := OriginalList.Count - 1;
end;

procedure TvxLangDesigner.btnCollectClick(Sender: TObject);
var
  Str: TvxWideStrings;
  i: integer;
begin
  CollectLangStart;
  UpdateLang;
  Str := TvxWideStringList.Create;
  Str.Assign(CollectLangStrings);
  for i := 0 to Str.Count - 1 do
    if FLang.Original.IndexOf(Str[i]) < 0 then
      FLang.Original.Add(Str[i]);
  Str.Free;
  CollectLangFinish;
  RebuildOriginalList;
end;

procedure TvxLangDesigner.btnCreateTemplateClick(Sender: TObject);
var
  Str: TvxWideStrings;
  i: integer;
begin
  if SaveDialog1.Execute then
  begin
    Str := TvxWideStringList.Create;
    Str.Assign(FLang.Original);
    for i := 0 to Str.Count - 1 do
      Str[i] := Str[i] + '=';
    Str.SaveToFile(SaveDialog1.FileName);
    Str.Free;
  end;
end;

procedure TvxLangDesigner.btnLoadTxtClick(Sender: TObject);
var
  Str: TvxWideStrings;
  i: integer;
begin
  if OpenDialog1.Execute then
  begin
    FLang.AddLang(inputLang.Text);
    langList.Items := FLang.Resources;
    langList.ItemIndex := langList.Items.IndexOf(inputLang.Text);
    RebuildOriginalList;

    layoutAdd.Visible := false;
    layoutSelect.Visible := true;

    Str := TvxWideStringList.Create;
    Str.LoadFromFile(OpenDialog1.FileName);
    for i := 0 to Str.Count - 1 do
      if FLang.LangStr[langList.Text].IndexOfName(Str.Names[i]) < 0 then
        FLang.LangStr[langList.Text].Add(Str[i])
      else
        FLang.LangStr[langList.Text].Values[Str.Names[i]] := Str.Values[Str.Names[i]];
    Str.Free;
    RebuildOriginalList;
  end;
end;

procedure TvxLangDesigner.btnLoadLngClick(Sender: TObject);
begin
  if OpenDialog2.Execute then
  begin
    FLang.LoadFromFile(OpenDialog2.FileName);
    RebuildOriginalList;
  end;
end;

procedure TvxLangDesigner.btnSaveLngClick(Sender: TObject);
begin
  if SaveDialog2.Execute then
  begin
    FLang.SaveToFile(SaveDialog2.FileName);
  end;
end;

{$IFNDEF FPC}
{$ELSE}
{$ENDIF}

procedure TvxPathDataDesigner.PathDataChange(Sender: TObject);
begin
  if previewLayout.Visible then
    previewPath.Data.Data := PathData.Text;
end;

procedure TvxPathDataDesigner.Button2Click(Sender: TObject);
begin
  ModalResult := mrOk;
end;

procedure TvxPathDataDesigner.Button3Click(Sender: TObject);
begin
  ModalResult := mrCancel;
end;

procedure TvxPathDataDesigner.Button1Click(Sender: TObject);
begin
  pathData.SelectAll;
  pathData.ClearSelection;
  pathData.PasteFromClipboard;
end;

{$IFNDEF FPC}
{$ELSE}
{$ENDIF}

type

  TvxHackVisual = class(TvxVisualObject);
  TvxHackBackground = class(TvxBackground);

  TvxStyleIDEDesigner = class(TvxDesigner)
  private
  public
    procedure SelectObject(ADesigner: TComponent; AObject: TvxObject; MultiSelection: array of TvxObject); override;
    procedure Modified(ADesigner: TComponent); override;
    function UniqueName(ADesigner: TComponent; ClassName: string): string; override;
    function IsSelected(ADesigner: TComponent; const AObject: TObject): boolean; override;
    procedure AddObject(AObject: TvxObject); override;
    procedure DeleteObject(AObject: TvxObject); override;
  end;

  { TvxStyleIDEDesigner }

procedure TvxStyleIDEDesigner.Modified(ADesigner: TComponent);
begin
end;

function TvxStyleIDEDesigner.IsSelected(ADesigner: TComponent; const AObject: TObject): boolean;
begin
  Result := false;
end;

procedure TvxStyleIDEDesigner.SelectObject(ADesigner: TComponent; AObject: TvxObject; MultiSelection: array of TvxObject);
begin
  if AObject = vgStyleDesigner.DesignScene.Root then
    Exit;

  vgStyleDesigner.Inspector.SelectedObject := AObject;
  if vgStyleDesigner.Inspector.SelectedObject is TvxObject then
    TvxObject(vgStyleDesigner.Inspector.SelectedObject).AddFreeNotify(vgStyleDesigner);
  if AObject.TagObject <> nil then
  begin
    vgStyleDesigner.ObjectsTree.Selected := TvxTreeViewItem(AObject.TagObject);
  end;
end;

function TvxStyleIDEDesigner.UniqueName(ADesigner: TComponent;
  ClassName: string): string;
begin
  Result := '';
end;

function DesignResources(AResource: TvxResources; Current: string): boolean;
var
  SaveDesigner: TvxDesigner;
  S: string;
begin
  Result := false;
  if AResource <> nil then
  begin
    SaveDesigner := vgDesigner;
    vgDesigner := TvxStyleIDEDesigner.Create(Application);

    vgStyleDesigner := TvxStyleDesigner.Create(Application);
    {$IFDEF WIN32}
    with TRegistry.Create do
    begin
      RootKey := HKEY_CURRENT_USER;
      if OpenKey('Software\ksdev\vgstyledesigner', true) then
      begin
        if ReadString('position') <> '' then
        begin
          vgStyleDesigner.Position := poDesigned;
          with vgStringToRect(ReadString('position')) do
          begin
            vgStyleDesigner.Left := round(left);
            vgStyleDesigner.Top := round(top);
            vgStyleDesigner.Width := round(right);
            vgStyleDesigner.Height := round(bottom);
          end;
        end;
        if ReadString('left') <> '' then
          vgStyleDesigner.vgScene1.width := round(vgStrToFloat(ReadString('left')));
        if ReadString('right') <> '' then
          vgStyleDesigner.vgScene2.width := round(vgStrToFloat(ReadString('right')));
      end;
      Free;
    end;
    {$ENDIF}
    {$IFDEF FPC}
    Application.ProcessMessages;
    {$ENDIF}
    vgStyleDesigner.DesignScene.DesignTime := true;
    vgStyleDesigner.FResource := AResource;

    if vgStyleDesigner.DesignScene.Root <> nil then
      vgStyleDesigner.DesignScene.Root.DeleteChildren;

    AResource.FillStrings;
    vgStyleDesigner.LoadFromStrings(AResource.Resource);

    vgStyleDesigner.ObjectsTree.CollapseAll;

    if (vgStyleDesigner.DesignScene.Root <> nil) and (vgStyleDesigner.DesignScene.Root.FindResource(Current) <> nil) then
      vgDesigner.SelectObject(nil, vgStyleDesigner.DesignScene.Root.FindResource(Current), []);

    if vgStyleDesigner.ShowModal = mrOk then
    begin
      vgStyleDesigner.SaveToStrings(AResource.Resource);
      Result := true;
    end;
    {$IFDEF WIN32}
    with TRegistry.Create do
    begin
      RootKey := HKEY_CURRENT_USER;
      if OpenKey('Software\ksdev\vgstyledesigner', true) then
      begin
        WriteString('position', vgRectToString(vgRect(vgStyleDesigner.Left, vgStyleDesigner.Top, vgStyleDesigner.Width, vgStyleDesigner.Height)));
        WriteString('left', vgFloatToStr(vgStyleDesigner.vgScene1.width));
        WriteString('right', vgFloatToStr(vgStyleDesigner.vgScene2.width));
      end;
      Free;
    end;
    {$ENDIF}
    vgStyleDesigner.vgScene1.Free;
    vgStyleDesigner.DesignScene.Free;
    vgStyleDesigner.vgScene2.Free;
    vgStyleDesigner.vgScene3.Free;

    vgStyleDesigner.Free;
    vgStyleDesigner := nil;

    vgDesigner.Free;

    vgDesigner := SaveDesigner;
  end;
end;

procedure TvxStyleIDEDesigner.AddObject(AObject: TvxObject);
begin
  inherited;
  vgStyleDesigner.UpdateTree;
end;

procedure TvxStyleIDEDesigner.DeleteObject(AObject: TvxObject);
begin
  inherited;
end;

{ TvxStyleDesigner }

procedure TvxStyleDesigner.textFilterChangeTracking(Sender: TObject);
begin
  UpdateTree;
end;

procedure TvxStyleDesigner.UpdateTree;
  procedure ProcessObject(Obj: TvxObject; Node: TvxTreeViewItem);
  var
    i: integer;
    N: TvxTreeViewItem;
    S: AnsiString;
  begin
    S := Obj.ResourceName;
    if S = '' then
      S := Obj.ClassName
    else
      S := S + ': ' + Obj.ClassName;

    if (textFilter.Text <> '') and (Obj.Parent = DesignScene.Root) then
    begin
      if Pos(textFilter.Text, S) = 0 then
        Exit;
    end;

    if Obj = DesignScene.Root then
    begin
      N := nil;
    end
    else
      if Node <> nil then
    begin
      N := TvxTreeViewItem.Create(Self);
      N.Parent := Node;
      N.Text := S;
      N.TagObject := Obj;
      N.Resource := 'objecttreeitemstyle';
      N.OnApplyResource := TreeItemApplyResource;
      if Obj.IsVisual then
        N.IsChecked := not Obj.Visual.Locked;
    end
    else
    begin
      N := TvxTreeViewItem.Create(Self);
      N.Parent := ObjectsTree;
      N.Text := S;
      N.TagObject := Obj;
      N.Resource := 'objecttreeitemstyle';
      N.OnApplyResource := TreeItemApplyResource;
      if Obj.IsVisual then
        N.IsChecked := not Obj.Visual.Locked;
    end;
    Obj.TagObject := N;
    if Obj.isVisual and (Obj.Parent = DesignScene.Root) then
    begin
      Obj.Visual.DesignHide := true;
      // center
      with Obj.Visual do
      begin
        SetBounds(Trunc((DesignScene.Width - Width) / 2), Trunc((DesignScene.Height - Height) / 2), Width, Height);
      end;
    end;
    if Obj.ChildrenCount > 0 then
      for i := 0 to Obj.ChildrenCount - 1 do
      begin
        if (DesignScene.Root is TvxBackground) and (Obj.Children[i] = TvxHackBackground(DesignScene.Root).FResourceLink) then
          Continue;
        ProcessObject(Obj.Children[i], N);
      end;
  end;
begin
  if DesignScene.Root <> nil then
  begin
    ObjectsTree.Clear;
    ObjectsTree.BeginUpdate;
    ProcessObject(DesignScene.Root, nil);
    ObjectsTree.EndUpdate;
    DesignScene.AddUpdateRect(vgRect(0, 0, 1000, 1000));
  end;
end;

procedure TvxStyleDesigner.TreeItemApplyResource(Sender: TObject);
begin
  TvxTreeViewItem(Sender).Binding['deletebutton'] := EventToVariant(DoDeleteButton);
  TvxTreeViewItem(Sender).Binding['vischeck'] := EventToVariant(DoVisCheck);
  if TvxTreeViewItem(Sender).FindBinding('vischeck') <> nil then
  begin
    TvxObject(TvxTreeViewItem(Sender).FindBinding('vischeck')).TagObject := TvxTreeViewItem(Sender).TagObject;
    TvxVisualObject(TvxTreeViewItem(Sender).FindBinding('vischeck')).Visible := TvxTreeViewItem(Sender).TagObject is TvxVisualObject;
    if TvxTreeViewItem(Sender).TagObject is TvxVisualObject then
      TvxTreeViewItem(Sender).Binding['vischeck'] := TvxVisualObject(TvxTreeViewItem(Sender).TagObject).Visible;
  end;
  if not (TvxTreeViewItem(Sender).TagObject is TvxVisualObject) then
    TvxVisualObject(TvxTreeViewItem(Sender).FindResource('check')).Visible := false;
end;

procedure TvxStyleDesigner.DoVisCheck(Sender: TObject);
begin
  TvxVisualObject(TvxObject(Sender).TagObject).Visible := TvxObject(Sender).Data;
end;

procedure TvxStyleDesigner.ObjectsTreeChange(Sender: TObject);
var
  New, Old: TvxObject;
begin
  if (ObjectsTree.Selected <> nil) and (ObjectsTree.Selected.TagObject <> nil) then
  begin
    Old := TvxObject(Inspector.SelectedObject);
    if (Old <> nil) and (Old.Parent <> nil) then
      while Old.Parent <> DesignScene.Root do
        Old := Old.Parent;
    New := TvxObject(ObjectsTree.Selected.TagObject);
    while New.Parent <> DesignScene.Root do
      New := New.Parent;
    if New.IsVisual then
    begin
      // center
      New.Visual.Position.X := round((DesignScene.Width - New.Visual.Width) / 2);
      New.Visual.Position.Y := round((DesignScene.Height - New.Visual.Height) / 2);
      //
      if (Old <> nil) and (Old.IsVisual) then
      begin
        if Old <> DesignScene.Root then
          Old.Visual.DesignHide := true
      end
      else
        if (Old <> nil) and (Old.Parent <> nil) and (Old.Parent.IsVisual) then
      begin
        if Old.Parent <> DesignScene.Root then
          Old.Parent.Visual.DesignHide := true;
      end;
      if New <> DesignScene.Root then
        New.Visual.DesignHide := false;
    end
    else
    begin
      if (New <> nil) and (New.Parent <> nil) and (New.Parent.IsVisual) then
      begin
        New.Parent.Visual.DesignHide := false;
      end;
    end;
    Inspector.SelectedObject := TvxObject(ObjectsTree.Selected.TagObject);
    if TvxObject(ObjectsTree.Selected.TagObject).isVisual then
      DesignScene.Selected := TvxVisualObject(ObjectsTree.Selected.TagObject);
  end;
end;

procedure TvxStyleDesigner.Button1Click(Sender: TObject);
var
  S: TStrings;
begin
  { Load style }
  if OpenDialog1.Execute then
  begin
    S := TStringList.Create;
    S.LoadFromFile(OpenDialog1.FileName);
    LoadFromStrings(S);
    S.Free;
  end;
end;

procedure TvxStyleDesigner.Button2Click(Sender: TObject);
var
  S: TStrings;
begin
  { Save style }
  if SaveDialog1.Execute then
  begin
    S := TStringList.Create;
    SaveToStrings(S);
    S.SaveToFile(SaveDialog1.FileName);
    S.Free;
  end;
end;

procedure TvxStyleDesigner.LoadFromStrings(Str: TStrings);
var
  S: TStream;
  i: integer;
  Root: TvxObject;
begin
  S := TMemoryStream.Create;
  try
    Inspector.SelectedObject := nil;
    DesignScene.Selected := nil;
    ObjectsTree.Selected := nil;

    Str.SaveToStream(S);
    if S.Position > 0 then
    begin
      S.Position := 0;
      if DesignScene.Root <> nil then
        DesignScene.Root.Free;
      Root := CreateObjectFromStream(nil, S);
      DesignScene.AddObject(Root);
      for i := 0 to Root.ChildrenCount - 1 do
        if Root.Children[i].isVisual then
        begin
          {          TvxVisualObject(Root.FChildren[i]).Position.X := random(400);
                    TvxVisualObject(Root.FChildren[i]).Position.Y := random(400);}
          TvxVisualObject(Root.Children[i]).Locked := false;
        end;
      if Root.ChildrenCount > 0 then
        vgDesigner.SelectObject(nil, Root.Children[0], []);
      UpdateTree;
      DesignScene.RealignRoot;

      if Root is TvxBackground then
      begin
        btnBack.Visible := true;
        rectBack.Fill.Assign(TvxBackground(Root).Fill);
      end
      else
        btnBack.Visible := false;
    end;
  finally
    S.Free;
  end;
end;

procedure TvxStyleDesigner.SaveToStrings(Str: TStrings);
var
  S: TStream;
  i: integer;
  Root: TvxObject;
begin
  { Save style }
  S := TMemoryStream.Create;
  try
    Root := DesignScene.Root;
    Str.Clear;
    for i := 0 to Root.ChildrenCount - 1 do
      if Root.Children[i].isVisual then
      begin
        TvxVisualObject(Root.Children[i]).Locked := false;
      end;
    Root.SaveToStream(S);
    S.Position := 0;
    Str.LoadFromStream(S);
  finally
    S.Free;
  end;
end;

procedure TvxStyleDesigner.Button3Click(Sender: TObject);
begin
  { apply }
  if FResource <> nil then
    SaveToStrings(FResource.Resource);
end;

procedure TvxStyleDesigner.btnClearClick(Sender: TObject);
begin
  { clear }
  btnClear.Enabled := false;
  ClearTimer.Enabled := true;
end;

procedure TvxStyleDesigner.ClearTimerTimer(Sender: TObject);
var
  R: TvxBackground;
begin
  ClearTimer.Enabled := false;
  Inspector.SelectedObject := nil;
  DesignScene.Selected := nil;
  ObjectsTree.Selected := nil;

  DesignScene.Root.Free;
  R := TvxBackground.Create(nil);
  DesignScene.AddObject(R);

  UpdateTree;
  btnClear.Enabled := true;
end;

procedure TvxStyleDesigner.btnLoadDefaultClick(Sender: TObject);
var
  i: integer;
  S: TStream;
  Root: TvxObject;
begin
  { Default }
  if DefaultStyles = nil then
    Exit;

  Inspector.SelectedObject := nil;
  DesignScene.Selected := nil;
  ObjectsTree.Selected := nil;
  Root := nil;

  {$IFDEF FPC}
  if System.FindResource(HInstance, PChar('defaultvxstyle'), RT_RCDATA) <> 0 then
    {$ELSE}
  if Windows.FindResource(HInstance, PChar('defaultvxstyle'), RT_RCDATA) <> 0 then
    {$ENDIF}
  begin
    S := TResourceStream.Create(HInstance, 'defaultvxstyle', RT_RCDATA);
    Root := CreateObjectFromBinStream(nil, S);
    S.Free;
  end;
  DesignScene.Root.Free;
  DesignScene.AddObject(Root);
  for i := 0 to Root.ChildrenCount - 1 do
    if Root.Children[i].isVisual then
    begin
      TvxVisualObject(Root.Children[i]).Locked := false;
    end;

  if Root.ChildrenCount > 0 then
    vgDesigner.SelectObject(nil, Root.Children[0], []);
  UpdateTree;

  DesignScene.RealignRoot;

  if Root is TvxBackground then
  begin
    btnBack.Visible := true;
    rectBack.Fill.Assign(TvxBackground(Root).Fill);
  end
  else
    btnBack.Visible := false;
end;

procedure TvxStyleDesigner.FormCreate(Sender: TObject);
begin
  OpenDialog1.Filter := 'VGScene style|*.vxstyle';
  SaveDialog1.Filter := 'VGScene style|*.vxstyle';
end;

procedure TvxStyleDesigner.DeleteObject(AObject: TvxObject; FreeObject: boolean);
var
  A, P: TvxObject;
  Sel: TvxTreeViewItem;
begin
  if AObject <> nil then
  begin
    AObject.RemoveFreeNotify(vgStyleDesigner);

    Sel := TvxTreeViewItem(AObject.TagObject);
    A := AObject;
    P := A.Parent;
    if P <> nil then
    begin
      Inspector.SelectedObject := P;
      if P.TagObject <> nil then
        ObjectsTree.Selected := TvxTreeViewItem(P.TagObject);
    end
    else
    begin
      Inspector.SelectedObject := nil;
      if P.TagObject <> nil then
        ObjectsTree.Selected := nil;
    end;
    Sel.Release;
    if FreeObject then
      A.Release
    else
      A.TagObject := nil;
    ObjectsTree.Realign;
  end;
end;

procedure TvxStyleDesigner.btnBackClick(Sender: TObject);
begin
  vgBrushDialog1.Brush.Assign(rectBack.Fill);
  if vgBrushDialog1.Execute then
  begin
    rectBack.Fill.Assign(vgBrushDialog1.Brush);
    if (DesignScene.Root <> nil) and (DesignScene.Root is TvxBackground) then
      TvxBackground(DesignScene.Root).Fill.Assign(vgBrushDialog1.Brush);
    TvxBackground(DesignScene.Root).Repaint;
  end;
end;

procedure TvxStyleDesigner.DoDeleteButton(Sender: TObject);
begin
  if ObjectsTree.Selected = nil then
    Exit;
  if (Sender is TvxSpeedButton) then
  begin // fixed fast click deletebutton
    TvxSpeedButton(Sender).Enabled := False;
  end;
  DeleteObject(TvxObject(ObjectsTree.Selected.TagObject), true);
end;

procedure TvxStyleDesigner.ObjectsTreeMouseUp(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: Single);
begin
  if (Button = mbRight) then
  begin
    DesignScene.OpenDesignPopup;
  end;
end;

procedure TvxStyleDesigner.ObjectsTreeDragChange(SourceItem,
  DestItem: TvxTreeViewItem; Allow: Boolean);
begin
  if DestItem = nil then
    TvxObject(SourceItem.TagObject).Parent := DesignScene.Root
  else
    TvxObject(SourceItem.TagObject).Parent := TvxObject(DestItem.TagObject)
end;

procedure TvxStyleDesigner.InspectorChangeProperty(Sender: TObject;
  PropertyName: string);
begin
  if vgStyleDesigner.Inspector.SelectedObject = nil then
    Exit;
  if TvxTreeViewItem(TvxObject(vgStyleDesigner.Inspector.SelectedObject).TagObject) = nil then
    Exit;

  if PropertyName = 'ResourceName' then
  begin
    TvxTreeViewItem(TvxObject(vgStyleDesigner.Inspector.SelectedObject).TagObject).Text :=
      GetPropValue(vgStyleDesigner.Inspector.SelectedObject, PropertyName) + ': ' + vgStyleDesigner.Inspector.SelectedObject.ClassName;
  end;
end;

procedure TvxStyleDesigner.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent is TvxObject) and Assigned(TvxObject(AComponent).Scene) and (TvxObject(AComponent).Scene.GetComponent = DesignScene) then
    DeleteObject(TvxObject(AComponent), false);
end;

procedure TvxStyleDesigner.ObjectsTreeChangeCheck(Sender: TObject);
begin
  if (ObjectsTree.Selected <> nil) and (ObjectsTree.Selected.TagObject <> nil) and (TvxObject(ObjectsTree.Selected.TagObject).IsVisual) then
  begin
    TvxVisualObject(ObjectsTree.Selected.TagObject).Locked := not ObjectsTree.Selected.IsChecked;
  end;
end;

procedure TvxStyleDesigner.DesignRootDragOver(Sender: TObject;
  const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean);
begin
  Accept := true;
end;

procedure Blur(const Canvas: TvxCanvas; const Bitmap: TvxBitmap; const Radius: integer; UseAlpha: boolean = true);
var
  pix: PvgColorArray;
  w, h, wm, hm, wh, vdiv: integer;
  rsum, gsum, bsum, asum, x, y, i, yp, yi, yw: integer;
  P: cardinal;
  divsum: integer;
  stackpointer, stackstart: integer;
  sir: PvgColorRec;
  rbs, r1, routsum, goutsum, boutsum, aoutsum, rinsum, ginsum, binsum, ainsum: integer;
  dv: PIntArray;
  vmin: PIntArray;
  r, g, b, a: PIntArray;
  stack: PvgColorArray;
begin
  if (radius < 1) then
    Exit;

  pix := Bitmap.Scanline[0];

  w := Bitmap.width;
  h := Bitmap.height;
  wm := w - 1;
  hm := h - 1;
  wh := w * h;
  vdiv := radius + radius + 1;

  GetMem(r, wh * SizeOf(Integer));
  GetMem(g, wh * SizeOf(Integer));
  GetMem(b, wh * SizeOf(Integer));
  GetMem(a, wh * SizeOf(Integer));
  GetMem(vmin, max(w, h) * SizeOf(Integer));
  divsum := (vdiv + 1) shr 1;
  divsum := divsum * divsum;
  GetMem(dv, 256 * divsum * SizeOf(Integer));
  for i := 0 to 256 * divsum - 1 do
    dv[i] := (i div divsum);

  yw := 0;
  yi := 0;

  GetMem(stack, vdiv * SizeOf(TvxColor));

  r1 := radius + 1;

  for y := 0 to h - 1 do
  begin
    rinsum := 0;
    ginsum := 0;
    binsum := 0;
    ainsum := 0;
    routsum := 0;
    goutsum := 0;
    boutsum := 0;
    aoutsum := 0;
    rsum := 0;
    gsum := 0;
    bsum := 0;
    asum := 0;
    for i := -radius to radius do
    begin
      p := pix[yi + min(wm, max(i, 0))];
      sir := @stack[i + radius];
      sir.Color := p;
      rbs := r1 - abs(i);
      rsum := rsum + (sir.r * rbs);
      gsum := gsum + (sir.g * rbs);
      bsum := bsum + (sir.b * rbs);
      if UseAlpha then
        asum := asum + (sir.a * rbs);
      if (i > 0) then
      begin
        rinsum := rinsum + sir.r;
        ginsum := ginsum + sir.g;
        binsum := binsum + sir.b;
        if UseAlpha then
          ainsum := ainsum + sir.a;
      end
      else
      begin
        routsum := routsum + sir.r;
        goutsum := goutsum + sir.g;
        boutsum := boutsum + sir.b;
        if UseAlpha then
          aoutsum := aoutsum + sir.a;
      end
    end;
    stackpointer := radius;

    for x := 0 to w - 1 do
    begin
      r[yi] := dv[rsum];
      g[yi] := dv[gsum];
      b[yi] := dv[bsum];
      if UseAlpha then
        a[yi] := dv[asum];

      rsum := rsum - routsum;
      gsum := gsum - goutsum;
      bsum := bsum - boutsum;
      if UseAlpha then
        asum := asum - aoutsum;

      stackstart := stackpointer - radius + vdiv;
      sir := @stack[stackstart mod vdiv];

      routsum := routsum - sir.r;
      goutsum := goutsum - sir.g;
      boutsum := boutsum - sir.b;
      if UseAlpha then
        aoutsum := aoutsum - sir.a;

      if (y = 0) then
      begin
        vmin[x] := min(x + radius + 1, wm);
      end;
      p := pix[yw + vmin[x]];
      sir.color := p;

      rinsum := rinsum + sir.r;
      ginsum := ginsum + sir.g;
      binsum := binsum + sir.b;
      if UseAlpha then
        ainsum := ainsum + sir.a;

      rsum := rsum + rinsum;
      gsum := gsum + ginsum;
      bsum := bsum + binsum;
      if UseAlpha then
        asum := asum + ainsum;

      stackpointer := (stackpointer + 1) mod vdiv;
      sir := @stack[(stackpointer) mod vdiv];

      routsum := routsum + sir.r;
      goutsum := goutsum + sir.g;
      boutsum := boutsum + sir.b;
      if UseAlpha then
        aoutsum := aoutsum + sir.a;

      rinsum := rinsum - sir.r;
      ginsum := ginsum - sir.g;
      binsum := binsum - sir.b;
      if UseAlpha then
        ainsum := ainsum - sir.a;

      yi := yi + 1;
    end;
    yw := yw + w;
  end;

  for x := 0 to w - 1 do
  begin
    rinsum := 0;
    ginsum := 0;
    binsum := 0;
    ainsum := 0;
    routsum := 0;
    goutsum := 0;
    boutsum := 0;
    aoutsum := 0;
    rsum := 0;
    gsum := 0;
    bsum := 0;
    asum := 0;
    yp := -radius * w;
    for i := -radius to radius do
    begin
      yi := max(0, yp) + x;

      sir := @stack[i + radius];

      sir.r := r[yi];
      sir.g := g[yi];
      sir.b := b[yi];
      if UseAlpha then
        sir.a := a[yi];

      rbs := r1 - abs(i);

      rsum := rsum + (r[yi] * rbs);
      gsum := gsum + (g[yi] * rbs);
      bsum := bsum + (b[yi] * rbs);
      if UseAlpha then
        asum := asum + (a[yi] * rbs);

      if (i > 0) then
      begin
        rinsum := rinsum + sir.r;
        ginsum := ginsum + sir.g;
        binsum := binsum + sir.b;
        if UseAlpha then
          ainsum := ainsum + sir.a;
      end
      else
      begin
        routsum := routsum + sir.r;
        goutsum := goutsum + sir.g;
        boutsum := boutsum + sir.b;
        if UseAlpha then
          aoutsum := aoutsum + sir.a;
      end;

      if (i < hm) then
      begin
        yp := yp + w;
      end
    end;
    yi := x;
    stackpointer := radius;
    for y := 0 to h - 1 do
    begin
      pix[yi] := (dv[asum] shl 24) or (dv[rsum] shl 16) or (dv[gsum] shl 8) or dv[bsum];

      rsum := rsum - routsum;
      gsum := gsum - goutsum;
      bsum := bsum - boutsum;
      if UseAlpha then
        asum := asum - aoutsum;

      stackstart := stackpointer - radius + vdiv;
      sir := @stack[stackstart mod vdiv];

      routsum := routsum - sir.r;
      goutsum := goutsum - sir.g;
      boutsum := boutsum - sir.b;
      if UseAlpha then
        aoutsum := aoutsum - sir.a;

      if (x = 0) then
      begin
        vmin[y] := min(y + r1, hm) * w;
      end;
      p := x + vmin[y];

      sir.r := r[p];
      sir.g := g[p];
      sir.b := b[p];
      if UseAlpha then
        sir.a := a[p];

      rinsum := rinsum + sir.r;
      ginsum := ginsum + sir.g;
      binsum := binsum + sir.b;
      if UseAlpha then
        ainsum := ainsum + sir.a;

      rsum := rsum + rinsum;
      gsum := gsum + ginsum;
      bsum := bsum + binsum;
      if UseAlpha then
        asum := asum + ainsum;

      stackpointer := (stackpointer + 1) mod vdiv;
      sir := @stack[stackpointer];

      routsum := routsum + sir.r;
      goutsum := goutsum + sir.g;
      boutsum := boutsum + sir.b;
      if UseAlpha then
        aoutsum := aoutsum + sir.a;

      rinsum := rinsum - sir.r;
      ginsum := ginsum - sir.g;
      binsum := binsum - sir.b;
      if UseAlpha then
        ainsum := ainsum - sir.a;

      yi := yi + w;
    end;
  end;
  FreeMem(stack, vdiv * SizeOf(TvxColor));
  FreeMem(dv, 256 * divsum * SizeOf(Integer));
  FreeMem(vmin, max(w, h) * SizeOf(Integer));
  FreeMem(a, wh * SizeOf(Integer));
  FreeMem(r, wh * SizeOf(Integer));
  FreeMem(g, wh * SizeOf(Integer));
  FreeMem(b, wh * SizeOf(Integer));
end;

{ TvxShadowEffect ===================================================================}

constructor TvxShadowEffect.Create(AOwner: TComponent);
begin
  inherited;
  //  DisablePaint := true;
  FShadowColor := $FF000000;
  FDirection := 45;
  FOpacity := 0.6;
  FSoftness := 0.3;
  FDistance := 3;
end;

destructor TvxShadowEffect.Destroy;
begin
  inherited;
end;

function TvxShadowEffect.GetOffset: TvxPoint;
var
  S, C: single;
begin
  vgSinCos(vgDegToRad(FDirection), S, C);
  Result := vgPoint(Trunc(FSoftness * 20), Trunc(FSoftness * 20));
end;

function TvxShadowEffect.GetRect(const ARect: TvxRect): TvxRect;
var
  S, C: single;
begin
  Result := ARect;
  vgInflateRect(Result, Trunc(FSoftness * 20), Trunc(FSoftness * 20));
  vgSinCos(vgDegToRad(FDirection), S, C);
  vgOffsetRect(Result, FDistance * C, FDistance * S);
end;

function TvxShadowEffect.GetShadowColor: string;
begin
  Result := vgColorToStr(FShadowColor);
end;

procedure TvxShadowEffect.ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single);
var
  Bits: PvgColorRecArray;
  Mask: PByteArray;
  Sn, Cs: single;
  Off: TvxPoint;
begin
  { create mask }
  Mask := Visual.CreateMask;
  { fill color }
  Visual.FillColor(vgOpacity(vgCorrectColor(FShadowColor), FOpacity));
  { stack blur version }
  Blur(Canvas, Visual, Trunc(5 + FSoftness * 10));
  { apply mask }
  vgSinCos(vgDegToRad(FDirection), Sn, Cs);
  Off := vgPoint(FDistance * Cs * Data, FDistance * Sn * Data);
  Visual.ApplyMask(Mask, -round(Off.X), -round(Off.Y));
  { free mask }
  FreeMem(Mask, Visual.Width * Visual.Height);
end;

procedure TvxShadowEffect.SetDirection(const Value: single);
begin
  if FDirection <> Value then
  begin
    FDirection := Value;
    UpdateParentEffects;
  end;
end;

procedure TvxShadowEffect.SetDistance(const Value: single);
begin
  if FDistance <> Value then
  begin
    FDistance := Value;
    UpdateParentEffects;
  end;
end;

procedure TvxShadowEffect.SetOpacity(const Value: single);
begin
  if FOpacity <> Value then
  begin
    FOpacity := Value;
    if FOpacity < 0 then
      FOpacity := 0;
    if FOpacity > 1 then
      FOpacity := 1;
    UpdateParentEffects;
  end;
end;

procedure TvxShadowEffect.SetShadowColor(const Value: string);
begin
  if FShadowColor <> vgStrToColor(Value) then
  begin
    FShadowColor := vgStrToColor(Value);
    UpdateParentEffects;
  end;
end;

procedure TvxShadowEffect.SetSoftness(const Value: single);
begin
  if FSoftness <> Value then
  begin
    FSoftness := Value;
    if FSoftness < 0 then
      FSoftness := 0;
    if FSoftness > 3 then
      FSoftness := 3;
    UpdateParentEffects;
  end;
end;

{ TvxBlurEffect ===================================================================}

constructor TvxBlurEffect.Create(AOwner: TComponent);
begin
  inherited;
  DisablePaint := true;
  FSoftness := 0.3;
end;

destructor TvxBlurEffect.Destroy;
begin
  inherited;
end;

function TvxBlurEffect.GetOffset: TvxPoint;
begin
  Result := vgPoint(Trunc(FSoftness * 20), Trunc(FSoftness * 20));
end;

function TvxBlurEffect.GetRect(const ARect: TvxRect): TvxRect;
begin
  Result := ARect;
  vgInflateRect(Result, Trunc(FSoftness * 20), Trunc(FSoftness * 20));
end;

procedure TvxBlurEffect.ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single);
begin
  { stack blur version }
  if FSoftness > 0 then
    Blur(Canvas, Visual, Trunc(FSoftness * 15));
end;

procedure TvxBlurEffect.SetSoftness(const Value: single);
begin
  if FSoftness <> Value then
  begin
    FSoftness := Value;
    if FSoftness < 0 then
      FSoftness := 0;
    if FSoftness > 9 then
      FSoftness := 9;
    UpdateParentEffects;
  end;
end;

{ TvxGlowEffect ===================================================================}

constructor TvxGlowEffect.Create(AOwner: TComponent);
begin
  inherited;
  //  DisablePaint := true;
  FOpacity := 0.9;
  FGlowColor := $FFFFD700;
  FSoftness := 0.4;
end;

destructor TvxGlowEffect.Destroy;
begin
  inherited;
end;

function TvxGlowEffect.GetGlowColor: string;
begin
  Result := vgColorToStr(FGlowColor);
end;

function TvxGlowEffect.GetOffset: TvxPoint;
begin
  Result := vgPoint(4 + Trunc(FSoftness * 23), 4 + Trunc(FSoftness * 23));
end;

function TvxGlowEffect.GetRect(const ARect: TvxRect): TvxRect;
begin
  Result := ARect;
  vgInflateRect(Result, 4 + Trunc(FSoftness * 23), 4 + Trunc(FSoftness * 23));
end;

procedure TvxGlowEffect.ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single);
var
  Bits: PvgColorRecArray;
  Mask: PByteArray;
begin
  { create mask }
  Mask := Visual.CreateMask;
  { fill color }
  Visual.FillColor(vgOpacity(vgCorrectColor(FGlowColor), FOpacity));
  { stack blur version }
  Blur(Canvas, Visual, Trunc(5 + FSoftness * 10));
  { apply mask }
  Visual.ApplyMask(Mask);
  { free mask }
  FreeMem(Mask, Visual.Width * Visual.Height);
end;

procedure TvxGlowEffect.SetGlowColor(const Value: string);
begin
  if FGlowColor <> vgStrToColor(Value) then
  begin
    FGlowColor := vgStrToColor(Value);
    UpdateParentEffects;
  end;
end;

procedure TvxGlowEffect.SetOpacity(const Value: single);
begin
  if FOpacity <> Value then
  begin
    FOpacity := Value;
    if FOpacity < 0 then
      FOpacity := 0;
    if FOpacity > 1 then
      FOpacity := 1;
    UpdateParentEffects;
  end;
end;

procedure TvxGlowEffect.SetSoftness(const Value: single);
begin
  if FSoftness <> Value then
  begin
    FSoftness := Value;
    if FSoftness < 0 then
      FSoftness := 0;
    if FSoftness > 9 then
      FSoftness := 9;
    UpdateParentEffects;
  end;
end;

{ TvxInnerGlowEffect ===================================================================}

constructor TvxInnerGlowEffect.Create(AOwner: TComponent);
begin
  inherited;
  //  DisablePaint := true;
  AfterPaint := true;
end;

destructor TvxInnerGlowEffect.Destroy;
begin
  inherited;
end;

function TvxInnerGlowEffect.GetOffset: TvxPoint;
begin
  Result := vgPoint(Trunc(FSoftness * 20), Trunc(FSoftness * 20));
end;

function TvxInnerGlowEffect.GetRect(const ARect: TvxRect): TvxRect;
begin
  Result := ARect;
  vgInflateRect(Result, Trunc(FSoftness * 20), Trunc(FSoftness * 20));
end;

procedure TvxInnerGlowEffect.ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single);
var
  Bits: PvgColorRecArray;
  Mask: PByteArray;
begin
  { invert }
  Visual.InvertAlpha;
  { create mask }
  Mask := Visual.CreateMask;
  { fill color }
  Visual.FillColor(vgOpacity(vgCorrectColor(FGlowColor), FOpacity));
  { stack blur version }
  Blur(Canvas, Visual, Trunc(5 + FSoftness * 10));
  { apply mask }
  Visual.ApplyMask(Mask);
  { free mask }
  FreeMem(Mask, Visual.Width * Visual.Height);
end;

{ TvxBevelEffect ==============================================================}

constructor TvxBevelEffect.Create(AOwner: TComponent);
begin
  inherited;
  DisablePaint := true;
  FDirection := 45;
  FSize := 10;
end;

destructor TvxBevelEffect.Destroy;
begin
  inherited;
end;

function TvxBevelEffect.GetOffset: TvxPoint;
begin
  Result := vgPoint(5, 5);
end;

function TvxBevelEffect.GetRect(const ARect: TvxRect): TvxRect;
begin
  Result := ARect;
  vgInflateRect(Result, 5, 5);
end;

function VectorAngleCosine(const V1, V2: TvxVector): Single;
var
  dot, len1, len2: single;
begin
  len1 := sqrt((v1.x * v1.x) + (v1.y * v1.y) + (v1.w * v1.w));
  len2 := sqrt((v2.x * v2.x) + (v2.y * v2.y) + (v2.w * v2.w));
  dot := (V1.V[0] * V2.V[0] + V1.V[1] * V2.V[1] + V1.V[2] * V2.V[2]);
  Result := len1 * len2;
  if Abs(Result) > 1E-40 then
    Result := dot / Result
  else
    Result := 1;
end;

procedure TvxBevelEffect.ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single);
var
  color: cardinal;
  DestBits, Bits: PvgColorRecArray;
  i, j: integer;
  a, h0, h1, h2, h3: single;
  alpha: byte;
  light, n, v, b: TvxVector;
  LightMap: TvxBitmap;
begin
  if FSize = 0 then
    Exit;

  DestBits := PvgColorRecArray(Visual.Scanline[0]);
  { create lightmap }
  LightMap := TvxBitmap.Create(Visual.Width, Visual.Height);
  Bits := PvgColorRecArray(LightMap.Scanline[0]);
  { copy bitmap }
  System.Move(DestBits^, Bits^, Visual.Width * Visual.Height * 4);
  { blur - make HeightMap }
  Blur(Canvas, LightMap, FSize);
  { calculate lighting }
  a := DegToRad(FDirection);
  light.x := cos(a);
  light.y := 0;
  light.w := sin(a);
  { make normalmap from hightmap }
  for j := Visual.Height - 2 downto 0 do
  begin
    for i := Visual.Width - 2 downto 0 do
    begin
      // only calc not transparent pixels
      {$IFDEF FPC_BIG_ENDIAN}
      alpha := DestBits[(i) + ((j) * Visual.Width)].Color and $FF;
      {$ELSE}
      alpha := DestBits[(i) + ((j) * Visual.Width)].A;
      {$ENDIF}
      if alpha > 0 then
      begin
        {$IFDEF FPC_BIG_ENDIAN}
        h0 := (Bits[i + ((j + 1) * Visual.Width)].Color and $FF) / $FF; //.height(x  ,z+1);
        h1 := (Bits[(i + 1) + ((j + 1) * Visual.Width)].Color and $FF) / $FF; //height(x+1,z+1);
        h2 := (Bits[(i + 1) + (j * Visual.Width)].Color and $FF) / $FF; //height(x+1,  z);
        h3 := (Bits[(i + 1) + ((j + 1) * Visual.Width)].Color and $FF) / $FF; //height(x  ,  z);
        {$ELSE}
        h0 := (Bits[i + ((j + 1) * Visual.Width)].Color and $FF000000 shr 24) / $FF; //.height(x  ,z+1);
        h1 := (Bits[(i + 1) + ((j + 1) * Visual.Width)].Color and $FF000000 shr 24) / $FF; //height(x+1,z+1);
        h2 := (Bits[(i + 1) + (j * Visual.Width)].Color and $FF000000 shr 24) / $FF; //height(x+1,  z);
        h3 := (Bits[(i + 1) + ((j + 1) * Visual.Width)].Color and $FF000000 shr 24) / $FF; //height(x  ,  z);
        {$ENDIF}

        v.x := 1.0;
        v.y := h2 - h3;
        v.w := 0;

        b.x := 0;
        b.y := h0 - h3;
        b.w := 1; // vector length

        // calc normal
        n.x := b.y * v.w - v.y * b.w;
        n.y := v.x * b.w - b.x * v.w;
        n.w := b.x * v.y - v.x * b.y;

        // normalize
        n.x := n.x / b.w;
        n.y := n.y / b.w;
        n.w := n.w / b.w;

        // calc light
        a := VectorAngleCosine(light, n) * FSize;

        // set value
        {$IFDEF FPC_BIG_ENDIAN}
        color := DestBits[(i) + ((j) * Visual.Width)].Color;
        ReverseBytes(@color, 4);
        DestBits[(i) + ((j) * Visual.Width)].Color := vgPremultyAlpha(vgOpacity(vgChangeHSL(color, 0, 0, a * 0.4), alpha / $FF));
        ReverseBytes(@DestBits[(i) + ((j) * Visual.Width)], 4);
        {$ELSE}
        DestBits[(i) + ((j) * Visual.Width)].Color := vgPremultyAlpha(vgOpacity(vgChangeHSL(DestBits[(i) + ((j) * Visual.Width)].Color, 0, 0, a * 0.4), alpha / $FF));
        {$ENDIF}
      end;
    end;
  end;
  LightMap.Free;
end;

procedure TvxBevelEffect.SetDirection(const Value: single);
begin
  if FDirection <> Value then
  begin
    FDirection := Value;
    UpdateParentEffects;
  end;
end;

procedure TvxBevelEffect.SetSize(const Value: integer);
begin
  if FSize <> Value then
  begin
    FSize := Value;
    UpdateParentEffects;
  end;
end;

{ TvxReflectionEffect }

constructor TvxReflectionEffect.Create(AOwner: TComponent);
begin
  inherited;
  //  DisablePaint := true;
  FOffset := 0;
  FLength := 0.5;
  FOpacity := 0.5;
end;

destructor TvxReflectionEffect.Destroy;
begin
  inherited;
end;

function TvxReflectionEffect.GetOffset: TvxPoint;
begin
  Result := vgPoint(2, 2);
end;

function TvxReflectionEffect.GetRect(const ARect: TvxRect): TvxRect;
begin
  Result := ARect;
  vgInflateRect(Result, 2, 2);
  vgOffsetRect(Result, 0, vgRectHeight(ARect) + FOffset);
end;

procedure TvxReflectionEffect.ProcessEffect(Canvas: TvxCanvas; const Visual: TvxBitmap; const Data: single);
var
  Bits: PvgColorRecArray;
  Line: array[0..2048] of TvxColor;
  c, a, i, j: integer;
  alpha: byte;
  color: cardinal;
begin
  Bits := PvgColorRecArray(Visual.Scanline[0]);
  c := Visual.Height - 1;
  a := round(c * FLength);
  { without Offset }
  Visual.FlipHorizontal;
  { set alpha }
  for j := 0 to c do
    if j > (c - a) then
      for i := 0 to Visual.Width - 1 do
      begin
        // only calc not transparent pixels
        {$IFDEF FPC_BIG_ENDIAN}
        alpha := Bits[i + (Visual.Height - 1 - j) * Visual.Width].Color and $FF;
        {$ELSE}
        alpha := Bits[i + (Visual.Height - 1 - j) * Visual.Width].A;
        {$ENDIF}
        if alpha > 0 then
        begin
          {$IFDEF FPC_BIG_ENDIAN}
          color := Bits[i + (Visual.Height - 1 - j) * Visual.Width].Color;
          ReverseBytes(@color, 4);
          TvxColorRec(color).A := Trunc(((j - (c - a)) / a) * FOpacity * alpha);
          Bits[i + (Visual.Height - 1 - j) * Visual.Width].Color := vgPremultyAlpha(color);
          ReverseBytes(@Bits[i + (Visual.Height - 1 - j) * Visual.Width], 4);
          {$ELSE}
          Bits[i + (Visual.Height - 1 - j) * Visual.Width].A := Trunc(((j - (c - a)) / a) * FOpacity * alpha);
          Bits[i + (Visual.Height - 1 - j) * Visual.Width].Color := vgPremultyAlpha(Bits[i + (Visual.Height - 1 - j) * Visual.Width].Color);
          {$ENDIF}
        end;
      end
    else
      vgFillLongword(@Bits[(Visual.Height - 1 - j) * Visual.Width], Visual.Width, $0);
end;

procedure TvxReflectionEffect.SetLength(const Value: single);
begin
  if FLength <> Value then
  begin
    FLength := Value;
    if FLength < 0.1 then
      FLength := 0.1;
    if FLength > 1 then
      FLength := 1;
    UpdateParentEffects;
  end;
end;

procedure TvxReflectionEffect.SetOffset(const Value: integer);
begin
  if FOffset <> Value then
  begin
    FOffset := Value;
    UpdateParentEffects;
  end;
end;

procedure TvxReflectionEffect.SetOpacity(const Value: single);
begin
  if FOpacity <> Value then
  begin
    FOpacity := Value;
    UpdateParentEffects;
  end;
end;

{ TvxIPhoneButton ===================================================================}

constructor TvxIPhoneButton.Create(AOwner: TComponent);
begin
  inherited;
  FBackground := TvxBrush.Create(vgBrushSolid, $FF808080);
  FBackground.OnChanged := BackChanged;
end;

destructor TvxIPhoneButton.Destroy;
begin
  FBackground.Free;
  inherited;
end;

procedure TvxIPhoneButton.BackChanged(Sender: TObject);
var
  T: TvxObject;
begin
  T := FindResource('background');
  if (T <> nil) and (T is TvxShape) then
    TvxShape(T).Fill.Assign(FBackground);
end;

procedure TvxIPhoneButton.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('background');
  if (T <> nil) and (T is TvxShape) then
    TvxShape(T).Fill.Assign(FBackground);
end;

procedure TvxIPhoneButton.SetBackground(const Value: TvxBrush);
begin

end;

{ TvxDockBar }

constructor TvxDockBar.Create(AOwner: TComponent);
begin
  inherited;
  FMinSize := 32;
  FMaxSize := 64;
end;

destructor TvxDockBar.Destroy;
begin
  inherited;
end;

procedure TvxDockBar.MouseLeave;
begin
  inherited;
  FMousePos := vgPoint(0, 0);
  Realign;
end;

procedure TvxDockBar.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
end;

procedure TvxDockBar.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  FMousePos := vgPoint(X, Y);
  Realign;
end;

procedure TvxDockBar.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
end;

procedure TvxDockBar.Paint;
begin
  inherited;
end;

procedure TvxDockBar.Realign;
var
  i, j: integer;
  dist, Pos, MaxWidth, Amplitude: single;
  hot: boolean;
  List: TList;
begin
  inherited;
  if FChildren = nil then
    Exit;
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  try
    { make order left to right list }
    List := TList.Create;
    for i := 0 to FChildren.Count - 1 do
    begin
      if not TvxObject(FChildren[i]).isVisual then
        Continue;
      if not TvxVisualObject(FChildren[i]).Visible then
        Continue;

      if List.Count > 0 then
      begin
        for j := 0 to List.Count - 1 do
        begin
          if TvxVisualObject(FChildren[i]).Position.X < TvxVisualObject(List[j]).Position.X then
            Break;
        end;
        List.Insert(j, FChildren[i]);
      end
      else
        List.Add(FChildren[i]);
    end;
    { align }
    if FMousePos.X = 0 then
    begin
      { mouse leave }
      MaxWidth := List.Count * MinSize;
      for i := 0 to List.Count - 1 do
      begin
        TvxVisualObject(List[i]).Position.Y := Height - MinSize;
        TvxVisualObject(List[i]).Position.X := (Width / 2) - (MaxWidth / 2) + (i * MinSize);
        TvxVisualObject(List[i]).Height := MinSize;
        TvxVisualObject(List[i]).Width := MinSize;
      end;
    end
    else
    begin
      Amplitude := FMaxSize * 1.5;
      MaxWidth := (List.Count * MinSize);
      { check hot object }
      hot := false;
      for i := 0 to List.Count - 1 do
      begin
        if (FMousePos.X >= TvxVisualObject(List[i]).Position.X) and (FMousePos.X <= TvxVisualObject(List[i]).Position.X + TvxVisualObject(List[i]).Width) then
        begin
          hot := true;
          Break;
        end
      end;
      { set sizes }
      for i := 0 to List.Count - 1 do
      begin
        if (FMousePos.X >= TvxVisualObject(List[i]).Position.X) and (FMousePos.X <= TvxVisualObject(List[i]).Position.X + TvxVisualObject(List[i]).Width) then
        begin
          TvxVisualObject(List[i]).Width := MaxSize;
          TvxVisualObject(List[i]).Height := MaxSize;
          MaxWidth := MaxWidth + (MaxSize - MinSize);
        end
        else
        begin
          dist := (TvxVisualObject(List[i]).Position.X + (TvxVisualObject(List[i]).Width / 2)) - FMousePos.X;
          if (Abs(dist) < Amplitude) and (hot) then
          begin
            TvxVisualObject(List[i]).Width := MinSize + Sin((Pi / 2) + ((dist / Amplitude) * (Pi / 2))) * (MaxSize - MinSize);
            TvxVisualObject(List[i]).Height := TvxVisualObject(List[i]).Width;
            MaxWidth := MaxWidth + (TvxVisualObject(List[i]).Width - MinSize);
          end
          else
          begin
            TvxVisualObject(List[i]).Width := MinSize;
            TvxVisualObject(List[i]).Height := MinSize;
          end;
        end;
      end;
      { align }
      Pos := ((Width / 2) - (MaxWidth / 2));
      for i := 0 to List.Count - 1 do
      begin
        TvxVisualObject(List[i]).Position.Y := Height - TvxVisualObject(List[i]).Height - 1;
        TvxVisualObject(List[i]).Position.X := Pos;
        Pos := Pos + TvxVisualObject(List[i]).Height;
      end;
    end;
    { }
    List.Free;
  finally
    FDisableAlign := false;
  end;
end;

procedure TvxDockBar.SetMaxSize(const Value: single);
begin
  FMaxSize := Value;
end;

procedure TvxDockBar.SetMinSize(const Value: single);
begin
  FMinSize := Value;
end;

{ TvxDropTarget }

constructor TvxDropTarget.Create(AOwner: TComponent);
begin
  inherited;
  DragDisableHighlight := true;
  Width := 120;
  Height := 120;
end;

procedure TvxDropTarget.DragDrop(const Data: TvxDragObject;
  const Point: TvxPoint);
begin
  inherited;
  if Assigned(FOnDrop) then
    FOnDrop(Self, Data, Point);
end;

procedure TvxDropTarget.DragOver(const Data: TvxDragObject;
  const Point: TvxPoint; var Accept: Boolean);
begin
  inherited;
  Accept := true; //(Length(Data.Files) > 0) and FileExists(Data.Files[0]) and (Pos(ExtractFileExt(LowerCase(Data.Files[0])), Filter) > 0);
end;

{ Graph objects ===============================================================}

{ TvxPlotGrid }

constructor TvxPlotGrid.Create(AOwner: TComponent);
begin
  inherited;
  FLineFill := TvxBrush.Create(vgBrushSolid, $FF505050);
  FLineFill.OnChanged := LineFillChanged;
  FMarks := 25;
  FFrequency := 5;
end;

destructor TvxPlotGrid.Destroy;
begin
  FLineFill.Free;
  inherited;
end;

procedure TvxPlotGrid.LineFillChanged(Sender: TObject);
begin
  Repaint;
end;

procedure TvxPlotGrid.Paint;
var
  x, y: single;
begin
  x := 0;
  y := 0;
  Canvas.Stroke.Assign(FLineFill);
  while x < Width / 2 do
  begin
    if (x = 0) then
    begin
      Canvas.StrokeThickness := 2;
      Canvas.Stroke.SolidColor := FLineFill.SolidColor
    end
    else
    begin
      if (frac(x) = 0) and (frac(x / frequency / marks) = 0) then
        Canvas.Stroke.SolidColor := FLineFill.SolidColor
      else
        Canvas.Stroke.SolidColor := vgOpacity(FLineFill.SolidColor, 0.4);
      Canvas.StrokeThickness := 1;
    end;

    Canvas.DrawLine(vgPoint(round(Width / 2) + x + (Canvas.StrokeThickness / 2), 0), vgPoint(round(Width / 2) + x + (Canvas.StrokeThickness / 2), Height), AbsoluteOpacity);
    if x <> 0 then
      Canvas.DrawLine(vgPoint(round(Width / 2) - x + (Canvas.StrokeThickness / 2), 0), vgPoint(round(Width / 2) - x + (Canvas.StrokeThickness / 2), Height), AbsoluteOpacity);
    x := x + FFrequency;
  end;
  while y < Height / 2 do
  begin
    if (y = 0) then
    begin
      Canvas.StrokeThickness := 2;
      Canvas.Stroke.SolidColor := FLineFill.SolidColor
    end
    else
    begin
      if (frac(y) = 0) and (frac(y / frequency / marks) = 0) then
        Canvas.Stroke.SolidColor := FLineFill.SolidColor
      else
        Canvas.Stroke.SolidColor := vgOpacity(FLineFill.SolidColor, 0.4);
      Canvas.StrokeThickness := 1;
    end;

    Canvas.DrawLine(vgPoint(0, round(Height / 2) + y + (Canvas.StrokeThickness / 2)), vgPoint(Width, round(Height / 2) + y + (Canvas.StrokeThickness / 2)), AbsoluteOpacity);
    if y <> 0 then
      Canvas.DrawLine(vgPoint(0, round(Height / 2) - y + (Canvas.StrokeThickness / 2)), vgPoint(Width, round(Height / 2) - y + (Canvas.StrokeThickness / 2)), AbsoluteOpacity);
    y := y + FFrequency;
  end;
end;

procedure TvxPlotGrid.SetFrequency(const Value: single);
begin
  if FFrequency <> Value then
  begin
    FFrequency := Value;
    if FFrequency < 0.001 then
      FFrequency := 0.001;
    Repaint;
  end;
end;

procedure TvxPlotGrid.SetLineFill(const Value: TvxBrush);
begin
  FLineFill.Assign(Value);
end;

procedure TvxPlotGrid.SetMarks(const Value: single);
begin
  if FMarks <> Value then
  begin
    FMarks := Value;
    Repaint;
  end;
end;

{ TvxImageViewer }

constructor TvxImageViewer.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'framedscrollboxstyle';
  MouseTracking := true;
  MouseScaling := true;
  Cursor := crHandPoint;
  FScale := 1;
  FBack := TvxRectangle.Create(Self);
  FBack.HitTest := false;
  FBack.Parent := Self;
  FBack.Locked := true;
  FBack.Stroke.Style := vgBrushNone;
  FBack.Stored := false;
  FBack.Visible := false;
  FImage := TvxImage.Create(Self);
  FImage.HitTest := false;
  FImage.Parent := Self;
  FImage.Locked := true;
  FImage.Stored := false;
  FImage.WrapMode := vgImageStretch;
  FImage.Bitmap.OnChange := DoBitmapChange;
end;

destructor TvxImageViewer.Destroy;
begin
  inherited;
end;

function TvxImageViewer.GetBitmap: TvxBitmap;
begin
  Result := FImage.Bitmap;
end;

function TvxImageViewer.GetContentBounds: TvxRect;
begin
  FImage.SetBounds(0, 0, Bitmap.Width * BitmapScale, Bitmap.Height * BitmapScale);

  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    if FImage.Width < ContentLayout.Width then
      FImage.Position.X := round((ContentLayout.Width - FImage.Width) / 2);
    if FImage.Height < ContentLayout.Height then
      FImage.Position.Y := round((ContentLayout.Height - FImage.Height) / 2);
  end;
  FBack.SetBounds(FImage.Position.X, FImage.Position.Y, FImage.Width, FImage.Height);

  Result := vgUnionRect(vgRect(0, 0, 0, 0), FImage.ParentedRect);
end;

procedure TvxImageViewer.MouseWheel(Shift: TShiftState;
  WheelDelta: integer; var Handled: boolean);
begin
  if MouseScaling then
  begin
    BitmapScale := BitmapScale + (WheelDelta / 120) * 0.04;
    Handled := true;
  end;
  inherited;
end;

procedure TvxImageViewer.BestFit;
var
  R: TvxRect;
  s: single;
  NeedRealign: boolean;
begin
  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    NeedRealign := false;
    if (VScrollBar <> nil) and (VScrollBar.Enabled) then
      NeedRealign := true;
    if (VScrollBar <> nil) and (VScrollBar.Enabled) then
      NeedRealign := true;
    R := vgRect(0, 0, Bitmap.Width, Bitmap.Height);
    s := vgFitRect(R, ContentLayout.LocalRect);
    if s >= 1 then
      BitmapScale := 1 / s
    else
      BitmapScale := 1;
    if NeedRealign then
    begin
      R := vgRect(0, 0, Bitmap.Width, Bitmap.Height);
      s := vgFitRect(R, ContentLayout.LocalRect);
      if s >= 1 then
        BitmapScale := 1 / s
      else
        BitmapScale := 1;
    end;
  end
end;

procedure TvxImageViewer.SetBitmap(const Value: TvxBitmap);
begin
  FImage.Bitmap := Value;
end;

procedure TvxImageViewer.SetScale(const Value: single);
begin
  if FScale <> Value then
  begin
    FScale := Value;
    if FScale < 0.01 then
      FScale := 0.01;
    if FScale > 10 then
      FScale := 10;
    Realign;
    Centre;
  end;
end;

function TvxImageViewer.GetBackgroundFill: TvxBrush;
begin
  Result := FBack.Fill;
end;

procedure TvxImageViewer.SetBackgroundFill(const Value: TvxBrush);
begin
  FBack.Fill := Value;
end;

procedure TvxImageViewer.DoBitmapChange(Sender: TObject);
begin
  Realign;
end;

procedure TvxImageViewer.SetShowBackground(const Value: boolean);
begin
  if FShowBackground <> Value then
  begin
    FShowBackground := Value;
    FBack.Visible := FShowBackground;
  end;
end;

function TvxImageViewer.GetData: Variant;
begin
  Result := ObjectToVariant(Bitmap);
end;

procedure TvxImageViewer.SetData(const Value: Variant);
begin
  if VarIsNull(Value) then
    Bitmap.SetSize(1, 1)
  else
    if VarIsObject(Value) then
  begin
    if VariantToObject(Value) is TPersistent then
      Bitmap.Assign(TPersistent(VariantToObject(Value)));
  end
  else
    Bitmap.LoadFromFile(Value)
end;

{ TvxCalendar }

constructor TvxCalendar.Create(AOwner: TComponent);
var
  i: integer;
  L: TvxVisualObject;
  AYear, AMonth, ADay: Word;
begin
  inherited;
  FDateTime := Now;
  DecodeDate(FDateTime, AYear, AMonth, ADay);
  FFirstDayOfWeek := vgLocaleDefault;
  Width := 180;
  Height := 160;
  L := TvxLayout.Create(Self);
  with L do
  begin
    Parent := Self;
    Locked := true;
    Stored := false;
    Height := 19;
    Align := vaMostTop;
    Padding.Bottom := 2;
    FPrev := TvxButton.Create(Self);
    with FPrev do
    begin
      Parent := L;
      Width := 19;
      Locked := true;
      Stored := false;
      Align := vaLeft;
      Padding.Right := 2;
      Resource := 'transparentcirclebuttonstyle';
      OnClick := DoPrevClick;
      RepeatClick := true;
      with TvxScrollArrowLeft.Create(Self) do
      begin
        Parent := FPrev;
        Width := 5;
        Height := 5;
        Stroke.Style := vgBrushNone;
        Align := vaCenter;
        HitTest := false;
        Stored := false;
        Locked := true;
      end;
    end;
    FToday := TvxButton.Create(Self);
    with FToday do
    begin
      Parent := L;
      Width := 19;
      Locked := true;
      Stored := false;
      Align := vaLeft;
      Position.X := 30;
      Padding.Right := 2;
      Resource := 'transparentcirclebuttonstyle';
      OnClick := DoTodayClick;
      RepeatClick := true;
      with TvxEllipse.Create(Self) do
      begin
        Parent := FToday;
        Width := 5;
        Height := 5;
        Stroke.Style := vgBrushNone;
        Align := vaCenter;
        HitTest := false;
        Stored := false;
        Locked := true;
      end;
    end;
    FNext := TvxButton.Create(Self);
    with FNext do
    begin
      Parent := L;
      Width := 19;
      Locked := true;
      Stored := false;
      Position.X := 50;
      Align := vaLeft;
      Padding.Right := 2;
      Resource := 'transparentcirclebuttonstyle';
      RepeatClick := true;
      OnClick := DoNextClick;
      with TvxScrollArrowRight.Create(Self) do
      begin
        Parent := FNext;
        Width := 5;
        Height := 5;
        Stroke.Style := vgBrushNone;
        Align := vaCenter;
        HitTest := false;
        Stored := false;
        Locked := true;
      end;
    end;
    FMonths := TvxPopupBox.Create(Self);
    with FMonths do
    begin
      Parent := L;
      Align := vaClient;
      Locked := true;
      Stored := false;
      DisableFocusEffect := true;
      Padding.Left := 5;
      Padding.Right := 5;
      Resource := 'labelstyle';
      for i := 1 to 12 do
        Items.Add(LongMonthNames[i]);
      Font.Style := vgFontBold;
      TextAlign := vgTextAlignFar;
      ItemIndex := AMonth - 1;
      OnChange := DoMonthChange;
    end;
    FYears := TvxPopupBox.Create(Self);
    with FYears do
    begin
      Parent := L;
      Width := 40;
      Align := vaRight;
      Locked := true;
      Stored := false;
      DisableFocusEffect := true;
      Resource := 'labelstyle';
      for i := 1 to 10 do
        Items.Add(IntToStr(AYear - i));
      Items.Add(IntToStr(AYear));
      for i := 1 to 10 do
        Items.Add(IntToStr(AYear + i));
      Font.Style := vgFontBold;
      TextAlign := vgTextAlignNear;
      ItemIndex := 10;
      OnChange := DoYearChange;
    end;
  end;
  FWeek := TvxGridLayout.Create(Self);
  with FWeek do
  begin
    Parent := Self;
    Locked := true;
    Stored := false;
    Height := 19;
    Position.Y := 20;
    ItemHeight := 19;
    Align := vaTop;
    Padding.Bottom := 2;
    for i := 0 to 6 do
      with TvxLabel.Create(Self) do
      begin
        Parent := FWeek;
        Locked := true;
        Stored := false;
        TextAlign := vgTextAlignCenter;
        WordWrap := false;
      end;
    ItemWidth := Width / 7;
  end;
  FWeeks := TvxGridLayout.Create(Self);
  with FWeeks do
  begin
    Parent := Self;
    Locked := true;
    Stored := false;
    Width := 23;
    Align := vaMostLeft;
    Padding.Top := 19 + 2;
    ItemHeight := 19;
    ItemWidth := Width;
    Visible := false;
    for i := 0 to 5 do
      with TvxLabel.Create(Self) do
      begin
        Parent := FWeeks;
        Locked := true;
        Stored := false;
        TextAlign := vgTextAlignCenter;
        WordWrap := false;
      end;
  end;
  FDays := TvxListBox.Create(Self);
  with FDays do
  begin
    Parent := Self;
    Locked := true;
    Stored := false;
    Position.Y := 50;
    Height := 19 * 6;
    Align := vaTop;
    Columns := 7;
    ItemHeight := 19;
    AlternatingRowBackground := true;
    HideSelectionUnfocused := false;
    ShowScrollBars := false;
    OnChange := DoDayChange;
    Resource := 'transparentlistboxstyle';
    for i := 1 to 6 * 7 do
      with TvxListBoxItem.Create(Self) do
      begin
        Parent := FDays;
        Locked := true;
        Stored := false;
        TextAlign := vgTextAlignFar;
        WordWrap := false;
      end;
  end;
  FillList;
end;

function WeekOfYear(aDate: tDateTime): byte;
var
  t, m, year: word;
  newyear: tDateTime;
  KW: word;
  wtag_ny: word;
begin
  DecodeDate(aDate, year, m, t); // calc year
  newyear := EncodeDate(year, 1, 1); // calc 1.1.year
  wtag_ny := ord(DayofWeek(newyear)); // DOW of 1.1.year
  KW := Trunc(((aDate - newyear + ((wtag_ny + 1) mod 7) - 3) / 7) + 1);
  if (KW = 0) then
  begin
    KW := 0;
  end;
  result := KW;
end;

procedure TvxCalendar.FillList;
var
  i: integer;
  AYear, PreMonth, AMonth, ADay: Word;
  Date: TDate;
  First, Last: integer;
  A: array[0..1] of char;
  Item: TvxListBoxItem;
begin
  FDisableDayChange := FDisableDayChange + 1;
  try
    { first day }
    if FFirstDayOfWeek = vgLocaleDefault then
    begin
      {$IFDEF WINDOWS}
      GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IFIRSTDAYOFWEEK, A, SizeOf(A));
      {$ENDIF}
      FFirstDayOfWeekNum := Ord(A[0]) - Ord('0');
    end
    else
      FFirstDayOfWeekNum := Ord(FFirstDayOfWeek);
    FFirstDayOfWeekNum := (8 + FFirstDayOfWeekNum) mod 7;
    { week days }
    for i := 0 to 6 do
      TvxLabel(FWeek.Children[i]).Text := ShortDayNames[1 + ((7 + i + FFirstDayOfWeekNum) mod 7)];
    { days }
    DecodeDate(FDateTime, AYear, AMonth, ADay);
    PreMonth := AMonth - 1;
    if PreMonth < 1 then
      PreMonth := 12;
    Date := EncodeDate(AYear, AMonth, 1);
    First := DayOfWeek(Date);
    if First - FFirstDayOfWeekNum < 3 then
      First := First + 7;
    if FDays.Count - (First + MonthDays[IsLeapYear(AYear), AMonth] - FFirstDayOfWeekNum) < 3 then
      First := First - 7;
    FDays.Tag := First; // store first
    Date := IncMonth(Date, 1);
    Last := DayOfWeek(Date);
    for i := 1 to First do
    begin
      Item := FDays.Items[i - 1];
      if Item = nil then
        Continue;
      Item.Opacity := 0.3;
      Item.Text := IntToStr(MonthDays[IsLeapYear(AYear), PreMonth] - First + i + 1 + FFirstDayOfWeekNum);
    end;
    for i := 1 to MonthDays[IsLeapYear(AYear), AMonth] do
    begin
      Item := FDays.Items[First + i - 2 - FFirstDayOfWeekNum];
      if Item = nil then
        Continue;
      Item.Opacity := 1;
      Item.Text := IntToStr(i);
    end;
    for i := First + MonthDays[IsLeapYear(AYear), AMonth] to FDays.Count + FFirstDayOfWeekNum do
    begin
      Item := FDays.Items[i - 1 - FFirstDayOfWeekNum];
      if Item = nil then
        Continue;
      Item.Opacity := 0.3;
      Item.Text := IntToStr(i - First - MonthDays[IsLeapYear(AYear), AMonth] + 1);
    end;
    { weeks number }
    if FWeekNumbers then
    begin
      FWeeks.Visible := true;
      DecodeDate(FDateTime, AYear, AMonth, ADay);
      Date := EncodeDate(AYear, AMonth, 1);
      for i := 0 to 5 do
        if WeekOfYear(Date) + i = 0 then
          TvxLabel(FWeeks.Children[i]).Text := IntToStr(52)
        else
          if WeekOfYear(Date) = 0 then
          TvxLabel(FWeeks.Children[i]).Text := IntToStr(i)
        else
          if WeekOfYear(Date) + i > 52 then
          TvxLabel(FWeeks.Children[i]).Text := IntToStr(WeekOfYear(Date) + i - 52)
        else
          TvxLabel(FWeeks.Children[i]).Text := IntToStr(WeekOfYear(Date) + i);
    end
    else
      FWeeks.Visible := false;
    { selection }
    FDays.ItemIndex := First + ADay - 2 - FFirstDayOfWeekNum;
    { month }
    FMonths.ItemIndex := AMonth - 1;
    { years }
    FYears.Items.Clear;
    for i := 10 downto 1 do
      FYears.Items.Add(IntToStr(AYear - i));
    FYears.Items.Add(IntToStr(AYear));
    for i := 1 to 10 do
      FYears.Items.Add(IntToStr(AYear + i));
    FYears.Text := IntToStr(AYear);
  finally
    FDisableDayChange := FDisableDayChange - 1;
  end;
end;

destructor TvxCalendar.Destroy;
begin
  inherited;
end;

function TvxCalendar.GetData: Variant;
begin
  Result := VarFromDateTime(FDateTime);
end;

procedure TvxCalendar.SetData(const Value: Variant);
var
  D: TDateTime;
begin
  if VarIsType(Value, varDate) then
    Date := VarToDateTime(Value)
  else
    if VarIsStr(Value) and TryStrToDateTime(AnsiString(Value), D) then
    Date := D;
end;

procedure TvxCalendar.DoDayChange(Sender: TObject);
var
  AYear, AMonth, ADay: Word;
begin
  DecodeDate(FDateTime, AYear, AMonth, ADay);
  if FDays.ItemIndex - FDays.Tag + 2 + FFirstDayOfWeekNum < 1 then
  begin
  end
  else
    if FDays.ItemIndex - FDays.Tag + 2 + FFirstDayOfWeekNum > MonthDays[IsLeapYear(AYear), AMonth] then
  begin
  end
  else
    DateTime := EncodeDate(AYear, AMonth, FDays.ItemIndex - FDays.Tag + 2 + FFirstDayOfWeekNum);
  if Assigned(FOnDayChange) and (FDisableDayChange = 0) then
    FOnDayChange(Self);
end;

procedure TvxCalendar.DoTodayClick(Sender: TObject);
begin
  Date := Now;
  if Assigned(FOnDayChange) and (FDisableDayChange = 0) then
    FOnDayChange(Self);
end;

procedure TvxCalendar.DoNextClick(Sender: TObject);
begin
  Date := IncMonth(Date, 1);
end;

procedure TvxCalendar.DoPrevClick(Sender: TObject);
begin
  Date := IncMonth(Date, -1);
end;

procedure TvxCalendar.DoMonthChange(Sender: TObject);
var
  AYear, AMonth, ADay: Word;
begin
  DecodeDate(FDateTime, AYear, AMonth, ADay);
  DateTime := EncodeDate(AYear, FMonths.ItemIndex + 1, ADay);
end;

procedure TvxCalendar.DoYearChange(Sender: TObject);
var
  AYear, AMonth, ADay: Word;
begin
  DecodeDate(FDateTime, AYear, AMonth, ADay);
  DateTime := EncodeDate(StrToInt(FYears.Text), AMonth, ADay);
end;

procedure TvxCalendar.Realign;
begin
  inherited;
  if FWeek <> nil then
    FWeek.ItemWidth := FWeek.Width / 7 - 0.1;
end;

function TvxCalendar.GetDate: TDate;
begin
  Result := TDate(FDateTime);
end;

procedure TvxCalendar.SetDate(Value: TDate);
begin
  FDisableDayChange := FDisableDayChange + 1;
  ReplaceTime(TDateTime(Value), FDateTime);
  try
    SetDateTime(Value);
  except
    SetDateTime(FDateTime);
    raise;
  end;
  FDisableDayChange := FDisableDayChange - 1;
end;

procedure TvxCalendar.SetDateTime(const Value: TDateTime);
begin
  if FDateTime <> Value then
  begin
    FDateTime := Value;
    FillList;
    if Assigned(FBindingObjects) then
      ToBindingObjects;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxCalendar.SetFirstDayOfWeek(const Value: TvxCalDayOfWeek);
begin
  if FFirstDayOfWeek <> Value then
  begin
    FFirstDayOfWeek := Value;
    FillList;
  end;
end;

procedure TvxCalendar.SetTodayDefault(const Value: Boolean);
begin
  FTodayDefault := Value;
  if FTodayDefault then
    Date := Now;
end;

procedure TvxCalendar.SetWeekNumbers(const Value: Boolean);
begin
  if FWeekNumbers <> Value then
  begin
    FWeekNumbers := Value;
    FillList;
  end;
end;

procedure TvxCalendar.MouseWheel(Shift: TShiftState; WheelDelta: integer;
  var Handled: boolean);
begin
  inherited;
  if not Handled then
  begin
    if WheelDelta > 0 then
      Date := IncMonth(Date, -1)
    else
      Date := IncMonth(Date, 1);
    Handled := true;
  end;
end;

{ TvxCalendarBox }

constructor TvxCalendarBox.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := true;
  Cursor := crDefault;
  TextAlign := vgTextAlignNear;
  FResource := 'combotextboxstyle';
  FPopup := TvxPopup.Create(Self);
  FPopup.FResource := 'combopopupstyle';
  FPopup.PlacementTarget := Self;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FPopup.OnClosePopup := DoClosePopup;
  FPopup.Width := 186;
  FPopup.Height := 166;
  FCalendar := TvxCalendar.Create(Self);
  FCalendar.Parent := FPopup;
  FCalendar.Stored := false;
  FCalendar.Padding.Rect := vgRect(3, 3, 3, 3);
  FCalendar.Align := vaClient;
  FCalendar.OnChange := DoCalendarChanged;
  FCalendar.OnDayChange := DoDayChanged;
  Text := DateTimeToStr(FCalendar.DateTime);
  Width := 100;
  Height := 22;
end;

destructor TvxCalendarBox.Destroy;
begin
  inherited;
end;

procedure TvxCalendarBox.DoCalendarChanged(Sender: TObject);
begin
  Text := DateTimeToStr(FCalendar.DateTime);
end;

procedure TvxCalendarBox.DoDayChanged(Sender: TObject);
begin
  if FPopup.IsOpen then
    DropDown;
end;

procedure TvxCalendarBox.DoClosePopup(Sender: TObject);
begin
end;

procedure TvxCalendarBox.DropDown;
begin
  if not FPopup.IsOpen then
  begin
    FPopup.Placement := FPlacement;
    FPopup.IsOpen := true;
  end
  else
  begin
    FPopup.IsOpen := false;
  end;
end;

function TvxCalendarBox.GetDate: TDate;
begin
  Result := FCalendar.Date;
end;

procedure TvxCalendarBox.SetDate(const Value: TDate);
begin
  FCalendar.Date := Value;
  Text := DateTimeToStr(FCalendar.DateTime);
end;

procedure TvxCalendarBox.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if (Button = mbLeft) then
  begin
    DropDown;
  end;
end;

procedure TvxCalendarBox.DoContentPaint(Sender: TObject;
  const Canvas: TvxCanvas; const ARect: TvxRect);
begin
  Canvas.Font.Assign(Font);
  Canvas.Fill.Assign(FontFill);
  Canvas.FillText(ARect, ARect, Text, false, AbsoluteOpacity, TextAlign, vgTextAlignCenter);
end;

procedure TvxCalendarBox.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('Content');
  if (T <> nil) and (T is TvxContent) then
  begin
    TvxContent(T).OnPaint := DoContentPaint;
  end;
end;

{ TvxCalendarTextBox }

constructor TvxCalendarTextBox.Create(AOwner: TComponent);
begin
  inherited;
  Cursor := crDefault;
  FFilterChar := '0123456789./';
  FResource := 'combotextboxstyle';
  FPopup := TvxPopup.Create(Self);
  FPopup.FResource := 'combopopupstyle';
  FPopup.PlacementTarget := Self;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FPopup.OnClosePopup := DoClosePopup;
  FPopup.Width := 186;
  FPopup.Height := 166;
  FCalendar := TvxCalendar.Create(Self);
  FCalendar.Parent := FPopup;
  FCalendar.Stored := false;
  FCalendar.Padding.Rect := vgRect(3, 3, 3, 3);
  FCalendar.Align := vaClient;
  FCalendar.OnChange := DoCalendarChanged;
  FCalendar.OnDayChange := DoDayChanged;
  Text := DateTimeToStr(FCalendar.DateTime);
end;

destructor TvxCalendarTextBox.Destroy;
begin
  inherited;
end;

procedure TvxCalendarTextBox.DoCalendarChanged(Sender: TObject);
begin
  if FPopup.IsOpen then
  begin
    Text := DateTimeToStr(FCalendar.DateTime);
    CaretPosition := Length(Text);
    Change;
    FNeedChange := false;
    DropDown;
  end;
end;

procedure TvxCalendarTextBox.DoDayChanged(Sender: TObject);
begin
end;

procedure TvxCalendarTextBox.DoClosePopup(Sender: TObject);
begin
  if ShowCaret and IsFocused then
    ShowCaretProc;
end;

procedure TvxCalendarTextBox.DropDown;
begin
  if not FPopup.IsOpen then
  begin
    if ShowCaret then
      HideCaret;
    FPopup.Placement := FPlacement;
    FPopup.IsOpen := true;
  end
  else
  begin
    FPopup.IsOpen := false;
  end;
end;

function TvxCalendarTextBox.GetDate: TDate;
begin
  Result := FCalendar.Date;
end;

procedure TvxCalendarTextBox.SetDate(const Value: TDate);
begin
  FCalendar.Date := Value;
  Text := DateTimeToStr(FCalendar.DateTime);
end;

procedure TvxCalendarTextBox.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if (Button = mbLeft) and not vgPtInRect(vgPoint(X, Y), ContentRect) then
  begin
    DropDown;
  end;
end;

{ TvxCompoundTrackBar =========================================================}

constructor TvxCompoundTrackBar.Create(AOwner: TComponent);
var
  C: TvxControl;
begin
  inherited;
  FDecimalDigits := 2;

  Width := 200;
  Height := 20;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    Padding.right := 5;
    WordWrap := false;
    TextAlign := vgTextAlignFar;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
  end;
  FTrackBar := TvxTrackbar.Create(Self);
  with FTrackBar do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'TrackBar';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoTrack;
    OnTracking := DoTracking;
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaRight;
  end;
  FValueLabel := TvxValueLabel.Create(Self);
  with FValueLabel do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'ValueLabel';
    Text := '0';
    Padding.left := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
end;

procedure TvxCompoundTrackBar.UpdateLabel;
begin
  if (FTrackBar.Frequency <> 0) and (frac(FTrackBar.Frequency) = 0) then
    FValueLabel.Text := IntToStr(Trunc(Value)) + Suffix
  else
    FValueLabel.Text := Format('%.' + IntToStr(FDecimalDigits) + 'f', [Self.Value]) + Suffix;
end;

procedure TvxCompoundTrackBar.DoTrack(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

procedure TvxCompoundTrackBar.DoTracking(Sender: TObject);
begin
  UpdateLabel;
end;

function TvxCompoundTrackBar.GetValue: single;
begin
  Result := FTrackBar.Value;
end;

procedure TvxCompoundTrackBar.SetDecimalDigits(const Value: integer);
begin
  if FDecimalDigits <> Value then
  begin
    FDecimalDigits := Value;
    UpdateLabel;
  end;
end;

procedure TvxCompoundTrackBar.SetValue(const Value: single);
begin
  FTrackBar.Value := Value;
  UpdateLabel;
end;

procedure TvxCompoundTrackBar.SetSuffix(const Value: WideString);
begin
  if FSuffix <> Value then
  begin
    FSuffix := Value;
    UpdateLabel;
  end;
end;

{ TvxCompoundAngleBar }

constructor TvxCompoundAngleBar.Create(AOwner: TComponent);
var
  C: TvxControl;
begin
  inherited;
  FDecimalDigits := 2;

  Width := 200;
  Height := 20;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    WordWrap := false;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    TextAlign := vgTextAlignFar;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Width := 40;
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
  end;
  FAngleBar := TvxAngleButton.Create(Self);
  with FAngleBar do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaFit;
    Name := 'AngleBar';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaRight;
  end;
  FValueLabel := TvxValueLabel.Create(Self);
  with FValueLabel do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'ValueLabel';
    Text := '0';
    Padding.left := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
end;

procedure TvxCompoundAngleBar.UpdateLabel;
begin
  FValueLabel.Text := IntToStr(Trunc(Value)) + '';
end;

procedure TvxCompoundAngleBar.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
  UpdateLabel;
end;

function TvxCompoundAngleBar.GetValue: single;
begin
  Result := FAngleBar.Value;
end;

procedure TvxCompoundAngleBar.SetValue(const Value: single);
begin
  FAngleBar.Value := Value;
  UpdateLabel;
end;

{ TvxCompoundTextBox }

constructor TvxCompoundTextBox.Create(AOwner: TComponent);
var
  C: TvxControl;
begin
  inherited;
  Width := 200;
  Height := 21;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    TextAlign := vgTextAlignFar;
    WordWrap := false;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
  end;
  FTextBox := TvxTextBox.Create(Self);
  with FTextBox do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'TextBox';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
end;

procedure TvxCompoundTextBox.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

function TvxCompoundTextBox.GetText: WideString;
begin
  Result := FTextBox.Text;
end;

procedure TvxCompoundTextBox.SetText(const Value: WideString);
begin
  FTextBox.Text := Value;
end;

{ TvxCompoundMemo }

constructor TvxCompoundMemo.Create(AOwner: TComponent);
begin
  inherited;
  Width := 200;
  Height := 60;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    TextAlign := vgTextAlignFar;
    WordWrap := false;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  FMemo := TvxMemo.Create(Self);
  with FMemo do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
    Name := 'Memo';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
end;

procedure TvxCompoundMemo.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

function TvxCompoundMemo.GetText: WideString;
begin
  Result := FMemo.Text;
end;

procedure TvxCompoundMemo.SetText(const Value: WideString);
begin
  FMemo.Text := Value;
end;

{ TvxCompoundNumberBox }

constructor TvxCompoundNumberBox.Create(AOwner: TComponent);
var
  C: TvxControl;
begin
  inherited;
  Width := 200;
  Height := 21;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    WordWrap := false;
    Width := 70;
    TextAlign := vgTextAlignFar;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
  end;
  FNumberBox := TvxNumberBox.Create(Self);
  with FNumberBox do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'NumberBox';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
end;

procedure TvxCompoundNumberBox.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

function TvxCompoundNumberBox.GetValue: single;
begin
  Result := FNumberBox.Value;
end;

procedure TvxCompoundNumberBox.SetValue(const Value: single);
begin
  FNumberBox.Value := Value;
end;

{ TvxCompoundPopupBox }

constructor TvxCompoundPopupBox.Create(AOwner: TComponent);
var
  C: TvxControl;
begin
  inherited;
  Width := 200;
  Height := 21;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    TextAlign := vgTextAlignFar;
    WordWrap := false;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
  end;
  FPopupBox := TvxPopupBox.Create(Self);
  with FPopupBox do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'PopupBox';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
end;

procedure TvxCompoundPopupBox.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

function TvxCompoundPopupBox.GetItemIndex: integer;
begin
  Result := FPopupBox.ItemIndex;
end;

procedure TvxCompoundPopupBox.SetItemIndex(const Value: integer);
begin
  FPopupBox.ItemIndex := Value;
end;

{ TvxCompoundColorButton }

constructor TvxCompoundColorButton.Create(AOwner: TComponent);
var
  C: TvxControl;
begin
  inherited;
  Width := 200;
  Height := 21;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    TextAlign := vgTextAlignFar;
    WordWrap := false;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  C := TvxControl.Create(Self);
  with C do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Width := 60;
  end;
  FColorButton := TvxColorButton.Create(Self);
  with FColorButton do
  begin
    Parent := C;
    Stored := false;
    Locked := true;
    Align := vaVertCenter;
    Name := 'ColorButton';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
end;

procedure TvxCompoundColorButton.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

function TvxCompoundColorButton.GetValue: string;
begin
  Result := FColorButton.Color;
end;

procedure TvxCompoundColorButton.SetValue(const Value: string);
begin
  FColorButton.Color := Value;
end;

{ TvxCompoundImage }

constructor TvxCompoundImage.Create(AOwner: TComponent);
begin
  inherited;
  Width := 200;
  Height := 60;
  FTextLabel := TvxLabel.Create(Self);
  with FTextLabel do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaLeft;
    Name := 'TextLabel';
    Text := 'Caption';
    Width := 70;
    TextAlign := vgTextAlignFar;
    WordWrap := false;
    Padding.right := 5;
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
  end;
  FImage := TvxImageControl.Create(Self);
  with FImage do
  begin
    Parent := Self;
    Stored := false;
    Locked := true;
    Align := vaClient;
    Name := 'Image';
    {$IFDEF ks_compiler7_up}
    SetSubComponent(True);
    {$ENDIF}
    {$IFDEF FPC}
    SetSubComponent(True);
    {$ENDIF}
    OnChange := DoChange;
  end;
end;

procedure TvxCompoundImage.DoChange(Sender: TObject);
begin
  if Assigned(FOnChange) then
    FOnChange(Sender);
end;

type

  TvxHackVisualObject = class(TvxVisualObject);

  { TvxHeaderItem }

constructor TvxHeaderItem.Create(AOwner: TComponent);
begin
  inherited;
  CanFocused := false;
  TextAlign := vgTextAlignNear;
  DragMode := vgDragAutomatic;
  FSplitter := TvxVisualObject.Create(Self);
  FSplitter.Parent := Self;
  FSplitter.Width := 3;
  FSplitter.Align := vaRight;
  FSplitter.Locked := true;
  FSplitter.Stored := false;
  FSplitter.HitTest := true;
  FSplitter.AutoCapture := true;
  FSplitter.Cursor := crHSplit;
  FSplitter.OnMouseMove := DoSplitterMouseMove;
  FLeftSplitter := TvxVisualObject.Create(Self);
  FLeftSplitter.Parent := Self;
  FLeftSplitter.Width := 3;
  FLeftSplitter.Align := vaLeft;
  FLeftSplitter.Locked := true;
  FLeftSplitter.Stored := false;
  FLeftSplitter.HitTest := true;
  FLeftSplitter.AutoCapture := true;
  FLeftSplitter.Cursor := crHSplit;
  FLeftSplitter.OnMouseMove := DoLeftSplitterMouseMove;
end;

procedure TvxHeaderItem.DoSplitterMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y, Dx, Dy: single);
var
  NewSize: single;
begin
  if TvxHackVisualObject(FSplitter).FPressed then
  begin
    NewSize := AbsoluteToLocal(FSplitter.LocalToAbsolute(vgPoint(X, Y))).X;
    if NewSize < 0 then
      NewSize := 0;

    if (Parent <> nil) and (Parent is TvxHeader) then
    begin
      if Assigned(TvxHeader(Parent).OnResizeItem) then
        TvxHeader(Parent).OnResizeItem(Self, NewSize);
    end;
    Width := NewSize;
    if (Parent <> nil) and (Parent is TvxHeader) then
      TvxHeader(Parent).Realign;
  end;
end;

procedure TvxHeaderItem.DoLeftSplitterMouseMove(Sender: TObject;
  Shift: TShiftState; X, Y, Dx, Dy: single);
var
  P: TvxPoint;
  LeftItem: TvxHeaderItem;
begin
  if (Index > 0) and TvxHackVisualObject(FLeftSplitter).FPressed then
  begin
    if (Parent <> nil) and (Parent is TvxHeader) then
      LeftItem := TvxHeaderItem(TvxHeader(Parent).Children[Index - 1]);
    if LeftItem = nil then
      Exit;

    P := FLeftSplitter.LocalToAbsolute(vgPoint(X, Y));

    P := LeftItem.FSplitter.AbsoluteToLocal(P);
    TvxHackVisualObject(LeftItem.FSplitter).FPressed := true;
    LeftItem.DoSplitterMouseMove(Sender, Shift, P.X, P.Y, 0, 0);
    TvxHackVisualObject(LeftItem.FSplitter).FPressed := false;
  end;
end;

procedure TvxHeaderItem.DragDrop(const Data: TvxDragObject;
  const Point: TvxPoint);
var
  NewIndex, OldIndex: integer;
begin
  inherited;
  NewIndex := Index;
  OldIndex := TvxObject(Data.Source).Index;
  TvxObject(Data.Source).Index := Index;
  if (Header <> nil) and Assigned(Header.OnRealignItem) then
    Header.OnRealignItem(TvxObject(Data.Source), OldIndex, NewIndex);
end;

procedure TvxHeaderItem.DragEnd;
begin
  inherited;
end;

procedure TvxHeaderItem.DragOver(const Data: TvxDragObject;
  const Point: TvxPoint; var Accept: Boolean);
begin
  Accept := (Data.Source is TvxHeaderItem) and (TvxHeaderItem(Data.Source).Header = Header) and (DragMode <> vgDragManual);
end;

function TvxHeaderItem.Header: TvxHeader;
begin
  if (Parent <> nil) and (Parent is TvxHeader) then
    Result := TvxHeader(Parent)
  else
    Result := nil;
end;

{ TvxHeader }

constructor TvxHeader.Create(AOwner: TComponent);
begin
  inherited;
  ClipChildren := true;
  FSides := AllSides;
  FLastItem := TvxHeaderItem.Create(Self);
  FLastItem.Parent := Self;
  FLastItem.Stored := false;
  FLastItem.Locked := true;
  FLastItem.Width := 50;
  FLastItem.DragMode := vgDragManual;
end;

function TvxHeader.GetItem(Index: integer): TvxHeaderItem;
begin
  Result := TvxHeaderItem(Children[Index]);
end;

function TvxHeader.ItemClass: string;
begin
  Result := 'TvxHeaderItem';
end;

procedure TvxHeader.Paint;
var
  R: TvxRect;
begin
  inherited Paint;
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
end;

procedure TvxHeader.Realign;
var
  i: integer;
  R: TvxRect;

  procedure DoPosition(Control: TvxVisualObject);
  begin
    if not Control.Visible then
      Exit;
    with R do
    begin
      Control.SetBounds(Left, Top, Control.Width, Height);
      if Control <> FLastItem then
        Left := Left + Control.Width;
    end;
  end;

  procedure DoAlign;
  var
    I, J: Integer;
    Control: TvxVisualObject;
  begin
    for I := 0 to ChildrenCount - 1 do
    begin
      if not (TvxVisualObject(Children[I]) is TvxHeaderItem) then
        Continue;
      DoPosition(TvxVisualObject(Children[I]));
      // sides
      TvxHeaderItem(Children[I]).Sides := FSides;
      // corners
      TvxHeaderItem(Children[I]).xRadius := Radius;
      TvxHeaderItem(Children[I]).yRadius := Radius;
      if I = 0 then
      begin
        TvxHeaderItem(Children[I]).Corners := [vgCornerTopLeft];
        TvxHeaderItem(Children[I]).Sides := TvxHeaderItem(Children[I]).Sides + (FSides * [vgSideLeft]) - [vgSideRight];
      end
      else
        if Children[I] = FLastItem then
      begin
        TvxHeaderItem(Children[I]).Corners := [vgCornerTopRight];
        TvxHeaderItem(Children[I]).Sides := TvxHeaderItem(Children[I]).Sides + [vgSideLeft];
      end
      else
      begin
        TvxHeaderItem(Children[I]).Corners := [];
        TvxHeaderItem(Children[I]).Sides := TvxHeaderItem(Children[I]).Sides + [vgSideLeft] - [vgSideRight];
      end;
    end;
  end;

begin
  inherited;
  if csDestroying in ComponentState then
    Exit;
  if FDisableAlign then
    Exit;
  if ChildrenCount = 0 then
    Exit;
  FDisableAlign := true;
  try
    FChildren.Remove(FLastItem);
    FChildren.Add(FLastItem);

    R := vgRect(FOffset, 0, FWidth, FHeight);
    R := Margins.MarginRect(R);
    DoAlign;

    if R.Left > R.Right then
      FLastItem.Width := 0
    else
      FLastItem.Width := R.Right - R.Left;
  finally
    FDisableAlign := false;
  end;
end;

procedure TvxHeader.SetRadius(const Value: single);
begin
  if FRadius <> Value then
  begin
    FRadius := Value;
    Realign;
  end;
end;

procedure TvxHeader.SetSides(const Value: TvxSides);
begin
  if FSides <> Value then
  begin
    FSides := Value;
    Realign;
  end;
end;

{ Cells =======================================================================}

{ TvxTextCell }

{ TvxCheckCell }

{ TvxProgressCell }

{ Columns =====================================================================}

{ TvxColumn }

constructor TvxColumn.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  Width := 100;
  HitTest := false;
  CanFocused := false;
end;

function TvxColumn.CreateCellControl: TvxControl;
begin
  Result := TvxTextCell.Create(Self);
  TvxTextCell(Result).OnChange := DoTextChanged;
end;

procedure TvxColumn.DoTextChanged(Sender: TObject);
begin
  if Grid = nil then
    Exit;
  if FUpdateColumn then
    Exit;
  if FDisableChange then
    Exit;
  with vgStringToPoint(TvxObject(Sender).TagString) do
  begin
    Grid.SetValue(trunc(x), trunc(y), TvxControl(Sender).Data);
    if Assigned(Grid.FOnEdititingDone) then
      Grid.FOnEdititingDone(Grid, trunc(x), trunc(y));
  end;
end;

procedure TvxColumn.DoCanFocused(Sender: TObject; var ACanFocused: boolean);
begin
  if Grid = nil then
    Exit;
  ACanFocused := Grid.CanEditModify;
  if ACanFocused and ReadOnly then
    ACanFocused := false;
end;

procedure TvxColumn.DoEnterFocus(Sender: TObject);
begin
  if Grid = nil then
    Exit;
  Grid.ColumnIndex := Index;
  FSaveData := TvxObject(Sender).Data;
end;

procedure TvxColumn.DoKeyDown(Sender: TObject; var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  if (KeyChar <> #0) and (Grid <> nil) and not Grid.CanEditAcceptKey(KeyChar) then
    KeyChar := #0;
  if (Key = VK_RETURN) and (Grid <> nil) then
    Grid.SetFocus;
  if (Key = VK_ESCAPE) and (Grid <> nil) then
  begin
    FDisableChange := true;
    try
      TvxObject(Sender).Data := FSaveData;
    finally
      FDisableChange := false;
    end;
    Grid.Reset;
  end;
  if (Key = VK_UP) or (Key = VK_DOWN) and (Grid <> nil) then
  begin
    Grid.SetFocus;
    Grid.KeyDown(Key, Keychar, Shift);
  end;
end;

function TvxColumn.Grid: TvxCustomGrid;
var
  P: TvxObject;
begin
  P := Parent;
  while (P <> nil) do
  begin
    if P is TvxCustomGrid then
    begin
      Result := TvxCustomGrid(P);
      Exit;
    end;
    P := P.Parent;
  end;
  Result := nil;
end;

procedure TvxColumn.ClearColumn;
var
  i: integer;
begin
  for i := 0 to High(FCellControls) do
    FCellControls[i].Free;
  SetLength(FCellControls, 0);
end;

function TvxColumn.CellControlByPoint(X, Y: single): TvxControl;
var
  i: integer;
  P: TvxPoint;
begin
  Result := nil;
  if Grid = nil then
    Exit;

  P := Grid.LocalToAbsolute(vgPoint(X, Y));
  for i := 0 to High(FCellControls) do
    if FCellControls[i].Visible and (FCellControls[i].pointInObject(P.X, P.Y)) then
    begin
      Result := FCellControls[i];
      Exit;
    end;
end;

function TvxColumn.CellControlByRow(Row: integer): TvxControl;
var
  i: integer;
begin
  Result := nil;
  if Grid = nil then
    Exit;

  for i := 0 to High(FCellControls) do
    if (FCellControls[i].Visible) and (trunc(vgStringToPoint(FCellControls[i].TagString).Y) = Row) then
    begin
      Result := FCellControls[i];
      Exit;
    end;
end;

procedure TvxColumn.UpdateColumn;
var
  i, C: integer;
  V: Variant;
begin
  if Grid = nil then
    Exit;
  FUpdateColumn := true;
  try
    { Create controls }
    if Length(FCellControls) < Min(Grid.RowCount, Grid.VisibleRows) then
    begin
      C := High(FCellControls);
      SetLength(FCellControls, Min(Grid.RowCount, Grid.VisibleRows));
      for i := C + 1 to Min(Grid.RowCount, Grid.VisibleRows) - 1 do
      begin
        FCellControls[i] := CreateCellControl;
        FCellControls[i].Parent := Self;
        FCellControls[i].HitTest := false;
        FCellControls[i].Visible := false;
        FCellControls[i].Locked := true;
        FCellControls[i].Stored := false;
        FCellControls[i].OnCanFocused := DoCanFocused;
        FCellControls[i].OnEnterFocus := DoEnterFocus;
        FCellControls[i].OnKeyDown := DoKeyDown;
      end;
    end;
    { Hide if need }
    if Length(FCellControls) > Min(Grid.RowCount, Grid.VisibleRows) then
    begin
      for i := Min(Grid.RowCount, Grid.VisibleRows) to High(FCellControls) do
        FCellControls[i].Visible := false;
    end;
    { Update Data }
    for i := 0 to Min(Grid.RowCount, Grid.VisibleRows) - 1 do
    begin
      if Grid.TopRow + i >= Grid.RowCount then
        Break;

      V := Grid.GetValue(Index, Grid.TopRow + i);

      FCellControls[i].Visible := true;
      FCellControls[i].SetBounds(0, i * Grid.RowHeight, Width, Grid.RowHeight);
      FCellControls[i].TagString := vgPointToString(vgPoint(Index, Grid.TopRow + i));
      FCellControls[i].Data := V;
    end;
    UpdateSelected;
  finally
    FUpdateColumn := false;
  end;
end;

procedure TvxColumn.UpdateSelected;
var
  i: integer;
begin
  if Grid = nil then
    Exit;
  if Grid.ReadOnly then
    Exit;
  if ReadOnly then
    Exit;
  for i := 0 to Min(Grid.RowCount, Grid.VisibleRows) - 1 do
  begin
    if Grid.IsSelected(Grid.TopRow + i) and (Grid.ColumnIndex = Index) then
    begin
      FCellControls[i].CanFocused := true;
      FCellControls[i].HitTest := true
    end
    else
    begin
      FCellControls[i].CanFocused := false;
      FCellControls[i].HitTest := false;
      if FCellControls[i].IsFocused then
        Grid.SetFocus;
    end;
  end;
end;

procedure TvxColumn.SetHeader(const Value: WideString);
begin
  if FHeader <> Value then
  begin
    FHeader := Value;
    if (Grid <> nil) and (Grid.FHeader <> nil) then
      Grid.FHeader.Items[Index].Text := FHeader;
  end;
end;

{ TvxCheckColumn }

constructor TvxCheckColumn.Create(AOwner: TComponent);
begin
  inherited;
end;

function TvxCheckColumn.CreateCellControl: TvxControl;
begin
  Result := TvxCheckCell.Create(Self);
  TvxCheckCell(Result).OnChange := DoCheckChanged;
end;

procedure TvxCheckColumn.DoCheckChanged(Sender: TObject);
begin
  if Grid = nil then
    Exit;
  if FUpdateColumn then
    Exit;
  with vgStringToPoint(TvxObject(Sender).TagString) do
  begin
    Grid.SetValue(trunc(x), trunc(y), TvxControl(Sender).Data);
    if Assigned(Grid.FOnEdititingDone) then
      Grid.FOnEdititingDone(Grid, trunc(x), trunc(y));
  end;
end;

{ TvxProgressColumn }

constructor TvxProgressColumn.Create(AOwner: TComponent);
begin
  inherited;
  FMax := 100;
end;

function TvxProgressColumn.CreateCellControl: TvxControl;
begin
  Result := TvxProgressCell.Create(Self);
  TvxProgressCell(Result).Min := FMin;
  TvxProgressCell(Result).Max := FMax;
end;

{ TvxPopupColumn }

constructor TvxPopupColumn.Create(AOwner: TComponent);
begin
  inherited;
  FItems := TvxWideStringList.Create;
end;

destructor TvxPopupColumn.Destroy;
begin
  FItems.Free;
  inherited;
end;

function TvxPopupColumn.CreateCellControl: TvxControl;
begin
  Result := TvxPopupCell.Create(Self);
  TvxPopupCell(Result).Items.Assign(FItems);
end;

procedure TvxPopupColumn.SetItems(const Value: TvxWideStrings);
begin
  FItems.Assign(Value);
end;

{ TvxImageColumn }

constructor TvxImageColumn.Create(AOwner: TComponent);
begin
  inherited;
end;

function TvxImageColumn.CreateCellControl: TvxControl;
begin
  Result := TvxImageCell.Create(Self);
  TvxImageCell(Result).EnableOpenDialog := false;
end;

{ Grids ======================================================================}

{ TvxCustomGrid ==============================================================}

constructor TvxCustomGrid.Create(AOwner: TComponent);
begin
  inherited;
  FOddFill := TvxBrush.Create(vgBrushSolid, $20000000);
  FLineFill := TvxBrush.Create(vgBrushSolid, $FF202020);
  FShowSelectedCell := true;
  FShowVertLines := true;
  FShowHorzLines := true;
  FShowHeader := true;
  FRowHeight := 21;
  FRowCount := 100;
  CanFocused := true;
  AutoCapture := true;
  Width := 100;
  Height := 100;
  FItemHeight := 0;
end;

destructor TvxCustomGrid.Destroy;
begin
  if FSelections <> nil then
    FSelections.Free;
  FLineFill.Free;
  FOddFill.Free;
  inherited;
end;

function TvxCustomGrid.ItemClass: string;
begin
  Result := 'TvxColumn;TvxCheckColumn;TvxProgressColumn;TvxPopupColumn;TvxImageColumn';
end;

procedure TvxCustomGrid.FreeStyle;
begin
  inherited;
  FSelection := nil;
  FFocus := nil;
  FHeader := nil;
end;

procedure TvxCustomGrid.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('content');
  if (T <> nil) and (T.IsVisual) then
  begin
    TvxVisualObject(T).OnBeforePaint := DoContentPaint;
    TvxVisualObject(T).OnPaint := DoContentPaint2;
  end;
  T := FindResource('header');
  if (T <> nil) and (T is TvxHeader) then
  begin
    FHeader := TvxHeader(T);
    FHeader.OnRealignItem := DoRealignItem;
    FHeader.OnResizeItem := DoResizeItem;
    FHeader.Visible := FShowHeader;
  end;
  T := FindResource('selection');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    FSelection := TvxVisualObject(T);
    FSelection.Visible := false;
  end;
  T := FindResource('focus');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    FFocus := TvxVisualObject(T);
    FFocus.Visible := false;
  end;
  T := FindResource('AlternatingRowBackground');
  if (T <> nil) and (T is TvxBrushObject) then
  begin
    FOddFill.Assign(TvxBrushObject(T).Brush);
  end;
  T := FindResource('LineFill');
  if (T <> nil) and (T is TvxBrushObject) then
  begin
    FLineFill.Assign(TvxBrushObject(T).Brush);
  end;
  UpdateColumns;
  UpdateHeader;
  UpdateSelection;
end;

procedure TvxCustomGrid.UpdateSelection;
var
  i: integer;
  P: TvxPoint;
  R: TvxRect;
  Sel: boolean;
  SelRects: array of TvxRect;
  Clone: TvxVisualObject;
  Vis: boolean;
begin
  if FSelection = nil then
    Exit;
  if ColumnCount = 0 then
    Exit;
  if RowCount = 0 then
  begin
    if FSelections <> nil then
      for i := 0 to FSelections.Count - 1 do
        TvxVisualObject(FSelections[i]).Visible := false;
    if FFocus <> nil then
      FFocus.Visible := false;
    Exit;
  end;
  // calc rects
  Vis := true;
  Sel := false;
  SetLength(SelRects, 0);
  for i := 0 to RowCount - 1 do
  begin
    if IsSelected(i) then
    begin
      P := vgPoint(0, i * FRowHeight);
      P := FContent.LocalToAbsolute(P);
      if (FSelection.Parent <> nil) and FSelection.Parent.IsVisual then
        P := FSelection.Parent.Visual.AbsoluteToLocal(P);
      if FContent.Width < ClientWidth then
        R := vgRect(P.X, P.Y, P.X + ClientWidth, P.Y + FRowHeight)
      else
        R := vgRect(P.X, P.Y, P.X + FContent.Width, P.Y + FRowHeight);
      if (Length(SelRects) > 0) and (i > 0) and (IsSelected(i - 1)) then
        SelRects[High(SelRects)] := vgUnionRect(R, SelRects[High(SelRects)])
      else
      begin
        SetLength(SelRects, Length(SelRects) + 1);
        SelRects[High(SelRects)] := R;
      end;
      Sel := true;
    end;
  end;
  // Create selection list
  if FSelections = nil then
    FSelections := TList.Create;
  // create selections
  if FSelections.Count < Length(SelRects) then
    for i := FSelections.Count to Length(SelRects) - 1 do
    begin
      Clone := TvxVisualObject(FSelection.Clone(Self));
      Clone.ResourceName := '';
      FSelections.Add(Clone);
      Clone.Parent := FSelection.Parent;
      Clone.Stored := false;
    end;
  // hide if not need
  if Length(SelRects) < FSelections.Count then
    for i := Length(SelRects) to FSelections.Count - 1 do
    begin
      TvxVisualObject(FSelections[i]).Visible := false;
    end;
  // align selections
  for i := 0 to High(SelRects) do
  begin
    TvxVisualObject(FSelections[i]).Visible := Vis;
    if Vis then
    begin
      with SelRects[i] do
        TvxVisualObject(FSelections[i]).SetBounds(Left, Top, Right - Left, Bottom - Top);
      if (FFocus <> nil) and (FShowSelectedCell) then
      begin
        FFocus.Visible := true;
        FFocus.BringToFront;
        P := vgPoint(Columns[ColumnIndex].Position.X, 0);
        P := FContent.LocalToAbsolute(P);
        if (FSelection.Parent <> nil) and FSelection.Parent.IsVisual then
          P := FSelection.Parent.Visual.AbsoluteToLocal(P);
        with SelRects[i] do
          FFocus.SetBounds(P.X + FFocus.Padding.Left, SelRects[i].Top + FFocus.Padding.Top,
            Columns[FColumnIndex].Width - (FFocus.Padding.Left + FFocus.Padding.Right),
            SelRects[i].Bottom - SelRects[i].Top - (FFocus.Padding.Top + FFocus.Padding.Bottom));
      end;
    end;
  end;
  //
  for i := 0 to ColumnCount - 1 do
    Columns[i].UpdateSelected;
end;

procedure TvxCustomGrid.DoRealignItem(Sender: TObject; OldIndex, NewIndex: integer);
begin
  if ColumnIndex = Columns[OldIndex].Index then
    ColumnIndex := NewIndex;
  Columns[OldIndex].Index := NewIndex;
end;

procedure TvxCustomGrid.DoResizeItem(Sender: TObject;
  var NewSize: single);
begin
  if NewSize < 10 then
    NewSize := 10;
  Columns[TvxHeaderItem(Sender).Index].Width := NewSize;
end;

procedure TvxCustomGrid.UpdateHeader;
var
  i: integer;
  Item: TvxHeaderItem;
begin
  if FHeader = nil then
    Exit;

  FHeader.FOffset := -HScrollBar.Value;
  FHeader.FChildren.Remove(FHeader.FLastItem);
  if FHeader.ChildrenCount < ColumnCount then
    for i := FHeader.ChildrenCount to ColumnCount - 1 do
    begin
      Item := TvxHeaderItem.Create(Self);
      Item.Parent := FHeader;
      Item.Locked := true;
      Item.Stored := false;
    end;
  FHeader.FChildren.Add(FHeader.FLastItem);

  for i := 0 to ColumnCount - 1 do
  begin
    TvxHeaderItem(FHeader.Children[i]).Text := Columns[i].Header;
    TvxHeaderItem(FHeader.Children[i]).Width := Columns[i].Width;
  end;
  if FHeader <> nil then
    FHeader.Realign;
end;

procedure TvxCustomGrid.UpdateColumns;
var
  i: integer;
begin
  for i := 0 to ColumnCount - 1 do
  begin
    Columns[i].Position.Y := (TopRow * FRowHeight);
    Columns[i].UpdateColumn;
  end;
end;

procedure TvxCustomGrid.DoContentPaint(Sender: TObject;
  const Canvas: TvxCanvas; const ARect: TvxRect);
var
  i: integer;
  P: TvxPoint;
begin
  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    if FAlternatingRowBackground then
    begin
      Canvas.Fill.Assign(FOddFill);
      for i := 0 to Min(RowCount, VisibleRows) - 1 do
      begin
        if Odd(TopRow + i) then
        begin
          P := FContent.LocalToAbsolute(vgPoint(0, (TopRow + i) * FRowHeight));
          P := TvxVisualObject(Sender).AbsoluteToLocal(P);
          Canvas.FillRect(vgRect(P.X, P.Y, P.X + FContent.Width, P.Y + FRowHeight), 0, 0, [], AbsoluteOpacity);
        end;
      end;
    end;
  end;
end;

procedure TvxCustomGrid.DoContentPaint2(Sender: TObject;
  const Canvas: TvxCanvas; const ARect: TvxRect);
var
  i: integer;
  P: TvxPoint;
  State: integer;
begin
  if (FContent <> nil) and (ContentLayout <> nil) and (FShowVertLines or FShowHorzLines) then
  begin
    State := Canvas.SaveCanvas;
    Canvas.IntersectClipRect(ARect);

    Canvas.Stroke.Assign(FLineFill);
    if FShowHorzLines then
      for i := 0 to Min(RowCount, VisibleRows) do
      begin
        P := FContent.LocalToAbsolute(vgPoint(0, (TopRow + i) * FRowHeight));
        P := TvxVisualObject(Sender).AbsoluteToLocal(P);
        Canvas.DrawLine(vgPoint(P.X, P.Y - 0.5), vgPoint(P.X + FContent.Width, P.Y - 0.5), AbsoluteOpacity);
      end;
    if FShowVertLines then
      for i := 0 to ColumnCount - 1 do
      begin
        P := Columns[i].LocalToAbsolute(vgPoint(Columns[i].Width, 0));
        P := TvxVisualObject(Sender).AbsoluteToLocal(P);
        Canvas.DrawLine(vgPoint(P.X + 0.5, P.Y), vgPoint(P.X + 0.5, P.Y + (Min(RowCount, VisibleRows) * FRowHeight)), AbsoluteOpacity);
      end;

    Canvas.RestoreCanvas(State);
  end;
end;

function TvxCustomGrid.GetContentBounds: TvxRect;
var
  Col, R: TvxRect;
  i, Idx: integer;
begin
  Result := LocalRect;
  if FUpdating > 0 then
    Exit;
  if ContentLayout = nil then
    Exit;
  R := ContentLayout.LocalRect;
  if ColumnCount > 0 then
  begin
    R.Right := R.Left;
    R.Top := R.Top;
    for i := 0 to ColumnCount - 1 do
    begin
      Col := vgRect(R.Right, R.Top, R.Right + Columns[i].Width, R.Bottom);
      R.Right := R.Right + Columns[i].Width;
      Columns[i].SetBounds(Col.Left, (TopRow * FRowHeight), Columns[i].Width, ClientHeight);
      Columns[i].UpdateColumn;
    end;
    R.Bottom := R.Top + (FRowCount * FRowHeight);
  end;
  if vgRectWidth(R) < ContentLayout.Width then
    R.Right := R.Left + ContentLayout.Width;
  if vgRectHeight(R) < ContentLayout.Height then
    R.Bottom := R.Top + ContentLayout.Height;
  Result := R;
  UpdateColumns;
  UpdateHeader;
  UpdateSelection;
end;

procedure TvxCustomGrid.HScrollChange(Sender: TObject);
begin
  inherited;
  UpdateSelection;
  UpdateHeader;
end;

procedure TvxCustomGrid.VScrollChange(Sender: TObject);
begin
  inherited;
  UpdateColumns;
  UpdateSelection;
end;

function TvxCustomGrid.GetColumnCount: integer;
var
  i: integer;
begin
  Result := 0;
  if (FContent <> nil) and (FContent.ChildrenCount > 0) then
    for i := 0 to FContent.ChildrenCount - 1 do
      if FContent.Children[i] is TvxColumn then
      begin
        Inc(Result);
      end;
end;

function TvxCustomGrid.RowByPoint(const X, Y: single): integer;
var
  i: integer;
  P, P1: TvxPoint;
begin
  P := LocalToAbsolute(vgPoint(X, Y));
  if FContent <> nil then
  begin
    P := FContent.AbsoluteToLocal(P);
    Result := trunc(P.Y / FRowHeight);
    Exit;
  end;
  Result := -1;
end;

function TvxCustomGrid.ColumnByIndex(const Idx: integer): TvxColumn;
var
  c, i: integer;
begin
  c := 0;
  if (FContent <> nil) and (FContent.ChildrenCount > 0) then
    for i := 0 to FContent.ChildrenCount - 1 do
      if FContent.Children[i] is TvxColumn then
      begin
        if c = Idx then
        begin
          Result := TvxColumn(FContent.Children[i]);
          Exit;
        end;
        Inc(c);
      end;
  Result := nil;
end;

function TvxCustomGrid.ColumnByPoint(const X, Y: single): TvxColumn;
var
  i: integer;
  P, P1: TvxPoint;
begin
  P := LocalToAbsolute(vgPoint(X, Y));
  if (FContent <> nil) and (FContent.ChildrenCount > 0) then
    for i := 0 to FContent.ChildrenCount - 1 do
      if FContent.Children[i] is TvxColumn then
      begin
        if not TvxColumn(FContent.Children[i]).Visible then
          Continue;
        if not vgIntersectRect(TvxColumn(FContent.Children[i]).UpdateRect, UpdateRect) then
          Continue;
        if TvxColumn(FContent.Children[i]).pointInObject(P.X, P.Y) then
        begin
          Result := TvxColumn(FContent.Children[i]);
          Exit;
        end
      end;
  Result := nil;
end;

function TvxCustomGrid.CanEditModify: Boolean;
begin
  Result := not ReadOnly;
end;

function TvxCustomGrid.CanEditAcceptKey(Key: System.WideChar): Boolean;
begin
  Result := true;
end;

procedure TvxCustomGrid.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
  if RowCount > 0 then
  begin
    if (KeyChar <> #0) and not (ReadOnly) and not (Columns[ColumnIndex].ReadOnly) then
    begin
      if (Columns[ColumnIndex] <> nil) and (Columns[ColumnIndex].CellControlByRow(Selected) <> nil) then
      begin
        Columns[ColumnIndex].CellControlByRow(Selected).SetFocus;
        TvxHackVisualObject(Columns[ColumnIndex].CellControlByRow(Selected)).KeyDown(Key, KeyChar, Shift);
      end;
    end;
    case Key of
      VK_F2:
        begin
          if (Columns[ColumnIndex] <> nil) and (Columns[ColumnIndex].CellControlByRow(Selected) <> nil) then
            Columns[ColumnIndex].CellControlByRow(Selected).SetFocus;
        end;
      VK_UP:
        if FSelected > 0 then
          Selected := Selected - 1;
      VK_DOWN:
        if FSelected < FRowCount - 1 then
          Selected := Selected + 1;
      VK_HOME:
        if ssCtrl in Shift then
          Selected := 0
        else
          ColumnIndex := 0;
      VK_END:
        if ssCtrl in Shift then
          Selected := RowCount - 1
        else
          ColumnIndex := ColumnCount - 1;
      VK_PRIOR:
        if FSelected > 0 then
          Selected := Selected - Min(RowCount, VisibleRows);
      VK_NEXT:
        if FSelected < FRowCount - 1 then
          Selected := Selected + Min(RowCount, VisibleRows);
      VK_LEFT:
        if ColumnIndex > 0 then
          ColumnIndex := ColumnIndex - 1;
      VK_RIGHT:
        if ColumnIndex < ColumnCount - 1 then
          ColumnIndex := ColumnIndex + 1;
    else
      Exit;
    end;
    Key := 0;
  end;
end;

procedure TvxCustomGrid.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  Column: TvxColumn;
begin
  inherited;
  if Button = mbLeft then
  begin
    Selected := RowByPoint(X, Y);
    Column := ColumnByPoint(X, Y);
    if Column <> nil then
      ColumnIndex := Column.Index;
  end;
end;

procedure TvxCustomGrid.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  Column: TvxColumn;
begin
  inherited;
  if FPressed then
  begin
    Selected := RowByPoint(X, Y);
    Column := ColumnByPoint(X, Y);
    if Column <> nil then
      ColumnIndex := Column.Index;
  end;
end;

procedure TvxCustomGrid.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
end;

procedure TvxCustomGrid.AddObject(AObject: TvxObject);
begin
  if (FContent <> nil) and ((AObject is TvxColumn) or (AObject is TvxSelectionItem)) then
  begin
    FContent.AddObject(AObject);
    if FUpdating = 0 then
      Realign;
  end
  else
    inherited;
end;

procedure TvxCustomGrid.RemoveObject(AObject: TvxObject);
begin
  inherited;
end;

procedure TvxCustomGrid.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
end;

function TvxCustomGrid.GetColumn(Index: integer): TvxColumn;
begin
  Result := ColumnByIndex(Index);
end;

procedure TvxCustomGrid.SetRowCount(const Value: integer);
begin
  if FRowCount <> Value then
  begin
    FRowCount := Value;
    Realign;
    if (FSelected >= FRowCount) and (FRowCount > 0) then
      Selected := FRowCount - 1;
  end;
end;

procedure TvxCustomGrid.SetRowHeight(const Value: single);
begin
  if FRowHeight <> Value then
  begin
    FRowHeight := Value;
    if FRowHeight < 5 then
      FRowHeight := 5;
    Realign;
  end;
end;

function TvxCustomGrid.GetTopRow: integer;
begin
  if VScrollBar <> nil then
    Result := trunc(VScrollBar.Value / FRowHeight)
  else
    Result := 0;
end;

function TvxCustomGrid.GetVisibleRows: integer;
begin
  Result := trunc(ClientHeight / FRowHeight) + 2;
end;

function TvxCustomGrid.GetValue(Col, Row: integer): Variant;
begin
  Result := NULL;
  if Assigned(FOnGetValue) then
    FOnGetValue(Self, Col, Row, Result);
end;

procedure TvxCustomGrid.SetValue(Col, Row: integer; const Value: Variant);
begin
  if Assigned(FOnSetValue) then
    FOnSetValue(Self, Col, Row, Value);
end;

procedure TvxCustomGrid.SetSelected(const Value: integer);
begin
  if FSelected <> Value then
  begin
    FSelected := Value;
    if FSelected < 0 then
      FSelected := 0;
    if FSelected > FRowCount - 1 then
      FSelected := FRowCount - 1;

    if FSelected <= TopRow then
      VScrollBar.Value := FSelected * FRowHeight;
    if FSelected * FRowHeight > VScrollBar.Value + ClientHeight - FRowHeight then
      VScrollBar.Value := FSelected * FRowHeight - ClientHeight + FRowHeight;
    UpdateSelection;
  end;
end;

function TvxCustomGrid.IsSelected(Row: integer): boolean;
begin
  Result := Row = FSelected;
end;

procedure TvxCustomGrid.SetAlternatingRowBackground(const Value: boolean);
begin
  if FAlternatingRowBackground <> Value then
  begin
    FAlternatingRowBackground := Value;
    Repaint;
  end;
end;

procedure TvxCustomGrid.SetShowHorzLines(const Value: boolean);
begin
  if FShowHorzLines <> Value then
  begin
    FShowHorzLines := Value;
    Repaint;
  end;
end;

procedure TvxCustomGrid.SetShowVertLines(const Value: boolean);
begin
  if FShowVertLines <> Value then
  begin
    FShowVertLines := Value;
    Repaint;
  end;
end;

procedure TvxCustomGrid.SetColumnIndex(const Value: integer);
begin
  if FColumnIndex <> Value then
  begin
    FColumnIndex := Value;
    UpdateSelection;
    if Columns[FColumnIndex].Position.X < HScrollBar.Value then
      HScrollBar.Value := Columns[FColumnIndex].Position.X;
    if Columns[FColumnIndex].Position.X + Columns[FColumnIndex].Width > HScrollBar.Value + ClientWidth then
      HScrollBar.Value := Columns[FColumnIndex].Position.X + Columns[FColumnIndex].Width - ClientWidth;
  end;
end;

procedure TvxCustomGrid.SetShowHeader(const Value: boolean);
begin
  if FShowHeader <> Value then
  begin
    FShowHeader := Value;
    if FHeader <> nil then
      FHeader.Visible := FShowHeader;
  end;
end;

procedure TvxCustomGrid.Reset;
begin
  SetFocus;
end;

{ TvxStringColumn }

constructor TvxStringColumn.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxStringColumn.Destroy;
begin
  inherited;
end;

procedure TvxStringColumn.UpdateColumn;
begin
  if Grid = nil then
    Exit;
  SetLength(FCells, Grid.RowCount);
  inherited;
end;

{ TvxStringGrid }

constructor TvxStringGrid.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'gridstyle';
end;

destructor TvxStringGrid.Destroy;
begin
  inherited;
end;

function TvxStringGrid.GetValue(Col, Row: integer): Variant;
var
  C: TvxColumn;
begin
  C := Columns[Col];
  if C <> nil then
  begin
    if Length(TvxStringColumn(C).FCells) <> RowCount then
      SetLength(TvxStringColumn(C).FCells, RowCount);
    Result := TvxStringColumn(C).FCells[Row]
  end
  else
    Result := NULL;
end;

procedure TvxStringGrid.SetValue(Col, Row: integer; const Value: Variant);
var
  C: TvxColumn;
begin
  C := Columns[Col];
  if (C <> nil) then
  begin
    if Length(TvxStringColumn(C).FCells) <> RowCount then
      SetLength(TvxStringColumn(C).FCells, RowCount);
    TvxStringColumn(C).FCells[Row] := VarToWideStr(Value);
  end;
end;

function TvxStringGrid.GetCells(ACol, ARow: Integer): WideString;
begin
  Result := GetValue(ACol, ARow);
end;

procedure TvxStringGrid.SetCells(ACol, ARow: Integer;
  const Value: WideString);
begin
  SetValue(ACol, ARow, Value)
end;

function TvxStringGrid.ItemClass: string;
begin
  Result := 'TvxStringColumn';
end;

procedure TvxCustomGrid.SetShowSelectedCell(const Value: boolean);
begin
  if FShowSelectedCell <> Value then
  begin
    FShowSelectedCell := Value;
    UpdateSelection;
  end;
end;

{ TvxInspector }

constructor TvxInspector.Create(AOwner: TComponent);
begin
  inherited;
  FShowProperties := true;
  FShowEvents := false;
  FResource := 'treeviewstyle';
  HideSelectionUnfocused := false;
  FDisabledProperties := TStringList.Create;
  FEditButton := TvxButton.Create(Self);
  FEditButton.ResourceName := 'inspectorEditor';
  FEditButton.TagString := 'self';
  FEditButton.DisableFocusEffect := true;
  FEditButton.Visible := false;
  FEditButton.Stored := false;
  FEditButton.Parent := Self;
  FEditButton.OnClick := DoEditorChange;
  FEditButton.Visible := false;
  FEditButton.Position.X := 2000;
  FEditBox := TvxTextBox.Create(Self);
  FEditBox.ResourceName := 'inspectorEditor';
  FEditBox.TagString := 'self';
  FEditBox.DisableFocusEffect := true;
  FEditBox.Padding.Rect := vgRect(0, 0, 0, 0);
  FEditBox.Stored := false;
  FEditBox.Parent := Self;
  FEditBox.OnChange := DoEditorChange;
  FEditBox.Visible := false;
  FEditBox.Position.X := 2000;
  FComboBox := TvxPopupBox.Create(Self);
  FComboBox.ResourceName := 'inspectorEditor';
  FComboBox.TagString := 'self';
  FComboBox.DisableFocusEffect := true;
  FComboBox.Stored := false;
  FComboBox.Parent := Self;
  FComboBox.TextAlign := vgTextAlignNear;
  FComboBox.OnChange := DoEditorChange;
  FComboBox.Visible := false;
  FcomboBox.Position.X := 2000;
end;

destructor TvxInspector.Destroy;
begin
  if (FSelectedObject <> nil) and (FSelectedObject is TvxObject) then
    TvxObject(FSelectedObject).RemoveFreeNotify(Self);
  FDisabledProperties.Free;
  inherited;
end;

procedure TvxInspector.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSelectedObject) then
  begin
    SelectedObject := nil;
  end;
end;

procedure TvxInspector.InsAddObject(ItemRoot: TvxObject; Root: TObject);
var
  PropList: PPropList;
  PropInfo: PPropInfo;
  i, j, PropCount: integer;
  Obj: TObject;
  Item: TvxTreeViewItem;
  Value: TvxLabel;
  Cls: TClass;
begin
  if Root = nil then
    Exit;
  {$IFDEF KS_COMPILER5}
  PropCount := GetPropList(PTypeInfo(Root.ClassInfo), [tkUnknown, tkInteger, tkChar, tkEnumeration, tkFloat,
    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWString,
      tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArray], nil);
  GetMem(PropList, SizeOf(PPropInfo) * PropCount);
  PropCount := GetPropList(PTypeInfo(Root.ClassInfo), [tkUnknown, tkInteger, tkChar, tkEnumeration, tkFloat,
    tkString, tkSet, tkClass, tkMethod, tkWChar, tkLString, tkWString,
      tkVariant, tkArray, tkRecord, tkInterface, tkInt64, tkDynArray], PropList);
  {$ELSE}
  PropCount := GetPropList(PTypeInfo(Root.ClassInfo), PropList);
  {$ENDIF}
  if PropCount = 0 then
    Exit;

  try
    {$IFDEF KS_COMPILER6_UP}
    SortPropList(PropList, PropCount);
    {$ENDIF}
    for i := 0 to PropCount - 1 do
    begin
      with PropList[i]^ do
      begin
        if FDisabledProperties.IndexOf(Name) >= 0 then
          Continue;
        PropInfo := GetPropInfo(Root, Name);
        if PropInfo = nil then
          Continue;
        if PropInfo^.SetProc = nil then
          Continue;

        if (PropType^.Kind in [tkMethod]) and ((not FShowEvents) or (Root <> FSelectedObject)) then
          Continue;
        if not (PropType^.Kind in [tkMethod]) and (not FShowProperties) then
          Continue;

        Item := TvxTreeViewItem.Create(Self);
        Item.Parent := ItemRoot;
        Item.Text := Name;
        Item.Locked := true;
        Item.Stored := false;
        Value := TvxLabel.Create(Self);
        Value.ResourceName := 'inspectorEditor';
        Value.Locked := true;
        Value.Stored := false;
        Value.Parent := Item;
        Value.SetBounds(Width / 2, 0, Width, Item.Height + 2);
        Value.TextAlign := vgTextAlignNear;
        Value.WordWrap := false;
        Item.TagObject := Root;
        Item.TagString := Name;
        Item.Tag := Integer(Value);
        case PropType^.Kind of
          tkInteger:
            begin
              Value.Text := IntToStr(GetOrdProp(Root, Name));
            end;
          tkFloat:
            begin
              Value.Text := FloatToStr(GetFloatProp(Root, Name));
            end;
          tkClass:
            begin
              Obj := GetObjectProp(Root, Name);
              if (Obj is TvxObject) then
              begin
                TvxLabel(Value).Text := TComponent(Obj).Name;
                if TComponent(Obj).Name = '' then
                  TvxLabel(Value).Text := TvxObject(Obj).ResourceName;
              end
              else
                if Obj <> nil then
              begin
                Item.IsExpanded := false;
                TvxLabel(Value).Text := Obj.ClassName;
                if not (Obj is TvxObject) then
                  InsAddObject(Item, Obj);
              end;
            end;
          {$IFDEF KS_COMPILER11}tkUString, {$ENDIF}tkWString:
            begin
              {$IFDEF KS_COMPILER6_UP}
              Value.Text := GetWideStrProp(Root, Name);
              {$ELSE}
              Value.Text := GetStrProp(Root, Name);
              {$ENDIF}
            end;
          tkString, tkLString:
            begin
              Value.Text := GetStrProp(Root, Name);
            end;
          tkMethod:
            begin
              Value.Text := GetStrProp(Root, Name);
            end;
          tkEnumeration:
            begin
              Value.Text := GetEnumProp(Root, Name);
            end;
          {$IFDEF FPC}
          tkBool:
            begin
              Value.Text := GetEnumProp(Root, Name);
            end;
          {$ENDIF}
        else
          Value.Text := GetStrProp(Root, Name);
        end;
      end;
    end;
  finally
    FreeMem(PropList, SizeOf(PPropInfo) * PropCount);
  end;
end;

procedure TvxInspector.RebuildList;
begin
  BeginUpdate;
  try
    FEditButton.TagObject := nil;
    FEditBox.TagObject := nil;
    FComboBox.TagObject := nil;
    Clear;
    if FSelectedObject <> nil then
      InsAddObject(Self, FSelectedObject);
  finally
    EndUpdate;
  end;
end;

procedure TvxInspector.RebuildEditor;
var
  PropInfo: PPropInfo;
  TypeData: PTypeData;
  Editor: TvxControl;
  L: TList;
  i: integer;
  Obj: TObject;
  M: TMethod;
begin
  FEditButton.Visible := false;
  FEditBox.Visible := false;
  FComboBox.Visible := false;
  if (Selected = nil) or (Selected.TagObject = nil) then
    Exit;

  PropInfo := GetPropInfo(Selected.TagObject, Selected.TagString);
  if PropInfo = nil then
    Exit;

  TypeData := GetTypeData(PropInfo.PropType{$IFNDEF FPC}^{$ENDIF});
  if TypeData = nil then
    Exit;

  if FEditButton.TagObject <> nil then
    TvxVisualObject(FEditButton.TagObject).Visible := true;
  if FEditBox.TagObject <> nil then
    TvxVisualObject(FEditBox.TagObject).Visible := true;
  if FComboBox.TagObject <> nil then
    TvxVisualObject(FComboBox.TagObject).Visible := true;
  with PropInfo^ do
  begin
    case PropType^.Kind of
      tkMethod:
        begin
          M := GetMethodProp(Selected.TagObject, Selected.TagString);
          if vgDesigner <> nil then
            FEditBox.Text := vgDesigner.GetMethodName(M);
          FEditBox.SelectAll;
          Editor := FEditBox;
        end;
      tkClass:
        begin
          Obj := GetObjectProp(Selected.TagObject, Selected.TagString);
          if (Obj is TvxGradient) or (Obj is TvxBrush) or (Obj is TvxBitmap) or (Obj is TvxPathData) or (Obj is TvxFont) then
          begin
            FEditButton.Text := 'Edit...';
            Editor := FEditButton;
          end
          else
            Editor := nil;
        end;
      tkInteger:
        begin
          FEditBox.Text := IntToStr(GetOrdProp(Selected.TagObject, Selected.TagString));
          Editor := FEditBox;
        end;
      tkFloat:
        begin
          FEditBox.Text := FloatToStr(GetFloatProp(Selected.TagObject, Selected.TagString));
          Editor := FEditBox;
        end;
      tkWString:
        begin
          {$IFDEF KS_COMPILER6_UP}
          FEditBox.Text := GetWideStrProp(Selected.TagObject, Selected.TagString);
          {$ELSE}
          FEditBox.Text := GetStrProp(Selected.TagObject, Selected.TagString);
          {$ENDIF}
          Editor := FEditBox;
        end;
      tkString, tkLString:
        begin
          FEditBox.Text := GetStrProp(Selected.TagObject, Selected.TagString);
          FEditBox.SelectAll;
          Editor := FEditBox;
        end;
      tkEnumeration:
        begin
          FComboBox.Items.Clear;
          FComboBox.ItemIndex := -1;
          for i := TypeData.MinValue to TypeData.MaxValue do
            FComboBox.Items.Add(GetEnumName(PropInfo.PropType{$IFNDEF FPC}^{$ENDIF}, i));
          FComboBox.ItemIndex := GetOrdProp(Selected.TagObject, Selected.TagString);
          Editor := FComboBox;
        end;
      {$IFDEF FPC}
      tkBool:
        begin
          FComboBox.Items.Clear;
          for i := TypeData.MinValue to TypeData.MaxValue do
            FComboBox.Items.Add(GetEnumName(PropInfo.PropType{$IFNDEF FPC}^{$ENDIF}, i));
          FComboBox.ItemIndex := GetOrdProp(Selected.TagObject, Selected.TagString);
          Editor := FComboBox;
        end;
      {$ENDIF}
    else
      FEditBox.Text := GetStrProp(Selected.TagObject, Selected.TagString);
      Editor := FEditBox;
    end;
  end;
  if Editor <> nil then
  begin
    Editor.Visible := true;
    Editor.Locked := true;
    Editor.Stored := false;
    Editor.TagObject := TObject(Selected.Tag);
    if Editor.TagObject <> nil then
      TvxVisualObject(Editor.TagObject).Visible := false;
    UpdateEditorPos;
    if Editor.Visible then
      Editor.SetFocus;
  end;
end;

procedure TvxInspector.DoEditorChange(Sender: TObject);
var
  Obj: TObject;
  F: TFontDialog;
  S: string;
  EditDlg: TvxPathDataDesigner;
  i: integer;
  L: TList;
  PropInfo: PPropInfo;
  M: TMethod;
begin
  if FUpdating > 0 then
    Exit;

  if (Selected <> nil) and (Selected.TagObject <> nil) then
  begin
    if (Sender = FEditButton) and FEditButton.Visible then
    begin
      { Designer }
      Obj := GetObjectProp(Selected.TagObject, Selected.TagString);
      if Obj is TvxBrush then
      begin
        SelectInDesign(Obj, TPersistent(SelectedObject));
      end;
      if Obj is TvxGradient then
      begin
        ShowGradientDialog(TvxGradient(Obj));
      end;
      if Obj is TvxBitmap then
      begin
        vgBitmapEditor := TvxBitmapEditor.Create(nil);
        vgBitmapEditor.AssignFromBitmap(TvxBitmap(Obj));
        if vgBitmapEditor.ShowModal = mrOk then
        begin
          vgBitmapEditor.AssignToBitmap(TvxBitmap(Obj));
        end;
        vgBitmapEditor.Free;
      end;
      if Obj is TvxPathData then
      begin
        EditDlg := TvxPathDataDesigner.Create(Self);
        EditDlg.PathData.Lines.Text := TvxPathData(Obj).Data;
        if EditDlg.ShowModal = mrOk then
        begin
          TvxPathData(Obj).Data := EditDlg.PathData.Lines.Text;
        end;
        EditDlg.Free;
      end;
      if Obj is TvxFont then
      begin
        F := TFontDialog.Create(nil);
        F.Font.Assign(TvxFont(Obj));
        if F.Execute then
        begin
          TvxFont(Obj).Assign(F.Font);
        end;
        F.Free;
      end;
    end;
    if (Sender = FEditBox) and FEditBox.Visible then
    begin
      PropInfo := GetPropInfo(Selected.TagObject, Selected.TagString);
      if PropInfo^.PropType^.Kind = tkMethod then
      begin
        if vgDesigner <> nil then
        begin
          M := vgDesigner.AddMethod(TvxTextBox(Sender).Text);
          SetMethodProp(Selected.TagObject, PropInfo, M);
          if (M.Code <> nil) and (TvxObject(Sender).TagObject <> nil) then
            TvxLabel(TvxObject(Sender).TagObject).Text := TvxTextBox(Sender).Text;
        end;
      end
      else
      begin
        SetPropValue(Selected.TagObject, Selected.TagString, TvxTextBox(Sender).Text);
        if TvxObject(Sender).TagObject <> nil then
          TvxLabel(TvxObject(Sender).TagObject).Text := TvxTextBox(Sender).Text;
      end;
    end;
    if (Sender = FComboBox) and FComboBox.Visible then
    begin
      SetPropValue(Selected.TagObject, Selected.TagString, TvxPopupBox(Sender).ItemIndex);
      if TvxObject(Sender).TagObject <> nil then
        TvxLabel(TvxObject(Sender).TagObject).Text := TvxPopupBox(Sender).Text;
    end;
    if Assigned(FOnChangeProperty) then
      FOnChangeProperty(Self, Selected.TagString);
  end;
end;

procedure TvxInspector.SetSelectedObject(const Value: TComponent);
begin
  if FSelectedObject <> Value then
  begin
    if (Editor <> nil) and (Editor.Visible) and (Editor <> FEditButton) then
      DoEditorChange(Editor);
    if (FSelectedObject <> nil) and (FSelectedObject is TvxObject) then
      TvxObject(FSelectedObject).RemoveFreeNotify(Self);
    FSelectedObject := Value;
    if (FSelectedObject <> nil) and (FSelectedObject is TvxObject) then
      TvxObject(FSelectedObject).AddFreeNotify(Self);
    RebuildList;
    RebuildEditor;
  end;
end;

procedure TvxInspector.SetSelected(const Value: TvxTreeViewItem);
begin
  if Value <> Selected then
  begin
    if (Editor <> nil) and (Editor.Visible) and (Editor <> FEditButton) then
      DoEditorChange(Editor);
    inherited;
    RebuildEditor;
  end;
end;

procedure TvxInspector.SetDisabledProperties(const Value: TStrings);
begin
  FDisabledProperties.Assign(Value);
end;

function TvxInspector.Editor: TvxControl;
begin
  if FComboBox.Visible then
    Result := FComboBox
  else
    if FEditBox.Visible then
    Result := FEditBox
  else
    Result := FEditButton;
end;

procedure TvxInspector.VScrollChange(Sender: TObject);
begin
  inherited;
  UpdateEditorPos;
end;

procedure TvxInspector.UpdateEditorPos;
var
  R: TvxRect;
begin
  if (Editor <> nil) and (Selected <> nil) and (ContentLayout <> nil) then
  begin
    R := GetItemRect(Selected);
    R.TopLeft := FContent.LocalToAbsolute(R.TopLeft);
    R.BottomRight := FContent.LocalToAbsolute(R.BottomRight);
    R.TopLeft := AbsoluteToLocal(R.TopLeft);
    R.BottomRight := AbsoluteToLocal(R.BottomRight);
    with R do
    begin
      Editor.SetBounds(Width / 2 + (Selected.Level * Selected.Height), Top + 1,
        ContentLayout.Width - (Width / 2) - FContent.Position.X + ContentLayout.Position.X - (Selected.Level * Selected.Height) - 1,
        Selected.Height - 2);
    end;
    if Editor.Position.Y < 0 then
      Editor.Opacity := 0
    else
      if Editor.Position.Y + Editor.Height > Height then
      Editor.Opacity := 0
    else
      Editor.Opacity := 1
  end;
end;

procedure TvxInspector.DialogKey(var Key: Word; Shift: TShiftState);
begin
  inherited;
  if (Count > 0) and (Selected <> nil) and (Scene <> nil) and
    (Scene.GetFocused = Editor) then
  begin
    case Key of
      VK_ADD: Selected.IsExpanded := true;
      VK_SUBTRACT: Selected.IsExpanded := false;
      VK_HOME:
        if Editor <> FEditBox then
          Selected := ItemByGlobalIndex(0)
        else
          Exit;
      VK_END:
        if Editor <> FEditBox then
          Selected := ItemByGlobalIndex(GlobalCount - 1)
        else
          Exit;
      VK_UP:
        if Selected.GlobalIndex > 0 then
          Selected := ItemByGlobalIndex(Selected.GlobalIndex - 1);
      VK_DOWN:
        if Selected.GlobalIndex < GlobalCount - 1 then
          Selected := ItemByGlobalIndex(Selected.GlobalIndex + 1);
    else
      Exit;
    end;
    Key := 0;
  end;
end;

procedure TvxInspector.SetShowEvents(const Value: boolean);
begin
  if FShowEvents <> Value then
  begin
    FShowEvents := Value;
    RebuildList
  end;
end;

procedure TvxInspector.SetShowProperties(const Value: boolean);
begin
  if FShowProperties <> Value then
  begin
    FShowProperties := Value;
    RebuildList
  end;
end;

{ TvxLayout ===================================================================}

constructor TvxLayout.Create(AOwner: TComponent);
begin
  inherited;
  HitTest := false;
end;

destructor TvxLayout.Destroy;
begin
  inherited;
end;

procedure TvxLayout.Paint;
var
  R: TvxRect;
begin
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
end;

{ TvxScrollContent }

constructor TvxScrollContent.Create(AOwner: TComponent);
begin
  inherited;
  ClipChildren := true;
end;

function TvxScrollContent.GetClipRect: TvxRect;
begin
  if (Parent <> nil) and (Parent is TvxScrollBox) and (TvxScrollBox(Parent).ContentLayout <> nil) then
  begin
    Result := TvxScrollBox(Parent).ContentLayout.LocalRect;
    if (TvxScrollBox(Parent).VScrollBar <> nil) and (TvxScrollBox(Parent).VScrollBar.Enabled) then
      vgOffsetRect(Result, 0, TvxScrollBox(Parent).VScrollBar.Value);
    if (TvxScrollBox(Parent).HScrollBar <> nil) and (TvxScrollBox(Parent).HScrollBar.Enabled) then
      vgOffsetRect(Result, TvxScrollBox(Parent).HScrollBar.Value, 0);
  end
  else
    Result := inherited GetClipRect;
end;

function TvxScrollContent.ObjectByPoint(X, Y: single): TvxVisualObject;
var
  P: TvxPoint;
begin
  Result := inherited ObjectByPoint(X, Y);
  if Result <> nil then
  begin
    P := AbsoluteToLocal(vgPoint(X, Y));
    if not vgPtInRect(P, ClipRect) then
      Result := nil;
  end;
end;

procedure TvxScrollContent.Paint;
var
  State: cardinal;
begin
  inherited;
  State := Canvas.SaveCanvas;
  Canvas.SetMatrix(AbsoluteMatrix);
  Canvas.IntersectClipRect(ClipRect);

  if (Parent <> nil) and (Parent is TvxScrollBox) and (TvxScrollBox(Parent).ContentLayout <> nil) then
  begin
    TvxScrollBox(Parent).ContentPaint(Canvas, LocalRect);
  end;

  Canvas.RestoreCanvas(State);
end;

procedure TvxScrollContent.PaintChildren;
begin
  inherited;
end;

procedure TvxScrollContent.AddObject(AObject: TvxObject);
begin
  inherited;
  if (Parent <> nil) and (Parent is TvxScrollBox) then
    TvxScrollBox(Parent).ContentAddObject(AObject);
end;

procedure TvxScrollContent.RemoveObject(AObject: TvxObject);
begin
  if (Parent <> nil) and (Parent is TvxScrollBox) then
    TvxScrollBox(Parent).ContentBeforeRemoveObject(AObject);
  inherited;
  if (Parent <> nil) and (Parent is TvxScrollBox) then
    TvxScrollBox(Parent).ContentRemoveObject(AObject);
end;

function TvxScrollContent.GetUpdateRect: TvxRect;
begin
  {  Result := inherited GetUpdateRect;
    exit;}
  if FRecalcUpdateRect then
  begin
    if (Parent <> nil) and (Parent is TvxScrollBox) then
    begin
      if (TvxScrollBox(Parent).ContentLayout <> nil) then
        FUpdateRect := TvxScrollBox(Parent).ContentLayout.UpdateRect
      else
        FUpdateRect := TvxScrollBox(Parent).UpdateRect;
    end;
  end;
  Result := FUpdateRect;
end;

{ TvxScrollBox }

constructor TvxScrollBox.Create(AOwner: TComponent);
begin
  inherited;
  AutoCapture := true;
  FAnimated := true;
  FAutoHide := true;
  FShowScrollBars := true;
  FContent := TvxScrollContent.Create(Self);
  FContent.Parent := Self;
  FContent.Stored := false;
  FContent.Locked := true;
  FContent.HitTest := false;
end;

destructor TvxScrollBox.Destroy;
begin
  FContent := nil;
  inherited;
end;

procedure TvxScrollBox.FreeStyle;
begin
  inherited;
  FContentLayout := nil;
  FHScrollBar := nil;
  FVScrollBar := nil;
end;

procedure TvxScrollBox.ApplyStyle;
var
  B: TvxObject;
begin
  inherited;
  B := FindResource('sizegrip');
  if (B <> nil) and (B.IsVisual) then
    B.Visual.Visible := FShowSizeGrip;

  if FUseSmallScrollBars then
  begin
    B := FindResource('vsmallscrollbar');
    if (B <> nil) and (B is TvxScrollBar) then
    begin
      FVScrollBar := TvxScrollBar(B);
      FVScrollBar.OnChange := VScrollChange;
      FVScrollBar.Locked := true;
      if FVScrollBar.Tag = 0 then
        FVScrollBar.Tag := Integer(FVScrollBar.Align);
    end;
    B := FindResource('hsmallscrollbar');
    if (B <> nil) and (B is TvxScrollBar) then
    begin
      FHScrollBar := TvxScrollBar(B);
      FHScrollBar.OnChange := HScrollChange;
      FHScrollBar.Locked := true;
      if FHScrollBar.Tag = 0 then
        FHScrollBar.Tag := Integer(FHScrollBar.Align);
    end;
    // hide standard
    B := FindResource('vscrollbar');
    if (B <> nil) and (B.IsVisual) then
      B.Visual.Visible := false;
    B := FindResource('hscrollbar');
    if (B <> nil) and (B.IsVisual) then
      B.Visual.Visible := false;
  end;
  if not FUseSmallScrollBars or ((FVScrollBar = nil) or (FHScrollBar = nil)) then
  begin
    B := FindResource('vscrollbar');
    if (B <> nil) and (B is TvxScrollBar) then
    begin
      FVScrollBar := TvxScrollBar(B);
      FVScrollBar.OnChange := VScrollChange;
      FVScrollBar.Locked := true;
      if FVScrollBar.Tag = 0 then
        FVScrollBar.Tag := Integer(FVScrollBar.Align);
    end;
    B := FindResource('hscrollbar');
    if (B <> nil) and (B is TvxScrollBar) then
    begin
      FHScrollBar := TvxScrollBar(B);
      FHScrollBar.OnChange := HScrollChange;
      FHScrollBar.Locked := true;
      if FHScrollBar.Tag = 0 then
        FHScrollBar.Tag := Integer(FHScrollBar.Align);
    end;
    // hide standard
    B := FindResource('vsmallscrollbar');
    if (B <> nil) and (B.IsVisual) then
      B.Visual.Visible := false;
    B := FindResource('hsmallscrollbar');
    if (B <> nil) and (B.IsVisual) then
      B.Visual.Visible := false;
  end;

  B := FindResource('content');
  if (B <> nil) and (B.IsVisual) then
    FContentLayout := B.Visual;

  Realign;
  FVScrollAni := nil;
  FHScrollAni := nil;
end;

function TvxScrollBox.GetContentBounds: TvxRect;
var
  i: integer;
  R, LocalR: TvxRect;
begin
  Result := vgRect(0, 0, Width, Height);
  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    R := ContentLayout.LocalRect;
    for i := 0 to FContent.ChildrenCount - 1 do
      if TvxObject(FContent.Children[i]).isVisual then
        if (TvxVisualObject(FContent.Children[i]).Visible) then
        begin
          LocalR := TvxVisualObject(FContent.Children[i]).ParentedRect;
          R := vgUnionRect(R, LocalR);
        end;
    Result := R;
  end;
end;

procedure TvxScrollBox.RealignContent(R: TvxRect);
begin
  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    FContent.SetBounds(R.Left, R.Top, vgRectWidth(R), vgRectHeight(R));
    FContent.FRecalcUpdateRect := true; // need to recalc
  end;
end;

procedure TvxScrollBox.Realign;
  procedure IntAlign;
  var
    R: TvxRect;
  begin
    R := GetContentBounds;
    if vgRectWidth(R) * vgRectHeight(R) = 0 then
      Exit;
    vgOffsetRect(R, ContentLayout.Position.X, ContentLayout.Position.Y);
    if (HScrollBar <> nil) and (HScrollBar.Enabled) then
      vgOffsetRect(R, -FScrollDesign.X, 0);
    if (VScrollBar <> nil) and (VScrollBar.Enabled) then
      vgOffsetRect(R, 0, -FScrollDesign.Y);
    RealignContent(R);
    // realign resource
    if ContentLayout.Parent <> nil then
      ContentLayout.Parent.Visual.BeginUpdate;
    if (VScrollBar <> nil) then
    begin
      VScrollBar.Enabled := vgRectHeight(R) > ContentLayout.Height;
      if FAutoHide then
        VScrollBar.Visible := VScrollBar.Enabled;
      if not FShowScrollBars then
      begin
        VScrollBar.Opacity := 0;
        VScrollBar.Align := vaNone;
      end
      else
      begin
        VScrollBar.Opacity := 1;
        VScrollBar.Align := TvxAlign(VScrollBar.Tag);
      end;
    end;
    if (HScrollBar <> nil) then
    begin
      HScrollBar.Enabled := vgRectWidth(R) > ContentLayout.Width;
      if FAutoHide then
        HScrollBar.Visible := HScrollBar.Enabled;
      if not FShowScrollBars then
      begin
        HScrollBar.Opacity := 0;
        HScrollBar.Align := vaNone;
      end
      else
      begin
        HScrollBar.Opacity := 1;
        HScrollBar.Align := TvxAlign(HScrollBar.Tag);
        if (VScrollBar <> nil) and (VScrollBar.Enabled) then
          HScrollBar.Padding.right := VScrollBar.Width;
      end;
    end;
    if ContentLayout.Parent <> nil then
    begin
      ContentLayout.Parent.Visual.EndUpdate;
      ContentLayout.Parent.Visual.Realign;
    end;
    // align scrollbars
    if (VScrollBar <> nil) then
    begin
      VScrollBar.Enabled := vgRectHeight(R) > ContentLayout.Height;
      if FAutoHide then
        VScrollBar.Visible := VScrollBar.Enabled;
      if not FShowScrollBars then
      begin
        VScrollBar.Opacity := 0;
        VScrollBar.Align := vaNone;
        VScrollBar.Position.Y := Width + 100;
      end
      else
      begin
        VScrollBar.Opacity := 1;
        VScrollBar.HitTest := true;
        VScrollBar.Align := TvxAlign(VScrollBar.Tag);
      end;
      VScrollBar.BringToFront;
      if VScrollBar.Visible and (ContentLayout <> nil) then
      begin
        VScrollBar.Max := vgRectHeight(R);
        VScrollBar.ViewportSize := ContentLayout.Height;
        VScrollBar.SmallChange := VScrollBar.ViewportSize / 5;
        VScrollBar.Value := FScrollDesign.Y;
      end
      else
      begin
        VScrollBar.Value := 0;
      end;
    end;
    if (HScrollBar <> nil) then
    begin
      HScrollBar.Enabled := vgRectWidth(R) > ContentLayout.Width;
      HScrollBar.Padding.right := 0;
      if FAutoHide then
        HScrollBar.Visible := HScrollBar.Enabled;
      if not FShowScrollBars then
      begin
        HScrollBar.Opacity := 0;
        HScrollBar.Align := vaNone;
        HScrollBar.Position.Y := Height + 100;
      end
      else
      begin
        HScrollBar.Opacity := 1;
        HScrollBar.Align := TvxAlign(HScrollBar.Tag);
        if (VScrollBar <> nil) and (VScrollBar.Enabled) then
          HScrollBar.Padding.right := VScrollBar.Width;
      end;
      HScrollBar.BringToFront;
      if HScrollBar.Visible and (ContentLayout <> nil) then
      begin
        HScrollBar.Max := vgRectWidth(R);
        HScrollBar.ViewportSize := ContentLayout.Width;
        HScrollBar.SmallChange := HScrollBar.ViewportSize / 5;
        HScrollBar.Value := ContentLayout.Position.X - FContent.Position.X;
      end
      else
        HScrollBar.Value := 0;
    end;
  end;
var
  R, NewR: TvxRect;
begin
  if csDestroying in ComponentState then
    Exit;
  inherited;
  if csLoading in ComponentState then
    Exit;
  if ContentLayout = nil then
    Exit;
  if FDisableAlign then
    Exit;
  if FUpdating > 0 then
    Exit;
  FDisableAlign := true;
  try
    R := ContentLayout.LocalRect;
    IntAlign;
    NewR := ContentLayout.LocalRect;
    if (vgRectWidth(NewR) <> vgRectWidth(R)) or (vgRectHeight(NewR) <> vgRectHeight(R)) then
    begin
      IntAlign;
    end;
  finally
    FDisableAlign := false;
  end;
end;

function TvxScrollBox.ContentRect: TvxRect;
begin
  if ContentLayout <> nil then
    Result := ContentLayout.ParentedRect
  else
    Result := LocalRect;
end;

function TvxScrollBox.VScrollBarValue: single;
begin
  if (VScrollBar <> nil) and (VScrollBar.Visible) then
    Result := VScrollBar.Value
  else
    Result := 0;
end;

function TvxScrollBox.HScrollBarValue: single;
begin
  if (HScrollBar <> nil) and (HScrollBar.Visible) then
    Result := HScrollBar.Value
  else
    Result := 0;
end;

procedure TvxScrollBox.HScrollChange(Sender: TObject);
begin
  if ContentLayout = nil then
    Exit;
  if HScrollBar.Visible then
    FContent.Position.X := ContentLayout.Position.X - HScrollBar.Value
  else
    FContent.Position.X := ContentLayout.Position.X;
  FScrollDesign.X := HScrollBar.Value;
end;

procedure TvxScrollBox.VScrollChange(Sender: TObject);
begin
  if ContentLayout = nil then
    Exit;
  if VScrollBar.Visible then
    FContent.Position.Y := ContentLayout.Position.Y - VScrollBar.Value
  else
    FContent.Position.Y := ContentLayout.Position.Y;
  FScrollDesign.Y := VScrollBar.Value;
end;

procedure TvxScrollBox.CreateHScrollAni;
begin
  if FHScrollAni = nil then
  begin
    FHScrollAni := TvxFloatAnimation.Create(Self);
    FHScrollAni.Parent := HScrollBar;
    FHScrollAni.AnimationType := vgAnimationOut;
    FHScrollAni.Interpolation := vgInterpolationQuadratic;
    FHScrollAni.Duration := 0.7;
    FHScrollAni.PropertyName := 'Value';
    FHScrollAni.StartFromCurrent := true;
  end;
end;

procedure TvxScrollBox.CreateVScrollAni;
begin
  if FVScrollAni = nil then
  begin
    FVScrollAni := TvxFloatAnimation.Create(Self);
    FVScrollAni.Parent := VScrollBar;
    FVScrollAni.AnimationType := vgAnimationOut;
    FVScrollAni.Interpolation := vgInterpolationQuadratic;
    FVScrollAni.Duration := 0.7;
    FVScrollAni.PropertyName := 'Value';
    FVScrollAni.StartFromCurrent := true;
  end;
end;

procedure TvxScrollBox.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  inherited;
  if (Button = mbLeft) and FMouseTracking then
  begin
    FLastDelta := vgPoint(0, 0);
    FDownPos := vgPoint(X, Y);
    FCurrentPos := vgPoint(X, Y);
    FDown := true;
    if (FVScrollAni <> nil) and FVScrollAni.Running then
      FVScrollAni.StopAtCurrent;
    if (FHScrollAni <> nil) and FHScrollAni.Running then
      FHScrollAni.StopAtCurrent;
  end;
end;

procedure TvxScrollBox.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if FDown and FMouseTracking then
  begin
    if (VScrollBar <> nil) and (VScrollBar.Visible) then
    begin
      VScrollBar.Value := VScrollBar.Value - (Y - FCurrentPos.Y);
      FLastDelta.Y := (Y - FCurrentPos.Y);
    end;
    if (HScrollBar <> nil) and (HScrollBar.Visible) then
    begin
      HScrollBar.Value := HScrollBar.Value - (X - FCurrentPos.X);
      FLastDelta.X := (X - FCurrentPos.X);
    end;
    FCurrentPos := vgPoint(X, Y);
  end;
end;

procedure TvxScrollBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if FDown and FMouseTracking then
  begin
    FDown := false;
    // animation
    if FAnimated and ((FLastDelta.X <> 0) or (FLastDelta.Y <> 0)) then
    begin
      if (VScrollBar <> nil) and (VScrollBar.Visible) then
      begin
        CreateVScrollAni;
        if FVScrollAni.Running then
          FVScrollAni.StopAtCurrent;
        FVScrollAni.StopValue := VScrollBar.Value - (FLastDelta.Y * 7);
        FVScrollAni.Start;
      end;
      if (HScrollBar <> nil) and (HScrollBar.Visible) then
      begin
        CreateHScrollAni;
        if FHScrollAni.Running then
          FHScrollAni.StopAtCurrent;
        FHScrollAni.StopValue := HScrollBar.Value - (FLastDelta.X * 7);
        FHScrollAni.Start;
      end;
    end;
  end;
end;

procedure TvxScrollBox.MouseWheel(Shift: TShiftState; WheelDelta: integer;
  var Handled: boolean);
begin
  inherited;
  if not Handled and not (FDisableMouseWheel) and (VScrollBar <> nil) and (VScrollBar.Visible) then
  begin
    if FAnimated then
    begin
      CreateVScrollAni;
      if FVScrollAni.Running then
        FVScrollAni.StopAtCurrent;
      FVScrollAni.StopValue := VScrollBar.Value - (VScrollBar.SmallChange * 3 * (WheelDelta / 120));
      FVScrollAni.Start;
    end
    else
      VScrollBar.Value := VScrollBar.Value - (VScrollBar.SmallChange * 3 * (WheelDelta / 120));
    Handled := true;
  end;
  if not Handled and not (FDisableMouseWheel) and (HScrollBar <> nil) and (HScrollBar.Visible) then
  begin
    if FAnimated then
    begin
      CreateHScrollAni;
      if FHScrollAni.Running then
        FHScrollAni.StopAtCurrent;
      FHScrollAni.StopValue := HScrollBar.Value - (HScrollBar.SmallChange * 3 * (WheelDelta / 120));
      FHScrollAni.Start;
    end
    else
      HScrollBar.Value := HScrollBar.Value - (HScrollBar.SmallChange * 3 * (WheelDelta / 120));
    Handled := true;
  end;
end;

procedure TvxScrollBox.AddObject(AObject: TvxObject);
begin
  if (FContent <> nil) and (AObject.TagString <> 'self') and (AObject <> FContent) and (AObject <> FResourceLink) and not (AObject is TvxEffect) and not (AObject is TvxAnimation) then
  begin
    FContent.AddObject(AObject);
  end
  else
    inherited;
end;

procedure TvxScrollBox.Loaded;
begin
  inherited;
  // ScrollTo(-FScrollDesign.X, -FScrollDesign.Y);
end;

procedure TvxScrollBox.Centre;
begin
  if (VScrollBar <> nil) and (VScrollBar.Visible) then
  begin
    VScrollBar.Value := (VScrollBar.Max - VScrollBar.ViewportSize) / 2;
  end;
  if (HScrollBar <> nil) and (HScrollBar.Visible) then
  begin
    HScrollBar.Value := (HScrollBar.Max - HScrollBar.ViewportSize) / 2;
  end;
end;

procedure TvxScrollBox.ScrollTo(const Dx, Dy: single);
begin
  if (VScrollBar <> nil) and (VScrollBar.Visible) then
    VScrollBar.Value := VScrollBar.Value - Dy;
  if (HScrollBar <> nil) and (HScrollBar.Visible) then
    HScrollBar.Value := HScrollBar.Value - Dx;
end;

procedure TvxScrollBox.InViewRect(const Rect: TvxRect);
begin

end;

procedure TvxScrollBox.SetShowScrollBars(const Value: boolean);
begin
  if FShowScrollBars <> Value then
  begin
    FShowScrollBars := Value;
    Realign;
  end;
end;

procedure TvxScrollBox.SetShowSizeGrip(const Value: boolean);
begin
  if FShowSizeGrip <> Value then
  begin
    FShowSizeGrip := Value;
    ApplyStyle;
  end;
end;

procedure TvxScrollBox.DefineProperties(Filer: TFiler);
begin
  inherited;
  // Filer.DefineProperty('ScrollDesign', ReadScrollDesign, WriteScrollDesign, (FScrollDesign.X <> 0) and (FScrollDesign.Y <> 0));
end;

procedure TvxScrollBox.ReadScrollDesign(Reader: TReader);
begin
  FScrollDesign := vgStringToPoint(Reader.ReadString);
  ;
end;

procedure TvxScrollBox.WriteScrollDesign(Writer: TWriter);
begin
  Writer.WriteString(vgPointToString(FScrollDesign));
end;

procedure TvxScrollBox.ContentPaint(const Canvas: TvxCanvas; const ARect: TvxRect);
begin

end;

procedure TvxScrollBox.SetUseSmallScrollBars(const Value: boolean);
begin
  if FUseSmallScrollBars <> Value then
  begin
    FUseSmallScrollBars := Value;
    ApplyStyle;
  end;
end;

function TvxScrollBox.ClientHeight: single;
begin
  if ContentLayout <> nil then
    Result := ContentLayout.Height
  else
    Result := Height;
end;

function TvxScrollBox.ClientWidth: single;
begin
  if ContentLayout <> nil then
    Result := ContentLayout.Width
  else
    Result := Width;
end;

procedure TvxScrollBox.ContentAddObject(AObject: TvxObject);
begin

end;

procedure TvxScrollBox.ContentRemoveObject(AObject: TvxObject);
begin

end;

procedure TvxScrollBox.ContentBeforeRemoveObject(AObject: TvxObject);
begin

end;

{ TvxGridLayout }

constructor TvxGridLayout.Create(AOwner: TComponent);
begin
  inherited;
  ItemHeight := 64;
  ItemWidth := 64;
end;

procedure TvxGridLayout.Realign;
var
  i: integer;
  CurPos: TvxPoint;
begin
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  { content }
  CurPos := vgPoint(Margins.Left, Margins.Top);
  for i := 0 to ChildrenCount - 1 do
    if Children[i].IsVisual then
      with Children[i].Visual do
      begin
        SetBounds(CurPos.X + Padding.Left, CurPos.Y + Padding.Top, FItemWidth - Padding.Left - Padding.right,
          FItemHeight - Padding.top - Padding.bottom);
        if Orientation = vgHorizontal then
        begin
          CurPos.X := CurPos.X + FItemWidth;
          if CurPos.X + FItemWidth > Self.Width - Self.Margins.Left - Self.Margins.Right then
          begin
            CurPos.X := Self.Margins.Left;
            CurPos.Y := CurPos.Y + FItemHeight;
          end;
        end
        else
        begin
          CurPos.Y := CurPos.Y + FItemHeight;
          if CurPos.Y + FItemHeight > Self.Height - Self.Margins.Top - Self.Margins.Bottom then
          begin
            CurPos.Y := Self.Margins.Top;
            CurPos.X := CurPos.X + FItemWidth;
          end;
        end;
      end;
  FDisableAlign := false;
end;

procedure TvxGridLayout.SetItemHeight(const Value: single);
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    Realign;
  end;
end;

procedure TvxGridLayout.SetItemWidth(const Value: single);
begin
  if FItemWidth <> Value then
  begin
    FItemWidth := Value;
    Realign;
  end;
end;

procedure TvxGridLayout.SetOrientation(const Value: TvxOrientation);
begin
  if FOrientation <> Value then
  begin
    FOrientation := Value;
    Realign;
  end;
end;

{ TvxScaledLayout }

constructor TvxScaledLayout.Create(AOwner: TComponent);
begin
  inherited;
  FOriginalWidth := Width;
  FOriginalHeight := Height;
end;

destructor TvxScaledLayout.Destroy;
begin
  inherited;
end;

procedure TvxScaledLayout.Realign;
begin
  if (Parent <> nil) and (Parent is TvxScrollBox) and (TvxScrollBox(Parent).FUpdating > 0) then
    Exit;
  inherited;
  if not (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    RecalcAbsolute;
    FRecalcUpdateRect := true;
  end;
end;

function TvxScaledLayout.GetChildrenMatrix: TvxMatrix;
begin
  if (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    OriginalHeight := Height;
    OriginalWidth := Width;
  end;
  Result := IdentityMatrix;
  Result.m11 := Width / FOriginalWidth;
  Result.m22 := Height / FOriginalHeight;
end;

procedure TvxScaledLayout.Paint;
var
  R: TvxRect;
begin
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
  inherited;
end;

procedure TvxScaledLayout.SetOriginalHeight(const Value: single);
begin
  if FOriginalHeight <> Value then
  begin
    FOriginalHeight := Value;
    if FOriginalHeight < 1 then
      FOriginalHeight := 1;
    RecalcAbsolute;
  end;
end;

procedure TvxScaledLayout.SetOriginalWidth(const Value: single);
begin
  if FOriginalWidth <> Value then
  begin
    FOriginalWidth := Value;
    if FOriginalWidth < 1 then
      FOriginalWidth := 1;
    RecalcAbsolute;
  end;
end;

procedure TvxScaledLayout.SetHeight(const Value: single);
begin
  inherited;
  if (Assigned(FScene) and (FScene.GetDesignTime)) then
    OriginalHeight := Height
  else
    RecalcAbsolute;
end;

procedure TvxScaledLayout.SetWidth(const Value: single);
begin
  inherited;
  if (Assigned(FScene) and (FScene.GetDesignTime)) then
    OriginalWidth := Width
  else
    RecalcAbsolute;
end;

{ TvxVertScrollBox }

constructor TvxVertScrollBox.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'scrollboxstyle';
end;

function TvxVertScrollBox.GetContentBounds: TvxRect;
var
  i: integer;
begin
  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    FContent.Width := ContentLayout.Width;
  end;
  Result := inherited GetContentBounds;
end;

{ TvxFramedVertScrollBox }

constructor TvxFramedVertScrollBox.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'framedscrollboxstyle';
end;

{ TvxSplitLayout }

constructor TvxSplitLayout.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxSplitLayout.Destroy;
begin
  inherited;
end;

{$IFNDEF NOVCL}
{ TvxNonVGLayout }

constructor TvxNonVGLayout.Create(AOwner: TComponent);
begin
  inherited;
  FVisibleTimer := TvxTimer.Create(Self);
  FVisibleTimer.Enabled := false;
  FVisibleTimer.Interval := 100;
  FVisibleTimer.OnTimer := DoVisibleTimer;
end;

destructor TvxNonVGLayout.Destroy;
begin
  FVisibleTimer.Free;
  inherited;
end;

procedure TvxNonVGLayout.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FControl) then
    FControl := nil;
end;

function TvxNonVGLayout.CheckParentVisible: boolean;
begin
  Result := inherited CheckParentVisible;
  if (FControl = nil) then
    Exit;
  if (Result <> FControl.Visible) then
  begin
    FControl.Visible := Result;
    FVisibleTimer.Enabled := FControl.Visible;
    if (FControl.Visible) then
      Realign;
  end;
end;

procedure TvxNonVGLayout.Realign;
var
  R: TvxRect;
begin
  inherited;
  if (FControl <> nil) and (FControl.Visible) then
  begin
    R := AbsoluteRect;
    FControl.SetBounds(round(R.Left), round(R.Top), round(vgRectWidth(R)), round(vgRectHeight(R)));
  end;
end;

procedure TvxNonVGLayout.MatrixChanged(Sender: TObject);
var
  R: TvxRect;
begin
  inherited;
  if (FControl <> nil) and (FControl.Visible) then
  begin
    R := AbsoluteRect;
    FControl.SetBounds(round(R.Left), round(R.Top), round(vgRectWidth(R)), round(vgRectHeight(R)));
  end;
end;

procedure TvxNonVGLayout.SetControl(const Value: TControl);
begin
  if FControl <> Value then
  begin
    if Assigned(FScene) and (FControl = FScene.GetComponent) then
      Exit;
    FControl := Value;
    Realign;
  end;
end;

procedure TvxNonVGLayout.DoVisibleTimer(Sender: TObject);
begin
  CheckParentVisible;
end;

{$ENDIF}

type
  TvxHackObject = class(TvxVisualObject);

  { TvxListBoxItem }

constructor TvxListBoxItem.Create(AOwner: TComponent);
begin
  inherited;
  Position.Point := vgPoint(5000, 5000);
  TextAlign := vgTextAlignNear;
  FAutoTranslate := true;
  FText := '';
  Height := 19;
  Width := 19;
  HitTest := false;
end;

destructor TvxListBoxItem.Destroy;
begin
  inherited;
end;

procedure TvxListBoxItem.ApplyStyle;
var
  B: TvxObject;
begin
  inherited;
  B := FindResource('check');
  if (B <> nil) and (B is TvxCheckBox) then
  begin
    FCheck := TvxCheckBox(B);
    FCheck.IsChecked := IsChecked;
    FCheck.OnChange := DoCheckClick;
    if ListBox <> nil then
      FCheck.Visible := ListBox.ShowCheckboxes
    else
      FCheck.Visible := false;
  end;
  StartTriggerAnimation(Self, 'IsSelected');
end;

procedure TvxListBoxItem.FreeStyle;
begin
  inherited;
  FCheck := nil;
end;

procedure TvxListBoxItem.DoCheckClick(Sender: TObject);
begin
  if FCheck <> nil then
    FIsChecked := FCheck.IsChecked;
  if ListBox <> nil then
  begin
    ListBox.SetFocus;
    ListBox.ItemIndex := Index;
    if Assigned(ListBox.OnChangeCheck) then
      ListBox.OnChangeCheck(Self);
  end;
end;

function TvxListBoxItem.ComboBox: TvxComboBox;
var
  P: TvxObject;
begin
  P := Parent;
  while (P <> nil) do
  begin
    if P is TvxComboBox then
    begin
      Result := TvxComboBox(P);
      Exit;
    end;
    P := P.Parent;
  end;
  Result := nil;
end;

function TvxListBoxItem.ListBox: TvxListBox;
var
  P: TvxObject;
begin
  P := Parent;
  while (P <> nil) do
  begin
    if P is TvxListBox then
    begin
      Result := TvxListBox(P);
      Exit;
    end;
    if P is TvxComboBox then
    begin
      Result := TvxComboBox(P).FListBox;
      Exit;
    end;
    P := P.Parent;
  end;
  Result := nil;
end;

procedure TvxListBoxItem.DesignSelect;
begin
  inherited;
  if (ComboBox <> nil) then
  begin
    if ComboBox.FPopup.DesignHide then
      ComboBox.DesignClick;
  end;
end;

procedure TvxListBoxItem.DesignInsert;
begin
  inherited;
  if (ComboBox <> nil) then
  begin
    if ComboBox.FPopup.DesignHide then
      ComboBox.DesignClick;
  end;
end;

procedure TvxListBoxItem.Paint;
var
  R: TvxRect;
begin
  inherited Paint;
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
end;

function TvxListBoxItem.GetParentComponent: TComponent;
begin
  if (ComboBox <> nil) then
    Result := ComboBox
  else
    if (ListBox <> nil) then
    Result := ListBox
  else
    Result := inherited GetParentComponent;
end;

function TvxListBoxItem.EnterFocusChildren(AObject: TvxVisualObject): boolean;
begin
  Result := inherited EnterFocusChildren(AObject);
  if (ListBox <> nil) then
  begin
    if ListBox.MultiSelect then
      ListBox.ClearSelection;
    ListBox.ItemIndex := Index;
    Result := true;
  end;
end;

procedure TvxListBoxItem.UpdateCheck;
var
  i: integer;
begin
  if (ListBox <> nil) and (FCheck <> nil) then
    FCheck.Visible := ListBox.ShowCheckboxes;
  if ChildrenCount > 0 then
    for i := 0 to ChildrenCount - 1 do
      if Children[i] is TvxListboxItem then
        TvxListboxItem(Children[i]).UpdateCheck;
end;

procedure TvxListBoxItem.SetIsChecked(const Value: boolean);
begin
  if FIsChecked <> Value then
  begin
    FIsChecked := Value;
    if FCheck <> nil then
      FCheck.IsChecked := FIsChecked;
  end;
end;

procedure TvxListBoxItem.SetIsSelected(const Value: boolean);
begin
  if FIsSelected <> Value then
  begin
    FIsSelected := Value;
    StartTriggerAnimation(Self, 'IsSelected');
    if FIsSelected and (ListBox <> nil) and not (Listbox.MultiSelect) then
      Listbox.ItemIndex := Index
    else
      if not FIsSelected and (ListBox <> nil) and not (Listbox.MultiSelect) and (Listbox.ItemIndex = Index) then
      Listbox.ItemIndex := -1
    else
      if Listbox <> nil then
      Listbox.UpdateSelection;
  end;
end;

procedure TvxListBoxItem.DragEnd;
begin
  inherited;
  DragLeave;
  if (ListBox <> nil) then
    ListBox.FDragItem := nil;
end;

{ TvxListBox ==================================================================}

constructor TvxListBox.Create(AOwner: TComponent);
begin
  inherited;
  FOddFill := TvxBrush.Create(vgBrushSolid, $20000000);
  FColumns := 1;
  FHideSelectionUnfocused := true;
  FContent.DisableDefaultAlign := true;
  FItemIndex := -1;
  CanFocused := true;
  AutoCapture := true;
  Width := 100;
  Height := 100;
end;

destructor TvxListBox.Destroy;
begin
  if FSelections <> nil then
    FSelections.Free;
  FOddFill.Free;
  inherited;
end;

function TvxListBox.ItemClass: string;
begin
  Result := 'TvxListBoxItem';
end;

procedure TvxListBox.HScrollChange(Sender: TObject);
begin
  inherited;
  UpdateSelection;
end;

procedure TvxListBox.VScrollChange(Sender: TObject);
begin
  inherited;
  UpdateSelection;
end;

function CompareListItem(item1, item2: TvxObject): integer;
begin
  if (item1 is TvxListBoxItem) and (item2 is TvxListBoxItem) then
  begin
    if (TvxListBoxItem(item1).ListBox <> nil) and Assigned(TvxListBoxItem(item1).ListBox.OnCompare) then
      Result := TvxListBoxItem(item1).ListBox.OnCompare(TvxListBoxItem(item1), TvxListBoxItem(item2))
    else
      {$IFDEF KS_COMPILER5}
      Result := CompareText(TvxListBoxItem(item1).Text, TvxListBoxItem(item2).Text);
    {$ELSE}
      Result := WideCompareText(TvxListBoxItem(item1).Text, TvxListBoxItem(item2).Text);
    {$ENDIF}
  end
  else
    Result := 0;
end;

procedure TvxListBox.SortItems;
begin
  if not FSorted then
    Exit;
  FContent.Sort(CompareListItem);
end;

procedure TvxListBox.DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
var
  i: integer;
  Item: TvxListBoxItem;
  P: TvxPoint;
  R: TvxRect;
begin
  if (FContent <> nil) and (ContentLayout <> nil) then
  begin
    if FAlternatingRowBackground then
    begin
      Canvas.Fill.Assign(FOddFill);
      for i := 0 to Count div Columns do
      begin
        if Odd(i) then
        begin
          if i * Columns > Count - 1 then
            Item := ItemByIndex(Count - 1)
          else
            Item := ItemByIndex(i * Columns);
          P := Item.LocalToAbsolute(vgPoint(0, 0));
          P := TvxVisualObject(Sender).AbsoluteToLocal(P);
          R := vgRect(P.X, P.Y, P.X + ContentLayout.Width, P.Y + Item.Height);
          if not vgIntersectRect(R, ARect) then
            Continue;
          Canvas.FillRect(R, 0, 0, [], AbsoluteOpacity);
        end;
      end;
    end;
  end;
end;

procedure TvxListBox.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('content');
  if (T <> nil) and (T.IsVisual) then
  begin
    TvxVisualObject(T).OnBeforePaint := DoContentPaint;
  end;
  T := FindResource('selection');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    FSelection := TvxVisualObject(T);
    FSelection.Visible := false;
    UpdateSelection;
  end;
  T := FindResource('AlternatingRowBackground');
  if (T <> nil) and (T is TvxBrushObject) then
  begin
    FOddFill.Assign(TvxBrushObject(T).Brush);
  end;
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    TvxVisualObject(T).Visible := false;
  end;
end;

procedure TvxListBox.FreeStyle;
begin
  inherited;
  FSelection := nil;
  if FSelections <> nil then
    FSelections.Clear;
end;

procedure TvxListBox.UpdateSelection;
var
  i: integer;
  P: TvxPoint;
  R: TvxRect;
  Sel: boolean;
  SelRects: array of TvxRect;
  Clone: TvxVisualObject;
  Vis: boolean;
  Item: TvxListboxItem;
begin
  if FSelection = nil then
    Exit;
  // calc rects
  Vis := true;
  Sel := false;
  SetLength(SelRects, 0);
  for i := 0 to Count - 1 do
  begin
    Item := Items[i];
    if (Item.IsSelected) and vgIntersectRect(Item.UpdateRect, UpdateRect) then
    begin
      P := Item.LocalToAbsolute(vgPoint(0, 0));
      if (FSelection.Parent <> nil) and FSelection.Parent.IsVisual then
        P := FSelection.Parent.Visual.AbsoluteToLocal(P);
      R := vgRect(P.X, P.Y, P.X + Item.Width, P.Y + Item.Height);
      if (Length(SelRects) > 0) and (i > 0) and (Items[i - 1].IsSelected) then
        SelRects[High(SelRects)] := vgUnionRect(R, SelRects[High(SelRects)])
      else
      begin
        SetLength(SelRects, Length(SelRects) + 1);
        SelRects[High(SelRects)] := R;
      end;
      Sel := true;
    end;
  end;
  // Create selection list
  if FSelections = nil then
    FSelections := TList.Create;
  // create selections
  if FSelections.Count < Length(SelRects) then
    for i := FSelections.Count to Length(SelRects) - 1 do
    begin
      Clone := TvxVisualObject(FSelection.Clone(Self));
      Clone.ResourceName := '';
      FSelections.Add(Clone);
      Clone.Parent := FSelection.Parent;
      Clone.Stored := false;
    end;
  // hide if not need
  if Length(SelRects) < FSelections.Count then
    for i := Length(SelRects) to FSelections.Count - 1 do
    begin
      TvxVisualObject(FSelections[i]).Visible := false;
    end;
  // Check visible
  if HideSelectionUnfocused and not IsFocused then
    Vis := false;
  // align selections
  for i := 0 to High(SelRects) do
  begin
    TvxVisualObject(FSelections[i]).Visible := Vis;
    if Vis then
    begin
      with SelRects[i] do
        TvxVisualObject(FSelections[i]).SetBounds(Left, Top, Right - Left, Bottom - Top);
    end;
  end;
end;

procedure TvxListBox.ContentAddObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxListBoxItem then
    if FUpdating = 0 then
      Realign;
end;

procedure TvxListBox.ContentBeforeRemoveObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxListBoxItem then
  begin
    if FItemIndex > TvxListBoxItem(AObject).Index then
    begin
      Dec(FItemIndex);
      UpdateSelection;
    end;
    TvxListBoxItem(AObject).IsSelected := false;
  end;
end;

procedure TvxListBox.ContentRemoveObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxListBoxItem then
  begin
    if FUpdating = 0 then
      Realign;
  end;
end;

function TvxListBox.GetContentBounds: TvxRect;
var
  R: TvxRect;
  i, j, Idx: integer;
  RowHeight, ColWidth, CurY: single;
begin
  Result := LocalRect;
  if FUpdating > 0 then
    Exit;
  if ContentLayout = nil then
    Exit;
  R := ContentLayout.LocalRect;
  { FContent }
  if FContent <> nil then
  begin
    { Sort if need }
    SortItems;
    { Set Selection }
    if not MultiSelect and (Selected <> nil) then
      Selected.IsSelected := true;
    { Align }
    case FListStyle of
      vgListVertical:
        begin
          { correct items size }
          if FItemWidth <> 0 then
          begin
            FColumns := trunc((R.Right - R.Left) / FItemWidth);
            if FColumns < 1 then
              FColumns := 1;
            if FContent.ChildrenCount > 0 then
              for i := 0 to (FContent.ChildrenCount - 1) do
                with TvxListBoxItem(FContent.Children[i]) do
                begin
                  if FItemHeight <> 0 then
                    SetBounds(Position.X, Position.Y, FItemWidth, FItemHeight)
                  else
                    SetBounds(Position.X, Position.Y, FItemWidth, Height);
                end;
          end;
          if (FItemWidth = 0) and (FItemHeight <> 0) then
          begin
            if FContent.ChildrenCount > 0 then
              for i := 0 to (FContent.ChildrenCount - 1) do
                if FContent.Children[i] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[i]) do
                  begin
                    SetBounds(Position.X, Position.Y, Width, FItemHeight)
                  end;
          end;
          { calc items size }
          CurY := 0;
          if FContent.ChildrenCount > 0 then
            for i := 0 to (FContent.ChildrenCount - 1) div FColumns do
            begin
              RowHeight := 0;
              for j := 0 to FColumns - 1 do
              begin
                if (i * FColumns) + j > FContent.ChildrenCount - 1 then
                  Continue;
                if FContent.Children[(i * FColumns) + j] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[(i * FColumns) + j]) do
                  begin
                    if Height + Padding.Top + Padding.Bottom > RowHeight then
                      RowHeight := Height + Padding.Top + Padding.Bottom;
                  end;
              end;
              // set correct height
              for j := 0 to FColumns - 1 do
              begin
                if (i * FColumns) + j > FContent.ChildrenCount - 1 then
                  Continue;
                if FContent.Children[(i * FColumns) + j] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[(i * FColumns) + j]) do
                  begin
                    Height := RowHeight - Padding.Top - Padding.Bottom;
                  end;
              end;
              CurY := CurY + RowHeight;
            end;
          FContent.Height := CurY;
          { align }
          CurY := 0;
          Idx := 0;
          if FContent.ChildrenCount > 0 then
            for i := 0 to (FContent.ChildrenCount - 1) div FColumns do
            begin
              RowHeight := 0;
              for j := 0 to FColumns - 1 do
              begin
                if (i * FColumns) + j > FContent.ChildrenCount - 1 then
                  Continue;

                if FItemWidth <> 0 then
                  ColWidth := FItemWidth
                else
                  ColWidth := (R.Right - R.Left) / FColumns;

                if FContent.Children[(i * FColumns) + j] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[(i * FColumns) + j]) do
                  begin
                    SetBounds(Padding.Left + (j * ColWidth), CurY + Padding.Top,
                      ColWidth - Padding.Left - Padding.Right, Height);

                    if Height + Padding.Top + Padding.Bottom > RowHeight then
                      RowHeight := Height + Padding.Top + Padding.Bottom;
                    Inc(Idx);
                  end;
              end;
              CurY := CurY + RowHeight;
            end;
          if CurY > 0 then
            R.Bottom := R.Top + CurY;
          if FItemWidth <> 0 then
            R.Right := R.Left + (FItemWidth * FColumns);
        end;
      vgListHorizontal:
        begin
          { correct items size }
          if FItemHeight <> 0 then
          begin
            FColumns := trunc((R.Bottom - R.Top - Padding.Top - Padding.Bottom) / FItemHeight);
            if FColumns < 1 then
              FColumns := 1;
            if FContent.ChildrenCount > 0 then
              for i := 0 to (FContent.ChildrenCount - 1) do
                with TvxListBoxItem(FContent.Children[i]) do
                begin
                  if FItemWidth <> 0 then
                    SetBounds(Position.X, Position.Y, FItemWidth, FItemHeight)
                  else
                    SetBounds(Position.X, Position.Y, Width, FItemHeight);
                end;
          end;
          if (FItemHeight = 0) and (FItemWidth <> 0) then
          begin
            if FContent.ChildrenCount > 0 then
              for i := 0 to (FContent.ChildrenCount - 1) do
                with TvxListBoxItem(FContent.Children[i]) do
                begin
                  SetBounds(Position.X, Position.Y, FItemWidth, Height)
                end;
          end;
          { calc items size }
          CurY := 0;
          if FContent.ChildrenCount > 0 then
            for i := 0 to (FContent.ChildrenCount - 1) div FColumns do
            begin
              ColWidth := 0;
              if FItemHeight <> 0 then
                RowHeight := FItemHeight
              else
                RowHeight := (R.Bottom - R.Top) / FColumns;
              for j := 0 to FColumns - 1 do
                if FContent.Children[(i * FColumns) + j] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[(i * FColumns) + j]) do
                  begin
                    if ColWidth < Width + Padding.Left + Padding.Right then
                      ColWidth := Width + Padding.Left + Padding.Right;
                  end;
              // calc width
              for j := 0 to FColumns - 1 do
                if FContent.Children[(i * FColumns) + j] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[(i * FColumns) + j]) do
                  begin
                    Width := ColWidth - (Padding.Left + Padding.Right);
                  end;

              CurY := CurY + ColWidth;
            end;
          { selection }
          if FItemIndex > Count - 1 then
            FItemIndex := Count - 1;
          { align }
          CurY := 0;
          Idx := 0;
          if FContent.ChildrenCount > 0 then
            for i := 0 to (FContent.ChildrenCount - 1) div FColumns do
            begin
              ColWidth := 0;
              if FItemHeight <> 0 then
                RowHeight := FItemHeight
              else
                RowHeight := (R.Bottom - R.Top) / FColumns;
              for j := 0 to FColumns - 1 do
                if FContent.Children[(i * FColumns) + j] is TvxListBoxItem then
                  with TvxListBoxItem(FContent.Children[(i * FColumns) + j]) do
                  begin
                    if VScrollBar <> nil then
                      SetBounds(CurY + Padding.Left - VScrollBar.Value, Padding.Top + (j * RowHeight),
                        Width, RowHeight - Padding.Top - Padding.Bottom)
                    else
                      SetBounds(CurY + Padding.Left, Padding.Top + (j * RowHeight),
                        Width, RowHeight - Padding.Top - Padding.Bottom);
                    if ColWidth < Width + Padding.Left + Padding.Right then
                      ColWidth := Width + Padding.Left + Padding.Right;
                    Inc(Idx);
                  end;
              CurY := CurY + ColWidth;
            end;
          if CurY > 0 then
            R.Right := R.Left + CurY;
          if FItemHeight <> 0 then
            R.Bottom := R.Top + (FItemHeight * FColumns);
        end;
    end;
  end;
  UpdateSelection;
  Result := R;
end;

function TvxListBox.GetCount: integer;
begin
  Result := 0;
  if (FContent <> nil) then
    Result := FContent.ChildrenCount;
end;

function TvxListBox.ItemByIndex(const Idx: integer): TvxListBoxItem;
begin
  if (FContent <> nil) and (FContent.ChildrenCount > 0) and (Idx >= 0) and (Idx < FContent.ChildrenCount) then
    Result := TvxListBoxItem(FContent.Children[Idx])
  else
    Result := nil;
end;

function TvxListBox.ItemByPoint(const X, Y: single): TvxListBoxItem;
var
  i: integer;
  P: TvxPoint;
begin
  P := LocaltoAbsolute(vgPoint(X, Y));
  if (FContent <> nil) and (FContent.ChildrenCount > 0) then
    for i := 0 to FContent.ChildrenCount - 1 do
      if FContent.Children[i] is TvxListBoxItem then
        if TvxListBoxItem(FContent.Children[i]).pointInObject(P.X, P.Y) then
        begin
          Result := TvxListBoxItem(FContent.Children[i]);
          Exit;
        end;
  Result := nil;
end;

procedure TvxListBox.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
var
  i: integer;
begin
  inherited;
  if Count > 0 then
  begin
    if KeyChar <> #0 then
    begin
      for i := 0 to Count - 1 do
        if (Items[i].Text <> '') and (WideLowerCase(Items[i].Text[1]) = WideLowerCase(KeyChar)) then
        begin
          ItemIndex := i;
          Break;
        end;
      KeyChar := #0;
    end;
    case Key of
      VK_HOME: ItemIndex := 0;
      VK_END: ItemIndex := Count - FColumns;
      VK_UP:
        if ItemIndex > 0 then
        begin
          ItemIndex := ItemIndex - FColumns;
          if ItemIndex < 0 then
            ItemIndex := 0;
        end;
      VK_DOWN:
        begin
          if ItemIndex < Count - 1 then
            ItemIndex := ItemIndex + FColumns;
          if ItemIndex > Count - 1 then
            ItemIndex := Count - 1;
        end;
      VK_LEFT:
        if ItemIndex > 0 then
          ItemIndex := ItemIndex - 1;
      VK_RIGHT:
        if ItemIndex < Count - 1 then
          ItemIndex := ItemIndex + 1;
    else
      Exit;
    end;
    Key := 0;
  end;
end;

procedure TvxListBox.KeyUp(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
end;

procedure TvxListBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  Item: TvxListBoxItem;
begin
  inherited;
  if (Button = mbLeft) and not MouseTracking then
  begin
    Item := ItemByPoint(X, Y);
    if Item <> nil then
    begin
      if Multiselect then
      begin
        if ssCtrl in Shift then
          Item.IsSelected := not Item.IsSelected
        else
          if ssShift in Shift then
        begin
          SelectRange(Selected, Item);
          ItemIndex := Item.Index;
        end
        else
        begin
          SelectRange(Item, Item);
          ItemIndex := Item.Index;
        end;
        FFirstSelect := Item;
      end
      else
      begin
        if ItemIndex <> Item.Index then
        begin
          //Items[ItemIndex].IsChecked := false;
          ItemIndex := Item.Index;
          //Items[ItemIndex].IsChecked := true;

          //raise exception.Create('?');
        end
        else
          if AllowDrag then
          Scene.BeginVCLDrag(Selected, MakeScreenshot);
      end;
      if Assigned(Item.OnClick) then
        Item.OnClick(Item)
    end;
    FMouseSelecting := true;
  end;
end;

procedure TvxListBox.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  Item: TvxListBoxItem;
begin
  inherited;
  if (ssLeft in Shift) and FMouseSelecting then
  begin
    Item := ItemByPoint(X, Y);
    if Item <> nil then
    begin
      if Selected = Item then
        Exit;
      if MultiSelect then
      begin
        if ssCtrl in Shift then
          Item.IsSelected := not Item.IsSelected
        else
          SelectRange(FFirstSelect, Item);
        ItemIndex := Item.Index;
      end
      else
        ItemIndex := Item.Index;
    end;
  end;
end;

procedure TvxListBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  Item: TvxListBoxItem;
begin
  inherited;
  FFirstSelect := nil;
  if MouseTracking and (FLastDelta.X = 0) and (FLastDelta.Y = 0) then
  begin
    Item := ItemByPoint(X, Y);
    if Item <> nil then
      ItemIndex := Item.Index;
  end;
  FMouseSelecting := false;
end;

function TvxListBox.GetSelected: TvxListBoxItem;
begin
  Result := ItemByIndex(FItemIndex);
end;

procedure TvxListBox.SetItemIndex(const Value: integer);
var
  Item: TvxListBoxItem;
begin
  if FItemIndex <> Value then
  begin
    Item := ItemByIndex(ItemIndex);
    if (Item <> nil) and (not MultiSelect) then
      Item.IsSelected := false;

    FItemIndex := Value;
    if (ItemByIndex(FItemIndex) <> nil) and (FContent <> nil) and (VScrollBar <> nil) and (ContentLayout <> nil) then
    begin
      Item := ItemByIndex(FItemIndex);
      if FContent.Position.Y + Item.Position.Y + Item.Padding.Top + Item.Padding.Bottom + Item.Height > ContentLayout.Position.Y + ContentLayout.Height then
        VScrollBar.Value := VScrollBar.Value + (FContent.Position.Y + Item.Position.Y + Item.Padding.Top + Item.Padding.Bottom + Item.Height - ContentLayout.Position.Y - ContentLayout.Height);
      if FContent.Position.Y + Item.Position.Y < ContentLayout.Position.Y then
        VScrollBar.Value := VScrollBar.Value + FContent.Position.Y + Item.Position.Y - ContentLayout.Position.Y;
    end;
    if (ItemByIndex(FItemIndex) <> nil) and (FContent <> nil) and (HScrollBar <> nil) and (ContentLayout <> nil) then
    begin
      Item := ItemByIndex(FItemIndex);
      if FContent.Position.X + Item.Position.X + Item.Padding.Left + Item.Padding.Right + Item.Width > ContentLayout.Position.X + ContentLayout.Width then
        HScrollBar.Value := HScrollBar.Value + (FContent.Position.X + Item.Position.X + Item.Padding.Left + Item.Padding.Right + Item.Width - ContentLayout.Position.X - ContentLayout.Width);
      if FContent.Position.X + Item.Position.X < 0 then
        HScrollBar.Value := HScrollBar.Value + FContent.Position.X + Item.Position.X - ContentLayout.Position.X;
    end;
    if (ItemIndex >= 0) then
    begin
      Item := ItemByIndex(ItemIndex);
      if Item <> nil then
        Item.IsSelected := true;
    end;
    if (FUpdating = 0) then
    begin
      if Assigned(FBindingObjects) then
        ToBindingObjects;
      if Assigned(FOnChange) then
        FOnChange(ItemByIndex(FItemIndex));
    end;
    UpdateSelection;
  end;
end;

procedure TvxListBox.Clear;
var
  i: integer;
begin
  BeginUpdate;
  if FContent <> nil then
    if FContent.ChildrenCount > 0 then
      for i := FContent.ChildrenCount - 1 downto 0 do
        if FContent.Children[i] is TvxListboxItem then
          TvxObject(FContent.Children[i]).Free;
  FScrollDesign.Y := 0;
  FScrollDesign.X := 0;
  EndUpdate;
end;

procedure TvxListBox.SelectRange(Item1, Item2: TvxListBoxItem);
var
  i: integer;
begin
  if Item1 = nil then
    Exit;
  if Item2 = nil then
    Exit;
  for i := 0 to Min(Item1.Index, Item2.Index) - 1 do
    ItemByIndex(i).IsSelected := false;
  for i := Max(Item1.Index, Item2.Index) + 1 to Count - 1 do
    ItemByIndex(i).IsSelected := false;
  for i := Min(Item1.Index, Item2.Index) to Max(Item1.Index, Item2.Index) do
    ItemByIndex(i).IsSelected := true;
end;

procedure TvxListBox.ClearSelection;
var
  i: integer;
begin
  for i := 0 to Count - 1 do
    ItemByIndex(i).IsSelected := false;
end;

procedure TvxListBox.SelectAll;
var
  i: integer;
begin
  for i := 0 to Count - 1 do
    ItemByIndex(i).IsSelected := true;
end;

function TvxListBox.GetData: Variant;
begin
  if Selected <> nil then
    Result := Selected.Text
  else
    Result := '';
end;

procedure TvxListBox.SetData(const Value: Variant);
begin
  if Selected <> nil then
    Selected.Text := Value;
end;

procedure TvxListBox.EnterFocus;
begin
  inherited;
  if HideSelectionUnfocused and (Selected <> nil) then
    UpdateSelection;
end;

procedure TvxListBox.KillFocus;
begin
  inherited;
  if HideSelectionUnfocused and (Selected <> nil) then
    UpdateSelection;
end;

procedure TvxListBox.AddObject(AObject: TvxObject);
begin
  if (FContent <> nil) and ((AObject is TvxListBoxItem) or (AObject is TvxSelectionItem)) then
  begin
    FContent.AddObject(AObject);
  end
  else
    inherited;
end;

procedure TvxListBox.SetColumns(const Value: integer);
begin
  if FColumns <> Value then
  begin
    FColumns := Value;
    if FColumns < 1 then
      FColumns := 1;
    Realign;
  end;
end;

procedure TvxListBox.SetAlternatingRowBackground(const Value: boolean);
begin
  if FAlternatingRowBackground <> Value then
  begin
    FAlternatingRowBackground := Value;
    Repaint;
  end;
end;

procedure TvxListBox.SetMultiSelect(const Value: boolean);
begin
  if FMultiSelect <> Value then
  begin
    FMultiSelect := Value;
    if not FMultiSelect then
      ClearSelection;
  end;
end;

procedure TvxListBox.SetItemHeight(const Value: single);
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    Realign;
  end;
end;

procedure TvxListBox.SetItemWidth(const Value: single);
begin
  if FItemWidth <> Value then
  begin
    FItemWidth := Value;
    Realign;
  end;
end;

procedure TvxListBox.SetListStyle(const Value: TvxListStyle);
begin
  if FListStyle <> Value then
  begin
    FListStyle := Value;
    Realign;
  end;
end;

procedure TvxListBox.SetShowCheckboxes(const Value: boolean);
var
  i: integer;
begin
  if FShowCheckboxes <> Value then
  begin
    FShowCheckboxes := Value;
    for i := 0 to Count - 1 do
      if ItemByIndex(i) <> nil then
        ItemByIndex(i).UpdateCheck;
  end;
end;

function TvxListBox.GetItem(Index: integer): TvxListBoxItem;
begin
  Result := ItemByIndex(Index);
end;

procedure TvxListBox.SetSorted(const Value: boolean);
begin
  if FSorted <> Value then
  begin
    FSorted := Value;
    Realign;
  end;
end;

procedure TvxListBox.SetAllowDrag(const Value: boolean);
begin
  if FAllowDrag <> Value then
  begin
    FAllowDrag := Value;
    if FAllowDrag then
      DragDisableHighlight := true;
  end;
end;

{ TvxComboListBox }

constructor TvxComboListBox.Create(AOwner: TComponent);
begin
  inherited;
  HideSelectionUnfocused := false;
end;

destructor TvxComboListBox.Destroy;
begin
  inherited;
end;

procedure TvxComboListBox.ApplyResource;
begin
  inherited;
end;

procedure TvxComboListBox.GetChildren(Proc: TGetChildProc;
  Root: TComponent);
begin
  inherited;
end;

function TvxComboListBox.GetParentComponent: TComponent;
begin
  Result := inherited GetParentComponent;
end;

procedure TvxComboListBox.KillFocus;
begin
  inherited;
end;

procedure TvxComboListBox.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
end;

procedure TvxComboListBox.MouseMove(Shift: TShiftState; X, Y, Dx,
  Dy: single);
begin
  inherited;
end;

procedure TvxComboListBox.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
  if Key = VK_RETURN then
  begin
    if (Parent is TvxPopup) and (TvxPopup(Parent).IsOpen) and (FComboBox <> nil) and (FComboBox is TvxComboBox) then
    begin
      TvxComboBox(FComboBox).ItemIndex := ItemIndex;
      TvxPopup(Parent).IsOpen := false;
    end;
    if (Parent is TvxPopup) and (TvxPopup(Parent).IsOpen) and (FComboBox <> nil) and (FComboBox is TvxComboTextBox) then
    begin
      TvxComboTextBox(FComboBox).ItemIndex := ItemIndex;
      TvxPopup(Parent).IsOpen := false;
    end;
  end;
end;

procedure TvxComboListBox.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  inherited;
  if (Parent is TvxPopup) and (TvxPopup(Parent).IsOpen) and (FComboBox <> nil) and (FComboBox is TvxComboBox) then
  begin
    if vgPtInRect(vgPoint(X, Y), LocalRect) then
      if ItemByPoint(X, Y) <> nil then
        TvxComboBox(FComboBox).ItemIndex := ItemByPoint(X, Y).Index;
    TvxPopup(Parent).IsOpen := false;
  end;
  if (Parent is TvxPopup) and (TvxPopup(Parent).IsOpen) and (FComboBox <> nil) and (FComboBox is TvxComboTextBox) then
  begin
    if vgPtInRect(vgPoint(X, Y), LocalRect) then
      if ItemByPoint(X, Y) <> nil then
        TvxComboTextBox(FComboBox).ItemIndex := ItemByPoint(X, Y).Index;
    TvxPopup(Parent).IsOpen := false;
  end;
end;

procedure TvxComboListBox.MouseWheel(Shift: TShiftState;
  WheelDelta: integer; var Handled: boolean);
begin
  inherited;
end;

{ TvxComboBox =================================================================}

constructor TvxComboBox.Create(AOwner: TComponent);
begin
  inherited;
  DropDownCount := 8;
  CanFocused := true;
  FPopup := TvxPopup.Create(Self);
  FPopup.PlacementTarget := Self;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FListBox := TvxComboListBox.Create(Self);
  FListBox.Parent := FPopup;
  FListBox.FComboBox := Self;
  FListBox.Stored := false;
  FListBox.Align := vaClient;
  FListBox.ShowCheckboxes := false;
  Width := 100;
  Height := 22;
end;

destructor TvxComboBox.Destroy;
begin
  inherited;
end;

function TvxComboBox.ItemClass: string;
begin
  Result := 'TvxListBoxItem';
end;

procedure TvxComboBox.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('Content');
  if (T <> nil) and (T is TvxContent) then
  begin
    TvxContent(T).OnPaint := DoContentPaint;
    if (FListBox <> nil) and (FListBox.ItemByIndex(ItemIndex) <> nil) then
    begin
      FListBox.ItemByIndex(ItemIndex).Width := TvxContent(T).Width;
    end;
  end;
end;

procedure TvxComboBox.Realign;
begin
  inherited;
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  { FContent }
  if FPopup <> nil then
    FPopup.Width := Width;
  FDisableAlign := false;
end;

procedure TvxComboBox.Paint;
begin
  inherited;
end;

procedure TvxComboBox.PaintChildren;
begin
  inherited;
end;

procedure TvxComboBox.DoContentPaint(Sender: TObject;
  const Canvas: TvxCanvas; const ARect: TvxRect);
var
  SOpacity: single;
  Item: TvxListBoxItem;
  SaveSize: TvxPoint;
  SaveScene: IvgScene;
begin
  if FListBox <> nil then
  begin
    Item := FListBox.ItemByIndex(FListBox.ItemIndex);
    if Item <> nil then
    begin
      Item.ApplyResource;
      SOpacity := Item.FAbsoluteOpacity;
      SaveSize := vgPoint(Item.Width, Item.Height);
      SaveScene := Item.Scene;
      Item.SetNewScene(Scene);
      Item.SetSizeWithoutChange(vgRectWidth(ARect), vgRectHeight(ARect));
      Item.FAbsoluteOpacity := Opacity;
      Item.RecalcOpacity;
      Item.FRecalcOpacity := false;
      Item.PaintTo(Canvas, ARect, TvxObject(Sender));
      Item.FAbsoluteOpacity := SOpacity;
      Item.RecalcOpacity;
      Item.SetSizeWithoutChange(SaveSize.X, SaveSize.Y);
      Item.SetNewScene(SaveScene);
    end;
  end;
end;

procedure TvxComboBox.DropDown;
var
  Count, i: integer;
begin
  if not FPopup.IsOpen then
  begin
    FPopup.Placement := FPlacement;
    FPopup.Width := Width;
    Count := DropDownCount;
    if FListBox.Count < Count then
      Count := FListBox.Count;
    if FListbox.ItemHeight > 0 then
      FPopup.Height := (Count * FListbox.ItemHeight) + 4
    else
      FPopup.Height := Count * (Height - 4);
    FPopup.IsOpen := true;
    if FPopup.IsOpen then
      FListBox.SetFocus;
  end
  else
  begin
    FPopup.IsOpen := false;
  end;
end;

procedure TvxComboBox.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    DropDown;
  end;
end;

procedure TvxComboBox.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
end;

procedure TvxComboBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
end;

procedure TvxComboBox.MouseWheel(Shift: TShiftState; WheelDelta: integer;
  var Handled: boolean);
begin
  inherited;
  if WheelDelta < 0 then
  begin
    if ItemIndex < Count - 1 then
      ItemIndex := ItemIndex + 1
  end
  else
  begin
    if ItemIndex > 0 then
      ItemIndex := ItemIndex - 1;
  end;
  Handled := true;
end;

procedure TvxComboBox.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
var
  i: integer;
begin
  inherited;
  if Count > 0 then
  begin
    if KeyChar <> #0 then
    begin
      for i := 0 to Count - 1 do
        if (FListBox.Items[i].Text <> '') and (WideLowerCase(FListBox.Items[i].Text[1]) = WideLowerCase(KeyChar)) then
        begin
          ItemIndex := i;
          Break;
        end;
      KeyChar := #0;
    end;
    case Key of
      VK_HOME: ItemIndex := 0;
      VK_END: ItemIndex := Count - 1;
      VK_UP:
        if ItemIndex > 0 then
        begin
          ItemIndex := ItemIndex - 1;
          if ItemIndex < 0 then
            ItemIndex := 0;
        end;
      VK_DOWN:
        begin
          if ssAlt in Shift then
          begin
            DropDown;
          end
          else
          begin
            if ItemIndex < Count - 1 then
              ItemIndex := ItemIndex + 1;
            if ItemIndex > Count - 1 then
              ItemIndex := Count - 1;
          end;
        end;
      VK_LEFT:
        if ItemIndex > 0 then
          ItemIndex := ItemIndex - 1;
      VK_RIGHT:
        if ItemIndex < Count - 1 then
          ItemIndex := ItemIndex + 1;
    else
      Exit;
    end;
    Key := 0;
  end;
end;

procedure TvxComboBox.Clear;
begin
  if FListBox <> nil then
    FListBox.Clear;
end;

procedure TvxComboBox.AddObject(AObject: TvxObject);
begin
  if (FListBox <> nil) and ((AObject is TvxListBoxItem) or (AObject is TvxSelectionItem)) then
  begin
    FListBox.AddObject(AObject);
  end
  else
    inherited;
end;

procedure TvxComboBox.DoListBoxChange(Sender: TObject);
begin
end;

function TvxComboBox.GetItemIndex: integer;
begin
  if FListBox <> nil then
    Result := FListBox.ItemIndex
  else
    Result := -1;
end;

function TvxComboBox.GetCount: integer;
begin
  if FListBox <> nil then
    Result := FListBox.Count
  else
    Result := 0;
end;

procedure TvxComboBox.SetItemIndex(const Value: integer);
begin
  if FListBox <> nil then
  begin
    FListBox.ItemIndex := Value;
    if Assigned(FBindingObjects) then
      ToBindingObjects;
    if Assigned(FOnChange) then
      FOnChange(Self);
    if (FResourceLink <> nil) then
      FResourceLink.Visual.UpdateEffects;
    Repaint;
  end;
end;

procedure TvxComboBox.DesignClick;
begin
  inherited;
  FPopup.DesignHide := not FPopup.DesignHide;
  FPopup.Width := Width;
  if FListbox.ItemHeight > 0 then
    FPopup.Height := DropDownCount * FListbox.ItemHeight
  else
    FPopup.Height := DropDownCount * (Height - 4);
  FPopup.Position.X := 0;
  FPopup.Position.Y := Height;
  FPopup.Locked := FPopup.DesignHide;
end;

procedure TvxComboBox.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  j: integer;
begin
  inherited;
  if (FListBox <> nil) and (FListBox.FContent <> nil) then
    if (FListBox.FContent.ChildrenCount > 0) then
    begin
      for j := 0 to FListBox.FContent.ChildrenCount - 1 do
        if FListBox.FContent.Children[j].Stored then
          Proc(TComponent(FListBox.FContent.Children[j]));
    end;
end;

function TvxComboBox.GetListBoxResource: string;
begin
  Result := FListBox.Resource;
end;

procedure TvxComboBox.SetListBoxResource(const Value: string);
begin
  FListBox.Resource := Value;
end;

function TvxComboBox.GetItemHeight: single;
begin
  Result := FListBox.ItemHeight;
end;

procedure TvxComboBox.SetItemHeight(const Value: single);
begin
  FListBox.ItemHeight := Value;
end;

{ TvxStringListBox }

procedure TvxStringListBox.ApplyStyle;
begin
  inherited;
end;

constructor TvxStringListBox.Create(AOwner: TComponent);
begin
  inherited;
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
  FAutoTranslate := true;
  FItems := TvxWideStringList.Create;
  TvxWideStringList(FItems).OnChange := DoItemsChanged;
  FItemHeight := 19;
  FNeedResource := true;
  FResource := 'listboxstyle';
  FItemStyle := 'listboxitemstyle';
end;

destructor TvxStringListBox.Destroy;
begin
  FreeAndNil(FItems);
  FreeAndNil(FFont);
  inherited;
end;

procedure TvxStringListBox.EndUpdate;
begin
  FUpdating := FUpdating + 1;
  inherited EndUpdate;
  FUpdating := FUpdating - 1;
  if FUpdating = 0 then
    RebuildList;
end;

procedure TvxStringListBox.DoItemsChanged(Sender: TObject);
begin
  RebuildList;
end;

function TvxStringListBox.GetData: Variant;
begin
  if (ItemIndex >= 0) and (ItemIndex < FItems.Count) then
    Result := FItems[ItemIndex]
  else
    Result := '';
end;

procedure TvxStringListBox.SetData(const Value: Variant);
begin
  if (ItemIndex >= 0) and (ItemIndex < FItems.Count) then
    FItems[ItemIndex] := Value;
end;

procedure TvxStringListBox.RebuildList;
var
  i, SaveIndex: integer;
  SaveScrollDesign: TvxPoint;
  Item: TvxListBoxItem;
begin
  if FUpdating > 0 then
    Exit;
  if csDestroying in ComponentState then
    Exit;
  if Items = nil then
    Exit;

  BeginUpdate;
  SaveScrollDesign := FScrollDesign;
  SaveIndex := ItemIndex;
  Clear;
  for i := 0 to FItems.Count - 1 do
  begin
    Item := TvxListBoxItem.Create(Self);
    Item.AutoTranslate := FAutoTranslate;
    Item.Parent := Self;
    Item.Height := FItemHeight;
    Item.Stored := false;
    Item.Locked := true;
    Item.Text := FItems[i];
    Item.Font := FFont;
    Item.FResource := FItemStyle;
    Item.TextAlign := TextAlign;
  end;
  FItemIndex := SaveIndex;
  FScrollDesign := SaveScrollDesign;
  inherited EndUpdate;
end;

procedure TvxStringListBox.SetItems(const Value: TvxWideStrings);
begin
  FItems.Assign(Value);
end;

procedure TvxStringListBox.SetTextAlign(const Value: TvxTextAlign);
begin
  if FTextAlign <> Value then
  begin
    FTextAlign := Value;
    if not (csLoading in ComponentState) then
      RebuildList;
  end;
end;

procedure TvxStringListBox.SetFont(const Value: TvxFont);
begin
  FFont.Assign(Value);
end;

procedure TvxStringListBox.FontChanged(Sender: TObject);
var
  i: integer;
begin
  for i := 0 to Count - 1 do
    inherited Items[i].Font.Assign(FFont);
end;

procedure TvxStringListBox.SortItems;
begin
  TvxWideStringList(FItems).Sort;
end;

{ TvxStringComboBox }

constructor TvxStringComboBox.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  FItems := TvxWideStringList.Create;
  TvxWideStringList(FItems).OnChange := DoItemsChanged;
  FItemHeight := 19;
  FNeedResource := true;
  FResource := 'comboboxstyle';
  FItemStyle := 'listboxitemstyle';
end;

destructor TvxStringComboBox.Destroy;
begin
  FreeAndNil(FItems);
  inherited;
end;

procedure TvxStringComboBox.Clear;
begin
  inherited;
end;

procedure TvxStringComboBox.DoItemsChanged(Sender: TObject);
begin
  RebuildList;
end;

procedure TvxStringComboBox.RebuildList;
var
  SaveI, i: integer;
  Item: TvxListBoxItem;
begin
  if csDestroying in ComponentState then
    Exit;
  if Items = nil then
    Exit;
  BeginUpdate;
  SaveI := FListbox.ItemIndex;
  FListbox.FItemIndex := -1;
  Clear;
  for i := 0 to FItems.Count - 1 do
  begin
    Item := TvxListBoxItem.Create(Self);
    Item.AutoTranslate := FAutoTranslate;
    Item.Parent := Self;
    Item.Height := FItemHeight;
    Item.Stored := false;
    Item.Locked := true;
    Item.FResource := FItemStyle;
    Item.Text := FItems[i];
    Item.TextAlign := TextAlign;
  end;
  EndUpdate;
  FListbox.FItemIndex := SaveI;
  if FListbox.FItemIndex >= FListbox.Count then
    FListbox.FItemIndex := FListbox.Count - 1;
end;

procedure TvxStringComboBox.SetItemHeight(const Value: single);
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    RebuildList;
  end;
end;

procedure TvxStringComboBox.SetItems(const Value: TvxWideStrings);
begin
  FItems.Assign(Value);
end;

procedure TvxStringComboBox.SetTextAlign(const Value: TvxTextAlign);
begin
  if FTextAlign <> Value then
  begin
    FTextAlign := Value;
    if not (csLoading in ComponentState) then
      RebuildList;
  end;
end;

procedure TvxStringComboBox.ApplyStyle;
begin
  inherited;
end;

function TvxStringComboBox.GetData: Variant;
begin
  if (ItemIndex >= 0) and (ItemIndex < FItems.Count) then
    Result := FItems[ItemIndex]
  else
    Result := '';
end;

procedure TvxStringComboBox.SetData(const Value: Variant);
begin
  if (ItemIndex >= 0) and (ItemIndex < FItems.Count) then
    FItems[ItemIndex] := Value;
end;

{ TvxHorzListBox }

constructor TvxHorzListBox.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'listboxstyle';
  FNeedResource := true;
  FListStyle := vgListHorizontal;
end;

{ TvxHudStringListBox }

constructor TvxHudStringListBox.Create(AOwner: TComponent);
begin
  inherited;
  FNeedResource := true;
  FResource := 'hudlistboxstyle';
  FItemStyle := 'hudlistboxitemstyle';
end;

{ TvxHudStringComboBox }

constructor TvxHudStringComboBox.Create(AOwner: TComponent);
begin
  inherited;
  FNeedResource := true;
  FResource := 'hudcomboboxstyle';
  FListBox.FResource := 'hudcombolistboxstyle';
  FItemStyle := 'hudlistboxitemstyle';
end;

{ TvxHudListBox }

constructor TvxHudListBox.Create(AOwner: TComponent);
begin
  inherited;
end;

{ TvxHudHorzListBox }

constructor TvxHudHorzListBox.Create(AOwner: TComponent);
begin
  inherited;
  FNeedResource := true;
  FResource := 'hudlistboxstyle';
end;

{ TvxHudComboBox }

constructor TvxHudComboBox.Create(AOwner: TComponent);
begin
  inherited;
  FListBox.FResource := 'hudcombolistboxstyle';
end;

{ TvxImageThread }

constructor TvxImageThread.Create(const AImage: TvxImage; const AFileName: string; const AUseThumbnails: boolean);
begin
  inherited Create(true);
  FFileName := AFileName;
  FUseThumbnails := AUseThumbnails;
  FImage := AImage;
  Priority := tpIdle;
  FreeOnTerminate := true;
end;

destructor TvxImageThread.Destroy;
begin
  inherited;
end;

procedure TvxImageThread.Execute;
begin
  FTempBitmap := TvxBitmap.Create(0, 0);
  if FUseThumbnails then
    FTempBitmap.LoadThumbnailFromFile(FFileName, FImage.Width, FImage.Height, true)
  else
    FTempBitmap.LoadFromFile(FFileName);
  Synchronize(Finished);
end;

procedure TvxImageThread.Finished;
begin
  if FImage <> nil then
    FImage.Bitmap.Assign(FTempBitmap);
  FTempBitmap.Free;
end;

{ TvxImageListBoxItem }

procedure TvxImageListBoxItem.ApplyStyle;
begin
  inherited;
  if (ListBox is TvxImageListBox) then
  begin
    if (TextBorder <> nil) then
      TextBorder.Visible := TvxImageListBox(ListBox).ShowFileName;
    if (Text <> nil) then
      Text.Text := ExtractFileName(TagString);
  end;
  if (ListBox is TvxHorzImageListBox) then
  begin
    if (TextBorder <> nil) then
      TextBorder.Visible := TvxHorzImageListBox(ListBox).ShowFileName;
    if (Text <> nil) then
      Text.Text := ExtractFileName(TagString);
  end;
end;

function TvxImageListBoxItem.Text: TvxText;
begin
  Result := TvxText(FindResource('text'));
end;

function TvxImageListBoxItem.TextBorder: TvxVisualObject;
begin
  Result := TvxVisualObject(FindResource('textborder'));
end;

{ TvxImageListBox }

constructor TvxImageListBox.Create(AOwner: TComponent);
begin
  inherited;
  FUseThumbnails := true;
  FItemHeight := Trunc(Width);
  if Self is TvxHudImageListBox then
    FResource := 'HudListBoxStyle'
  else
    FResource := 'listboxstyle';
end;

procedure TvxImageListBox.AddBitmap(const AFile: string;
  const ABitmap: TvxBitmap);
var
  R: TvxRect;
  Item: TvxListBoxItem;
  Thumb: TvxImage;
begin
  // Create ListboxItem
  Item := TvxImageListBoxItem.Create(Self);
  Item.Parent := Self;
  Item.Height := FItemHeight;
  Item.Stored := false;
  Thumb := TvxImage.Create(Item);
  Thumb.Parent := Item;
  if ShowFileName then
    Thumb.Padding.Rect := vgRect(4, 4, 4, 20)
  else
    Thumb.Padding.Rect := vgRect(4, 4, 4, 4);
  Thumb.Align := vaClient;
  Thumb.Stored := false;
  Thumb.Locked := true;
  Thumb.HitTest := false;
  // create thumb
  if FUseThumbnails then
  begin
    R := vgRect(0, 0, ABitmap.Width, ABitmap.Height);
    vgFitRect(R, vgRect(0, 0, Height, Height));
    Thumb.Bitmap.SetSize(round(vgRectWidth(R)), round(vgRectHeight(R)));
    if Thumb.Bitmap.Canvas.BeginScene then
    begin
      Thumb.Bitmap.Canvas.DrawBitmap(ABitmap, vgRect(0, 0, ABitmap.Width, ABitmap.Height), vgRect(0, 0, Thumb.Bitmap.Width, Thumb.Bitmap.Height), 1);
      Thumb.Bitmap.Canvas.EndScene;
    end;
  end
  else
    Thumb.Bitmap.Assign(ABitmap);
  // Use Tag property as image loading state 1 - unload 0 - loaded
  Item.Tag := 0;
  // Set TagString property to image FileName
  Item.TagString := AFile;
  // Set the Item.TagObject as Thumb for later access
  Item.TagObject := Thumb;
  Realign;
  if Count = 1 then
    ItemIndex := 0;
end;

procedure TvxImageListBox.AddFile(const AFile: string);
var
  Dir, Ext: string;
  SR: TSearchRec;
  Item: TvxListBoxItem;
  Thumb: TvxImage;
begin
  Ext := LowerCase(ExtractFileExt(AFile));
  if Pos(Ext, DefaultFilterClass.GetFileTypes) > 0 then
  begin
    // Create ListboxItem
    Item := TvxImageListBoxItem.Create(Self);
    Item.Parent := Self;
    Item.Height := FItemHeight;
    Item.Stored := false;
    Item.OnApplyResource := DoApplyResource;
    Thumb := TvxImage.Create(Item);
    Thumb.Parent := Item;
    if ShowFileName then
      Thumb.Padding.Rect := vgRect(4, 4, 4, 20)
    else
      Thumb.Padding.Rect := vgRect(4, 4, 4, 4);
    Thumb.Align := vaClient;
    Thumb.Stored := false;
    Thumb.Locked := true;
    Thumb.HitTest := false;
    // Use Tag property as image loading state 1 - unload 0 - loaded
    Item.Tag := 1;
    // Set TagString property to image FileName
    Item.TagString := AFile;
    // Set the Item.TagObject as Thumb for later access
    Item.TagObject := Thumb;
  end;
  if Count = 1 then
    ItemIndex := 0;
end;

procedure TvxImageListBox.AddFolder(const Folder: string);
var
  Dir: string;
  SR: TSearchRec;
begin
  { add folder }
  { add SelectDialog }
  Dir := Folder;
  {$IFDEF UNIX}
  if (Length(Dir) > 0) and (Dir[Length(Dir)] <> '/') then
    Dir := Dir + '/';
  {$ELSE}
  if (Length(Dir) > 0) and (Dir[Length(Dir)] <> '\') then
    Dir := Dir + '\';
  {$ENDIF}
  BeginUpdate;
  if FindFirst(Dir + '*.*', $FFFF, SR) = 0 then
  begin
    repeat
      if SR.Name = '.' then
        Continue;
      if SR.Name = '..' then
        Continue;
      if SR.Attr and faDirectory = faDirectory then
        Continue;
      AddFile(Dir + SR.Name);
    until FindNext(SR) <> 0;
    FindClose(SR);
  end;
  EndUpdate;
  if Count > 0 then
    ItemIndex := 0;
end;

procedure TvxImageListBox.DoApplyResource(Sender: TObject);
begin
  if (TvxImageListboxItem(Sender).Tag = 1) and (TvxImageListboxItem(Sender).TagString <> '') then
  begin
    // Create ImageThread
    with TvxImageThread.Create(TvxImage(TvxImageListboxItem(Sender).TagObject), TvxImageListboxItem(Sender).TagString, FUseThumbnails) do
    begin
      // Clear Tag state
      TvxImageListboxItem(Sender).Tag := 0;
      // Resume thread
      Resume;
    end;
  end;
end;

function TvxImageListBox.GetImage(Index: integer): TvxImage;
var
  Item: TvxListBoxItem;
begin
  Item := ItemByIndex(Index);
  if (Item <> nil) and (Item.TagObject <> nil) and (Item.TagObject is TvxImage) then
    Result := TvxImage(Item.TagObject)
  else
    Result := nil;
end;

function TvxImageListBox.GetSelectedFileName: string;
begin
  if (Selected <> nil) then
    Result := Selected.TagString
  else
    Result := '';
end;

function TvxImageListBox.GetSelectedImage: TvxImage;
begin
  if (Selected <> nil) and (Selected.TagObject <> nil) and (Selected.TagObject is TvxImage) then
    Result := TvxImage(Selected.TagObject)
  else
    Result := nil;
end;

procedure TvxImageListBox.SetShowFileName(const Value: boolean);
begin
  if FShowFileName <> Value then
  begin
    FShowFileName := Value;
  end;
end;

procedure TvxImageListBox.SetItemHeight(const Value: single);
var
  i: integer;
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    FDisableAlign := true;
    try
      for i := 0 to Count - 1 do
        ItemByIndex(i).Height := ItemHeight;
    finally
      FDisableAlign := false;
      Realign;
    end;
  end;
end;

procedure TvxImageListBox.Clear;
var
  i: integer;
begin
  for i := 0 to Count - 1 do
    ItemByIndex(i).Tag := 0;
  inherited;
end;

procedure TvxImageListBox.BeginAutoDrag;
begin
  if SelectedImage <> nil then
    FScene.BeginVCLDrag(SelectedImage, SelectedImage.Bitmap);
end;

{ TvxHorzImageListBox }

constructor TvxHorzImageListBox.Create(AOwner: TComponent);
begin
  inherited;
  FItemHeight := 0;
  FItemWidth := Trunc(Height + 10);
  FListStyle := vgListHorizontal;
  if Self is TvxHudHorzImageListBox then
    FResource := 'HudListBoxStyle'
  else
    FResource := 'ListBoxStyle';
end;

procedure TvxListBox.DragDrop(const Data: TvxDragObject;
  const Point: TvxPoint);
var
  Obj: TvxListBoxItem;
  Allow: boolean;
begin
  inherited;
  if FDragItem <> nil then
  begin
    FDragItem.DragLeave;
    FDragItem := nil;
  end;
  with AbsoluteToLocal(Point) do
    Obj := ItemByPoint(X, Y);
  if Obj <> nil then
  begin
    Allow := true;
    if Assigned(OnDragChange) then
      OnDragChange(TvxListBoxItem(Data.Source), Obj, Allow);
    if Allow then
    begin
      Exchange(TvxListBoxItem(Data.Source), Obj);
    end;
  end;
end;

procedure TvxListBox.DragOver(const Data: TvxDragObject;
  const Point: TvxPoint; var Accept: Boolean);
var
  Obj: TvxListBoxItem;
begin
  inherited;
  with AbsoluteToLocal(Point) do
    Obj := ItemByPoint(X, Y);
  if (Obj <> FDragItem) then
  begin
    if FDragItem <> nil then
      FDragItem.DragLeave;
    FDragItem := Obj;
    if FDragItem <> nil then
    begin
      FDragItem.DragEnter(Data, Point);
      Accept := true;
    end
    else
      Accept := false;
  end
  else
    Accept := true;

  if FDragItem = Selected then
    Accept := false;
end;

procedure TvxListBox.Exchange(Item1, Item2: TvxListBoxItem);
begin
  if Item1.Index = FItemIndex then
    FItemIndex := Item2.Index
  else
    if Item2.Index = FItemIndex then
    FItemIndex := Item1.Index;
  FContent.Exchange(Item1, Item2);
end;

type

  TvxMemoLines = class(TvxWideStrings)
  private
    FMemo: TvxMemo;
  protected
    function Get(Index: Integer): WideString; override;
    function GetCount: Integer; override;
    procedure SetUpdateState(Updating: Boolean); override;
  public
    procedure Clear; override;
    procedure Delete(Index: Integer); override;
    procedure Insert(Index: Integer; const S: WideString); override;
  end;

  { TvxMemoLines }

procedure TvxMemoLines.Clear;
begin
  FMemo.ClearLines;
  FMemo.Change;
end;

procedure TvxMemoLines.Delete(Index: Integer);
begin
  FMemo.DeleteLine(Index);
  FMemo.Change;
end;

procedure TvxMemoLines.Insert(Index: Integer; const S: WideString);
begin
  FMemo.InsertLine(Index, S);
  FMemo.Change;
end;

function TvxMemoLines.Get(Index: Integer): WideString;
begin
  Result := FMemo.GetLine(Index);
end;

function TvxMemoLines.GetCount: Integer;
begin
  Result := FMemo.GetLineCount;
end;

procedure TvxMemoLines.SetUpdateState(Updating: Boolean);
begin
  inherited;
  FMemo.SetUpdateState(Updating);
end;

function ComposeCaretPos(ALine, APos: integer): TCaretPosition;
begin
  with Result do
  begin
    Line := ALine;
    Pos := APos;
  end;
end;

{ TvxMemo }

constructor TvxMemo.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FTextAlign := vgTextAlignNear;
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
  FFontFill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FSelectionFill := TvxBrush.Create(vgBrushSolid, $802A8ADF);
  FLines := TvxMemoLines.Create;
  (FLines as TvxMemoLines).FMemo := Self;
  CanFocused := true;
  Cursor := crIBeam;
  FInternalMustUpdateLines := true;

  CreatePopupMenu;

  FActionStack := TEdtActionStack.Create(Self);

  FTextAlignment := taLeftJustify;
  FAutoSelect := true;
  FCharCase := vgecNormal;
  FHideSelection := true;
  FMaxLength := 0;
  FReadOnly := false;

  FLMouseSelecting := false;
  FOldMPt := vgPoint(0, 0);

  FUpdating := false;

  with FCaretPosition do
  begin
    Line := 0;
    Pos := 0;
  end;

  FSelStart := ComposeCaretPos(0, 0);
  FSelEnd := ComposeCaretPos(0, 0);
  FSelected := false;

  FOldSelStartPos := -1;
  FOldSelEndPos := -1;
  FOldCaretPos := -1;

  AutoCapture := true;

  FWidesLineIndex := 0;
  SetLength(FTextWidth, 0);

  Width := 100;
end;

destructor TvxMemo.Destroy;
begin
  if FUnwrapLines <> nil then
    FUnwrapLines.Free;
  FSelectionFill.Free;
  FFontFill.Free;
  FFont.Free;
  FActionStack.Free;
  {$IFNDEF NOVCL}
  FPopupMenu.Free;
  {$ENDIF}
  FLines.Free;
  inherited;
end;

procedure TvxMemo.EnterFocus;
begin
  inherited;
  FNeedChange := false;
  UpdateCaretPosition(false);
  ShowCaretProc;
  if FScene.ShowKeyboardForControl(Self) then
  begin
    CaretPosition := TextPosToPos(Length(Text));
  end
  else
  begin
    with FCaretPosition do
    begin
      Line := 0;
      Pos := 0;
    end;
    if AutoSelect then
      SelectAll;
  end;
end;

procedure TvxMemo.Killfocus;
begin
  FScene.HideKeyboardForControl(Self);
  inherited;
  HideCaret;
  Change;
end;

function TvxMemo.TextWidth(const Str: WideString): single;
var
  R: TvxRect;
begin
  R := ContentRect;
  R.Right := 10000;
  Canvas.Font.Assign(Font);
  Canvas.MeasureText(R, R, Str, false, TextAlign, vgTextAlignCenter);
  Result := vgRectWidth(R);
end;

function TvxMemo.GetPositionPoint(ACaretPos: TCaretPosition): TvxPoint;
var
  WholeTextWidth: single;
  EditRectWidth: single;
  LineText: WideString;
begin
  Result.X := ContentRect.Left;
  Result.Y := ContentRect.Top + (GetLineHeight * ACaretPos.Line) - VScrollBarValue;
  WholeTextWidth := 0;
  if Canvas = nil then
    Exit;

  if (ACaretPos.Line < Lines.Count) and (Lines.Count > 0) then
  begin
    LineText := Lines[ACaretPos.Line];

    WholeTextWidth := TextWidth(LineText);

    if ACaretPos.Pos > 0 then
    begin
      if ACaretPos.Pos <= Length(LineText) then
        Result.X := Result.X + TextWidth(Copy(LineText, 1, ACaretPos.Pos))
      else
        Result.X := Result.X + TextWidth(LineText);
    end;
  end;
  EditRectWidth := ContentRect.Right - ContentRect.Left;
  if WholeTextWidth < EditRectWidth then
    case FTextAlign of
      vgTextAlignFar: Result.X := Result.X + (EditRectWidth - WholeTextWidth);
      vgTextAlignCenter: Result.X := Result.X + ((EditRectWidth - WholeTextWidth) / 2);
    end;
  Result.X := Result.X - HScrollBarValue;
end;

function TvxMemo.GetPointPosition(Pt: TvxPoint): TCaretPosition;
var
  CurX: double;
  TmpX,
    WholeTextWidth,
    EdiTvxRectWidth: single;
  LineText: WideString;
  LLine: integer;
  LPos: integer;
  TmpPt: TvxPoint;
  LEdiTvxRect: TvxRect;
begin
  with Result do
  begin
    Line := 0;
    Pos := 0;
  end;

  if Lines.Count <= 0 then
    Exit;

  LEdiTvxRect := ContentRect;

  with LEdiTvxRect, Pt do
  begin
    if x < Left then
      TmpPt.x := Left
    else
      if x > Right then
      TmpPt.x := Right
    else
      TmpPt.x := x;

    if y < Top then
      TmpPt.y := Top
    else
      if y > Bottom then
      TmpPt.y := Bottom
    else
      TmpPt.y := y;
  end;

  LLine := trunc((TmpPt.Y - ContentRect.Top) / GetLineHeight + trunc(VScrollBarValue / GetLineHeight));

  LPos := 0;

  if LLine > Lines.Count - 1 then
    LLine := Lines.Count - 1;

  LineText := Lines[LLine];

  if Length(LineText) > 0 then
  begin
    WholeTextWidth := TextWidth(LineText);

    EdiTvxRectWidth := ContentRect.Right - ContentRect.Left;
    TmpX := TmpPt.x;
    if WholeTextWidth < EdiTvxRectWidth then
      case TextAlign of
        vgTextAlignFar: TmpX := TmpPt.x - (EdiTvxRectWidth - WholeTextWidth);
        vgTextAlignCenter: TmpX := TmpPt.x - ((EdiTvxRectWidth - WholeTextWidth) / 2);
      end;

    TmpX := TmpX + HScrollBarValue;

    CurX := ContentRect.Left + TextWidth(LineText[1]) / 2;
    while (CurX < TmpX) and (LPos + 1 <= Length(LineText)) and (CurX < ContentRect.Right + HScrollBarValue) do
    begin
      CurX := ContentRect.Left + TextWidth(Copy(LineText, 1, LPos + 1)) + (Font.Size / 4);
      Inc(LPos);
    end;
  end;
  with Result do
  begin
    Line := LLine;
    Pos := LPos;
  end;
end;

procedure TvxMemo.KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
var
  TmpS: WideString;
  OldCaretPosition: TCaretPosition;
  WasSelection: boolean;
  LTmpOptions: TInsertOptions;
begin
  inherited KeyDown(Key, KeyChar, Shift);
  OldCaretPosition := CaretPosition;
  if (Key = VK_RETURN) then
  begin
    WasSelection := SelLength > 0;
    if WasSelection then
      DeleteFrom(GetSelBeg, SelLength, [doMoveCaret, doCanUndo] {true,true, false});
    if WasSelection then
      LTmpOptions := [ioUnDoPairedWithPriv]
    else
      LTmpOptions := [];
    TmpS := #13#10;
    InsertAfter(CaretPosition, TmpS, LTmpOptions + [ioMoveCaret, ioCanUndo] {false, true, true, WasSelection});
    SelLength := 0;
    Key := 0;
  end;
  case Key of
    VK_END:
      if ssCtrl in Shift then
        GoToTextEnd
      else
        GoToLineEnd;
    VK_HOME:
      if ssCtrl in Shift then
        GoToTextBegin
      else
        GoToLineBegin;
    VK_LEFT:
      if ssCtrl in Shift then
        CaretPosition := GetPrivWordBeging(CaretPosition)
      else
        MoveCaretLeft;
    VK_RIGHT:
      if ssCtrl in Shift then
        CaretPosition := GetNextWordBeging(CaretPosition)
      else
        MoveCaretRight;
    VK_UP:
      MoveCaretUp;
    VK_DOWN:
      MoveCaretDown;
    VK_PRIOR:
      MoveCaretPageUp;
    VK_NEXT:
      MoveCaretPageDown;
    VK_DELETE, 8: {Delete or BackSpace key was pressed}
      if not ReadOnly then
      begin
        if SelLength <> 0 then
        begin
          if ssShift in Shift then
            CutToClipboard
          else
            ClearSelection;
        end
        else
        begin
          TmpS := Text;
          if Key = VK_DELETE then
            DeleteFrom(CaretPosition, 1, [doMoveCaret, doCanUndo])
          else {BackSpace key was pressed}
            if PosToTextPos(CaretPosition) > 0 then
            DeleteFrom(GetPositionShift(CaretPosition, -1), 1, [doMoveCaret, doCanUndo]);
        end;
      end;
    VK_INSERT:
      if ssCtrl in Shift then
        CopyToClipboard
      else
        if ssShift in Shift then
        PasteFromClipboard;
  end;

  case KeyChar of
    'a', 'A':
      if Shift = [ssCtrl] then
      begin
        SelectAll;
        KeyChar := #0;
      end;
    'c', 'C':
      if Shift = [ssCtrl] then
      begin
        CopyToClipboard;
        KeyChar := #0;
      end;
    'v', 'V':
      if Shift = [ssCtrl] then
      begin
        PasteFromClipboard;
        KeyChar := #0;
      end;
    'x', 'X':
      if Shift = [ssCtrl] then
      begin
        CutToClipboard;
        KeyChar := #0;
      end;
    'z', 'Z':
      if Shift = [ssCtrl] then
      begin
        {UnDo};
        KeyChar := #0;
      end;
  end;

  if ((Ord(Keychar) >= 32) or (Keychar = #13)) and not ReadOnly then
  begin
    WasSelection := SelLength > 0;
    if WasSelection then
      DeleteFrom(GetSelBeg, SelLength, [doMoveCaret, doCanUndo] {true,true, false});
    if WasSelection then
      LTmpOptions := [ioUnDoPairedWithPriv]
    else
      LTmpOptions := [];
    if Keychar <> #13 then
    begin
      InsertAfter(CaretPosition, KeyChar, LTmpOptions + [ioMoveCaret, ioCanUndo] {false, true, true, WasSelection});
    end
    else
    begin
      TmpS := #13#10;
      InsertAfter(CaretPosition, TmpS, LTmpOptions + [ioMoveCaret, ioCanUndo] {false, true, true, WasSelection});
    end;
    SelLength := 0;
    Keychar := #0;
  end;

  if Key in [VK_END, VK_HOME, VK_LEFT, VK_RIGHT, VK_UP, VK_DOWN, VK_PRIOR, VK_NEXT] then
  begin
    if ssShift in Shift then
    begin
      if not FSelected then
        SelectAtPos(OldCaretPosition);
      SelectAtPos(CaretPosition);
      Repaint;
    end
    else
      if FSelected then
    begin
      FSelected := false;
      Repaint;
    end;
  end;
  UpdateCaretPosition(true);
end;

procedure TvxMemo.MouseDown(Button: TMouseButton; Shift: TShiftState; x, y: single);
begin
  inherited;
  if (Button = mbLeft) and (ssDouble in Shift) then
  begin
    if vgPtInRect(vgPoint(x, y), ContentRect) then
    begin
      FLMouseSelecting := false;
      SelectWord;
    end;
  end;
  if (Button = mbLeft) and vgPtInRect(vgPoint(x, y), ContentRect) then
  begin
    FLMouseSelecting := true;
    CaretPosition := GetPointPosition(vgPoint(x, y));
    FSelected := false;
    SelectAtPos(CaretPosition);
    Repaint;
  end;
end;

function TvxMemo.ContentPos: TvxPoint;
var
  T: TvxObject;
begin
  T := FindResource('content');
  if (T <> nil) and (T.IsVisual) then
  begin
    Result := TvxVisualObject(T).Position.Point;
  end;
end;

procedure TvxMemo.DoContentPaint(Sender: TObject; const Canvas: TvxCanvas; const ARect: TvxRect);
var
  R, TmpRect: TvxRect;
  LSelArea: TSelArea;
  CurSelRect: integer;
  SaveIndex: integer;
  CurChar, CurLine, LEndLine: integer;
  TmpPt: TvxPoint;
  LPageSize: single;
  LLeftTopCharPt: TvxPoint;
begin
  with Canvas do
  begin
    SaveIndex := Canvas.SaveCanvas;
    Canvas.IntersectClipRect(ARect);

    Font.Assign(Font);
    Fill.Assign(FFontFill);

    // text
    R := ContentRect;
    TmpRect := ARect;
    Canvas.Font.Assign(Font);
    LPageSize := GetPageSize;

    LLeftTopCharPt.X := TmpRect.Left;
    LLeftTopCharPt.Y := TmpRect.Top;

    CurLine := trunc(VScrollBarValue / GetLineHeight);
    if round(VScrollBarValue / GetLineHeight) + LPageSize - 1 < Lines.Count - 1 then
      LEndLine := Round(round(VScrollBarValue / GetLineHeight) + LPageSize - 1)
    else
      LEndLine := Lines.Count - 1;
    while CurLine <= LEndLine do
    begin
      TmpPt := GetPositionPoint(ComposeCaretPos(CurLine, 0));
      Canvas.FillText(vgRect(TmpPt.X - R.Left, TmpPt.Y - R.Top, $FFFF, TmpPt.Y - R.Top + (GetLineHeight * 1.25)), LocalRect, Lines[CurLine], false, 1, vgTextAlignNear, vgTextAlignNear);
      Inc(CurLine);
    end;

    // selection
    if IsFocused then
    begin
      LSelArea := GetSelArea;
      if GetShowSelection then
      begin
        Fill.Assign(FSelectionFill);
        for CurSelRect := Low(LSelArea) to High(LSelArea) do
        begin
          vgIntersectRect(TmpRect, LSelArea[CurSelRect], vgRect(0, 0, 1000, 1000));
          vgOffsetRect(TmpRect, -R.Left, -R.Top);
          FillRect(TmpRect, 0, 0, [], 1);
        end;
      end;
    end;
    Canvas.RestoreCanvas(SaveIndex);
  end;
end;

procedure TvxMemo.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('content');
  if (T <> nil) and (T.IsVisual) then
  begin
    TvxVisualObject(T).OnPaint := DoContentPaint;
  end;
  T := FindResource('selection');
  if (T <> nil) and (T is TvxBrushObject) then
  begin
    FSelectionFill.Assign(TvxBrushObject(T).Brush);
  end;
  { from style }
  T := FindResource('foreground');
  if (T <> nil) and (T is TvxBrushObject) then
    FFontFill.Assign(TvxBrushObject(T).Brush);
end;

procedure TvxMemo.UpdateHScrlBarByCaretPos;
var
  LEdiTvxRect: TvxRect;
  LCaretLinePos: integer;
  LCaretLine: integer;
  CurCaretX: integer;
begin
  if Lines.Count <= 0 then
    Exit;
  if Canvas = nil then
    Exit;

  LEdiTvxRect := ContentRect;
  CurCaretX := Round(GetPositionPoint(CaretPosition).X);

  if not ((CurCaretX < LEdiTvxRect.Left) or
    (CurCaretX > LEdiTvxRect.Right)) then
    Exit;

  LCaretLinePos := CaretPosition.Pos;
  LCaretLine := CaretPosition.Line;

  if FFirstVisibleChar >= (LCaretLinePos + 1) then
  begin
    FFirstVisibleChar := LCaretLinePos;
    if FFirstVisibleChar < 1 then
      FFirstVisibleChar := 1;
  end
  else
  begin // caret
    while (TextWidth(Copy(Lines[LCaretLine], FFirstVisibleChar, LCaretLinePos - FFirstVisibleChar + 1)) > LEdiTvxRect.Right - LEdiTvxRect.Left - 5) and (FFirstVisibleChar < Length(Lines[LCaretLine])) do
      Inc(FFirstVisibleChar);
  end;
  if (HScrollBar <> nil) and (HScrollBar.Visible) then
    HScrollBar.Value := TextWidth(Copy(Lines[LCaretLine], 1, FFirstVisibleChar - 1));
end;

procedure TvxMemo.MouseMove(Shift: TShiftState; x, y, dx, dy: single);
var
  LEdiTvxRect: TvxRect;
begin
  inherited;
  FOldMPt := vgPoint(x, y);

  if FLMouseSelecting then
  begin
    LEdiTvxRect := ContentRect;

    {    if y < LEdiTvxRect.Top then
          VScrollBar.AutoScrollUp := true
        else
          if y > LEdiTvxRect.Bottom then
            VScrollBar.AutoScrollDown := true
          else begin
            VScrollBar.AutoScrollDown := false;
            VScrollBar.AutoScrollUp := false;
          end;}

    SelectAtMousePoint;
  end;
end;

procedure TvxMemo.MouseUp(Button: TMouseButton; Shift: TShiftState;
  x, y: single);
begin
  inherited;
  FLMouseSelecting := false;
  if SelLength = 0 then
    FSelected := false;
end;

procedure TvxMemo.CopyToClipboard;
var
  Data: THandle;
  DataPtr: Pointer;
  Size: Cardinal;
  S: WideString;
begin
  {$IFNDEF NOVCL}
  {$IFNDEF FPC}
  if Length(SelText) > 0 then
  begin
    S := SelText;
    begin
      Size := Length(S);
      Data := GlobalAlloc(GMEM_MOVEABLE + GMEM_DDESHARE, 2 * Size + 2);
      try
        DataPtr := GlobalLock(Data);
        try
          Move(PWideChar(S)^, DataPtr^, 2 * Size + 2);
          Clipboard.SetAsHandle(CF_UNICODETEXT, Data);
        finally
          GlobalUnlock(Data);
        end;
      except
        GlobalFree(Data);
        raise;
      end;
    end;
  end;
  {$ELSE}
  if SelText <> '' then
    Clipbrd.Clipboard.AsText := UTF8Encode(SelText);
  {$ENDIF}
  {$ENDIF}
end;

procedure TvxMemo.PasteFromClipboard;
var
  WasSelection: boolean;
  Data: THandle;
  Insertion: WideString;
begin
  if ReadOnly then
    Exit;
  try
    {$IFNDEF NOVCL}
    {$IFNDEF FPC}
    if Clipbrd.Clipboard.HasFormat(CF_UNICODETEXT) then
    begin
      Data := Clipbrd.Clipboard.GetAsHandle(CF_UNICODETEXT);
      try
        if Data <> 0 then
          Insertion := PWideChar(GlobalLock(Data));
      finally
        if Data <> 0 then
          GlobalUnlock(Data);
      end;
    end
    else
      Insertion := Clipbrd.Clipboard.AsText;

    WasSelection := SelLength > 0;
    if WasSelection then
    begin
      DeleteFrom(GetSelBeg, SelLength, [doMoveCaret, doCanUndo]);
      InsertAfter(GetSelBeg, Insertion, [ioMoveCaret, ioCanUndo, ioUndoPairedWithPriv]);
    end
    else
      InsertAfter(CaretPosition, Insertion, [ioMoveCaret, ioCanUndo {, ioUndoPairedWithPriv}]);
    {$ELSE}
    WasSelection := SelLength > 0;
    if WasSelection then
    begin
      DeleteFrom(GetSelBeg, SelLength, [doMoveCaret, doCanUndo]);
      InsertAfter(GetSelBeg, {$IFDEF FPC}UTF8Decode{$ENDIF}(ClipBoard.AsText), [ioMoveCaret, ioCanUndo, ioUndoPairedWithPriv]);
    end
    else
      InsertAfter(CaretPosition, {$IFDEF FPC}UTF8Decode{$ENDIF}(ClipBoard.AsText), [ioMoveCaret, ioCanUndo {, ioUndoPairedWithPriv}]);
    {$ENDIF}
    {$ENDIF}
    Change;
  finally
  end;
end;

procedure TvxMemo.CreatePopupMenu;
{$IFNDEF NOVCL}
var
  TmpItem: TMenuItem;
  {$ENDIF}
begin
  {$IFNDEF NOVCL}
  FPopupMenu := TPopupMenu.Create(Self);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Undo';
    OnClick := DoUndo;
  end;
  FPopupMenu.Items.Add(TmpItem);

  //  FPopupMenu.Items.NewBottomLine;

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Cut';
    OnClick := DoCut;
  end;
  FPopupMenu.Items.Add(TmpItem);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Copy';
    OnClick := DoCopy;
  end;
  FPopupMenu.Items.Add(TmpItem);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Paste';
    OnClick := DoPaste;
  end;
  FPopupMenu.Items.Add(TmpItem);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Delete';
    OnClick := DoDelete;
  end;
  FPopupMenu.Items.Add(TmpItem);

  //  FPopupMenu.Items.NewBottomLine;

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Select All';
    OnClick := DoSelectAll;
  end;
  FPopupMenu.Items.Add(TmpItem);
  {$ENDIF}
end;

procedure TvxMemo.DoCut(Sender: TObject);
begin
  CutToClipboard;
end;

procedure TvxMemo.DoCopy(Sender: TObject);
begin
  CopyToClipboard;
end;

procedure TvxMemo.DoDelete(Sender: TObject);
begin
  ClearSelection;
end;

procedure TvxMemo.DoPaste(Sender: TObject);
begin
  PasteFromClipboard;
end;

procedure TvxMemo.UpdatePopupMenuItems;
var
  SelTextEmpty: boolean;
begin
  SelTextEmpty := SelText <> '';
  {$IFNDEF NOVCL}
  FPopupMenu.Items.Find('Undo').Enabled := FActionStack.AtLeast(1) and not ReadOnly;
  FPopupMenu.Items.Find('Cut').Enabled := SelTextEmpty and not ReadOnly;
  FPopupMenu.Items.Find('Copy').Enabled := SelTextEmpty;
  FPopupMenu.Items.Find('Paste').Enabled := (ClipBoard.AsText <> '') and not ReadOnly;
  FPopupMenu.Items.Find('Delete').Enabled := SelTextEmpty and not ReadOnly;
  FPopupMenu.Items.Find('Select All').Enabled := SelText <> Text;
  {$ENDIF}
end;

function TvxMemo.GetNextWordBeging(StartPosition: TCaretPosition): TCaretPosition;
var
  SpaceFound,
    WordFound: boolean;
  LLineText: WideString;
  CurPos: integer;
  CurLine: integer;
begin
  CurPos := StartPosition.Pos;
  CurLine := StartPosition.Line;

  if StartPosition.Pos < Length(GetLine(StartPosition.Line)) then
  begin
    LLineText := GetLine(StartPosition.Line);

    SpaceFound := false;
    WordFound := false;
    while (CurPos + 2 <= Length(LLineText)) and
      ((not ((LLineText[CurPos + 1] <> ' ') and SpaceFound))
      or not WordFound) do
    begin
      if LLineText[CurPos + 1] = ' ' then
        SpaceFound := true;
      if LLineText[CurPos + 1] <> ' ' then
      begin
        WordFound := true;
        SpaceFound := false;
      end;

      CurPos := CurPos + 1;
    end;
    if not SpaceFound then
      CurPos := CurPos + 1;
  end
  else
    if StartPosition.Line < Lines.Count - 1 then
  begin
    CurLine := CurLine + 1;
    CurPos := 0;
  end;

  with Result do
  begin
    Line := CurLine;
    Pos := CurPos;
  end
end;

function TvxMemo.GetPrivWordBeging(StartPosition: TCaretPosition): TCaretPosition;
var
  WordFound: boolean;
  LLineText: WideString;
  CurPos: integer;
  CurLine: integer;
begin
  Result := StartPosition;

  CurPos := StartPosition.Pos;
  CurLine := StartPosition.Line;

  if StartPosition.Pos > 0 then
  begin
    LLineText := GetLine(StartPosition.Line);

    WordFound := false;
    while (CurPos > 0) and
      ((LLineText[CurPos] <> ' ') or not WordFound) do
    begin
      if LLineText[CurPos] <> ' ' then
        WordFound := true;
      CurPos := CurPos - 1;
    end;
  end
  else
    if (StartPosition.Line - 1 >= 0) and (StartPosition.Line - 1 <= Lines.Count - 1) then
  begin
    CurLine := CurLine - 1;
    CurPos := Length(GetLine(CurLine));
  end;

  with Result do
  begin
    Line := CurLine;
    Pos := CurPos;
  end
end;

procedure TvxMemo.ClearSelection;
begin
  if not ReadOnly then
    DeleteFrom(GetSelBeg, SelLength, [doMoveCaret, doCanUndo]);
end;

procedure TvxMemo.CutToClipboard;
begin
  CopyToClipboard;
  ClearSelection;
end;

procedure TvxMemo.SelectAll;
begin
  FSelStart := TextPosToPos(Length(FText));
  FSelEnd := ComposeCaretPos(0, 0);
  FSelected := true;
  GoToTextEnd;
  Repaint;
end;

procedure TvxMemo.DoSelectAll(Sender: TObject);
begin
  SelectAll;
end;

procedure TvxMemo.DrawPasswordChar(SymbolRect: TvxRect; Selected: boolean);
var
  LRect: TvxRect;
begin
  { !!! Don't forget include clipping rountines
        Char symbol image must not extend out of EdiTvxRect}

  vgIntersectRect(LRect, SymbolRect, ContentRect);

  Canvas.Font.Assign(Font);
  //  if Selected then
  //    Canvas.Font.Color := clHighlightText;
  //  Canvas.Brush.Style := bsClear;
  //  Canvas.TexTvxRect(LRect, SymbolRect.Left, SymbolRect.Top, PasswordChar);
end;

function TvxMemo.CanAutoSize(var NewWidth, NewHeight: Integer): Boolean;
begin
  Result := True;
  NewHeight := Round(GetLineHeight + ContentRect.Top * 2);
end;

procedure TvxMemo.SelectWord;
begin
  FSelStart := GetPrivWordBeging(CaretPosition);
  FSelEnd := GetNextWordBeging(CaretPosition);
  FSelected := true;
  Repaint;
end;

procedure TvxMemo.Change;
begin
  if FNeedChange then
  begin
    if Assigned(FBindingObjects) then
      ToBindingObjects;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxMemo.ContextMenu(const ScreenPosition: TvxPoint);
begin
  inherited;
  if csDesigning in ComponentState then
    Exit;

  UpdatePopupMenuItems;
  {$IFNDEF NOVCL}
  FPopupMenu.PopupComponent := Self;
  FPopupMenu.Popup(round(ScreenPosition.X), round(ScreenPosition.Y));
  {$ENDIF}
end;

procedure TvxMemo.FontChanged(Sender: TObject);
begin
  inherited;
  if not (csLoading in ComponentState) then
  begin
    UpdateLines;
    UpdateCaretPosition(false);
    if not FUpdating then
      Realign;
  end;
end;

procedure TvxMemo.SetText(const Value: WideString);
begin
  if not ValidText(Value) then
    Exit;

  if Value <> Text then
  begin
    if (Value <> '') and (CharCase <> vgecNormal) then
      case CharCase of
        {$IFDEF KS_COMPILER5}
        vgecUpperCase: FText := UpperCase(Value);
        vgecLowerCase: FText := UpperCase(Value);
        {$ELSE}
        vgecUpperCase: FText := WideUpperCase(Value);
        vgecLowerCase: FText := WideUpperCase(Value);
        {$ENDIF}
      end
    else
      FText := Value;

    if FInternalMustUpdateLines then
    begin
      UpdateLines;
      if not FUpdating then
        Realign;
    end;

    if not (csLoading in ComponentState) and Assigned(OnChangeTracking) then
      OnChangeTracking(Self);
    FNeedChange := true;
  end;
end;

procedure TvxMemo.SetCaretPosition(const Value: TCaretPosition);
begin
  if Value.Line > Lines.Count - 1 then
    FCaretPosition.Line := Lines.Count - 1
  else
    FCaretPosition.Line := Value.Line;

  if FCaretPosition.Line < 0 then
    FCaretPosition.Line := 0;

  if Value.Pos < 0 then
    FCaretPosition.Pos := 0
  else
    if Value.Pos > Length(Lines[FCaretPosition.Line]) then
    FCaretPosition.Pos := Length(Lines[FCaretPosition.Line])
  else
    FCaretPosition.Pos := Value.Pos;

  UpdateCaretPosition(true);
end;

procedure TvxMemo.SetSelLength(const Value: integer);
begin
  FSelEnd := TextPosToPos(PosToTextPos(FSelStart) + value);
end;

procedure TvxMemo.SetSelStart(const Value: integer);
begin
  FSelStart := TextPosToPos(value);
end;

procedure TvxMemo.SetAutoSelect(const Value: boolean);
begin
  if FAutoSelect <> Value then
    FAutoSelect := Value;
end;

function TvxMemo.GetSelStart: integer;
begin
  if FSelected then
    Result := PosToTextPos(GetSelBeg)
  else
    Result := PosToTextPos(CaretPosition);
end;

function TvxMemo.GetSelArea: TSelArea;
var
  BegLine, EndLine, CurLine: integer;
  LPageSize: single;
  SelBegLineVisible, SelEndLineVisible: boolean;
begin
  if not FSelected then
  begin
    SetLength(Result, 0);
    Exit;
  end;

  SelBegLineVisible := true;
  SelEndLineVisible := true;

  BegLine := GetSelBeg.Line;

  if BegLine < trunc(VScrollBarValue / GetLineHeight) then
  begin
    BegLine := trunc(VScrollBarValue / GetLineHeight);
    SelBegLineVisible := false;
  end;

  EndLine := GetSelEnd.Line;
  LPageSize := GetPageSize;

  if EndLine > round(VScrollBarValue / GetLineHeight) + LPageSize - 1 then
  begin
    EndLine := Round(round(VScrollBarValue / GetLineHeight) + LPageSize - 1);
    SelEndLineVisible := false;
  end;

  if EndLine < BegLine then
    EndLine := BegLine;

  SetLength(Result, EndLine - BegLine + 1);

  CurLine := BegLine;
  while (CurLine <= EndLine) and (CurLine < Lines.Count) do
  begin
    with Result[CurLine - BegLine] do
    begin
      Left := GetPositionPoint(ComposeCaretPos(CurLine, 0)).x;
      Right := GetPositionPoint(ComposeCaretPos(CurLine, Length(Lines[CurLine]))).x;
      Top := GetPositionPoint(ComposeCaretPos(CurLine, 0)).y;
      Bottom := GetPositionPoint(ComposeCaretPos(CurLine, 0)).y + GetLineHeight;
    end;
    Inc(CurLine);
  end;

  if EndLine - BegLine >= 0 then
  begin
    if SelBegLineVisible then
      Result[0].Left := GetPositionPoint(ComposeCaretPos(BegLine, GetSelBeg.Pos)).x;
    if SelEndLineVisible then
      Result[EndLine - BegLine].Right := GetPositionPoint(ComposeCaretPos(EndLine, GetSelEnd.Pos)).x;
  end;
end;

function TvxMemo.GetSelLength: integer;
begin
  if FSelected then
    Result := PosToTextPos(GetSelEnd) - PosToTextPos(GetSelBeg)
  else
    Result := 0;
end;

function TvxMemo.GetSelText: WideString;
var
  LSelStart,
    LSelLength: Integer;
begin
  if FSelected then
  begin
    LSelStart := SelStart;
    LSelLength := SelLength;
    Result := Copy(Text, LSelStart + 1, LSelLength);
  end
  else
    Result := '';
end;

procedure TvxMemo.SetCharCase(const Value: TEditCharCase);
var
  TmpS: WideString;
begin
  if FCharCase <> Value then
  begin
    FCharCase := Value;
    if Text <> '' then
    begin
      TmpS := Text;
      {      case Value of
              vgecUpperCase: Text := WideString(CharUpper(PChar(TmpS)));
              vgecLowerCase: Text := WideString(CharLower(PChar(TmpS)));
            end;}
    end;
  end;
end;

procedure TvxMemo.SetHideSelection(const Value: Boolean);
begin
  if FHideSelection <> Value then
  begin
    FHideSelection := Value;
    Repaint;
  end;
end;

procedure TvxMemo.SetMaxLength(const Value: Integer);
begin
  if FMaxLength <> Value then
  begin
    FMaxLength := Value;
  end;
end;

function TvxMemo.ValidText(NewText: WideString): boolean;
begin
  Result := true;
end;

procedure TvxMemo.SetTextAlignment(const Value: TAlignment);
begin
  if FTextAlignment <> Value then
  begin
    FTextAlignment := Value;
    Repaint;
  end;
end;

procedure TvxMemo.UpdateCaretPosition(UpdateScrllBars: boolean);
var
  TmpPt: TvxPoint;
  TmpRect: TvxRect;
begin
  if UpdateScrllBars then
  begin
    UpdateVScrlBarByCaretPos;
    UpdateHScrlBarByCaretPos;
  end;
  TmpRect := ContentRect;
  TmpPt := GetPositionPoint(CaretPosition);
  TmpPt.X := TmpPt.X + HScrollBarValue - TmpRect.Left;
  TmpPt.Y := TmpPt.Y + VScrollBarValue - TmpRect.Top;
  SetCaretSize(vgPoint(2, GetLineHeight));
  SetCaretPos(TmpPt);
  SetCaretColor(FFontFill.SolidColor);
end;

function TvxMemo.GetLineRealEnd(AStartPos: TCaretPosition; PText: PWideString): TCaretPosition;
begin
  Result.Line := AStartPos.Line;
  while (Result.Line + 1 <= Lines.Count - 1) and
    (GetLineInternal(Result.Line) = GetLine(Result.Line)) do
    Result.Line := Result.Line + 1;

  if (Result.Line <= Lines.Count - 1) and (Lines.Count > 0) then
  begin
    Result.Pos := Length(GetLine(Result.Line)) + FLinesBegs[Result.Line] - 1
  end
  else
    Result.Pos := 0;
end;

function TvxMemo.FillLocalLinesBegs(PText: PWideString; ABegChar, AEndChar: integer; TmpLinesBegs: PLinesBegs): integer;
var
  WStartChar, WSaveChar, WCurChar: integer;
  LCurChar, LSaveChar: integer;
  TmpS: WideString;
  TmpSWidth, WWidth: single;
  LTmpWidth: single;
  LEditRectWidth: single;
  Tok: WideString;
  LLongestLineWidth: single;
  CurLineIsEmpty: boolean;
  LWidth: single;
  i: integer;
  LLocalWidesLineWidth: integer;
begin
  Result := 0;
  SetLength(TmpLinesBegs^, 0);

  if PText^ = '' then
    Exit;

  LCurChar := ABegChar;
  TmpS := '';
  LTmpWidth := 0;
  CurLineIsEmpty := true;

  with ContentRect do
    LEditRectWidth := Right - Left;

  Result := -1;
  LLocalWidesLineWidth := -1;
  while LCurChar <= AEndChar do
  begin
    if (PText^[LCurChar] = #13) or (PText^[LCurChar] = #10) then
    begin
      LSaveChar := LCurChar - 1; // before #13
      if (PText^[LCurChar] = #13) and (LCurChar + 1 <= Length(PText^)) then
        if PText^[LCurChar + 1] = #10 then
          Inc(LCurChar);

      TmpSWidth := TextWidth(TmpS);
      if LLongestLineWidth < TmpSWidth then
      begin
        LLongestLineWidth := TmpSWidth;
        Result := Length(TmpLinesBegs^) - 1;
      end;

      if FWordWrap and (TextWidth(TmpS) > LEditRectWidth) then
      begin
        WCurChar := 1;
        WStartChar := 1;
        WSaveChar := 1;
        Tok := vgWideGetToken(WCurChar, TmpS, ' ,-');
        while Tok <> '' do
        begin
          WWidth := TextWidth(Copy(TmpS, WStartChar, WCurChar - WStartChar));
          if WWidth > LEditRectWidth then
          begin
            WStartChar := WSaveChar;
            SetLength(TmpLinesBegs^, Length(TmpLinesBegs^) + 1);
            TmpLinesBegs^[Length(TmpLinesBegs^) - 1] := LCurChar - Length(TmpS) + WSaveChar - 2;
          end;
          WSaveChar := WCurChar;
          Tok := vgWideGetToken(WCurChar, TmpS, ' ,-');
          if WSaveChar = WCurChar then
            Break; {!!! - error }
        end;
      end;

      SetLength(TmpLinesBegs^, Length(TmpLinesBegs^) + 1);
      TmpLinesBegs^[Length(TmpLinesBegs^) - 1] := LCurChar + 1;

      TmpS := '';
      LTmpWidth := 0;
      CurLineIsEmpty := true;
    end
    else
    begin
      CurLineIsEmpty := false;
      TmpS := TmpS + PText^[LCurChar];
    end;
    Inc(LCurChar);
  end;
  if FWordWrap and (TextWidth(TmpS) > LEditRectWidth) then
  begin
    WCurChar := 1;
    WStartChar := 1;
    WSaveChar := 1;
    Tok := vgWideGetToken(WCurChar, TmpS, ' ,-');
    while Tok <> '' do
    begin
      WWidth := TextWidth(Copy(TmpS, WStartChar, WCurChar - WStartChar));
      if WWidth > LEditRectWidth then
      begin
        WStartChar := WSaveChar;
        SetLength(TmpLinesBegs^, Length(TmpLinesBegs^) + 1);
        TmpLinesBegs^[Length(TmpLinesBegs^) - 1] := LCurChar - Length(TmpS) + WSaveChar - 1;
      end;
      WSaveChar := WCurChar;
      Tok := vgWideGetToken(WCurChar, TmpS, ' ,-');
      if WSaveChar = WCurChar then
        Break; {!!! - error }
    end;
  end
  else
  begin
    LWidth := Canvas.TextWidth(TmpS);
    if LWidth > LLocalWidesLineWidth then
      Result := Length(TmpLinesBegs^) - 1;
  end;
  if Length(TmpLinesBegs^) = 0 then
    Result := 0;
end;

procedure TvxMemo.UpdateLines;
const
  Sep: WideString = ' ,-.;:'#65292;
var
  WStartChar, WSaveChar, WCurChar: integer;
  LCurChar, LSaveChar: integer;
  TmpS: WideString;
  TmpSWidth, WWidth: single;
  LTmpWidth: single;
  LEditRectWidth: single;
  Tok, LText: WideString;
  LLongestLineWidth: single;
  CurLineIsEmpty: boolean;
  i: integer;
begin
  FWidesLineIndex := 0;
  SetLength(FLinesBegs, 0);
  if Text = '' then
    Exit;

  SetLength(FLinesBegs, 0);
  SetLength(FLinesBegs, 1);
  with ContentRect do
    LEditRectWidth := Right - Left;
  if Canvas = nil then
    Exit;

  // first check linecreaks
  LText := Text;
  TmpS := '';
  LCurChar := 1;
  LTmpWidth := 0;
  CurLineIsEmpty := true;
  FLinesBegs[0] := 1;
  LLongestLineWidth := 0;
  while LCurChar <= Length(LText) do
  begin
    if (LText[LCurChar] = #13) or (LText[LCurChar] = #10) then
    begin
      LSaveChar := LCurChar - 1; // before #13
      if (LText[LCurChar] = #13) and (LCurChar + 1 <= Length(LText)) then
        if LText[LCurChar + 1] = #10 then
          Inc(LCurChar);

      TmpSWidth := TextWidth(TmpS);
      if LLongestLineWidth < TmpSWidth then
      begin
        LLongestLineWidth := TmpSWidth;
        FWidesLineIndex := Length(FLinesBegs) - 1;
      end;

      if FWordWrap and (TextWidth(TmpS) > LEditRectWidth) then
      begin
        WCurChar := 1;
        WStartChar := 1;
        WSaveChar := 1;
        Tok := vgWideGetToken(WCurChar, TmpS, Sep);
        while Tok <> '' do
        begin
          WWidth := TextWidth(Copy(TmpS, WStartChar, WCurChar - WStartChar));
          if WWidth > LEditRectWidth then
          begin
            WStartChar := WSaveChar;
            SetLength(FLinesBegs, Length(FLinesBegs) + 1);
            FLinesBegs[Length(FLinesBegs) - 1] := LCurChar - Length(TmpS) + WSaveChar - 2;
          end;
          WSaveChar := WCurChar;
          Tok := vgWideGetToken(WCurChar, TmpS, Sep);
          if WSaveChar = WCurChar then
            Break; {!!! - error }
        end;
      end;

      SetLength(FLinesBegs, Length(FLinesBegs) + 1);
      FLinesBegs[Length(FLinesBegs) - 1] := LCurChar + 1;

      TmpS := '';
      LTmpWidth := 0;
      CurLineIsEmpty := true;
    end
    else
    begin
      CurLineIsEmpty := false;
      TmpS := TmpS + LText[LCurChar];
    end;
    Inc(LCurChar);
  end;
  // last line
  if FWordWrap and (TextWidth(TmpS) > LEditRectWidth) then
  begin
    WCurChar := 1;
    WStartChar := 1;
    WSaveChar := 1;
    Tok := vgWideGetToken(WCurChar, TmpS, Sep);
    while Tok <> '' do
    begin
      WWidth := TextWidth(Copy(TmpS, WStartChar, WCurChar - WStartChar));
      if WWidth > LEditRectWidth then
      begin
        WStartChar := WSaveChar;
        SetLength(FLinesBegs, Length(FLinesBegs) + 1);
        FLinesBegs[Length(FLinesBegs) - 1] := LCurChar - Length(TmpS) + WSaveChar - 1;
      end;
      WSaveChar := WCurChar;
      Tok := vgWideGetToken(WCurChar, TmpS, Sep);
      if WSaveChar = WCurChar then
        Break; {!!! - error }
    end;
  end
  else
    if LLongestLineWidth < Canvas.TextWidth(TmpS) then
    FWidesLineIndex := Length(FLinesBegs) - 1;
end;

procedure TvxMemo.UpdateRngLinesBegs(PText: PWideString; AUpdBegLine, AUpdEndLine, AUpdBegChar, AUpdEndChar, ACharDelta, AOldWideslLineWidth: integer);
var
  LUpdEndChar,
    LNewWidesLineIndex,
    LLineDelta, i: integer;
  LTmpLinesBegs: TLinesBegs;
begin
  if (Length(FLinesBegs) = 0) and (PText^ <> '') then
  begin
    SetLength(FLinesBegs, 1);
    FLinesBegs[0] := 1;
  end;

  LUpdEndChar := AUpdEndChar + ACharDelta;
  LNewWidesLineIndex := FillLocalLinesBegs(PText, AUpdBegChar, LUpdEndChar, @LTmpLinesBegs) + AUpdBegLine;

  LLineDelta := Length(LTmpLinesBegs) - (AUpdEndLine - AUpdBegLine);

  if LLineDelta > 0 then
  begin
    SetLength(FLinesBegs, Length(FLinesBegs) + LLineDelta);
    for i := Length(FLinesBegs) - 1 downto AUpdEndLine + 1 + LLineDelta do
      FLinesBegs[i] := FLinesBegs[i - LLineDelta] + ACharDelta;
  end
  else
  begin
    for i := AUpdBegLine + 1 to Length(FLinesBegs) - 1 + LLineDelta do
      FLinesBegs[i] := FLinesBegs[i - LLineDelta] + ACharDelta;
    SetLength(FLinesBegs, Length(FLinesBegs) + LLineDelta);
  end;

  for i := 0 to Length(LTmpLinesBegs) - 1 do
    if AUpdBegLine + i + 1 <= Length(FLinesBegs) - 1 then
      FLinesBegs[AUpdBegLine + i + 1] := LTmpLinesBegs[i];

  if FWidesLineIndex > Length(FLinesBegs) - 1 then
    FWidesLineIndex := Round(GetWidestLine)
  else
    if LineWidth[LNewWidesLineIndex] >= AOldWideslLineWidth then
    FWidesLineIndex := LNewWidesLineIndex
  else
    if not ((FWidesLineIndex < AUpdBegLine) or (FWidesLineIndex > AUpdEndLine)) then
    FWidesLineIndex := GetWidestLine;

  if not FUpdating then
    Realign;
end;

procedure TvxMemo.InsertAfter(Position: TCaretPosition; S: WideString; Options: TInsertOptions);
var
  LText: WideString;
  Insertion: WideString;
  LUpdBegLine, LUpdBegChar, LUpdEndLine, LUpdEndChar: integer;
  R: integer;
  LInsertionLength: integer;
  LOldWideslLineWidth: single;
begin
  R := PosToTextPos(CaretPosition);
  LText := Text;
  Insertion := S;
  if MaxLength > 0 then
    Insertion := Copy(Insertion, 1, MaxLength - Length(LText));

  if ioCanUndo in Options then
    FActionStack.FragmentInserted(PosToTextPos(Position), Length(S), ioUnDoPairedWithPriv in Options);

  LUpdBegLine := Position.Line;
  if (Length(FLinesBegs) > 0) and (Position.Line <= Length(FLinesBegs) - 1) then
    LUpdBegChar := FLinesBegs[Position.Line]
  else
    LUpdBegChar := 1;

  with GetLineRealEnd(Position, @LText) do
  begin
    LUpdEndLine := Line;
    LUpdEndChar := Pos;
  end;

  LInsertionLength := Length(Insertion);
  LOldWideslLineWidth := LineWidth[FWidesLineIndex];

  Insert(Insertion, LText, PosToTextPos(Position) + 1);
  try
    FInternalMustUpdateLines := false;
    Text := LText;
  finally
    FInternalMustUpdateLines := true;
  end;

  UpdateRngLinesBegs(@LText, LUpdBegLine, LUpdEndLine,
    LUpdBegChar, LUpdEndChar, LInsertionLength, Round(LOldWideslLineWidth));

  if ioSelected in Options then
  begin
    FSelStart := Position;
    FSelEnd := GetPositionShift(Position, Length(Insertion));
    FSelected := true;
    CaretPosition := FSelEnd;
  end
  else
  begin
    if not (csLoading in ComponentState) then
    begin
      CaretPosition := TextPosToPos(R + Length(Insertion));
      UpdateCaretPosition(false);
    end;
  end;

  if not FUpdating then
    Realign;
end;

procedure TvxMemo.DeleteFrom(Position: TCaretPosition; ALength: integer; Options: TDeleteOptions);
var
  LUpdBegLine, LUpdEndLine,
    LUpdBegChar, LUpdEndChar: integer;
  LText: WideString;
  LTmpPos, LTmpLength: integer;
  LOldWideslLineWidth: integer;
begin
  LText := Text;

  LTmpLength := ALength;
  LTmpPos := PosToTextPos(Position) + 1;

  if (LTmpPos + ALength - 1 + 1 <= System.Length(LText)) and
    (LTmpPos + ALength - 1 >= 1) and
    (LText[LTmpPos + ALength - 1] = #13) and
    (LText[LTmpPos + ALength - 1 + 1] = #10) then
    LTmpLength := LTmpLength + 1;

  if (LTmpPos - 1 >= 0) and
    (LTmpPos <= System.Length(LText)) and
    (LText[LTmpPos] = #10) and
    (LText[LTmpPos - 1] = #13) then
  begin
    LTmpLength := LTmpLength + 1;
    LTmpPos := LTmpPos - 1;
  end;

  if (doCanUndo in Options) and (LTmpLength > 0) then
    FActionStack.FragmentDeleted(LTmpPos, Copy(LText, LTmpPos, LTmpLength));

  LUpdBegLine := Position.Line;
  if Position.Line <= Length(FLinesBegs) - 1 then
    LUpdBegChar := FLinesBegs[Position.Line]
  else
    LUpdBegChar := 1;

  with GetLineRealEnd(GetPositionShift(Position, LTmpLength - 1), @LText) do
  begin
    LUpdEndLine := Line;
    LUpdEndChar := Pos;
  end;

  LOldWideslLineWidth := Round(LineWidth[FWidesLineIndex]);

  Delete(LText, LTmpPos, LTmpLength);

  try
    FInternalMustUpdateLines := false;
    Text := LText;
  finally
    FInternalMustUpdateLines := true;
  end;

  UpdateRngLinesBegs(@LText, LUpdBegLine, LUpdEndLine,
    LUpdBegChar, LUpdEndChar, -LTmpLength, LOldWideslLineWidth);

  if (doMoveCaret in Options) or (SelLength <> 0) then
  begin
    FSelected := false;
    CaretPosition := Position;
  end;

  if not FUpdating then
    Realign;
end;

procedure TvxMemo.DoUndo(Sender: TObject);
begin
  UnDo;
end;

procedure TvxMemo.UnDo;
begin
  FActionStack.RollBackAction;
end;

function TvxMemo.GetContentBounds: TvxRect;
begin
  Result := inherited GetContentBounds;
  if FWordWrap then
  begin
    StorePositions;
    UpdateLines;
    RestorePositions;
  end;
  if Lines.Count > 0 then
    Result.Bottom := Result.Top + (Lines.Count * GetLineHeight);
  // Updating Horizontal scrollbar params
  if not FWordWrap and (TextWidth(Lines[FWidesLineIndex]) > (Result.Right - Result.Left)) then
    Result.Right := Result.Left + TextWidth(Lines[FWidesLineIndex]) + 10; // for caret
  UpdateHScrlBarByCaretPos;
end;

procedure TvxMemo.SetLines(const Value: TvxWideStrings);
begin
  FLines.Assign(Value);
end;

function TvxMemo.TextPosToPos(APos: integer): TCaretPosition;
var
  CurRangeBeg, CurRangeEnd: integer;
  TmpI: integer;
begin
  with Result do
  begin
    Line := 0;
    Pos := 0;
  end;

  if Lines.Count <= 0 then
    Exit;

  CurRangeBeg := 0;
  CurRangeEnd := Length(FLinesBegs) - 1;
  repeat
    if ((CurRangeBeg < Length(FLinesBegs) - 1) and
      (APos + 1 >= FLinesBegs[CurRangeBeg]) and
      (APos + 1 < FLinesBegs[CurRangeBeg + 1]))
      or ((CurRangeBeg = Length(FLinesBegs) - 1) and
      (APos + 1 >= FLinesBegs[CurRangeBeg]))
      then
      CurRangeEnd := CurRangeBeg
    else
    begin
      if APos + 1 < FLinesBegs[CurRangeBeg] then
      begin
        TmpI := CurRangeEnd - CurRangeBeg + 1;
        CurRangeEnd := CurRangeBeg;
        CurRangeBeg := CurRangeBeg - TmpI div 2;
      end
      else
        if APos + 1 >= FLinesBegs[CurRangeEnd] then
      begin
        TmpI := CurRangeEnd - CurRangeBeg + 1;
        CurRangeBeg := CurRangeEnd;
        CurRangeEnd := CurRangeEnd + TmpI div 2;
      end
      else
        CurRangeEnd := (CurRangeBeg + CurRangeEnd) div 2;

      if CurRangeBeg < 0 then
        CurRangeBeg := 0;

      if CurRangeEnd < 0 then
        CurRangeEnd := 0;

      if CurRangeEnd > Length(FLinesBegs) - 1 then
        CurRangeEnd := Length(FLinesBegs) - 1;

      if CurRangeBeg > Length(FLinesBegs) - 1 then
        CurRangeBeg := Length(FLinesBegs) - 1;
    end;

  until CurRangeBeg = CurRangeEnd;
  Result.Line := CurRangeBeg;

  if Result.Line <= Length(FLinesBegs) - 1 then
    Result.Pos := APos - FLinesBegs[Result.Line] + 1;
end;

procedure TvxMemo.MoveCaretLeft;
begin
  MoveCareteBy(-1);
end;

procedure TvxMemo.MoveCaretRight;
begin
  MoveCareteBy(1);
end;

procedure TvxMemo.MoveCareteBy(Delta: integer);
begin
  CaretPosition := GetPositionShift(CaretPosition, Delta);
end;

procedure TvxMemo.VScrollChange(Sender: TObject);
begin
  inherited;
  UpdateCaretPosition(false);
end;

function TvxMemo.GetLineHeight: single;
begin
  Result := round(FFont.Size * (1.25));
end;

procedure TvxMemo.HScrlBarChange(Sender: TObject);
begin
  Repaint;
  UpdateCaretPosition(false);
end;

procedure TvxMemo.UpdateVScrlBarByCaretPos;
var
  LCaretPosLine: integer;
  LPageSize: single;
begin
  LCaretPosLine := CaretPosition.Line;
  LPageSize := GetPageSize;

  if (VScrollBar <> nil) and (LCaretPosLine * GetLineHeight < VScrollBarValue) then
    VScrollBar.Value := LCaretPosLine * GetLineHeight;

  if (VScrollBar <> nil) and ((LCaretPosLine + 1) * GetLineHeight > VScrollBarValue + ContentLayout.Height) then
    VScrollBar.Value := (LCaretPosLine - LPageSize + 1) * GetLineHeight;
end;

procedure TvxMemo.SetWordWrap(const Value: boolean);
begin
  if FWordWrap <> Value then
  begin
    FWordWrap := Value;
    UpdateLines;
    if not FUpdating then
      Realign;
    UpdateCaretPosition(false);
  end;
end;

procedure TvxMemo.GetLineBounds(LineIndex: integer; var LineBeg,
  LineLength: integer);
begin
  if Length(FLinesBegs) = 0 then
  begin
    LineBeg := 1;
    LineLength := 0;
    Exit;
  end;

  if (LineIndex <= Length(FLinesBegs) - 1) and (LineIndex >= 0) then
  begin
    LineBeg := FLinesBegs[LineIndex];
    if (LineIndex + 1 < Length(FLinesBegs)) then
      LineLength := FLinesBegs[LineIndex + 1] - LineBeg
    else
      LineLength := Length(Text) - LineBeg + 1;
  end
  else
  begin
    LineBeg := 0;
    LineLength := 0;
  end;
end;

function TvxMemo.GetLineCount: integer;
begin
  if Text <> '' then
    Result := Length(FLinesBegs)
  else
    Result := 0;
end;

function TvxMemo.GetLine(Index: integer): WideString;
begin
  Result := GetLineInternal(Index);
  if Length(Result) > 0 then
    if Result[Length(Result)] = #10 then
      Delete(Result, Length(Result), 1);
  if Length(Result) > 0 then
    if Result[Length(Result)] = #13 then
      Delete(Result, Length(Result), 1);
end;

procedure TvxMemo.InsertLine(Index: Integer; const S: WideString);
begin
  if Index < GetLineCount then
    InsertAfter(ComposeCaretPos(Index, 0), S + #13 + #10, [])
  else
    if (Index > 0) and (GetLineCount > 0) then
  begin
    InsertAfter(ComposeCaretPos(Index - 1, Length(GetLineInternal(Index - 1))), #13 + #10 + S, [])
  end
  else
    InsertAfter(ComposeCaretPos(Index, 0), S, []);
end;

procedure TvxMemo.DeleteLine(Index: Integer);
begin
  if Index = GetLineCount - 1 then
    DeleteFrom(ComposeCaretPos(Index - 1, Length(GetLineInternal(Index - 1))) {LLineBeg-1}, Length(GetLineInternal(Index)) + 1, [])
  else
    DeleteFrom(ComposeCaretPos(Index, 0) {LLineBeg}, Length(GetLineInternal(Index)) + 1, []);
end;

procedure TvxMemo.ClearLines;
begin
  Text := '';
end;

procedure TvxMemo.SelectAtMousePoint;
var
  TmpPt: TvxPoint;
  LEdiTvxRect: TvxRect;
begin
  LEdiTvxRect := ContentRect;
  TmpPt := FOldMPt;
  with TmpPt, LEdiTvxRect do
  begin
    if y < Top then
      y := Top
    else
      if y > Bottom then
      y := Bottom;

    if x < Left then
      x := Left
    else
      if x > Right then
      x := Right;
  end;

  CaretPosition := GetPointPosition(TmpPt);
  SelectAtPos(CaretPosition);
  Repaint;
end;

function TvxMemo.GetPageSize: single;
begin
  with ContentRect do
    Result := (Bottom - Top) / GetLineHeight;
end;

function TvxMemo.GetLineWidth(LineNum: Integer): single;
begin
  if (LineNum >= 0) and (LineNum <= Lines.Count - 1) then
  begin
    Result := Canvas.TextWidth(Lines[LineNum]);
  end
  else
    Result := 0;
end;

function TvxMemo.PosToTextPos(APostion: TCaretPosition): integer;
var
  LTmpLine: integer;
begin
  Result := 0;
  if Text = '' then
    Exit;

  with APostion do
  begin
    if Line <= Length(FLinesBegs) - 1 then
      LTmpLine := Line
    else
      LTmpLine := Length(FLinesBegs) - 1;

    if LTmpLine < 0 then
      exit;

    Result := FLinesBegs[LTmpLine];

    if Pos <= Length(GetLineInternal(LTmpLine)) then
      Result := Result + Pos - 1
    else
      Result := Result + Length(GetLineInternal(LTmpLine)) - 1;

  end;
end;

function TvxMemo.GetLineInternal(Index: integer): WideString;
var
  LLineBeg, LLineLength: integer;
begin
  GetLineBounds(Index, LLineBeg, LLineLength);
  Result := Copy(Text, LLineBeg, LLineLength);
end;

procedure TvxMemo.GoToTextBegin;
begin
  with FCaretPosition do
  begin
    Line := 0;
    Pos := 0;
  end;
end;

procedure TvxMemo.GoToTextEnd;
begin
  with FCaretPosition do
  begin
    Line := Lines.Count - 1;
    if Line >= 0 then
      Pos := Length(Lines[Line])
    else
      Pos := 0;
  end;
end;

procedure TvxMemo.GoToLineEnd;
begin
  with FCaretPosition do
  begin
    if Line <= Lines.Count - 1 then
      Pos := Length(GetLine(CaretPosition.Line));
  end;
end;

procedure TvxMemo.GoToLineBegin;
begin
  with FCaretPosition do
  begin
    Pos := 0;
  end;
end;

function TvxMemo.GetSelBeg: TCaretPosition;
begin
  if FSelStart.Line < FSelEnd.Line then
    Result := FSelStart
  else
    if FSelEnd.Line < FSelStart.Line then
    Result := FSelEnd
  else
    if FSelStart.Pos < FSelEnd.Pos then
    Result := FSelStart
  else
    Result := FSelEnd;
end;

function TvxMemo.GetSelEnd: TCaretPosition;
begin
  if FSelStart.Line > FSelEnd.Line then
    Result := FSelStart
  else
    if FSelEnd.Line > FSelStart.Line then
    Result := FSelEnd
  else
    if FSelStart.Pos > FSelEnd.Pos then
    Result := FSelStart
  else
    Result := FSelEnd;
end;

procedure TvxMemo.SelectAtPos(APos: TCaretPosition);
begin
  if not FSelected then
  begin
    FSelStart := APos;
    FSelEnd := APos;
    FSelected := true;
  end
  else
  begin
    FSelEnd := APos;
  end;
end;

function TvxMemo.GetPositionShift(APos: TCaretPosition;
  Delta: integer): TCaretPosition;
var
  LNewPos: TCaretPosition;
  LNewTextPos: integer;
  i: integer;
  CurLineText: WideString;
begin
  LNewPos := APos;
  with LNewPos do
    if Delta >= 14 then
    begin
      LNewTextPos := PosToTextPos(CaretPosition) + Delta;

      if Delta > 0 then
      begin
        if (LNewTextPos + 1 <= Length(Text)) and
          (Text[LNewTextPos + 1] = #10) then
          Inc(LNewTextPos);
      end
      else
        if Delta < 0 then
      begin
        if (LNewTextPos + 1 - 1 >= Length(Text)) and
          (Text[LNewTextPos + 1 - 1] = #10) then
          Dec(LNewTextPos);
      end;

      LNewPos := TextPosToPos(LNewTextPos);
    end
    else
    begin
      CurLineText := GetLineInternal(Line);
      if Delta > 0 then
      begin
        i := 1;
        while i <= Delta do
        begin
          Pos := Pos + 1;
          if (Pos + 1 <= Length(CurLineText)) and (CurLineText[Pos + 1] = #10) then
          begin
            Inc(Pos);
            Inc(i);
          end;
          if Pos + 1 > Length(CurLineText) then
          begin
            if Line + 1 <= Lines.Count - 1 then
            begin
              Line := Line + 1;
              CurLineText := GetLineInternal(Line);
              Pos := 0;
            end
            else
              Pos := Length(CurLineText);
          end;
          Inc(i);
        end;
      end
      else
      begin {Delta < 0}
        i := 1;
        while i <= Abs(Delta) do
        begin
          if Pos - 1 >= 0 then
            Pos := Pos - 1
          else
          begin
            if Line - 1 >= 0 then
            begin
              Line := Line - 1;
              CurLineText := GetLineInternal(Line);
              if CurLineText[Length(CurLineText)] = #10 then
                Pos := Length(CurLineText) - 2
              else
                Pos := Length(CurLineText) - 1;
            end;
          end;
          Inc(i);
        end;
      end;
    end;
  Result := LNewPos;
end;

procedure TvxMemo.RestorePositions;
begin
  if FOldCaretPos >= 0 then
    CaretPosition := TextPosToPos(FOldCaretPos);
  if FSelected and (FOldSelStartPos >= 0) then
  begin
    FSelStart := TextPosToPos(FOldSelStartPos);
    FSelEnd := TextPosToPos(FOldSelEndPos);
    FOldSelStartPos := -1;
  end;
end;

procedure TvxMemo.StorePositions;
begin
  FOldCaretPos := PosToTextPos(CaretPosition);
  if FSelected then
  begin
    FOldSelStartPos := PosToTextPos(FSelStart);
    FOldSelEndPos := PosToTextPos(FSelEnd);
  end;
end;

procedure TvxMemo.MoveCaretVertical(LineDelta: integer);
var
  NewLine, NewY, OldX: integer;
begin
  with FCaretPosition do
  begin
    NewLine := Line + LineDelta;
    if NewLine < 0 then
      NewLine := 0
    else
      if NewLine > Lines.Count - 1 then
      NewLine := Lines.Count - 1;

    NewY := Round(GetPositionPoint(ComposeCaretPos(NewLine, Pos)).Y);
    OldX := Round(GetPositionPoint(CaretPosition).X);
    Line := NewLine;
    Pos := Round(GetPointPosition(vgPoint(OldX, NewY)).Pos);
  end;
end;

procedure TvxMemo.MoveCaretDown;
begin
  MoveCaretVertical(1);
end;

procedure TvxMemo.MoveCaretUp;
begin
  MoveCaretVertical(-1);
end;

procedure TvxMemo.MoveCaretPageDown;
begin
  MoveCaretVertical(round(GetPageSize));
end;

procedure TvxMemo.MoveCaretPageUp;
begin
  MoveCaretVertical(-round(GetPageSize));
end;

function TvxMemo.GetWidestLine: integer;
var
  i: integer;
  LWidth, LMaxWidth: single;
begin
  Result := -1;
  LMaxWidth := -1;
  for i := 0 to Lines.Count - 1 do
  begin
    LWidth := LineWidth[i];
    if LWidth > LMaxWidth then
    begin
      Result := i;
      LMaxWidth := LWidth;
    end;
  end;
end;

function TvxMemo.GetShowSelection: boolean;
begin
  Result := IsFocused or not HideSelection;
end;

procedure TvxMemo.MouseWheel(Shift: TShiftState; WheelDelta: integer;
  var Handled: boolean);
begin
  inherited;
  if (VScrollBar <> nil) and (VScrollBar.Visible) then
  begin
    VScrollBar.Value := VScrollBar.Value - (WheelDelta / 30);
  end;
end;

function TvxMemo.GetData: Variant;
begin
  Result := Text;
end;

procedure TvxMemo.SetData(const Value: Variant);
begin
  Text := Value;
end;

procedure TvxMemo.SetFont(const Value: TvxFont);
begin
  FFont.Assign(Value);
end;

procedure TvxMemo.SetTextAlign(const Value: TvxTextAlign);
begin
  FTextAlign := Value;
end;

procedure TvxMemo.SetUpdateState(Updating: Boolean);
begin
  FUpdating := Updating;
  if not Updating then
    Realign;
end;

function TvxMemo.GetUnwrapLines: TvxWideStrings;
begin
  if FUnwrapLines = nil then
    FUnwrapLines := TvxWideStringList.Create;
  FUnwrapLines.Text := FText;
  Result := FUnwrapLines;
end;

{ TEdtActionStack }

constructor TEdtActionStack.Create(AOwner: TvxMemo);
begin
  inherited Create;
  FOwner := AOwner;
end;

destructor TEdtActionStack.Destroy;
var
  TmpItem: PEdtAction;
begin
  while AtLeast(1) do
  begin
    TmpItem := Pop;
    Finalize(TmpItem^);
    FreeMem(TmpItem);
  end;
  inherited;
end;

procedure TEdtActionStack.FragmentDeleted(StartPos: integer;
  Fragment: WideString);
var
  TmpItem: PEdtAction;
begin
  if Fragment = '' then
    Exit;

  if (not AtLeast(1)) or
    not ((PEdtAction(Peek)^.ActionType = atDelete) and
    (PEdtAction(Peek)^.StartPosition - StartPos - Length(Fragment) <= 1) and
    (PEdtAction(Peek)^.StartPosition - StartPos >= 0)) then
  begin
    New(TmpItem);
    Initialize(TmpItem^);
    Push(TmpItem);

    with TmpItem^ do
    begin
      ActionType := atDelete;
      StartPosition := StartPos;
      DeletedFragment := Fragment;
      PairedWithPriv := false;
    end;
  end
  else
    case PEdtAction(Peek)^.ActionType of
      atDelete:
        begin
          if StartPos > 0 then
          begin
            if StartPos < PEdtAction(Peek)^.StartPosition then
              PEdtAction(Peek)^.DeletedFragment := Fragment + PEdtAction(Peek)^.DeletedFragment
            else
              PEdtAction(Peek)^.DeletedFragment := PEdtAction(Peek)^.DeletedFragment + Fragment;
            PEdtAction(Peek)^.StartPosition := StartPos;
          end;
        end;
    end;
end;

procedure TEdtActionStack.FragmentInserted(StartPos, FragmentLength: integer; IsPairedWithPriv: boolean);
var
  TmpItem: PEdtAction;
begin
  if FragmentLength = 0 then
    Exit;

  if (not AtLeast(1)) or
    not ((PEdtAction(Peek)^.ActionType = atInsert) and
    (PEdtAction(Peek)^.StartPosition + PEdtAction(Peek)^.Length = StartPos)) then
  begin
    New(TmpItem);
    Initialize(TmpItem^);
    Push(TmpItem);
    with TmpItem^ do
    begin
      ActionType := atInsert;
      StartPosition := StartPos;
      Length := FragmentLength;
      PairedWithPriv := IsPairedWithPriv;
    end;
  end
  else
    case PEdtAction(Peek)^.ActionType of
      atInsert: PEdtAction(Peek)^.Length := PEdtAction(Peek)^.Length + FragmentLength;
    end;
end;

procedure TEdtActionStack.CaretMovedBy(Shift: integer);
begin

end;

function TEdtActionStack.RollBackAction: boolean;
var
  TmpItem: PEdtAction;
  WasPaired: boolean;
  LTmpOptions: TInsertOptions;
begin
  Result := AtLeast(1);
  if not (Result and Assigned(FOwner)) then
    Exit;

  repeat
    TmpItem := Pop;

    with TmpItem^, FOwner do
    begin
      if DeletedFragment <> #13 + #10 then
        LTmpOptions := [ioSelected]
      else
        LTmpOptions := [];

      case ActionType of
        atDelete: InsertAfter(TextPosToPos(StartPosition - 1), DeletedFragment, LTmpOptions + [ioMoveCaret] {DeletedFragment<>#13+#10, true, false, false});
        atInsert: DeleteFrom(TextPosToPos(StartPosition), Length, [doMoveCaret]);
      end;
    end;

    WasPaired := TmpItem^.PairedWithPriv;
    Finalize(TmpItem^);
    Dispose(TmpItem);
  until (not AtLeast(1)) or (not WasPaired);
end;

{ TvxShape ====================================================================}

constructor TvxShape.Create(AOwner: TComponent);
begin
  inherited;
  FFill := TvxBrush.Create(vgBrushSolid, $FFE0E0E0);
  FFill.OnChanged := FillChanged;
  FStroke := TvxBrush.Create(vgBrushSolid, $FF000000);
  FStroke.SolidColor := $FF000000;
  FStroke.OnChanged := StrokeChanged;
  FStrokeThickness := 1;
end;

destructor TvxShape.Destroy;
begin
  FStroke.Free;
  FFill.Free;
  inherited;
end;

function TvxShape.GetShapeRect: TvxRect;
begin
  Result := LocalRect;
  if FStroke.Style <> vgBrushNone then
    if Odd(Round(FStrokeThickness)) then
    begin
      vgInflateRect(Result, -(FStrokeThickness / 2), -(FStrokeThickness / 2));
    end
    else
      vgInflateRect(Result, -(FStrokeThickness / 2), -(FStrokeThickness / 2));
end;

procedure TvxShape.FillChanged(Sender: TObject);
begin
  if FUpdating = 0 then
    Repaint;
  FUpdateEffects := true;
end;

procedure TvxShape.StrokeChanged(Sender: TObject);
begin
  if FUpdating = 0 then
    Repaint;
  FUpdateEffects := true;
end;

procedure TvxShape.BeforePaint;
begin
  inherited;
  Canvas.Fill.Assign(FFill);
  Canvas.Stroke.Assign(FStroke);
  Canvas.StrokeThickness := FStrokeThickness;
  Canvas.StrokeCap := FStrokeCap;
  Canvas.StrokeJoin := FStrokeJoin;
  Canvas.StrokeDash := FStrokeDash;
end;

procedure TvxShape.AfterPaint;
begin
  inherited AfterPaint;
  Canvas.StrokeDash := vgDashSolid;
  Canvas.StrokeThickness := 1;
end;

function TvxShape.isStrokeThicknessStored: Boolean;
begin
  Result := StrokeThickness <> 1;
end;

procedure TvxShape.SetFill(const Value: TvxBrush);
begin
  FFill.Assign(Value);
end;

procedure TvxShape.SetStroke(const Value: TvxBrush);
begin
  FStroke.Assign(Value);
end;

procedure TvxShape.SetStrokeThickness(const Value: single);
begin
  if FStrokeThickness <> Value then
  begin
    FStrokeThickness := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxShape.SetStrokeCap(const Value: TvxStrokeCap);
begin
  if FStrokeCap <> Value then
  begin
    FStrokeCap := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxShape.SetStrokeJoin(const Value: TvxStrokeJoin);
begin
  if FStrokeJoin <> Value then
  begin
    FStrokeJoin := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxShape.SetStrokeDash(const Value: TvxStrokeDash);
begin
  if FStrokeDash <> Value then
  begin
    FStrokeDash := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

{ TvxLine }

constructor TvxLine.Create(AOwner: TComponent);
begin
  inherited;
end;

procedure TvxLine.Paint;
begin
  case FLineType of
    vgLineHorizontal: Canvas.DrawLine(GetShapeRect.TopLeft, vgPoint(GetShapeRect.Right, GetShapeRect.Top), AbsoluteOpacity);
    vgLineVertical: Canvas.DrawLine(GetShapeRect.TopLeft, vgPoint(GetShapeRect.Left, GetShapeRect.Bottom), AbsoluteOpacity);
  else
    Canvas.DrawLine(GetShapeRect.TopLeft, GetShapeRect.BottomRight, AbsoluteOpacity);
  end;
end;

procedure TvxLine.SetLineType(const Value: TvxLineType);
begin
  if FLineType <> Value then
  begin
    FLineType := Value;
    Repaint;
  end;
end;

{ TvxEllipse }

procedure TvxEllipse.Paint;
begin
  Canvas.FillEllipse(GetShapeRect, AbsoluteOpacity);
  Canvas.DrawEllipse(GetShapeRect, AbsoluteOpacity);
end;

function TvxEllipse.PointInObject(X, Y: single): boolean;
var
  P: TvxPoint;
begin
  Result := false;
  P := AbsoluteToLocal(vgPoint(X, Y));
  if Width * Height = 0 then
    Exit;
  if (Sqr((P.X * 2 - Width) / Width) + Sqr((P.Y * 2 - Height) / Height) <= 1) then
  begin
    Result := true;
  end;
end;

{ TvxCircle }

procedure TvxCircle.Paint;
var
  R: TvxRect;
begin
  R := vgRect(0, 0, vgMaxFloat(Width, Height), vgMaxFloat(Width, Height));
  vgFitRect(R, GetShapeRect);
  Canvas.FillEllipse(R, AbsoluteOpacity);
  Canvas.DrawEllipse(R, AbsoluteOpacity);
end;

{ TvxPie }

constructor TvxPie.Create(AOwner: TComponent);
begin
  inherited;
  FStartAngle := 0;
  FEndAngle := -90;
end;

procedure TvxPie.Paint;
var
  P: TvxPathData;
begin
  P := TvxPathData.Create;
  P.MoveTo(vgPoint(Width / 2, Height / 2));
  P.AddArc(vgPoint(Width / 2, Height / 2), vgPoint((Width - StrokeThickness) / 2, (Height - StrokeThickness) / 2), FStartAngle, FEndAngle - FStartAngle);
  P.LineTo(vgPoint(Width / 2, Height / 2));
  P.ClosePath;
  Canvas.FillPath(P, P.GetBounds, AbsoluteOpacity);
  Canvas.DrawPath(P, P.GetBounds, AbsoluteOpacity);
  P.Free;
end;

function TvxPie.PointInObject(X, Y: single): boolean;
var
  P: TvxPathData;
begin
  if (Canvas <> nil) then
  begin
    P := TvxPathData.Create;
    P.MoveTo(vgPoint(Width / 2, Height / 2));
    P.AddArc(vgPoint(Width / 2, Height / 2), vgPoint((Width - StrokeThickness) / 2, (Height - StrokeThickness) / 2), FStartAngle, FEndAngle - FStartAngle);
    P.LineTo(vgPoint(Width / 2, Height / 2));
    P.ClosePath;
    Result := Canvas.PtInPath(AbsoluteToLocal(vgPoint(X, Y)), P.GetBounds, P);
    P.Free;
  end
  else
    Result := inherited PointInObject(X, Y);
end;

procedure TvxPie.SetEndAngle(const Value: single);
begin
  if FEndAngle <> Value then
  begin
    FEndAngle := Value;
    Repaint;
  end;
end;

procedure TvxPie.SetStartAngle(const Value: single);
begin
  if FStartAngle <> Value then
  begin
    FStartAngle := Value;
    Repaint;
  end;
end;

{ TvxArc }

constructor TvxArc.Create(AOwner: TComponent);
begin
  inherited;
  Fill.Style := vgBrushNone;
  Fill.DefaultStyle := vgBrushNone;
  FStartAngle := 0;
  FEndAngle := -90;
end;

procedure TvxArc.Paint;
begin
  Canvas.FillArc(vgPoint(Width / 2, Height / 2), vgPoint((Width - StrokeThickness) / 2, ((Height - StrokeThickness) / 2)), FStartAngle, FEndAngle, AbsoluteOpacity);
  Canvas.DrawArc(vgPoint(Width / 2, Height / 2), vgPoint((Width - StrokeThickness) / 2, ((Height - StrokeThickness) / 2)), FStartAngle, FEndAngle, AbsoluteOpacity);
end;

function TvxArc.PointInObject(X, Y: single): boolean;
begin
  Result := inherited PointInObject(X, Y);
end;

procedure TvxArc.SetEndAngle(const Value: single);
begin
  if FEndAngle <> Value then
  begin
    FEndAngle := Value;
    Repaint;
  end;
end;

procedure TvxArc.SetStartAngle(const Value: single);
begin
  if FStartAngle <> Value then
  begin
    FStartAngle := Value;
    Repaint;
  end;
end;

{ TvxRectangle }

constructor TvxRectangle.Create(AOwner: TComponent);
begin
  inherited;
  FCorners := AllCorners;
  FxRadius := 0;
  FyRadius := 0;
  FSides := AllSides;
end;

function TvxRectangle.IsCornersStored: Boolean;
begin
  Result := FCorners <> AllCorners;
end;

function TvxRectangle.IsSidesStored: Boolean;
begin
  Result := FSides * AllSides <> []
end;

procedure TvxRectangle.Paint;
var
  R: TvxRect;
  Off: single;
begin
  R := GetShapeRect;
  if Sides <> AllSides then
  begin
    Off := R.Left;
    if not (vgSideTop in FSides) then
      R.Top := R.Top - Off;
    if not (vgSideLeft in FSides) then
      R.Left := R.Left - Off;
    if not (vgSideBottom in FSides) then
      R.Bottom := R.Bottom + Off;
    if not (vgSideRight in FSides) then
      R.Right := R.Right + Off;
    Canvas.FillRect(R, xRadius, yRadius, FCorners, AbsoluteOpacity, CornerType);
    Canvas.DrawRectSides(GetShapeRect, xRadius, yRadius, FCorners, AbsoluteOpacity, Sides, CornerType);
  end
  else
  begin
    Canvas.FillRect(R, xRadius, yRadius, FCorners, AbsoluteOpacity, CornerType);
    Canvas.DrawRect(R, xRadius, yRadius, FCorners, AbsoluteOpacity, CornerType);
  end;
end;

procedure TvxRectangle.SetCorners(const Value: TvxCorners);
begin
  if FCorners <> Value then
  begin
    FCorners := Value;
    Repaint;
  end;
end;

procedure TvxRectangle.SetCornerType(const Value: TvxCornerType);
begin
  if FCornerType <> Value then
  begin
    FCornerType := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxRectangle.SetxRadius(const Value: single);
begin
  if FxRadius <> Value then
  begin
    FxRadius := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxRectangle.SetyRadius(const Value: single);
begin
  if FyRadius <> Value then
  begin
    FyRadius := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxRectangle.SetSides(const Value: TvxSides);
begin
  if FSides <> Value then
  begin
    FSides := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

{ TvxBlurRectangle }

constructor TvxBlurRectangle.Create(AOwner: TComponent);
begin
  inherited;
  Stroke.Style := vgBrushNone;
  FSoftness := 0.3;
  FRecreate := true;
end;

destructor TvxBlurRectangle.Destroy;
begin
  if FBuffer <> nil then
    FreeAndNil(FBuffer);
  inherited;
end;

procedure TvxBlurRectangle.Paint;
var
  R: TvxRect;
  Radius: integer;
begin
  Radius := Trunc(FSoftness * 15);
  if FBuffer = nil then
  begin
    FBuffer := TvxBitmap.Create(Round(Width), Round(Height));
    FRecreate := true;
  end;
  if (FBuffer.Width <> Round(Width)) or (FBuffer.Height <> Round(Height)) then
  begin
    FBuffer.SetSize(Round(Width), Round(Height));
    FRecreate := true;
  end;

  if FRecreate then
  begin
    R := vgRect(Radius, Radius, Width - Radius, Height - Radius);
    FBuffer.Clear(0);
    FBuffer.Canvas.Fill.Assign(Fill);
    FBuffer.Canvas.FillRect(R, xRadius, yRadius, FCorners, AbsoluteOpacity, CornerType);
    FBuffer.Canvas.Stroke.Assign(Stroke);
    FBuffer.Canvas.DrawRect(R, xRadius, yRadius, FCorners, AbsoluteOpacity, CornerType);
    Blur(nil, FBuffer, Radius);
    FRecreate := false;
  end;
  Canvas.DrawBitmap(FBuffer, LocalRect, LocalRect, AbsoluteOpacity, true);
end;

procedure TvxBlurRectangle.SetSoftness(const Value: single);
begin
  if FSoftness <> Value then
  begin
    FSoftness := Value;
    FRecreate := true;
    Repaint;
  end;
end;

procedure TvxBlurRectangle.SetCorners(const Value: TvxCorners);
begin
  if Value <> Corners then
  begin
    inherited;
    FRecreate := true;
  end;
end;

procedure TvxBlurRectangle.SetCornerType(const Value: TvxCornerType);
begin
  if Value <> CornerType then
  begin
    inherited;
    FRecreate := true;
  end;
end;

procedure TvxBlurRectangle.SetxRadius(const Value: single);
begin
  if Value <> xRadius then
  begin
    inherited;
    FRecreate := true;
  end;
end;

procedure TvxBlurRectangle.SetyRadius(const Value: single);
begin
  if Value <> yRadius then
  begin
    inherited;
    FRecreate := true;
  end;
end;

procedure TvxBlurRectangle.FillChanged(Sender: TObject);
begin
  inherited;
  FRecreate := true;
end;

{ TvxRoundRect }

constructor TvxRoundRect.Create(AOwner: TComponent);
begin
  inherited;
  FCorners := AllCorners;
end;

function TvxRoundRect.IsCornersStored: Boolean;
begin
  Result := FCorners <> AllCorners;
end;

procedure TvxRoundRect.Paint;
var
  Radius: single;
begin
  if Height < Width then
    Radius := vgRectHeight(GetShapeRect) / 2
  else
    Radius := vgRectWidth(GetShapeRect) / 2;
  Canvas.FillRect(GetShapeRect, Radius, Radius, FCorners, AbsoluteOpacity);
  Canvas.DrawRect(GetShapeRect, Radius, Radius, FCorners, AbsoluteOpacity);
end;

procedure TvxRoundRect.SetCorners(const Value: TvxCorners);
begin
  if FCorners <> Value then
  begin
    FCorners := Value;
    Repaint;
  end;
end;

{ TvxBlurRoundRect }

constructor TvxBlurRoundRect.Create(AOwner: TComponent);
begin
  inherited;
  Stroke.Style := vgBrushNone;
  FSoftness := 0.3;
  FRecreate := true;
end;

destructor TvxBlurRoundRect.Destroy;
begin
  if FBuffer <> nil then
    FreeAndNil(FBuffer);
  inherited;
end;

procedure TvxBlurRoundRect.Paint;
var
  R: TvxRect;
  Radius: integer;
  rectRadius: single;
begin
  Radius := Trunc(FSoftness * 15);
  if FBuffer = nil then
  begin
    FBuffer := TvxBitmap.Create(Round(Width), Round(Height));
    FRecreate := true;
  end;
  if (FBuffer.Width <> Round(Width)) or (FBuffer.Height <> Round(Height)) then
  begin
    FBuffer.SetSize(Round(Width), Round(Height));
    FRecreate := true;
  end;

  if FRecreate then
  begin
    R := vgRect(Radius, Radius, Width - Radius, Height - Radius);
    rectRadius := vgRectHeight(R) / 2;
    FBuffer.Clear(0);
    FBuffer.Canvas.Fill.Assign(Fill);
    FBuffer.Canvas.FillRect(R, rectRadius, rectRadius, FCorners, AbsoluteOpacity);
    FBuffer.Canvas.Stroke.Assign(Stroke);
    FBuffer.Canvas.DrawRect(R, rectRadius, rectRadius, FCorners, AbsoluteOpacity);
    Blur(nil, FBuffer, Radius);
    FRecreate := false;
  end;
  Canvas.DrawBitmap(FBuffer, LocalRect, LocalRect, AbsoluteOpacity, true);
end;

procedure TvxBlurRoundRect.SetSoftness(const Value: single);
begin
  if FSoftness <> Value then
  begin
    FSoftness := Value;
    FRecreate := true;
    Repaint;
  end;
end;

procedure TvxBlurRoundRect.SetCorners(const Value: TvxCorners);
begin
  if Value <> Corners then
  begin
    inherited;
    FRecreate := true;
  end;
end;

procedure TvxBlurRoundRect.FillChanged(Sender: TObject);
begin
  inherited;
  FRecreate := true;
end;

{ TvxCalloutRectangle }

constructor TvxCalloutRectangle.Create(AOwner: TComponent);
begin
  inherited;
  FCalloutWidth := 23;
  FCalloutLength := 11;
  FPath := TvxPathData.Create;
end;

destructor TvxCalloutRectangle.Destroy;
begin
  FreeAndNil(FPath);
  inherited;
end;

procedure TvxCalloutRectangle.CreatePath;
var
  x1, x2, y1, y2: single;
  R: TvxRect;
  Off: single;
begin
  R := GetShapeRect;
  case CalloutPosition of
    vgCalloutTop: R.Top := R.Top + FCalloutLength;
    vgCalloutLeft: R.Left := R.Left + FCalloutLength;
    vgCalloutBottom: R.Bottom := R.Bottom - FCalloutLength;
    vgCalloutRight: R.Right := R.Right - FCalloutLength;
  end;
  if Sides <> AllSides then
  begin
    Off := R.Left;
    if not (vgSideTop in FSides) then
      R.Top := R.Top - Off;
    if not (vgSideLeft in FSides) then
      R.Left := R.Left - Off;
    if not (vgSideBottom in FSides) then
      R.Bottom := R.Bottom + Off;
    if not (vgSideRight in FSides) then
      R.Right := R.Right + Off;
  end;
  x1 := xRadius;
  if vgRectWidth(R) - (x1 * 2) < 0 then
    x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
  x2 := x1 / 2;
  y1 := yRadius;
  if vgRectHeight(R) - (y1 * 2) < 0 then
    y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
  y2 := y1 / 2;
  FPath.Clear;
  FPath.MoveTo(vgPoint(R.Left, R.Top + y1));
  if vgCornerTopLeft in FCorners then
  begin
    case FCornerType of
      // vgCornetRound - default
      vgCornerBevel: FPath.LineTo(vgPoint(R.Left + x1, R.Top));
      vgCornerInnerRound: FPath.CurveTo(vgPoint(R.Left + x2, R.Top + y1), vgPoint(R.Left + x1, R.Top + y2), vgPoint(R.Left + x1, R.Top));
      vgCornerInnerLine:
        begin
          FPath.LineTo(vgPoint(R.Left + x2, R.Top + y1));
          FPath.LineTo(vgPoint(R.Left + x1, R.Top + y2));
          FPath.LineTo(vgPoint(R.Left + x1, R.Top));
        end;
    else
      FPath.CurveTo(vgPoint(R.Left, R.Top + (y2)), vgPoint(R.Left + x2, R.Top), vgPoint(R.Left + x1, R.Top))
    end;
  end
  else
  begin
    if vgSideLeft in FSides then
      FPath.LineTo(vgPoint(R.Left, R.Top))
    else
      FPath.MoveTo(vgPoint(R.Left, R.Top));
    if vgSideTop in FSides then
      FPath.LineTo(vgPoint(R.Left + x1, R.Top))
    else
      FPath.MoveTo(vgPoint(R.Left + x1, R.Top));
  end;
  if not (vgSideTop in FSides) then
    FPath.MoveTo(vgPoint(R.Right - x1, R.Top))
  else
  begin
    if (FCalloutPosition = vgCalloutTop) then
    begin
      if CalloutOffset = 0 then
      begin
        FPath.LineTo(vgPoint((R.Right - R.Left) / 2 - (CalloutWidth / 2), R.Top));
        FPath.LineTo(vgPoint((R.Right - R.Left) / 2, R.Top - FCalloutLength));
        FPath.LineTo(vgPoint((R.Right - R.Left) / 2 + (CalloutWidth / 2), R.Top));
        FPath.LineTo(vgPoint(R.Right - x1, R.Top));
      end
      else
        if CalloutOffset > 0 then
      begin
        FPath.LineTo(vgPoint(R.Left + FCalloutOffset, R.Top));
        FPath.LineTo(vgPoint(R.Left + FCalloutOffset + (CalloutWidth / 2), R.Top - FCalloutLength));
        FPath.LineTo(vgPoint(R.Left + FCalloutOffset + CalloutWidth, R.Top));
        FPath.LineTo(vgPoint(R.Right - x1, R.Top));
      end
      else
      begin
        FPath.LineTo(vgPoint(R.Right - Abs(FCalloutOffset) - CalloutWidth, R.Top));
        FPath.LineTo(vgPoint(R.Right - Abs(FCalloutOffset) - (CallOutWidth / 2), R.Top - FCalloutLength));
        FPath.LineTo(vgPoint(R.Right - Abs(FCalloutOffset), R.Top));
        FPath.LineTo(vgPoint(R.Right - x1, R.Top));
      end;
    end
    else
      FPath.LineTo(vgPoint(R.Right - x1, R.Top));
  end;
  if vgCornerTopRight in FCorners then
  begin
    case FCornerType of
      // vgCornetRound - default
      vgCornerBevel: FPath.LineTo(vgPoint(R.Right, R.Top + y1));
      vgCornerInnerRound: FPath.CurveTo(vgPoint(R.Right - x1, R.Top + y2), vgPoint(R.Right - x2, R.Top + y1), vgPoint(R.Right, R.Top + y1));
      vgCornerInnerLine:
        begin
          FPath.LineTo(vgPoint(R.Right - x1, R.Top + y2));
          FPath.LineTo(vgPoint(R.Right - x2, R.Top + y1));
          FPath.LineTo(vgPoint(R.Right, R.Top + y1));
        end;
    else
      FPath.CurveTo(vgPoint(R.Right - x2, R.Top), vgPoint(R.Right, R.Top + (y2)), vgPoint(R.Right, R.Top + y1))
    end;
  end
  else
  begin
    if vgSideTop in FSides then
      FPath.LineTo(vgPoint(R.Right, R.Top))
    else
      FPath.MoveTo(vgPoint(R.Right, R.Top));
    if vgSideRight in FSides then
      FPath.LineTo(vgPoint(R.Right, R.Top + y1))
    else
      FPath.MoveTo(vgPoint(R.Right, R.Top + y1));
  end;
  if not (vgSideRight in FSides) then
    FPath.MoveTo(vgPoint(R.Right, R.Bottom - y1))
  else
  begin
    if (FCalloutPosition = vgCalloutRight) then
    begin
      if CalloutOffset = 0 then
      begin
        FPath.LineTo(vgPoint(R.Right, (R.Bottom - R.Top) / 2 - (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Right + FCalloutLength, (R.Bottom - R.Top) / 2));
        FPath.LineTo(vgPoint(R.Right, (R.Bottom - R.Top) / 2 + (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Right, R.Bottom - y1));
      end
      else
        if CalloutOffset > 0 then
      begin
        FPath.LineTo(vgPoint(R.Right, R.Top + CalloutOffset));
        FPath.LineTo(vgPoint(R.Right + FCalloutLength, R.Top + CalloutOffset + (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Right, R.Top + CalloutOffset + CalloutWidth));
        FPath.LineTo(vgPoint(R.Right, R.Bottom - y1));
      end
      else
      begin
        FPath.LineTo(vgPoint(R.Right, R.Bottom + CalloutOffset));
        FPath.LineTo(vgPoint(R.Right + FCalloutLength, R.Bottom + CalloutOffset + (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Right, R.Bottom + CalloutOffset + CalloutWidth));
        FPath.LineTo(vgPoint(R.Right, R.Bottom - y1));
      end;
    end
    else
      FPath.LineTo(vgPoint(R.Right, R.Bottom - y1));
  end;
  if vgCornerBottomRight in FCorners then
  begin
    case FCornerType of
      // vgCornetRound - default
      vgCornerBevel: FPath.LineTo(vgPoint(R.Right - x1, R.Bottom));
      vgCornerInnerRound: FPath.CurveTo(vgPoint(R.Right - x2, R.Bottom - y1), vgPoint(R.Right - x1, R.Bottom - y2), vgPoint(R.Right - x1, R.Bottom));
      vgCornerInnerLine:
        begin
          FPath.LineTo(vgPoint(R.Right - x2, R.Bottom - y1));
          FPath.LineTo(vgPoint(R.Right - x1, R.Bottom - y2));
          FPath.LineTo(vgPoint(R.Right - x1, R.Bottom));
        end;
    else
      FPath.CurveTo(vgPoint(R.Right, R.Bottom - (y2)), vgPoint(R.Right - x2, R.Bottom), vgPoint(R.Right - x1, R.Bottom))
    end;
  end
  else
  begin
    if vgSideRight in FSides then
      FPath.LineTo(vgPoint(R.Right, R.Bottom))
    else
      FPath.MoveTo(vgPoint(R.Right, R.Bottom));
    if vgSideBottom in FSides then
      FPath.LineTo(vgPoint(R.Right - x1, R.Bottom))
    else
      FPath.MoveTo(vgPoint(R.Right - x1, R.Bottom));
  end;
  if not (vgSideBottom in FSides) then
    FPath.MoveTo(vgPoint(R.Left + x1, R.Bottom))
  else
  begin
    if (FCalloutPosition = vgCalloutBottom) then
    begin
      if CalloutOffset = 0 then
      begin
        FPath.LineTo(vgPoint((R.Right - R.Left) / 2 + (CalloutWidth / 2), R.Bottom));
        FPath.LineTo(vgPoint((R.Right - R.Left) / 2, R.Bottom + FCalloutLength));
        FPath.LineTo(vgPoint((R.Right - R.Left) / 2 - (CalloutWidth / 2), R.Bottom));
        FPath.LineTo(vgPoint(R.Left + x1, R.Bottom));
      end
      else
        if CalloutOffset > 0 then
      begin
        FPath.LineTo(vgPoint(R.Left + FCalloutOffset + CalloutWidth, R.Bottom));
        FPath.LineTo(vgPoint(R.Left + FCalloutOffset + (CalloutWidth / 2), R.Bottom + FCalloutLength));
        FPath.LineTo(vgPoint(R.Left + FCalloutOffset, R.Bottom));
        FPath.LineTo(vgPoint(R.Left + x1, R.Bottom));
      end
      else
      begin
        FPath.LineTo(vgPoint(R.Right - Abs(FCalloutOffset), R.Bottom));
        FPath.LineTo(vgPoint(R.Right - Abs(FCalloutOffset) - (CalloutWidth / 2), R.Bottom + FCalloutLength));
        FPath.LineTo(vgPoint(R.Right - Abs(FCalloutOffset) - CalloutWidth, R.Bottom));
        FPath.LineTo(vgPoint(R.Left + x1, R.Bottom));
      end;
    end
    else
      FPath.LineTo(vgPoint(R.Left + x1, R.Bottom));
  end;
  if vgCornerBottomLeft in FCorners then
  begin
    case FCornerType of
      // vgCornetRound - default
      vgCornerBevel: FPath.LineTo(vgPoint(R.Left, R.Bottom - y1));
      vgCornerInnerRound: FPath.CurveTo(vgPoint(R.Left + x1, R.Bottom - y2), vgPoint(R.Left + x2, R.Bottom - y1), vgPoint(R.Left, R.Bottom - y1));
      vgCornerInnerLine:
        begin
          FPath.LineTo(vgPoint(R.Left + x1, R.Bottom - y2));
          FPath.LineTo(vgPoint(R.Left + x2, R.Bottom - y1));
          FPath.LineTo(vgPoint(R.Left, R.Bottom - y1));
        end;
    else
      FPath.CurveTo(vgPoint(R.Left + x2, R.Bottom), vgPoint(R.Left, R.Bottom - (y2)), vgPoint(R.Left, R.Bottom - y1))
    end;
  end
  else
  begin
    if vgSideBottom in FSides then
      FPath.LineTo(vgPoint(R.Left, R.Bottom))
    else
      FPath.MoveTo(vgPoint(R.Left, R.Bottom));
    if vgSideLeft in FSides then
      FPath.LineTo(vgPoint(R.Left, R.Bottom - y1))
    else
      FPath.MoveTo(vgPoint(R.Left, R.Bottom - y1));
  end;
  if (vgSideLeft in FSides) then
  begin
    if (FCalloutPosition = vgCalloutLeft) then
    begin
      if CalloutOffset = 0 then
      begin
        FPath.LineTo(vgPoint(R.Left, (R.Bottom - R.Top) / 2 + (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Left - FCalloutLength, (R.Bottom - R.Top) / 2));
        FPath.LineTo(vgPoint(R.Left, (R.Bottom - R.Top) / 2 - (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Left, R.Top + y1));
      end
      else
        if CalloutOffset > 0 then
      begin
        FPath.LineTo(vgPoint(R.Left, R.Top + CalloutOffset + CalloutWidth));
        FPath.LineTo(vgPoint(R.Left - FCalloutLength, R.Top + CalloutOffset + (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Left, R.Top + CalloutOffset));
        FPath.LineTo(vgPoint(R.Left, R.Top + y1));
      end
      else
      begin
        FPath.LineTo(vgPoint(R.Left, R.Bottom + CalloutOffset + CalloutWidth));
        FPath.LineTo(vgPoint(R.Left - FCalloutLength, R.Bottom + CalloutOffset + (CalloutWidth / 2)));
        FPath.LineTo(vgPoint(R.Left, R.Bottom + CalloutOffset));
        FPath.LineTo(vgPoint(R.Left, R.Top + y1));
      end;
    end
    else
      FPath.LineTo(vgPoint(R.Left, R.Top + y1));
  end;
end;

procedure TvxCalloutRectangle.Paint;
var
  R: TvxRect;
begin
  CreatePath;
  R := FPath.GetBounds;
  Canvas.FillPath(FPath, R, AbsoluteOpacity);
  Canvas.DrawPath(FPath, R, AbsoluteOpacity);
end;

procedure TvxCalloutRectangle.SetCalloutWidth(const Value: single);
begin
  if FCalloutWidth <> Value then
  begin
    FCalloutWidth := Value;
    CreatePath;
    Repaint;
  end;
end;

procedure TvxCalloutRectangle.SetCalloutLength(const Value: single);
begin
  if FCalloutLength <> Value then
  begin
    FCalloutLength := Value;
    CreatePath;
    Repaint;
  end;
end;

procedure TvxCalloutRectangle.SetCalloutPosition(const Value: TvxCalloutPosition);
begin
  if FCalloutPosition <> Value then
  begin
    FCalloutPosition := Value;
    CreatePath;
    Repaint;
  end;
end;

procedure TvxCalloutRectangle.SetCalloutOffset(const Value: single);
begin
  if FCalloutOffset <> Value then
  begin
    FCalloutOffset := Value;
    CreatePath;
    Repaint;
  end;
end;

{ TvxText }

constructor TvxText.Create(AOwner: TComponent);
begin
  inherited;
  FHorzTextAlign := vgTextAlignCenter;
  FVertTextAlign := vgTextAlignCenter;
  FWordWrap := true;
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
  Fill.DefaultColor := $FF000000;
  Fill.SolidColor := $FF000000;
  Stroke.DefaultStyle := vgBrushNone;
  Stroke.Style := vgBrushNone;
end;

destructor TvxText.Destroy;
begin
  FFont.Free;
  inherited;
end;

function TvxText.GetData: Variant;
begin
  Result := Text;
end;

procedure TvxText.SetData(const Value: Variant);
begin
  Text := Value;
end;

procedure TvxText.FontChanged(Sender: TObject);
begin
  FUpdateEffects := true;
  if FAutoSize then
    AdjustSize;
  Repaint;
end;

procedure TvxText.Paint;
var
  R: TvxRect;
  M: TvxMatrix;
begin
  Canvas.Font.Assign(FFont);
  if FStretch then
  begin
    R := vgRect(0, 0, 1000, 1000);
    Canvas.MeasureText(R, R, FText, false, FHorzTextAlign, FVertTextAlign);
    vgOffsetRect(R, -R.Left, -R.Top);
    M := IdentityMatrix;
    if not vgIsRectEmpty(R) then
    begin
      M.m11 := vgRectWidth(LocalRect) / vgRectWidth(R);
      M.m22 := vgRectHeight(LocalRect) / vgRectHeight(R);
    end;
    Canvas.MultyMatrix(M);
    vgInflateRect(R, Font.Size / 3, Font.Size / 3);
    Canvas.FillText(R, R, FText, false, AbsoluteOpacity, FHorzTextAlign, FVertTextAlign);
  end
  else
  begin

    Canvas.FillText(LocalRect, LocalRect, FText, FWordWrap, AbsoluteOpacity, FHorzTextAlign, FVertTextAlign);
  end;
end;

procedure TvxText.SetWordWrap(const Value: boolean);
begin
  if FWordWrap <> Value then
  begin
    FWordWrap := Value;
    Repaint;
  end;
end;

procedure TvxText.SetAutoSize(const Value: boolean);
begin
  if FAutoSize <> Value then
  begin
    FAutoSize := Value;
    AdjustSize;
  end;
end;

procedure TvxText.SetStretch(const Value: boolean);
begin
  if FStretch <> Value then
  begin
    FUpdateEffects := true;
    FStretch := Value;
    if Stretch then
      AutoSize := false;
    Repaint;
  end;
end;

procedure TvxText.AdjustSize;
var
  R: TvxRect;
begin
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  if FAutoSize and (Canvas <> nil) and (FText <> '') then
  begin
    Canvas.Font.Assign(FFont);
    if WordWrap then
      R := vgRect(0, 0, Width, 1000)
    else
      R := vgRect(0, 0, 1000, 1000);
    Canvas.MeasureText(R, R, FText, WordWrap, vgTextAlignNear, vgTextAlignNear);
    if not WordWrap then
      Width := R.Right + (Font.Size / 2);
    if VertTextAlign <> vgTextAlignCenter then
      Height := R.Bottom;
  end;
  FDisableAlign := false;
  if FAutoSize and (Canvas <> nil) and (FText <> '') then
    if (Parent <> nil) and (Parent.IsVisual) then
      Parent.Visual.Realign;
end;

procedure TvxText.Realign;
begin
  inherited;
  if FAutoSize then
    AdjustSize;
end;

procedure TvxText.SetFont(const Value: TvxFont);
begin
  FFont.Assign(Value);
  if FAutoSize then
    AdjustSize;
end;

procedure TvxText.SetHorzTextAlign(const Value: TvxTextAlign);
begin
  if FHorzTextAlign <> Value then
  begin
    FHorzTextAlign := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxText.SetVertTextAlign(const Value: TvxTextAlign);
begin
  if FVertTextAlign <> Value then
  begin
    FVertTextAlign := Value;
    FUpdateEffects := true;
    Repaint;
  end;
end;

procedure TvxText.SetText(const Value: WideString);
begin
  if FText <> Value then
  begin
    FText := Value;
    FUpdateEffects := true;
    if FAutoSize then
      AdjustSize;
    Repaint;
  end;
end;

{ TvxImage ====================================================================}

constructor TvxImage.Create(AOwner: TComponent);
begin
  inherited;
  FBitmap := TvxBitmap.Create(0, 0);
  FBitmap.OnThreadLoaded := DoBitmapLoaded;
  FBitmap.OnBitmapDestroy := DoBitmapDestroy;
  FBitmap.OnChange := DoBitmapChanged;
  FBitmapMargins := TvxBounds.Create(vgRect(0, 0, 0, 0));
  FWrapMode := vgImageFit;
  fSelected := false;
end;

destructor TvxImage.Destroy;
begin
  FreeAndNil(FBitmapMargins);
  FBitmap.Free;
  //  if FBuffer <> nil then
    //  FreeAndNil(FBuffer);
  inherited;
end;

function TvxImage.GetData: Variant;
begin
  Result := ObjectToVariant(FBitmap);
end;

procedure TvxImage.SetData(const Value: Variant);
begin
  if VarIsObject(Value) then
  begin
    if VariantToObject(Value) is TPersistent then
      FBitmap.Assign(TPersistent(VariantToObject(Value)));
  end
  else
    FBitmap.LoadFromFile(Value)
end;

procedure TvxImage.DoBitmapLoaded(Sender: TObject);
begin
  { Update buffer }
  if Assigned(FOnBitmapLoaded) then
    FOnBitmapLoaded(Self);
  if not (csDestroying in ComponentState) then
    Repaint;
end;

procedure TvxImage.DoBitmapDestroy(Sender: TObject);
begin
end;

procedure TvxImage.DoBitmapChanged(Sender: TObject);
begin
  FUpdateEffects := true;
  Repaint;
end;

procedure TvxImage.Loaded;
begin
  inherited;
end;

procedure TvxImage.Realign;
begin
  inherited;
end;

procedure TvxImage.Paint;
var
  R: TvxRect;
  State: integer;
  i, j: integer;
  B: TvxBitmap;
begin
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;

  B := FBitmap;
  if FBitmap.ResourceBitmap <> nil then
    B := FBitmap.ResourceBitmap;
  if B.IsEmpty then
    Exit;

  if not FBitmapMargins.MarginEmpty then
  begin
    { lefttop }
    R := vgRect(0, 0, FBitmapMargins.Left, FBitmapMargins.Top);
    Canvas.DrawBitmap(B, vgRect(0, 0, FBitmapMargins.Left, FBitmapMargins.Top), R, AbsoluteOpacity, true);
    { top }
    R := vgRect(FBitmapMargins.Left, 0, Width - FBitmapMargins.Right, FBitmapMargins.Top);
    Canvas.DrawBitmap(B, vgRect(FBitmapMargins.Left, 0, B.Width - FBitmapMargins.Right, FBitmapMargins.Top), R, AbsoluteOpacity, true);
    { righttop }
    R := vgRect(Width - FBitmapMargins.Right, 0, Width, FBitmapMargins.Top);
    Canvas.DrawBitmap(B, vgRect(B.Width - FBitmapMargins.Right, 0, B.Width, FBitmapMargins.Top), R, AbsoluteOpacity, true);
    { left }
    R := vgRect(0, FBitmapMargins.Top, FBitmapMargins.Left, Height - FBitmapMargins.Bottom);
    Canvas.DrawBitmap(B, vgRect(0, FBitmapMargins.Top, FBitmapMargins.Left, B.Height - FBitmapMargins.Bottom), R, AbsoluteOpacity, true);
    { center }
    R := vgRect(FBitmapMargins.Left, FBitmapMargins.Top, Width - FBitmapMargins.Right, Height - FBitmapMargins.Bottom);
    Canvas.DrawBitmap(B, vgRect(FBitmapMargins.Left, FBitmapMargins.Top, B.Width - FBitmapMargins.Right, B.Height - FBitmapMargins.Bottom), R, AbsoluteOpacity, true);
    { right }
    R := vgRect(Width - FBitmapMargins.Right, FBitmapMargins.Top, Width, Height - FBitmapMargins.Bottom);
    Canvas.DrawBitmap(B, vgRect(B.Width - FBitmapMargins.Right, FBitmapMargins.Top, B.Width, B.Height - FBitmapMargins.Bottom), R, AbsoluteOpacity, true);
    { leftbottom }
    R := vgRect(0, Height - FBitmapMargins.Bottom, FBitmapMargins.Left, Height);
    Canvas.DrawBitmap(B, vgRect(0, B.Height - FBitmapMargins.Bottom, FBitmapMargins.Left, B.Height), R, AbsoluteOpacity, true);
    { bottom }
    R := vgRect(FBitmapMargins.Left, Height - FBitmapMargins.Bottom, Width - FBitmapMargins.Right, Height);
    Canvas.DrawBitmap(B, vgRect(FBitmapMargins.Left, B.Height - FBitmapMargins.Bottom, B.Width - FBitmapMargins.Right, B.Height), R, AbsoluteOpacity, true);
    { rightbottom }
    R := vgRect(Width - FBitmapMargins.Right, Height - FBitmapMargins.Bottom, Width, Height);
    Canvas.DrawBitmap(B, vgRect(B.Width - FBitmapMargins.Right, B.Height - FBitmapMargins.Bottom, B.Width, B.Height), R, AbsoluteOpacity, true);
  end
  else
  begin
    case FWrapMode of
      vgImageOriginal:
        begin
          State := Canvas.SaveCanvas;
          Canvas.IntersectClipRect(LocalRect);
          R := vgRect(0, 0, B.Width, B.Height);
          Canvas.DrawBitmap(B, vgRect(0, 0, B.Width, B.Height), R, AbsoluteOpacity, true);
          Canvas.RestoreCanvas(State);
        end;
      vgImageFit:
        begin
          R := vgRect(0, 0, B.Width, B.Height);
          vgFitRect(R, LocalRect);
          Canvas.DrawBitmap(B, vgRect(0, 0, B.Width, B.Height), R, AbsoluteOpacity, DisableInterpolation)
        end;
      vgImageStretch:
        begin
          R := LocalRect;
          Canvas.DrawBitmap(B, vgRect(0, 0, B.Width, B.Height), R, AbsoluteOpacity, DisableInterpolation)
        end;
      vgImageTile:
        begin
          State := Canvas.SaveCanvas;
          Canvas.IntersectClipRect(LocalRect);

          for i := 0 to round(Width / B.Width) do
            for j := 0 to round(Height / B.Height) do
            begin
              R := vgRect(0, 0, B.Width, B.Height);
              vgOffsetRect(R, i * B.Width, j * B.Height);
              Canvas.DrawBitmap(B, vgRect(0, 0, B.Width, B.Height), R, AbsoluteOpacity, true);
            end;

          Canvas.RestoreCanvas(State);
        end;
    end;
  end;

  if Selected then
  begin
    Canvas.DrawLine(vgPoint(0, 0), vgPoint(Width, Height), 1);
  end;
end;

procedure TvxImage.SetBitmap(const Value: TvxBitmap);
begin
  FBitmap.Assign(Value);
  Repaint;
end;

procedure TvxImage.SetSelected(const Value: Boolean);
begin
  fSelected := Value;
  Repaint;
end;

procedure TvxImage.SetWrapMode(const Value: TvxImageWrap);
begin
  if FWrapMode <> Value then
  begin
    FWrapMode := Value;
    repaint;
  end;
end;

{ TvxPath =====================================================================}

constructor TvxCustomPath.Create(AOwner: TComponent);
begin
  inherited;
  FWrapMode := vgPathStretch;
  FData := TvxPathData.Create;
  FData.OnChanged := DoChanged;
end;

destructor TvxCustomPath.Destroy;
begin
  FreeAndNil(FData);
  inherited;
end;

procedure TvxCustomPath.DoChanged(Sender: TObject);
begin
  Repaint;
end;

function TvxCustomPath.PointInObject(X, Y: single): boolean;
begin
  if Assigned(Scene) and Scene.GetDesignTime and not FLocked and not FInPaintTo then
  begin
    Result := inherited PointInObject(X, Y);
  end
  else
    if (Canvas <> nil) and (FData.ResourcePath <> nil) and (Length(FData.ResourcePath.PathData) > 1) then
  begin
    Result := Canvas.PtInPath(AbsoluteToLocal(vgPoint(X, Y)), GetShapeRect, FData.ResourcePath)
  end
  else
    if (Canvas <> nil) and (Length(FData.PathData) > 1) then
  begin
    Result := Canvas.PtInPath(AbsoluteToLocal(vgPoint(X, Y)), GetShapeRect, FData)
  end
  else
    Result := inherited PointInObject(X, Y);
end;

procedure TvxCustomPath.Paint;
var
  R: TvxRect;
  i, j: integer;
  State: integer;
  P: TvxPathData;
begin
  P := FData;
  if FData.ResourcePath <> nil then
    P := FData.ResourcePath;

  if not P.IsEmpty then
  begin
    case FWrapMode of
      vgPathOriginal:
        begin
          State := Canvas.SaveCanvas;
          Canvas.IntersectClipRect(LocalRect);

          R := P.GetBounds;
          vgOffsetRect(R, shapeRect.Left, shapeRect.Top);
          Canvas.FillPath(P, R, AbsoluteOpacity);
          Canvas.DrawPath(P, R, AbsoluteOpacity);

          Canvas.RestoreCanvas(State);
        end;
      vgPathFit:
        begin
          R := P.GetBounds;
          vgFitRect(R, ShapeRect);
          Canvas.FillPath(P, R, AbsoluteOpacity);
          Canvas.DrawPath(P, R, AbsoluteOpacity);
        end;
      vgPathStretch:
        begin
          Canvas.FillPath(P, ShapeRect, AbsoluteOpacity);
          Canvas.DrawPath(P, ShapeRect, AbsoluteOpacity);
        end;
      vgPathTile:
        begin
          State := Canvas.SaveCanvas;
          Canvas.IntersectClipRect(LocalRect);

          R := P.GetBounds;
          for i := 0 to round(Width / vgRectWidth(R)) do
            for j := 0 to round(Height / vgRectHeight(R)) do
            begin
              R := P.GetBounds;
              vgOffsetRect(R, shapeRect.Left, shapeRect.Top);
              vgOffsetRect(R, i * (vgRectWidth(R) + shapeRect.Left * 2), j * (vgRectHeight(R) + shapeRect.Top * 2));
              Canvas.FillPath(P, R, AbsoluteOpacity);
              Canvas.DrawPath(P, R, AbsoluteOpacity);
            end;

          Canvas.RestoreCanvas(State);
        end;
    end;
  end;
  if Assigned(Scene) and Scene.GetDesignTime and not FLocked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
end;

procedure TvxCustomPath.SetWrapMode(const Value: TvxPathWrap);
begin
  if FWrapMode <> Value then
  begin
    FWrapMode := Value;
    Repaint;
  end;
end;

procedure TvxCustomPath.SetData(const Value: TvxPathData);
begin
  FData.Assign(Value);
end;

{ TvxPaintBox }

constructor TvxPaintBox.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxPaintBox.Destroy;
begin
  inherited;
end;

procedure TvxPaintBox.Paint;
begin
  inherited;
  if Assigned(FOnPaint) then
    FOnPaint(Self, Canvas);
end;

{ TvxSelection }

constructor TvxSelection.Create(AOwner: TComponent);
begin
  inherited;
  AutoCapture := true;
  ParentBounds := true;
  FMinSize := 15;
  FGripSize := 3;
end;

destructor TvxSelection.Destroy;
begin
  inherited;
end;

function TvxSelection.GetAbsoluteRect: TvxRect;
begin
  Result := inherited GetAbsoluteRect;
  vgInflateRect(Result, FGripSize + 4, FGripSize + 4);
end;

procedure TvxSelection.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
var
  R: TvxRect;
begin
  inherited;
  FDownPos := vgPoint(X, Y);
  if Button = mbLeft then
  begin
    FRatio := Width / Height;
    R := LocalRect;
    R := vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize));
    if vgPtInRect(FDownPos, R) then
    begin
      FLeftTop := true;
      Exit;
    end;
    R := LocalRect;
    R := vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize));
    if vgPtInRect(FDownPos, R) then
    begin
      FRightTop := true;
      Exit;
    end;
    R := LocalRect;
    R := vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize));
    if vgPtInRect(FDownPos, R) then
    begin
      FRightBottom := true;
      Exit;
    end;
    R := LocalRect;
    R := vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize));
    if vgPtInRect(FDownPos, R) then
    begin
      FLeftBottom := true;
      Exit;
    end;
    FMove := true;
  end;
end;

procedure TvxSelection.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  P, OldPos, Size: TvxPoint;
  S, SaveW: single;
  R: TvxRect;
begin
  inherited;
  if Shift = [] then
  begin
    FMovePos := vgPoint(X, Y);
    P := LocalToAbsolute(FMovePos);
    if Parent <> nil then
      P := TvxVisualObject(Parent).AbsolutetoLocal(P);
    R := LocalRect;
    R := vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize));
    if vgPtInRect(FMovePos, R) and not FLeftTopHot then
    begin
      FLeftTopHot := true;
      Repaint;
    end
    else
      if not vgPtInRect(FMovePos, R) and FLeftTopHot then
    begin
      FLeftTopHot := false;
      Repaint;
    end;
    R := LocalRect;
    R := vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize));
    if vgPtInRect(FMovePos, R) and not FRightTopHot then
    begin
      FRightTopHot := true;
      Repaint;
    end
    else
      if not vgPtInRect(FMovePos, R) and FRightTopHot then
    begin
      FRightTopHot := false;
      Repaint;
    end;
    R := LocalRect;
    R := vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize));
    if vgPtInRect(FMovePos, R) and not FRightBottomHot then
    begin
      FRightBottomHot := true;
      Repaint;
    end
    else
      if not vgPtInRect(FMovePos, R) and FRightBottomHot then
    begin
      FRightBottomHot := false;
      Repaint;
    end;
    R := LocalRect;
    R := vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize));
    if vgPtInRect(FMovePos, R) and not FLeftBottomHot then
    begin
      FLeftBottomHot := true;
      Repaint;
    end
    else
      if not vgPtInRect(FMovePos, R) and FLeftBottomHot then
    begin
      FLeftBottomHot := false;
      Repaint;
    end;
  end;
  if ssLeft in Shift then
  begin
    FMovePos := vgPoint(X, Y);
    if FMove then
    begin
      Position.X := Position.X + (FMovePos.X - FDownPos.X);
      Position.Y := Position.Y + (FMovePos.Y - FDownPos.Y);
      if ParentBounds then
      begin
        if Position.X < 0 then
          Position.X := 0;
        if Position.Y < 0 then
          Position.Y := 0;
        if Position.X + Width > TvxVisualObject(Parent).Width then
          Position.X := TvxVisualObject(Parent).Width - Width;
        if Position.Y + Height > TvxVisualObject(Parent).Height then
          Position.Y := TvxVisualObject(Parent).Height - Height;
      end;
      if Assigned(FOnTrack) then
        FOnTrack(Self);
      Exit;
    end;
    OldPos := Position.Point;
    P := LocalToAbsolute(FMovePos);
    if Parent <> nil then
      P := TvxVisualObject(Parent).AbsolutetoLocal(P);
    if ParentBounds then
    begin
      if P.Y < 0 then
        P.Y := 0;
      if P.X < 0 then
        P.X := 0;
      if P.X > TvxVisualObject(Parent).Width then
        P.X := TvxVisualObject(Parent).Width;
      if P.Y > TvxVisualObject(Parent).Height then
        P.Y := TvxVisualObject(Parent).Height;
    end;
    if FLeftTop then
    begin
      Repaint;
      Size := vgPoint((Position.X - (P.X + FDownPos.X)), (Position.Y - (P.Y + FDownPos.Y)));
      if Parent <> nil then
        Size := vgPointFromVector(TvxVisualObject(Parent).LocalToAbsoluteVector(vgVector(Size)));
      Size := vgPointFromVector(AbsoluteToLocalVector(vgVector(Size)));

      if FProportional then
      begin
        Width := Width + Size.X;
        SaveW := Width;
        if Width < FMinSize then
          Width := FMinSize;
        if Width / FRatio < FMinSize then
          Width := Round(FMinSize * FRatio);
        Position.X := P.X + FDownPos.X - (Width - SaveW);
        Position.Y := Position.Y + (Height - Round(Width / FRatio));
        Height := Round(Width / FRatio);
      end
      else
      begin
        Width := Width + Size.X;
        Height := Height + Size.Y;
        Position.X := P.X + FDownPos.X;
        Position.Y := P.Y + FDownPos.Y;
        if Width < FMinSize then
          Width := FMinSize;
        if Height < FMinSize then
          Height := FMinSize;
      end;
      if Assigned(FOnTrack) then
        FOnTrack(Self);
      Repaint;
    end;
    if FRightTop then
    begin
      Repaint;
      Size := vgPoint((P.X { + FDownPos.X}) - Position.X, (Position.Y - (P.Y + FDownPos.Y)));
      if Parent <> nil then
        Size := vgPointFromVector(TvxVisualObject(Parent).LocalToAbsoluteVector(vgVector(Size)));
      Size := vgPointFromVector(AbsoluteToLocalVector(vgVector(Size)));

      Width := Size.X;
      if FProportional then
      begin
        if Width < FMinSize then
          Width := FMinSize;
        if Width / FRatio < FMinSize then
          Width := Round(FMinSize * FRatio);
        Position.Y := Position.Y + (Height - Round(Width / FRatio));
        Height := Round(Width / FRatio);
      end
      else
      begin
        Height := Height + Size.Y;
        Position.Y := P.Y + FDownPos.Y;
        if Width < FMinSize then
          Width := FMinSize;
        if Height < FMinSize then
          Height := FMinSize;
      end;
      if Assigned(FOnTrack) then
        FOnTrack(Self);
      Repaint;
    end;
    if FRightBottom then
    begin
      Repaint;
      Size := vgPoint((P.X { + FDownPos.X}) - Position.X, (P.Y { + FDownPos.Y)}) - Position.Y);
      if Parent <> nil then
        Size := vgPointFromVector(TvxVisualObject(Parent).LocalToAbsoluteVector(vgVector(Size)));
      Size := vgPointFromVector(AbsoluteToLocalVector(vgVector(Size)));

      Width := Size.X;
      if FProportional then
      begin
        if Width < FMinSize then
          Width := FMinSize;
        if Width / FRatio < FMinSize then
          Width := Round(FMinSize * FRatio);
        Height := Round(Width / FRatio);
      end
      else
      begin
        Height := Size.Y;
        if Width < FMinSize then
          Width := FMinSize;
        if Height < FMinSize then
          Height := FMinSize;
      end;

      if Assigned(FOnTrack) then
        FOnTrack(Self);
      Repaint;
    end;
    if FLeftBottom then
    begin
      Repaint;
      Size := vgPoint((Position.X - (P.X + FDownPos.X)), (P.Y { + FDownPos.Y)}) - Position.Y);
      if Parent <> nil then
        Size := vgPointFromVector(TvxVisualObject(Parent).LocalToAbsoluteVector(vgVector(Size)));
      Size := vgPointFromVector(AbsoluteToLocalVector(vgVector(Size)));

      if FProportional then
      begin
        Width := Width + Size.X;
        SaveW := Width;
        if Width < FMinSize then
          Width := FMinSize;
        if Width / FRatio < FMinSize then
          Width := Round(FMinSize * FRatio);
        Position.X := P.X + FDownPos.X - (Width - SaveW);
        Height := Round(Width / FRatio);
      end
      else
      begin
        Width := Width + Size.X;
        Position.X := P.X + FDownPos.X;
        Height := Size.Y;
        if Width < FMinSize then
          Width := FMinSize;
        if Height < FMinSize then
          Height := FMinSize;
      end;
      if Assigned(FOnTrack) then
        FOnTrack(Self);
      Repaint;
    end;
  end;
end;

function TvxSelection.PointInObject(X, Y: single): boolean;
var
  R: TvxRect;
  P: TvxPoint;
begin
  Result := inherited PointInObject(X, Y);
  if not Result then
  begin
    P := AbsoluteToLocal(vgPoint(X, Y));
    R := LocalRect;
    R := vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize));
    if vgPtInRect(P, R) then
    begin
      Result := true;
      Exit;
    end;
    R := LocalRect;
    R := vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize));
    if vgPtInRect(P, R) then
    begin
      Result := true;
      Exit;
    end;
    R := LocalRect;
    R := vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize));
    if vgPtInRect(P, R) then
    begin
      Result := true;
      Exit;
    end;
    R := LocalRect;
    R := vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize));
    if vgPtInRect(P, R) then
    begin
      Result := true;
      Exit;
    end;
  end;
end;

procedure TvxSelection.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if FMove or FLeftTop or FLeftBottom or FRightTop or FRightBottom then
  begin
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
  FMove := false;
  FLeftTop := false;
  FLeftBottom := false;
  FRightTop := false;
  FRightBottom := false;
end;

procedure TvxSelection.Paint;
var
  R: TvxRect;
begin
  if FHideSelection then
    Exit;
  R := LocalRect;
  vgInflateRect(R, -0.5, -0.5);
  Canvas.Fill.Style := vgBrushSolid;
  Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.StrokeThickness := 1;
  Canvas.Stroke.Style := vgBrushSolid;
  Canvas.Stroke.SolidColor := $FF1072C5;
  Canvas.StrokeDash := vgDashDash;
  Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
  Canvas.StrokeDash := vgDashSolid;
  { angles }
  R := LocalRect;
  vgInflateRect(R, -0.5, -0.5);
  if FLeftTopHot then
    Canvas.Fill.SolidColor := $FFFF0000
  else
    Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.Fillellipse(vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize)), AbsoluteOpacity);
  Canvas.DrawEllipse(vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize)), AbsoluteOpacity);
  R := LocalRect;
  if FRightTopHot then
    Canvas.Fill.SolidColor := $FFFF0000
  else
    Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.Fillellipse(vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize)), AbsoluteOpacity);
  Canvas.DrawEllipse(vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize)), AbsoluteOpacity);
  R := LocalRect;
  if FLeftBottomHot then
    Canvas.Fill.SolidColor := $FFFF0000
  else
    Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.Fillellipse(vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize)), AbsoluteOpacity);
  Canvas.DrawEllipse(vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize)), AbsoluteOpacity);
  R := LocalRect;
  if FRightBottomHot then
    Canvas.Fill.SolidColor := $FFFF0000
  else
    Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.FillEllipse(vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize)), AbsoluteOpacity);
  Canvas.DrawEllipse(vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize)), AbsoluteOpacity);
end;

procedure TvxSelection.MouseLeave;
begin
  inherited;
  FLeftTopHot := false;
  FLeftBottomHot := false;
  FRightTopHot := false;
  FRightBottomHot := false;
  Repaint;
end;

procedure TvxSelection.SetHideSelection(const Value: boolean);
begin
  if FHideSelection <> Value then
  begin
    FHideSelection := Value;
    Repaint;
  end;
end;

procedure TvxSelection.SetMinSize(const Value: integer);
begin
  if FMinSize <> Value then
  begin
    FMinSize := Value;
    if FMinSize < 1 then
      FMinSize := 1;
  end;
end;

procedure TvxSelection.SetGripSize(const Value: single);
begin
  if FGripSize <> Value then
  begin
    FGripSize := Value;
    if FGripSize > 20 then
      FGripSize := 20;
    if FGripSize < 1 then
      FGripSize := 1;
    Repaint;
  end;
end;

{ TvxSelectionPoint }

constructor TvxSelectionPoint.Create(AOwner: TComponent);
begin
  inherited;
  AutoCapture := true;
  DisableDesignResize := true;
  ParentBounds := true;
  FGripSize := 3;
  Width := FGripSize * 2;
  Height := FGripSize * 2;
end;

destructor TvxSelectionPoint.Destroy;
begin
  inherited;
end;

function TvxSelectionPoint.PointInObject(X, Y: single): boolean;
var
  P: TvxPoint;
begin
  Result := false;
  P := AbsoluteToLocal(vgPoint(X, Y));
  if (Abs(P.X) < GripSize) and (Abs(P.Y) < GripSize) then
  begin
    Result := true;
  end;
end;

procedure TvxSelectionPoint.Paint;
begin
  inherited;
  Canvas.StrokeThickness := 1;
  Canvas.Stroke.Style := vgBrushSolid;
  Canvas.Stroke.SolidColor := $FF1072C5;
  Canvas.Fill.Style := vgBrushSolid;
  if IsMouseOver then
    Canvas.Fill.SolidColor := $FFFF0000
  else
    Canvas.Fill.SolidColor := $FFFFFFFF;
  if Assigned(FScene) and (FScene.GetSelected = Self) then
    Canvas.Fill.SolidColor := $FFFF0000;

  Canvas.FillEllipse(vgRect(-(GripSize), -(GripSize), (GripSize), (GripSize)), AbsoluteOpacity);
  Canvas.DrawEllipse(vgRect(-(GripSize), -(GripSize), (GripSize), (GripSize)), AbsoluteOpacity);
end;

procedure TvxSelectionPoint.SetHeight(const Value: single);
begin
  inherited SetHeight(FGripSize * 2);
end;

procedure TvxSelectionPoint.SetWidth(const Value: single);
begin
  inherited SetWidth(FGripSize * 2);
end;

procedure TvxSelectionPoint.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if Button = mbLeft then
    FPressed := true;
end;

procedure TvxSelectionPoint.MouseMove(Shift: TShiftState; X, Y, Dx,
  Dy: single);
var
  P: TvxPoint;
begin
  inherited;
  if FPressed and (Parent <> nil) then
  begin
    P := LocalToAbsolute(vgPoint(X, Y));
    P := Parent.Visual.AbsoluteToLocal(P);
    if ParentBounds then
    begin
      if P.X < 0 then
        P.X := 0;
      if P.Y < 0 then
        P.Y := 0;
      if P.X > Parent.Visual.Width then
        P.X := Parent.Visual.Width;
      if P.Y > Parent.Visual.Height then
        P.Y := Parent.Visual.Height;
    end;
    Position.X := P.X;
    Position.Y := P.Y;
    if Assigned(FOnTrack) then
      FOnTrack(Self);
  end;
end;

procedure TvxSelectionPoint.MouseUp(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if FPressed then
  begin
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
  FPressed := false;
end;

procedure TvxSelectionPoint.MouseEnter;
begin
  inherited;
  Repaint;
end;

procedure TvxSelectionPoint.MouseLeave;
begin
  inherited;
  Repaint;
end;

function TvxSelectionPoint.GetUpdateRect: TvxRect;
begin
  Result := inherited GetUpdateRect;
  vgInflateRect(Result, GripSize + 1, Gripsize + 1);
end;

procedure TvxSelectionPoint.SetGripSize(const Value: single);
begin
  if FGripSize <> Value then
  begin
    FGripSize := Value;
    if FGripSize > 20 then
      FGripSize := 20;
    if FGripSize < 1 then
      FGripSize := 1;
    Repaint;
  end;
end;

{ TvxDesignFrame }

constructor TvxDesignFrame.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxDesignFrame.Destroy;
begin
  inherited;
end;

procedure TvxDesignFrame.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
end;

procedure TvxDesignFrame.MouseLeave;
begin
  inherited;
end;

procedure TvxDesignFrame.MouseMove(Shift: TShiftState; X, Y, Dx,
  Dy: single);
begin
  inherited;
end;

procedure TvxDesignFrame.MouseUp(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  inherited;
end;

procedure TvxDesignFrame.Paint;
begin

end;

{ TvxScrollArrowLeft }

constructor TvxScrollArrowLeft.Create(AOwner: TComponent);
begin
  inherited;
  Data.Data := 'M 1,0 L 1,1 L 0,0.500 L 1,0 Z';
  Data.Scale(100, 100);
  WrapMode := vgPathFit;
end;

{ TvxScrollArrowRight }

constructor TvxScrollArrowRight.Create(AOwner: TComponent);
begin
  inherited;
  Data.Data := 'M 0,0 L 0,1 L 1,0.500 Z';
  Data.Scale(100, 100);
  WrapMode := vgPathFit;
end;

{$IFDEF WINDOWS}

procedure UseDirect2DCanvas;
begin
  SetD2DDefault;
end;
{$ENDIF}

function VarIsObject(Value: Variant): boolean;
var
  S: string;
begin
  S := Value;
  if (S <> '') and (Pos('vgobj', S) = 1) then
    Result := true
  else
    Result := false;
end;

function ObjectToVariant(const AObject: TObject): Variant;
begin
  Result := 'vgobj' + IntToStr(Integer(Pointer(AObject)));
end;

function VariantToObject(const Value: Variant): TObject;
var
  S: string;
begin
  S := Value;
  if (S <> '') and (Pos('vgobj', S) = 1) then
    Result := TObject(Pointer(StrToInt(Copy(S, 6, 10))))
  else
    Result := nil;
end;

function VarIsEvent(Value: Variant): boolean;
var
  S: string;
begin
  if VarIsStr(Value) then
  begin
    S := Value;
    if (S <> '') and (Pos('vgmet', S) = 1) then
      Result := true
    else
      Result := false;
  end
  else
    Result := false
end;

function EventToVariant(const AMethod: TNotifyEvent): Variant;
begin
  Result := 'vgmet' + IntToHex(Integer(TMethod(AMethod).Data), 8) + IntToHex(Integer(TMethod(AMethod).Code), 8);
end;

function VariantToEvent(const Value: Variant): TNotifyEvent;
var
  S: string;
begin
  S := Value;
  if (S <> '') and (Pos('vgmet', S) = 1) then
  begin
    TMethod(Result).Data := Pointer(StrToInt('$' + Copy(S, 6, 8)));
    TMethod(Result).Code := Pointer(StrToInt('$' + Copy(S, 14, 8)));
  end
  else
  begin
    Result := nil;
  end;
end;

type
  THackComponent = class(TComponent);

procedure RegisterVGObject(const Category: string; const AObject: TvxObjectClass);
begin
  if ObjectList = nil then
  begin
    ObjectList := TStringList.Create;
  end;
  ObjectList.InsertObject(0, Category, TObject(AObject));
  ObjectList.Sort;
end;

procedure RegisterVGObjects(const Category: string; AClasses: array of TvxObjectClass);
var
  I: Integer;
begin
  for I := Low(AClasses) to High(AClasses) do
  begin
    RegisterVGObject(Category, AClasses[I]);
    RegisterClass(AClasses[I]);
  end;
end;

{ Resoruces }

var
  ResourceList: TList;

procedure AddResource(const AObject: TvxObject);
begin
  if ResourceList = nil then
  begin
    ResourceList := TList.Create;
    ResourceList.Capacity := 100;
  end;
  if ResourceList.IndexOf(AObject) < 0 then
    ResourceList.Add(AObject);
end;

procedure RemoveResource(const AObject: TvxObject);
var
  Idx: integer;
begin
  if ResourceList <> nil then
  begin
    Idx := ResourceList.IndexOf(AObject);
    if Idx >= 0 then
      ResourceList[Idx] := nil;
  end;
end;

function FindResource(const AResource: string): TvxObject;
var
  i: integer;
begin
  Result := nil;
  if ResourceList <> nil then
    for i := ResourceList.Count - 1 downto 0 do
      if (ResourceList[i] <> nil) and TvxObject(ResourceList[i]).Stored then
        if CompareText(TvxObject(ResourceList[i]).ResourceName, AResource) = 0 then
        begin
          Result := TvxObject(ResourceList[i]);
          Break;
        end;
end;

function CreateObjectFromStream(AOwner: TComponent; const AStream: TStream): TvxObject;
var
  Reader: TReader;
  SavePos: Longint;
  I: Integer;
  Flags: TFilerFlags;
  ClassName: string;
  ObjClass: TvxObjectClass;
  BinStream: TStream;
begin
  Result := nil;
  try
    BinStream := TMemoryStream.Create;
    try
      ObjectTextToBinary(AStream, BinStream);
      BinStream.Position := 0;

      Reader := TReader.Create(BinStream, 4096);
      {$IFDEF FPC}
      Reader.Driver.BeginRootComponent;
      ClassName := Reader.Driver.ReadStr;
      {$ELSE}
      Reader.ReadSignature;
      Reader.ReadPrefix(Flags, I);
      ClassName := Reader.ReadStr;
      {$ENDIF}

      ObjClass := TvxObjectClass(GetClass(ClassName));
      Result := ObjClass.Create(AOwner);
      if Result <> nil then
      begin
        BinStream.Position := 0;
        Result.IntLoadFromBinStream(BinStream);
      end;
      Reader.Free;
    finally
      BinStream.Free;
    end;
  except
    Result := nil;
  end;
end;

function CreateObjectFromBinStream(AOwner: TComponent; const AStream: TStream): TvxObject;
var
  Reader: TReader;
  SavePos: Longint;
  I: Integer;
  Flags: TFilerFlags;
  ClassName: string;
  ObjClass: TvxObjectClass;
begin
  Result := nil;
  try
    SavePos := AStream.Position;

    Reader := TReader.Create(AStream, 4096);
    {$IFDEF FPC}
    Reader.Driver.BeginRootComponent;
    ClassName := Reader.Driver.ReadStr;
    {$ELSE}
    Reader.ReadSignature;
    Reader.ReadPrefix(Flags, I);
    ClassName := Reader.ReadStr;
    {$ENDIF}

    ObjClass := TvxObjectClass(GetClass(ClassName));
    Result := ObjClass.Create(AOwner);
    if Result <> nil then
    begin
      AStream.Position := SavePos;
      Result.IntLoadFromBinStream(AStream);
    end;
    Reader.Free;
  except
    Result := nil;
  end;
end;

function LoadObjectFromStream(AObject: TvxObject; const AStream: TStream): TvxObject;
var
  Reader: TReader;
  SavePos: Longint;
  I: Integer;
  Flags: TFilerFlags;
  ClassName: string;
  ObjClass: TvxObjectClass;
  BinStream: TStream;
begin
  Result := nil;
  try
    BinStream := TMemoryStream.Create;
    try
      ObjectTextToBinary(AStream, BinStream);
      BinStream.Position := 0;
      Result := AObject;
      if Result <> nil then
      begin
        BinStream.Position := 0;
        Result.IntLoadFromBinStream(BinStream);
      end;
      Reader.Free;
    finally
      BinStream.Free;
    end;
  except
    Result := nil;
  end;
end;

{ Scenes }
var
  SceneList: TList;
  NeedResetLang: boolean;

procedure AddScene(const AScene: IvgScene);
begin
  if SceneList = nil then
    SceneList := TList.Create;
  if SceneList.IndexOf(Pointer(AScene)) < 0 then
    SceneList.Add(Pointer(AScene));
end;

procedure RemoveScene(const AScene: IvgScene);
begin
  SceneList.Remove(Pointer(AScene));
end;

{ Lang }

var
  CollectLang, Lang: TvxWideStrings;

procedure CollectLangStart;
begin
  ResetLang;
  if CollectLang = nil then
  begin
    CollectLang := TvxWideStringList.Create;
    CollectLang.Sorted := true;
    TvxWideStringList(CollectLang).CaseSensitive := true;
  end;
end;

procedure CollectLangFinish;
begin
  if CollectLang <> nil then
    FreeAndNil(CollectLang);
end;

function CollectLangStrings: TvxWideStrings;
begin
  Result := CollectLang;
end;

procedure CollectLangSave;
begin
  if CollectLang <> nil then
  begin
    CollectLang.SaveToFile(ExtractFilePath(ParamStr(0)) + 'lang.lng');
  end;
end;

procedure LoadLangFromFile(AFileName: string);
begin
  if not FileExists(AFileName) then
    Exit;
  ResetLang;
  if Lang = nil then
  begin
    Lang := TvxWideStringList.Create;
    Lang.Sorted := true;
    TvxWideStringList(Lang).CaseSensitive := true;
  end;
  Lang.LoadFromFile(AFileName);
  UpdateLang;
end;

procedure LoadLangFromStrings(AStr: TvxWideStrings);
begin
  if AStr = nil then
    Exit;
  ResetLang;
  if Lang = nil then
  begin
    Lang := TvxWideStringList.Create;
    Lang.Sorted := true;
    TvxWideStringList(Lang).CaseSensitive := true;
  end;
  Lang.Assign(AStr);
  UpdateLang;
end;

procedure ResetLang;
begin
  if Lang <> nil then
  begin
    NeedResetLang := true;
    try
      UpdateLang;
    finally
      NeedResetLang := false;
      FreeAndNil(Lang);
    end;
  end;
end;

procedure UpdateLang;
var
  i: integer;
begin
  if SceneList <> nil then
  begin
    for i := 0 to SceneList.Count - 1 do
      IvgScene(SceneList[i]).UpdateResource;
  end;
end;

function Translate(const AText: WideString): WideString;
var
  Idx: integer;
begin
  if AText = '' then
  begin
    Result := '';
    Exit;
  end;
  if Assigned(CustomTranslateProc) then
  begin
    if CustomTranslateProc(AText) <> '' then
      Result := CustomTranslateProc(AText)
    else
      Result := AText;
    Exit;
  end;
  if CollectLang <> nil then
  begin
    CollectLang.Add(AText)
  end;
  if Lang <> nil then
  begin
    if not NeedResetLang then
      Result := Lang.Values[AText]
    else
      if Lang.IndexOfValue(AText) >= 0 then
      Result := Lang.Names[Lang.IndexOfValue(AText)];
    if Result = '' then
      Result := AText;
  end
  else
    Result := AText;
end;

function TranslateText(const AText: WideString): WideString;
begin
  Result := Translate(AText);
end;

{ Geom ========================================================================}

function vgGetToken(var S: Ansistring; Separators: Ansistring; Stop: Ansistring = ''): Ansistring;
var
  i, Len: integer;
  CopyS: Ansistring;
begin
  Result := '';
  CopyS := S;
  Len := Length(CopyS);
  for i := 1 to Len do
  begin
    if Pos(CopyS[i], Stop) > 0 then
      Break;
    Delete(S, 1, 1);
    if Pos(CopyS[i], Separators) > 0 then
    begin
      Result := Result;
      Break;
    end;
    Result := Result + CopyS[i];
  end;
  Result := Trim(Result);
  S := Trim(S);
end;

function vgWideGetToken(var Pos: integer; const S: WideString; Separators: WideString; Stop: WideString = ''): WideString;
var
  i, Len: integer;
begin
  Result := '';
  Len := Length(S);
  { skip first separators }
  for i := Pos to Len do
    if System.Pos(S[i], Separators) <= 0 then
      Break;
  Pos := i;
  { get }
  for i := Pos to Len do
  begin
    if System.Pos(S[i], Stop) > 0 then
      Break;
    if System.Pos(S[i], Separators) > 0 then
      Break;
    Result := Result + S[i];
  end;
  { skip separators }
  Pos := i;
  for i := Pos to Len do
    if System.Pos(S[i], Separators) <= 0 then
      Break;
  Pos := i;
end;

procedure vgReverseBytes(p: Pointer; Count: integer);
var
  p1: PChar;
  p2: PChar;
  c: Char;
begin
  p1 := PChar(p);
  p2 := PChar(p) + Count - 1;
  while p1 < p2 do
  begin
    c := p1^;
    p1^ := p2^;
    p2^ := c;
    System.inc(p1);
    System.dec(p2);
  end;
end;

procedure vgMoveLongword(const Src: Pointer; Dst: Pointer; Count: Integer);
begin
  System.Move(Src^, Dst^, Count * 4); // move() is optimized and fast
end;

procedure vgFillLongword(Src: Pointer; Count: Integer; Value: Longword);
var
  i: integer;
begin
  {$IFDEF cpu64}
  for i := 0 to Count - 1 do
    PvgColorArray(Src)[i] := Value;
  {$ELSE}
  for i := 1 to Count shr 2 do
  begin // 4 DWORD by loop - aligned pipelined write
    PvgColorArray(Src)[0] := Value;
    PvgColorArray(Src)[1] := Value;
    PvgColorArray(Src)[2] := Value;
    PvgColorArray(Src)[3] := Value;
    inc(cardinal(Src), 16);
  end;
  for i := 0 to (Count and 3) - 1 do // last 0..3 DWORD
    PvgColorArray(Src)[i] := Value;
  {$ENDIF}
end;

procedure vgFillAlpha(Src: Pointer; Count: Integer; Alpha: byte);
var
  i: integer;
begin
  for i := 0 to Count - 1 do
    PvgColorRecArray(Src)[i].A := Alpha;
end;

procedure vgFillLongwordRect(Src: Pointer; W, H, X1, Y1, X2, Y2: Integer; Value: Longword);
var
  j: integer;
begin
  if x2 > W then
    x2 := W;
  if y2 > H then
    y2 := H;
  if x1 > x2 then
    x1 := x1;
  if y1 > y2 then
    y1 := y2;
  for j := y1 to y2 - 1 do
    vgFillLongword(@PvgColorArray(Src)[X1 + (j * W)], X2 - X1, Value);
end;

function vgMaxFloat(A1, A2: single): single;
begin
  if A1 > A2 then
    Result := A1
  else
    Result := A2;
end;

function vgMinFloat(A1, A2: single): single;
begin
  if A1 < A2 then
    Result := A1
  else
    Result := A2;
end;

function vgMinMax(x, mi, ma: single): single;
begin
  if (x < mi) then
    Result := mi
  else
    if (x > ma) then
    Result := ma
  else
    Result := x;
end;

{ Colors ========================================================================}

function vgRGBtoBGR(const C: TvxColor): TvxColor;
begin
  Result := C;
  TvxColorRec(Result).R := TvxColorRec(C).B;
  TvxColorRec(Result).B := TvxColorRec(C).R;
end;

{$IFNDEF NOVCL}

function vgColorFromVCL(const C: TColor): TvxColor;
begin
  Result := vgRGBtoBGR(ColorToRGB(C)) or $FF000000;
end;
{$ENDIF}

function vgCorrectColor(const C: TvxColor): TvxColor;
begin
  Result := C;
  {$IFDEF DARWIN}
  TvxColorRec(Result).R := TvxColorRec(C).B;
  TvxColorRec(Result).B := TvxColorRec(C).R;
  {$ENDIF}
end;

function vgPremultyAlpha(const C: TvxColor): TvxColor;
begin
  if TvxColorRec(C).A = 0 then
    Result := 0
  else
    if TvxColorRec(C).A = $FF then
    Result := C
  else
  begin
    TvxColorRec(Result).R := trunc(TvxColorRec(C).R * (TvxColorRec(C).A / $FF));
    TvxColorRec(Result).G := trunc(TvxColorRec(C).G * (TvxColorRec(C).A / $FF));
    TvxColorRec(Result).B := trunc(TvxColorRec(C).B * (TvxColorRec(C).A / $FF));
    TvxColorRec(Result).A := TvxColorRec(C).A;
  end;
end;

function vgUnpremultyAlpha(const C: TvxColor): TvxColor;
begin
  if TvxColorRec(C).A = 0 then
    Result := 0
  else
    if TvxColorRec(C).A = $FF then
    Result := C
  else
  begin
    TvxColorRec(Result).R := trunc(TvxColorRec(C).R / (TvxColorRec(C).A / $FF));
    TvxColorRec(Result).G := trunc(TvxColorRec(C).G / (TvxColorRec(C).A / $FF));
    TvxColorRec(Result).B := trunc(TvxColorRec(C).B / (TvxColorRec(C).A / $FF));
    TvxColorRec(Result).A := TvxColorRec(C).A;
  end;
end;

function vgOpacity(const C: TvxColor; const AOpacity: single): TvxColor;
begin
  Result := C;
  if AOpacity < 1 then
    TvxColorRec(Result).A := Trunc(TvxColorRec(C).A * AOpacity);
end;

function vgColor(R, G, B: Byte; A: Byte = $FF): TvxColor;
begin
  TvxColorRec(Result).R := R;
  TvxColorRec(Result).G := G;
  TvxColorRec(Result).B := B;
  TvxColorRec(Result).A := A;
end;

function vgChangeHSL(const C: TvxColor; dH, dS, dL: single): TvxColor;
var
  H, S, L: single;
  A: byte;
begin
  A := TvxColorRec(c).A;
  vgRGBtoHSL(C, H, S, L);
  H := H + dH;
  if H < 0 then
    H := 0;
  if H > 1 then
    H := 1;
  S := S + dS;
  if S < 0 then
    S := 0;
  if S > 1 then
    S := 1;
  L := L + dL;
  if L < 0 then
    L := 0;
  if L > 1 then
    L := 1;
  Result := vgHSLtoRGB(H, S, L);
  TvxColorRec(Result).A := A;
end;

function vgColorToStr(Value: TvxColor): string;
begin
  Result := '#' + IntToHex(Value, 8);
end;

function vgStrToColor(Value: string): TvxColor;
var
  i: integer;
begin
  if Value = #0 then
    Value := '$0'
  else
    if (Value <> '') and (Value[1] = '#') then
    Value[1] := '$'
  else
  begin
    for i := 0 to High(vgColorIdents) do
      if CompareText(Value, vgColorIdents[i].Name) = 0 then
      begin
        Value := vgColorIdents[i].Value;
        Value[1] := '$';
        Break;
      end;
  end;
  try
    Result := StrToInt(Value);
  except
  end;
end;

function vgFloatToStr(Value: single): string;
var
  S: char;
begin
  S := DecimalSeparator;
  try
    DecimalSeparator := '.';
    if Frac(Value) <> 0 then
      Result := Format('%.3f', [Value])
    else
      Result := IntToStr(Trunc(Value))
  finally
    DecimalSeparator := S;
  end;
end;

function vgStrToFloat(Value: string): single;
var
  S: char;
begin
  S := DecimalSeparator;
  try
    DecimalSeparator := '.';
    Result := StrToFloat(Value);
  finally
    DecimalSeparator := S;
  end;
end;

function vgHSLtoRGB(H, S, L: Single): TvxColor;
  function hue2rgb(p, q, t: single): single;
  begin
    if (t < 0) then
      t := t + 1;
    if (t > 1) then
      t := t - 1;
    if (t < 1 / 6) then
    begin
      Result := p + (q - p) * 6 * t;
      Exit;
    end;
    if (t < 1 / 2) then
    begin
      Result := q;
      Exit;
    end;
    if (t < 2 / 3) then
    begin
      Result := p + (q - p) * (2 / 3 - t) * 6;
      Exit;
    end;
    Result := p;
  end;
var
  r, g, b: single;
  q, p: single;
begin
  if (s = 0) then
  begin
    r := L;
    g := L;
    b := L;
  end
  else
  begin
    if (L < 0.5) then
      q := L * (1 + S)
    else
      q := L + S - L * S;
    p := 2 * L - q;
    r := hue2rgb(p, q, H + 1 / 3);
    g := hue2rgb(p, q, H);
    b := hue2rgb(p, q, H - 1 / 3);
  end;
  Result := vgColor(round(r * $FF), round(g * $FF), round(b * $FF));
end;

procedure vgRGBtoHSL(RGB: TvxColor; out H, S, L: single);
var
  r, g, b: single;
  d, mx, mn: single;
begin
  r := TvxColorRec(RGB).R / $FF;
  g := TvxColorRec(RGB).G / $FF;
  b := TvxColorRec(RGB).B / $FF;
  mx := Max(Max(R, G), B);
  mn := Min(Min(R, G), B);
  H := (mx + mn) / 2;
  L := H;
  S := H;
  if (mx = mn) then
  begin
    S := 0;
    H := 0;
  end
  else
  begin
    d := mx - mn;
    if L > 0.5 then
      S := d / (2 - mx - mn)
    else
      S := d / (mx + mn);
    if (mx = r) then
      H := (g - b) / d
    else
      if (mx = g) then
      H := (b - r) / d + 2
    else
      H := (r - g) / d + 4;
    H := H / 6;
    if H < 0 then
      H := H + 1;
  end;
end;

{ math }

const
  // to be used as descriptive indices
  X = 0;
  Y = 1;
  Z = 2;
  W = 3;

procedure vgSinCos(const Theta: single; var Sin, Cos: single);
var
  s, c: Extended;
begin
  Math.SinCos(Theta, s, c);
  Sin := s;
  Cos := c;
end;

function vgRadToDeg(const Degrees: single): single;
begin
  Result := Degrees * c180divPI;
end;

function vgDegToRad(const Degrees: single): single;
begin
  Result := Degrees * cPIdiv180;
end;

function vgNormalizeAngle(const angle: Single): Single;
begin
  Result := angle - Int(angle * cInv360) * c360;
  if Result < -c180 then
    Result := Result + c360;
end;

function vgPoint(X, Y: single): TvxPoint;
begin
  Result.X := X;
  Result.Y := Y;
end;

function vgMinPoint(P1, P2: TvxPoint): TvxPoint;
begin
  Result := P1;
  if (P2.y < P1.y) or ((P2.y = P1.y) and (P2.x < P1.x)) then
    Result := P2;
end;

function vgScalePoint(P: TvxPoint; dx, dy: single): TvxPoint;
begin
  Result.X := P.X * dx;
  Result.Y := P.Y * dy;
end;

function vgRect(ALeft, ATop, ARight, ABottom: single): TvxRect;
begin
  Result.Left := ALeft;
  Result.Top := ATop;
  Result.Right := ARight;
  Result.Bottom := ABottom;
end;

function vgNormalizeRect(const Pts: array of TvxPoint): TvxRect;
var
  i: integer;
begin
  Result.Left := $F000;
  Result.Top := $F000;
  Result.Right := -$F000;
  Result.Bottom := -$F000;
  for i := 0 to High(Pts) do
  begin
    if Pts[i].X < Result.Left then
      Result.Left := Pts[i].X;
    if Pts[i].Y < Result.Top then
      Result.Top := Pts[i].Y;
    if Pts[i].X > Result.Right then
      Result.Right := Pts[i].X;
    if Pts[i].Y > Result.Bottom then
      Result.Bottom := Pts[i].Y;
  end;
end;

function vgNormalizeRect2(const ARect: TvxRect): TvxRect;
begin
  with ARect do
    Result := vgNormalizeRect([vgPoint(Left, Top), vgPoint(Right, Top), vgPoint(Right, Bottom), vgPoint(Left, Bottom)]);
end;

procedure vgOffsetRect(var R: TvxRect; const Dx, Dy: single);
begin
  R.Left := R.Left + Dx;
  R.Right := R.Right + Dx;
  R.Top := R.Top + Dy;
  R.Bottom := R.Bottom + Dy;
end;

procedure vgMultiplyRect(var R: TvxRect; const Dx, Dy: single);
begin
  R.Left := R.Left * Dx;
  R.Right := R.Right * Dx;
  R.Top := R.Top * Dy;
  R.Bottom := R.Bottom * Dy;
end;

procedure vgInflateRect(var R: TvxRect; const Dx, Dy: single);
begin
  R.Left := R.Left - Dx;
  R.Right := R.Right + Dx;
  R.Top := R.Top - Dy;
  R.Bottom := R.Bottom + Dy;
end;

function vgUnionRect(const ARect1, ARect2: TvxRect): TvxRect;
begin
  Result.Left := ARect1.Left;
  if ARect2.Left < Result.Left then
    Result.Left := ARect2.Left;

  Result.Top := ARect1.Top;
  if ARect2.Top < Result.Top then
    Result.Top := ARect2.Top;

  Result.Right := ARect1.Right;
  if ARect2.Right > Result.Right then
    Result.Right := ARect2.Right;

  Result.Bottom := ARect1.Bottom;
  if ARect2.Bottom > Result.Bottom then
    Result.Bottom := ARect2.Bottom;
end;

function vgRectWidth(const R: TvxRect): single;
begin
  Result := R.Right - R.Left;
end;

function vgRectHeight(const R: TvxRect): single;
begin
  Result := R.Bottom - R.Top;
end;

function vgRectCenter(var R: TvxRect; Bounds: TvxRect): TvxRect;
begin
  vgOffsetRect(R, -R.Left, -R.Top);
  vgOffsetRect(R, round((vgRectWidth(Bounds) - vgRectWidth(R)) / 2), round((vgRectHeight(Bounds) - vgRectHeight(R)) / 2));
  vgOffsetRect(R, Bounds.Left, Bounds.Top);

  Result := R;
end;

function vgFitRect(var R: TvxRect; BoundsRect: TvxRect): single;
var
  ratio: single;
begin
  Result := 1;
  if vgRectWidth(BoundsRect) * vgRectHeight(BoundsRect) = 0 then
    Exit;

  if (vgRectWidth(R) / vgRectWidth(BoundsRect)) > (vgRectHeight(R) / vgRectHeight(BoundsRect)) then
    ratio := vgRectWidth(R) / vgRectWidth(BoundsRect)
  else
    ratio := vgRectHeight(R) / vgRectHeight(BoundsRect);

  if ratio < 1 then
  begin
    R := vgRect(0, 0, vgRectWidth(R), vgRectHeight(R));
  end
  else
  begin
    R := vgRect(0, 0, round(vgRectWidth(R) / ratio), round(vgRectHeight(R) / ratio));
  end;

  Result := ratio;
  vgRectCenter(R, BoundsRect);
end;

function vgIsRectEmpty(Rect: TvxRect): boolean;
begin
  Result := (vgRectWidth(Rect) <= 0) or (vgRectHeight(Rect) <= 0);
end;

function vgIntersectRect(const Rect1, Rect2: TvxRect): boolean;
begin
  Result := (Rect1.Left <= Rect2.Right) and (Rect1.Right >= Rect2.Left) and (Rect1.Top <= Rect2.Bottom) and (Rect1.Bottom >= Rect2.Top);
end;

function vgIntersectRect(var DestRect: TvxRect; const SrcRect1, SrcRect2: TvxRect): boolean;
begin
  Result := (SrcRect2.Left < SrcRect1.Right)
    and (SrcRect2.Right > SrcRect1.Left)
    and (SrcRect2.Top < SrcRect1.Bottom)
    and (SrcRect2.Bottom > SrcRect1.Top);

  if Result then
  begin
    DestRect.Left := Max(SrcRect1.Left, SrcRect2.Left);
    DestRect.Top := Max(SrcRect1.Top, SrcRect2.Top);
    DestRect.Right := Min(SrcRect1.Right, SrcRect2.Right);
    DestRect.Bottom := Min(SrcRect1.Bottom, SrcRect2.Bottom);
  end
  else
  begin
    DestRect.Left := 0;
    DestRect.Top := 0;
    DestRect.Right := 0;
    DestRect.Bottom := 0;
  end;
end;

function vgPtInRect(const P: TvxPoint; const Rect: TvxRect): boolean;
begin
  Result := (P.X >= Rect.Left) and (P.X <= Rect.Right) and (P.Y >= Rect.Top) and (P.Y <= Rect.Bottom);
end;

function vgRectToString(R: TvxRect): Ansistring;
begin
  Result := '(' + vgFloatToStr(R.Left) + ',' + vgFloatToStr(R.Top) + ',' + vgFloatToStr(R.Right) + ',' +
    vgFloatToStr(R.Bottom) + ')';
end;

function vgStringToRect(S: Ansistring): TvxRect;
begin
  try
    vgGetToken(S, ',()');
    Result.Left := vgStrToFloat(vgGetToken(S, ',()'));
    Result.Top := vgStrToFloat(vgGetToken(S, ',()'));
    Result.Right := vgStrToFloat(vgGetToken(S, ',()'));
    Result.Bottom := vgStrToFloat(vgGetToken(S, ',()'));
  except
    Result := vgRect(0, 0, 0, 0);
  end;
end;

function vgPointFromVector(const v: TvxVector): TvxPoint;
begin
  Result.x := v.x;
  Result.y := v.y;
end;

function vgPointToString(R: TvxPoint): Ansistring;
begin
  Result := '(' + vgFloatToStr(R.X) + ',' + vgFloatToStr(R.Y) + ')';
end;

function vgStringToPoint(S: Ansistring): TvxPoint;
begin
  try
    vgGetToken(S, ',()');
    Result.X := vgStrToFloat(vgGetToken(S, ',()'));
    Result.Y := vgStrToFloat(vgGetToken(S, ',()'));
  except
    Result := vgPoint(0, 0);
  end;
end;

function vgMatrixMultiply(const M1, M2: TvxMatrix): TvxMatrix;
begin
  Result.m11 := M1.m11 * M2.m11 + M1.m12 * M2.m21 + M1.m13 * M2.m31;
  Result.m12 := M1.m11 * M2.m12 + M1.m12 * M2.m22 + M1.m13 * M2.m32;
  Result.m13 := M1.m11 * M2.m13 + M1.m12 * M2.m23 + M1.m13 * M2.m33;
  Result.m21 := M1.m21 * M2.m11 + M1.m22 * M2.m21 + M1.m23 * M2.m31;
  Result.m22 := M1.m21 * M2.m12 + M1.m22 * M2.m22 + M1.m23 * M2.m32;
  Result.m23 := M1.m21 * M2.m13 + M1.m22 * M2.m23 + M1.m23 * M2.m33;
  Result.m31 := M1.m31 * M2.m11 + M1.m32 * M2.m21 + M1.m33 * M2.m31;
  Result.m32 := M1.m31 * M2.m12 + M1.m32 * M2.m22 + M1.m33 * M2.m32;
  Result.m33 := M1.m31 * M2.m13 + M1.m32 * M2.m23 + M1.m33 * M2.m33;
end;

function vgMatrixDeterminant(const M: TvxMatrix): single;
begin
  Result := M.M[X].V[X] * (M.M[Y].V[Y] * M.M[Z].V[Z] - M.M[Z].V[Y] * M.M[Y].V[Z])
    - M.M[X].V[Y] * (M.M[Y].V[X] * M.M[Z].V[Z] - M.M[Z].V[X] * M.M[Y].V[Z])
    + M.M[X].V[Z] * (M.M[Y].V[X] * M.M[Z].V[Y] - M.M[Z].V[X] * M.M[Y].V[Y]);
end;

procedure vgAdjointMatrix(var M: TvxMatrix);
var
  a1, a2, a3,
    b1, b2, b3,
    c1, c2, c3: Single;
begin
  a1 := M.M[X].V[X];
  a2 := M.M[X].V[Y];
  a3 := M.M[X].V[Z];
  b1 := M.M[Y].V[X];
  b2 := M.M[Y].V[Y];
  b3 := M.M[Y].V[Z];
  c1 := M.M[Z].V[X];
  c2 := M.M[Z].V[Y];
  c3 := M.M[Z].V[Z];
  M.M[X].V[X] := (b2 * c3 - c2 * b3);
  M.M[Y].V[X] := -(b1 * c3 - c1 * b3);
  M.M[Z].V[X] := (b1 * c2 - c1 * b2);

  M.M[X].V[Y] := -(a2 * c3 - c2 * a3);
  M.M[Y].V[Y] := (a1 * c3 - c1 * a3);
  M.M[Z].V[Y] := -(a1 * c2 - c1 * a2);

  M.M[X].V[Z] := (a2 * b3 - b2 * a3);
  M.M[Y].V[Z] := -(a1 * b3 - b1 * a3);
  M.M[Z].V[Z] := (a1 * b2 - b1 * a2);
end;

procedure vgScaleMatrix(var M: TvxMatrix; const factor: single);
var
  i: Integer;
begin
  for i := 0 to 2 do
  begin
    M.M[I].V[0] := M.M[I].V[0] * Factor;
    M.M[I].V[1] := M.M[I].V[1] * Factor;
    M.M[I].V[2] := M.M[I].V[2] * Factor;
  end;
end;

procedure vgInvertMatrix(var M: TvxMatrix);
var
  det: Single;
begin
  det := vgMatrixDeterminant(M);
  if Abs(Det) < EPSILON then
    M := IdentityMatrix
  else
  begin
    vgAdjointMatrix(M);
    vgScaleMatrix(M, 1 / det);
  end;
end;

function vgVector(const x, y: Single; const w: single = 1.0): TvxVector;
begin
  Result.X := x;
  Result.Y := y;
  Result.W := w;
end;

function vgVector(const P: TvxPoint; const w: single = 1.0): TvxVector;
begin
  Result.X := P.x;
  Result.Y := P.y;
  Result.W := w;
end;

function vgVectorTransform(const V: TvxVector; const M: TvxMatrix): TvxVector;
begin
  Result.V[X] := V.V[X] * M.M[X].V[X] + V.V[Y] * M.M[Y].V[X] + V.V[Z] * M.M[Z].V[X];
  Result.V[Y] := V.V[X] * M.M[X].V[Y] + V.V[Y] * M.M[Y].V[Y] + V.V[Z] * M.M[Z].V[Y];
  Result.V[2] := 1.0;
end;

function vgVectorAdd(const v1: TvxVector; const v2: TvxVector): TvxVector;
begin
  Result.v[0] := v1.v[0] + v2.v[0];
  Result.v[1] := v1.v[1] + v2.v[1];
  Result.W := 1.0;
end;

function vgVectorSubtract(const v1: TvxVector; const v2: TvxVector): TvxVector;
begin
  Result.v[0] := v1.v[0] - v2.v[0];
  Result.v[1] := v1.v[1] - v2.v[1];
  Result.W := 1.0;
end;

function vgVectorNorm(const v: TvxVector): Single;
begin
  Result := v.V[0] * v.V[0] + v.V[1] * v.V[1];
end;

function RSqrt(v: Single): Single;
var
  R: double;
begin
  R := Abs(V);
  if (R > 0) then
    Result := 1 / Sqrt(R)
  else
    Result := 1;
end;

function vgVectorNormalize(const v: TvxVector): TvxVector;
var
  invLen: Single;
begin
  invLen := RSqrt(Abs(vgVectorNorm(v)));
  Result.v[0] := v.v[0] * invLen;
  Result.v[1] := v.v[1] * invLen;
  Result.v[2] := 0.0;
end;

function vgVectorScale(const v: TvxVector; factor: Single): TvxVector;
begin
  Result.v[0] := v.v[0] * factor;
  Result.v[1] := v.v[1] * factor;
  Result.W := 1;
end;

function vgVectorLength(const v: TvxVector): Single;
begin
  Result := Sqrt(vgVectornorm(v));
end;

function vgVectorDotProduct(const V1, V2: TvxVector): Single;
begin
  Result := V1.V[0] * V2.V[0] + V1.V[1] * V2.V[1];
end;

function vgVectorAngleCosine(const V1, V2: TvxVector): Single;
begin
  if (vgVectorLength(V1) <> 0) and (vgVectorLength(V2) <> 0) then
  begin
    Result := vgVectorDotProduct(V1, V2) / (vgVectorLength(V1) * vgVectorLength(V2));
    if Result > 1 then
      Result := 1;
  end
  else
    Result := 0;
end;

function vgVectorCrossProductZ(const V1, V2: TvxVector): single;
begin
  // 3D Cross with Z = 0
  Result := v1.X * v2.Y - v1.Y * v2.X;
end;

function vgVectorCombine2(const V1, V2: TvxVector; const F1, F2: Single): TvxVector;
begin
  Result.V[X] := (F1 * V1.V[X]) + (F2 * V2.V[X]);
  Result.V[Y] := (F1 * V1.V[Y]) + (F2 * V2.V[Y]);
  Result.W := 1.0;
end;

function vgVectorReflect(const V, N: TvxVector): TvxVector;
begin
  Result := vgVectorCombine2(V, N, 1, -2 * vgVectorDotProduct(V, N));
end;

function vgVectorAngle(const V, N: TvxVector): single;
begin
  if vgVectorCrossProductZ(V, N) < 0 then
    Result := vgRadToDeg(ArcCos(vgVectorAngleCosine(V, N)))
  else
    Result := -vgRadToDeg(ArcCos(vgVectorAngleCosine(V, N)));
end;

function vgCreateRotationMatrix(angle: single): TvxMatrix;
var
  cosine, sine: single;
begin
  vgSinCos(angle, sine, cosine);

  Result.m11 := cosine;
  Result.m12 := sine;
  Result.m13 := 0;
  Result.m21 := -sine;
  Result.m22 := cosine;
  Result.m23 := 0;

  Result.m31 := 0;
  Result.m32 := 0;
  Result.m33 := 1;
end;

function vgInterpolateSingle(const start, stop, t: single): single;
begin
  Result := start + (stop - start) * t;
end;

function vgInterpolateRotation(start, stop, t: Single): Single;
begin
  Result := vgInterpolateSingle(start, stop, t);
end;

function vgInterpolateColor(start, stop: TvxColor; t: single): TvxColor;
begin
  TvxColorRec(Result).A := TvxColorRec(start).A + Trunc((TvxColorRec(stop).A - TvxColorRec(start).A) * t);
  TvxColorRec(Result).R := TvxColorRec(start).R + Trunc((TvxColorRec(stop).R - TvxColorRec(start).R) * t);
  TvxColorRec(Result).G := TvxColorRec(start).G + Trunc((TvxColorRec(stop).G - TvxColorRec(start).G) * t);
  TvxColorRec(Result).B := TvxColorRec(start).B + Trunc((TvxColorRec(stop).B - TvxColorRec(start).B) * t);
end;

function vgAppendColor(start, stop: TvxColor): TvxColor;
begin
  if TvxColorRec(start).A + TvxColorRec(stop).A < $FF then
    TvxColorRec(Result).A := TvxColorRec(start).A + TvxColorRec(stop).A
  else
    TvxColorRec(Result).A := $FF;
  if TvxColorRec(start).R + TvxColorRec(stop).R < $FF then
    TvxColorRec(Result).R := TvxColorRec(start).R + TvxColorRec(stop).R
  else
    TvxColorRec(Result).R := $FF;
  if TvxColorRec(start).G + TvxColorRec(stop).G < $FF then
    TvxColorRec(Result).G := TvxColorRec(start).G + TvxColorRec(stop).G
  else
    TvxColorRec(Result).G := $FF;
  if TvxColorRec(start).B + TvxColorRec(stop).B < $FF then
    TvxColorRec(Result).B := TvxColorRec(start).B + TvxColorRec(stop).B
  else
    TvxColorRec(Result).B := $FF;
end;

function vgSubtractColor(start, stop: TvxColor): TvxColor;
begin
  if TvxColorRec(start).A - TvxColorRec(stop).A < $FF then
    TvxColorRec(Result).A := TvxColorRec(start).A - TvxColorRec(stop).A
  else
    TvxColorRec(Result).A := $FF;
  if TvxColorRec(start).R - TvxColorRec(stop).R < $FF then
    TvxColorRec(Result).R := TvxColorRec(start).R - TvxColorRec(stop).R
  else
    TvxColorRec(Result).R := $FF;
  if TvxColorRec(start).G - TvxColorRec(stop).G < $FF then
    TvxColorRec(Result).G := TvxColorRec(start).G - TvxColorRec(stop).G
  else
    TvxColorRec(Result).G := $FF;
  if TvxColorRec(start).B - TvxColorRec(stop).B < $FF then
    TvxColorRec(Result).B := TvxColorRec(start).B - TvxColorRec(stop).B
  else
    TvxColorRec(Result).B := $FF;
end;

{ Interpolation ===============================================================}

{ interpolations }

function vgInterpolateBack(T, B, C, D, S: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        if S = 0 then
          S := 1.70158;
        T := T / D;
        Result := C * T * T * ((S + 1) * T - S) + B;
      end;
    vgAnimationOut:
      begin
        if S = 0 then
          S := 1.70158;
        T := T / D - 1;
        Result := C * (T * T * ((S + 1) * T + S) + 1) + B;
      end;
    vgAnimationInOut:
      begin
        if S = 0 then
          S := 1.70158;
        T := T / (D / 2);
        if T < 1 then
        begin
          S := S * 1.525;
          Result := C / 2 * (T * T * ((S + 1) * T - S)) + B;
        end
        else
        begin
          T := T - 2;
          S := S * 1.525;
          Result := C / 2 * (T * T * ((S + 1) * T + S) + 2) + B;
        end;
      end;
  end;
end;

function vgInterpolateBounce(T, B, C, D: Double; aType: TvxAnimationType): Double;
  function _EaseOut(T, B, C, D: Double): Double;
  begin
    T := T / D;
    if T < 1 / 2.75 then
    begin
      Result := C * (7.5625 * T * T) + B;
    end
    else
      if T < 2 / 2.72 then
    begin
      T := T - (1.5 / 2.75);
      Result := C * (7.5625 * T * T + 0.75) + B;
    end
    else
      if T < 2.5 / 2.75 then
    begin
      T := T - (2.25 / 2.75);
      Result := C * (7.5625 * T * T + 0.9375) + B;
    end
    else
    begin
      T := T - (2.625 / 2.75);
      Result := C * (7.5625 * T * T + 0.984375) + B;
    end;
  end;
  function _EaseIn(T, B, C, D: Double): Double;
  begin
    Result := C - _EaseOut(D - T, 0, C, D) + B;
  end;
begin
  case aType of
    vgAnimationIn:
      begin
        Result := _EaseIn(T, B, C, D);
      end;
    vgAnimationOut:
      begin
        Result := _EaseOut(T, B, C, D);
      end;
    vgAnimationInOut:
      begin
        if T < D / 2 then
          Result := _EaseIn(T * 2, 0, C, D) * 0.5 + B
        else
          Result := _EaseOut(T * 2 - D, 0, C, D) * 0.5 + C * 0.5 + B;
      end;
  end;
end;

function vgInterpolateCirc(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        T := T / D;
        Result := -C * (Sqrt(1 - T * T) - 1) + B;
      end;
    vgAnimationOut:
      begin
        T := T / D - 1;
        Result := C * Sqrt(1 - T * T) + B;
      end;
    vgAnimationInOut:
      begin
        T := T / (D / 2);
        if T < 1 then
          Result := -C / 2 * (Sqrt(1 - T * T) - 1) + B
        else
        begin
          T := T - 2;
          Result := C / 2 * (Sqrt(1 - T * T) + 1) + B;
        end;
      end;
  end;
end;

function vgInterpolateCubic(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        T := T / D;
        Result := C * T * T * T + B;
      end;
    vgAnimationOut:
      begin
        T := T / D - 1;
        Result := C * (T * T * T + 1) + B;
      end;
    vgAnimationInOut:
      begin
        T := T / (D / 2);
        if T < 1 then
          Result := C / 2 * T * T * T + B
        else
        begin
          T := T - 2;
          Result := C / 2 * (T * T * T + 2) + B;
        end;
      end;
  end;
end;

function vgInterpolateElastic(T, B, C, D, A, P: Double; aType: TvxAnimationType): Double;
var
  S: Double;
begin
  case aType of
    vgAnimationIn:
      begin
        if T = 0 then
        begin
          Result := B;
          Exit;
        end;
        T := T / D;
        if T = 1 then
        begin
          Result := B + C;
          Exit;
        end;
        if P = 0 then
          P := D * 0.3;
        if (A = 0) or (A < Abs(C)) then
        begin
          A := C;
          S := P / 4;
        end
        else
        begin
          S := P / (2 * Pi) * ArcSin(C / A);
        end;
        T := T - 1;
        Result := -(A * Power(2, 10 * T) * Sin((T * D - S) * (2 * Pi) / P)) + B;
      end;
    vgAnimationOut:
      begin
        if T = 0 then
        begin
          Result := B;
          Exit;
        end;
        T := T / D;
        if T = 1 then
        begin
          Result := B + C;
          Exit;
        end;
        if P = 0 then
          P := D * 0.3;
        if (A = 0) or (A < Abs(C)) then
        begin
          A := C;
          S := P / 4;
        end
        else
        begin
          S := P / (2 * Pi) * ArcSin(C / A);
        end;
        Result := A * Power(2, -10 * T) * Sin((T * D - S) * (2 * Pi) / P) + C + B;
      end;
    vgAnimationInOut:
      begin
        if T = 0 then
        begin
          Result := B;
          Exit;
        end;
        T := T / (D / 2);
        if T = 2 then
        begin
          Result := B + C;
          Exit;
        end;
        if P = 0 then
          P := D * (0.3 * 1.5);
        if (A = 0) or (A < Abs(C)) then
        begin
          A := C;
          S := P / 4;
        end
        else
        begin
          S := P / (2 * Pi) * ArcSin(C / A);
        end;

        if T < 1 then
        begin
          T := T - 1;
          Result := -0.5 * (A * Power(2, 10 * T) * Sin((T * D - S) * (2 * Pi) / P)) + B;
        end
        else
        begin
          T := T - 1;
          Result := A * Power(2, -10 * T) * Sin((T * D - S) * (2 * Pi) / P) * 0.5 + C + B;
        end;
      end;
  end;
end;

function vgInterpolateExpo(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        if T = 0 then
          Result := B
        else
          Result := C * Power(2, 10 * (T / D - 1)) + B;
      end;
    vgAnimationOut:
      begin
        if T = D then
          Result := B + C
        else
          Result := C * (-Power(2, -10 * T / D) + 1) + B;
      end;
    vgAnimationInOut:
      begin
        if T = 0 then
        begin
          Result := B;
          Exit;
        end;
        if T = D then
        begin
          Result := B + C;
          Exit;
        end;
        T := T / (D / 2);
        if T < 1 then
          Result := C / 2 * Power(2, 10 * (T - 1)) + B
        else
        begin
          T := T - 1;
          Result := C / 2 * (-Power(2, -10 * T) + 2) + B;
        end;
      end;
  end;
end;

function vgInterpolateLinear(T, B, C, D: Double): Double;
begin
  Result := C * T / D + B;
end;

function vgInterpolateQuad(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        T := T / D;
        Result := C * T * T + B;
      end;
    vgAnimationOut:
      begin
        T := T / D;
        Result := -C * T * (T - 2) + B;
      end;
    vgAnimationInOut:
      begin
        T := T / (D / 2);

        if T < 1 then
          Result := C / 2 * T * T + B
        else
        begin
          T := T - 1;
          Result := -C / 2 * (T * (T - 2) - 1) + B;
        end;
      end;
  end;
end;

function vgInterpolateQuart(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        T := T / D;
        Result := C * T * T * T * T + B;
      end;
    vgAnimationOut:
      begin
        T := T / D - 1;
        Result := -C * (T * T * T * T - 1) + B;
      end;
    vgAnimationInOut:
      begin
        T := T / (D / 2);
        if T < 1 then
          Result := C / 2 * T * T * T * T + B
        else
        begin
          T := T - 2;
          Result := -C / 2 * (T * T * T * T - 2) + B;
        end;
      end;
  end;
end;

function vgInterpolateQuint(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        T := T / D;
        Result := C * T * T * T * T * T + B;
      end;
    vgAnimationOut:
      begin
        T := T / D - 1;
        Result := C * (T * T * T * T * T + 1) + B;
      end;
    vgAnimationInOut:
      begin
        T := T / (D / 2);
        if T < 1 then
          Result := C / 2 * T * T * T * T * T + B
        else
        begin
          T := T - 2;
          Result := C / 2 * (T * T * T * T * T + 2) + B;
        end;
      end;
  end;
end;

function vgInterpolateSine(T, B, C, D: Double; aType: TvxAnimationType): Double;
begin
  case aType of
    vgAnimationIn:
      begin
        Result := -C * Cos(T / D * (Pi / 2)) + C + B;
      end;
    vgAnimationOut:
      begin
        Result := C * Sin(T / D * (Pi / 2)) + B;
      end;
    vgAnimationInOut:
      begin
        Result := -C / 2 * (Cos(Pi * T / D) - 1) + B;
      end;
  end;
end;

{ Classes =====================================================================}

function goodCompareObj(const a1, a2: TObject): Integer;
begin
  Result := integer(Pointer(a1)) - integer(Pointer(a2));
  if Result <> 0 then
  begin
    if Result < 0 then
      Result := 1
    else
      Result := -1;
    Exit;
  end;
end;

{$I dcm_widestr_impl.inc}

{ Storage Routines }

procedure WriteValue(W: TWriter; Value: TValueType);
var
  b: byte;
begin
  b := Byte(Value);
  W.Write(b, 1);
end;

procedure WriteStr(W: TWriter; const Value: string);
var
  i: integer;
  b: byte;
begin
  i := Length(Value);
  if i > 255 then
    i := 255;
  b := i;
  W.Write(b, 1);
  if i > 0 then
    W.Write(Value[1], i);
end;

function ReadStr(R: TReader): string;
var
  L: Byte;
begin
  R.Read(L, SizeOf(Byte));
  System.SetString(Result, PChar(nil), L);
  R.Read(Result[1], L);
end;

{ TvxStorageItem ==============================================================}

constructor TvxStorageItem.Create;
begin
  inherited Create;
end;

destructor TvxStorageItem.Destroy;
begin
  if FStream <> nil then
    FStream.Free;
  inherited;
end;

procedure TvxStorageItem.ReadItem(R: TReader);
var
  Count: Longint;
begin
  FType := R.NextValue;
  case FType of
    vaWString: FAsString := R.ReadWideString;
    vaString, vaLString: FAsString := R.ReadString;
    vaSingle: FAsFloat := R.ReadSingle;
    vaExtended: FAsFloat := R.ReadFloat;
    vaInt8, vaInt16, vaInt32: FAsInteger := R.ReadInteger;
    vaBinary:
      begin
        R.ReadValue;
        R.Read(Count, SizeOf(Count));
        AsStream.SetSize(Count);
        R.Read(AsStream.Memory^, Count);
      end;
    vaTrue, vaFalse: R.ReadBoolean;
  end;
end;

procedure TvxStorageItem.WriteItem(W: TWriter);
var
  Count: Longint;
begin
  case FType of
    vaWString: W.WriteWideString(FAsString);
    vaString, vaLString: W.WriteString(FAsString);
    vaSingle, vaExtended: W.WriteFloat(FAsFloat);
    vaInt8, vaInt16, vaInt32: W.WriteInteger(FAsInteger);
    vaBinary:
      begin
        WriteValue(W, vaBinary);
        Count := FStream.Size;
        W.Write(Count, SizeOf(Count));
        W.Write(FStream.Memory^, FStream.Size);
      end;
    vaTrue: WriteValue(W, vaTrue);
    vaFalse: WriteValue(W, vaFalse);
  else
    Count := 1;
  end;
end;

function TvxStorageItem.GetAsBool: boolean;
begin
  Result := FType = vaTrue;
end;

function TvxStorageItem.GetAsStream: TMemoryStream;
begin
  FType := vaBinary;
  if FStream = nil then
    FStream := TMemoryStream.Create;
  Result := FStream;
end;

procedure TvxStorageItem.SetAsFloat(const Value: single);
begin
  FType := vaSingle;
  FAsFloat := Value;
end;

procedure TvxStorageItem.SetAsString(const Value: WideString);
begin
  FType := vaWString;
  FAsString := Value;
end;

procedure TvxStorageItem.SetAsInteger(const Value: integer);
begin
  FType := vaInt32;
  FAsInteger := Value;
end;

procedure TvxStorageItem.SetAsBool(const Value: boolean);
begin
  if Value then
    FType := vaTrue
  else
    FType := vaFalse;
end;

{ TvxStorage }

const
  FilerSignature: array[1..4] of Char = 'TPF0';

constructor TvxStorage.Create;
begin
  inherited;
  FItems := TvxWideStringList.Create;
end;

destructor TvxStorage.Destroy;
begin
  FItems.Free;
  inherited;
end;

function TvxStorage.GetValues(Name: string): TvxStorageItem;
var
  Idx: integer;
  Item: TvxStorageItem;
begin
  Idx := FItems.IndexOf(Name);
  if Idx >= 0 then
    Result := TvxStorageItem(FItems.Objects[Idx])
  else
  begin
    Item := TvxStorageItem.Create;
    FItems.AddObject(Name, Item);
    Result := Item;
  end;
end;

procedure TvxStorage.SaveToStream(S: TStream);
var
  i: integer;
  W: TWriter;
begin
  W := TWriter.Create(S, 1024);
  try
    W.Write(FilerSignature, 4);
    WriteStr(W, 'Root');
    WriteStr(W, '');
    for i := 0 to FItems.Count - 1 do
    begin
      WriteStr(W, FItems[i]);
      TvxStorageItem(FItems.Objects[i]).WriteItem(W);
    end;
    W.WriteListEnd;
    // objects
    W.WriteListEnd;
  finally
    W.Free;
  end;
end;

procedure TvxStorage.LoadFromStream(S: TStream);
var
  R: TReader;
  Signature: Longint;
begin
  R := TReader.Create(S, 1024);
  try
    R.Read(Signature, SizeOf(Signature));
    ReadStr(R);
    ReadStr(R);
    while not R.EndOfList do
    begin
      Values[ReadStr(R)].ReadItem(R);
    end;
  finally
    R.Free;
  end;
end;

procedure TvxStorage.LoadFromFile(FileName: string);
var
  B, S: TStream;
begin
  S := TFileStream.Create(FileName, fmOpenRead);
  try
    B := TMemoryStream.Create;
    ObjectTextToBinary(S, B);
    B.Position := 0;
    LoadFromStream(B);
    B.Free;
  finally
    S.Free;
  end;
end;

procedure TvxStorage.SaveToFile(FileName: string);
var
  B, S: TStream;
begin
  S := TFileStream.Create(FileName, fmCreate);
  try
    B := TMemoryStream.Create;
    SaveToStream(B);
    B.Position := 0;
    ObjectBinaryToText(B, S);
    B.Free;
  finally
    S.Free;
  end;
end;

{ Spline ======================================================================}

procedure CholeskyDecomposition(const b: array of Single; const Count: integer;
  var Result: array of Single);
var
  Y, M1, M2: array of single;
  i, k, D, F: integer;
begin
  // calc Cholesky decomposition matrix
  D := 0;
  F := Count - 1;
  SetLength(M1, Count);

  SetLength(M2, Count - 1);
  M1[D] := sqrt(2);
  M2[D] := 1.0 / M1[D];
  for k := D + 1 to F - 1 do
  begin
    M1[K] := Sqrt(4 - M2[K - 1] * M2[K - 1]);
    M2[K] := 1.0 / M1[K];
  end;
  M1[F] := Sqrt(2 - M2[F - 1] * M2[F - 1]);

  SetLength(Y, Count);
  Y[D] := B[D] / M1[D];
  for i := D + 1 to F do
    Y[i] := (B[i] - Y[i - 1] * M2[i - 1]) / M1[i];

  Result[F] := Y[F] / M1[F];
  for i := F - 1 downto D do
    Result[i] := (Y[i] - Result[i + 1] * M2[i]) / M1[i];
end;

procedure CalcHermiteFactors(const Values: array of single; var Spline: TvxSplineMatrix);
var
  a, b, c, d: Single;
  i, n: Integer;
  M1, M2: array of single;
begin
  if (Length(Values) > 0) then
  begin
    n := Length(Values) - 1;

    SetLength(M1, Length(Values));
    M1[0] := 3 * (Values[1] - Values[0]);
    M1[n] := 3 * (Values[n] - Values[n - 1]);
    for i := 1 to n - 1 do
      M1[I] := 3 * (Values[I + 1] - Values[I - 1]);

    SetLength(M2, Length(Values));
    CholeskyDecomposition(M1, Length(Values), M2);

    SetLength(Spline, n);
    for i := 0 to n - 1 do
    begin
      // calc koeef
      a := Values[I];
      b := M2[I];
      c := 3 * (Values[I + 1] - Values[I]) - 2 * M2[I] - M2[I + 1];
      d := -2 * (Values[I + 1] - Values[I]) + M2[I] + M2[I + 1];
      // calc spline
      Spline[I][3] := a + I * (I * (c - I * d) - b);
      Spline[I][2] := b + I * (3 * I * d - 2 * c);
      Spline[I][1] := c - 3 * I * d;
      Spline[I][0] := d;
    end;
  end;
end;

function HermitInterpolate(const Spline: TvxSplineMatrix; const x: Single; const Count: Integer): single;
var
  i: integer;
begin
  if Length(Spline) > 0 then
  begin
    if x <= 0 then
      i := 0
    else
      if x > Count - 1 then
      i := Count - 1
    else
      i := trunc(x);
    if i = (Count - 1) then
      Dec(i);
    Result := ((Spline[i][0] * x + Spline[i][1]) * x + Spline[i][2]) * x + Spline[i][3];
  end
  else
    Result := 0;
end;

constructor TvxSpline.Create(const Polygon: TvxPolygon);
var
  i: integer;
  X, Y: array of single;
begin
  inherited Create;
  len := Length(Polygon);
  SetLength(X, len);
  SetLength(Y, len);
  for i := 0 to len - 1 do
  begin
    X[i] := Polygon[i].X;
    Y[i] := Polygon[i].Y;
  end;
  CalcHermiteFactors(X, matX);
  CalcHermiteFactors(Y, matY);
end;

destructor TvxSpline.Destroy;
begin
  inherited;
end;

procedure TvxSpline.SplineXY(const t: single; var X, Y: Single);
begin
  X := HermitInterpolate(MatX, t, len);
  Y := HermitInterpolate(MatY, t, len);
end;

{ TvxBounds }

constructor TvxBounds.Create(const ADefaultValue: TvxRect);
begin
  inherited Create;
  FDefaultValue := ADefaultValue;
  Rect := FDefaultValue;
end;

procedure TvxBounds.Assign(Source: TPersistent);
begin
  if Source is TvxBounds then
  begin
    Rect := TvxBounds(Source).Rect;
  end
  else
    inherited
end;

function TvxBounds.GetRect: TvxRect;
begin
  Result := vgRect(FLeft, FTop, FRight, FBottom);
end;

function TvxBounds.MarginRect(const R: TvxRect): TvxRect;
begin
  Result := vgRect(R.Left + FLeft, R.Top + FTop, R.Right - FRight, R.Bottom - FBottom);
end;

function TvxBounds.PaddinRect(const R: TvxRect): TvxRect;
begin
  Result := vgRect(R.Left - FLeft, R.Top - FTop, R.Right + FRight, R.Bottom + FBottom);
end;

function TvxBounds.Width: single;
begin
  Result := vgRectWidth(Rect);
end;

function TvxBounds.Height: single;
begin
  Result := vgRectHeight(Rect);
end;

function TvxBounds.MarginEmpty: boolean;
begin
  Result := (FLeft = 0) and (FTop = 0) and (FRight = 0) and (FBottom = 0);
end;

function TvxBounds.Empty: boolean;
begin
  Result := vgIsRectEmpty(Rect)
end;

procedure TvxBounds.SetBottom(const Value: single);
begin
  if FBottom <> Value then
  begin
    FBottom := Value;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

procedure TvxBounds.SetLeft(const Value: single);
begin
  if FLeft <> Value then
  begin
    FLeft := Value;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

procedure TvxBounds.SetRight(const Value: single);
begin
  if FRight <> Value then
  begin
    FRight := Value;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

procedure TvxBounds.SetTop(const Value: single);
begin
  if FTop <> Value then
  begin
    FTop := Value;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

procedure TvxBounds.SetRect(const Value: TvxRect);
begin
  if (FLeft <> Value.Left) or (FTop <> Value.Top) or (FRight <> Value.Right) or (FBottom <> Value.Bottom) then
  begin
    FLeft := Value.Left;
    FTop := Value.Top;
    FRight := Value.Right;
    FBottom := Value.Bottom;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

procedure TvxBounds.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('Rect', ReadRect, WriteRect, (FLeft <> DefaultValue.Left) or (FTop <> DefaultValue.Top) or
    (FRight <> DefaultValue.Right) or (FBottom <> DefaultValue.Bottom));
end;

procedure TvxBounds.ReadRect(Reader: TReader);
begin
  Rect := vgStringToRect(Reader.ReadString);
end;

procedure TvxBounds.WriteRect(Writer: TWriter);
begin
  Writer.WriteString(vgRectToString(Rect));
end;

{ TvxPosition }

constructor TvxPosition.Create(const ADefaultValue: TvxPoint);
begin
  inherited Create;
  FDefaultValue := ADefaultValue;
  FX := FDefaultValue.X;
  FY := FDefaultValue.Y;
end;

procedure TvxPosition.Assign(Source: TPersistent);
begin
  if Source is TvxPosition then
  begin
    Point := TvxPosition(Source).Point;
  end
  else
    inherited
end;

function TvxPosition.Empty: boolean;
begin
  Result := (FX = 0) and (FY = 0);
end;

procedure TvxPosition.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('Point', ReadPoint, WritePoint, (FX <> DefaultValue.X) or (FY <> DefaultValue.Y));
end;

procedure TvxPosition.ReadPoint(Reader: TReader);
begin
  Point := vgStringToPoint(Reader.ReadString);
end;

procedure TvxPosition.WritePoint(Writer: TWriter);
begin
  Writer.WriteString(vgPointToString(Point));
end;

function TvxPosition.GetPoint: TvxPoint;
begin
  Result := vgPoint(Fx, Fy);
end;

procedure TvxPosition.SetPoint(const Value: TvxPoint);
begin
  Fx := Value.X;
  Fy := Value.Y;
  if Assigned(OnChange) then
    OnChange(Self);
end;

procedure TvxPosition.SetX(const Value: single);
begin
  if FX <> Value then
  begin
    FX := Value;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

procedure TvxPosition.SetY(const Value: single);
begin
  if FY <> Value then
  begin
    FY := Value;
    if Assigned(OnChange) then
      OnChange(Self);
  end;
end;

{ TvxTransform ================================================================}

constructor TvxTransform.Create;
begin
  inherited;
  FMatrix := IdentityMatrix;
  FPosition := TvxPosition.Create(vgPoint(0, 0));
  FPosition.OnChange := MatrixChanged;
  FScale := TvxPosition.Create(vgPoint(1, 1));
  FScale.OnChange := MatrixChanged;
  FSkew := TvxPosition.Create(vgPoint(0, 0));
  FSkew.OnChange := MatrixChanged;
  FRotateCenter := TvxPosition.Create(vgPoint(0.5, 0.5));
  FRotateCenter.OnChange := MatrixChanged;
end;

destructor TvxTransform.Destroy;
begin
  FRotateCenter.Free;
  FScale.Free;
  FSkew.Free;
  FPosition.Free;
  inherited;
end;

procedure TvxTransform.Assign(Source: TPersistent);
begin
  if Source is TvxTransform then
  begin
    FPosition.FX := TvxTransform(Source).Position.FX;
    FPosition.FY := TvxTransform(Source).Position.FY;
    FScale.FX := TvxTransform(Source).Scale.FX;
    FScale.FY := TvxTransform(Source).Scale.FY;
    FSkew.FX := TvxTransform(Source).Skew.FX;
    FSkew.FY := TvxTransform(Source).Skew.FY;
    FRotateCenter.FX := TvxTransform(Source).RotateCenter.FX;
    FRotateCenter.FY := TvxTransform(Source).RotateCenter.FY;
    MatrixChanged(Self);
  end
  else
    inherited
end;

procedure TvxTransform.MatrixChanged(Sender: TObject);
begin
  FMatrix := IdentityMatrix;
  FMatrix.m31 := FPosition.X;
  FMatrix.m32 := FPosition.Y;
  FMatrix.m13 := FSkew.X;
  FMatrix.m23 := FSkew.Y;
  FMatrix.m11 := FScale.X;
  FMatrix.m22 := FScale.Y;
  if FRotateAngle <> 0 then
  begin
    {    M1 := IdentityMatrix;
        M1.m31 := -FRotateCenter.X * FWidth;
        M1.m32 := -FRotateCenter.Y * FHeight;
        M2 := IdentityMatrix;
        M2.m31 := FRotateCenter.X * FWidth;
        M2.m32 := FRotateCenter.Y * FHeight;
        RotMatrix := vgMatrixMultiply(M1, vgMatrixMultiply(vgCreateRotationMatrix(vgDegToRad(FRotateAngle)), M2));
        FMatrix := vgMatrixMultiply(RotMatrix, FMatrix); }
    FMatrix := vgMatrixMultiply(vgCreateRotationMatrix(vgDegToRad(FRotateAngle)), FMatrix);
  end;
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

procedure TvxTransform.SetRotateAngle(const Value: single);
begin
  if FRotateAngle <> Value then
  begin
    FRotateAngle := Value;
  end;
end;

{ TvxVisual ===================================================================}

constructor TvxVisual.Create;
begin
  inherited;
end;

procedure TvxVisual.Assign(Source: TPersistent);
begin
  if Source is TvxVisual then
  begin
    VisualObject := TvxVisual(Source).VisualObject;
  end
  else
    inherited;
end;

destructor TvxVisual.Destroy;
begin
  if FVisualObject <> nil then
  begin
    FVisualObject.RemoveFreeNotify(Self);
    FVisualObject := nil;
  end;
  inherited;
end;

procedure TvxVisual.SetVisualObject(const Value: TvxVisualObject);
begin
  if FVisualObject <> Value then
  begin
    if FVisualObject <> nil then
      FVisualObject.RemoveFreeNotify(Self);
    FVisualObject := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
    if FVisualObject <> nil then
      FVisualObject.AddFreeNotify(Self);
  end;
end;

function TvxPosition.GetVector: TvxVector;
begin
  Result := vgVector(FX, FY);
end;

procedure TvxPosition.SetVector(const Value: TvxVector);
begin
  Point := vgPoint(Value.X, Value.Y);
end;

procedure TvxPosition.Reflect(const Normal: TvxVector);
begin
  Vector := vgVectorReflect(Vector, Normal);
end;

{ TvxGradientPoint }

procedure TvxGradientPoint.Assign(Source: TPersistent);
begin
  if Source is TvxGradientPoint then
  begin
    FColor := TvxGradientPoint(Source).FColor;
    FOffset := TvxGradientPoint(Source).FOffset;
  end
  else
    inherited;
end;

{$IFDEF FPC}

constructor TvxGradientPoint.Create(ACollection: TCollection);
{$ELSE}

constructor TvxGradientPoint.Create(Collection: TCollection);
{$ENDIF}
begin
  inherited Create({$IFDEF FPC}ACollection{$ELSE}Collection{$ENDIF});
end;

function TvxGradientPoint.GetColor: string;
begin
  Result := vgColorToStr(FColor);
end;

procedure TvxGradientPoint.SetColor(const Value: string);
begin
  FColor := vgStrToColor(Value);
end;

{ TvxGradientPoints }

function TvxGradientPoints.GetPoint(Index: integer): TvxGradientPoint;
begin
  Result := TvxGradientPoint(Items[Index]);
end;

{ TvxGradient }

constructor TvxGradient.Create;
begin
  inherited;
  FStartPosition := TvxPosition.Create(vgPoint(0, 0));
  FStartPosition.OnChange := PositionChanged;
  FStopPosition := TvxPosition.Create(vgPoint(0, 1));
  FStopPosition.OnChange := PositionChanged;
  FRadialTransform := TvxTransform.Create;
  FRadialTransform.OnChanged := PositionChanged;
  FPoints := TvxGradientPoints.Create(TvxGradientPoint);
  with TvxGradientPoint(FPoints.Add) do
  begin
    IntColor := $FF000000;
  end;
  with TvxGradientPoint(FPoints.Add) do
  begin
    IntColor := $FFFFFFFF;
    Offset := 1;
  end;
end;

procedure TvxGradient.Assign(Source: TPersistent);
var
  SaveChanged: TNotifyEvent;
begin
  if Source is TvxGradient then
  begin
    SaveChanged := FOnChanged;
    FOnChanged := nil;
    FPoints.Clear;
    FPoints.Assign(TvxGradient(Source).FPoints);
    FStyle := TvxGradient(Source).Style;
    if FStyle = vgLinearGradient then
    begin
      FStopPosition.Assign(TvxGradient(Source).StopPosition);
      FStartPosition.Assign(TvxGradient(Source).StartPosition);
    end
    else
    begin
      FRadialTransform.Assign(TvxGradient(Source).RadialTransform);
    end;
    FOnChanged := SaveChanged;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end
  else
    inherited;
end;

destructor TvxGradient.Destroy;
begin
  FStartPosition.Free;
  FStopPosition.Free;
  FRadialTransform.Free;
  FPoints.Free;
  inherited;
end;

procedure TvxGradient.Change;
begin
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

function TvxGradient.InterpolateColor(Offset: single): TvxColor;
var
  i: integer;
begin
  if FPoints.Count > 1 then
  begin
    if Offset < 0 then
      Offset := 0;
    if Offset > 1 then
      Offset := 1;
    if Offset < FPoints[0].Offset then
    begin
      Result := Points[0].IntColor;
      Exit;
    end;
    if Offset > FPoints[FPoints.Count - 1].Offset then
    begin
      Result := FPoints[FPoints.Count - 1].IntColor;
      Exit;
    end;
    for i := 0 to FPoints.Count - 2 do
    begin
      if (Offset < Points[i].Offset) then
        Continue;
      if Points[i + 1].Offset - Points[i].Offset <= 0 then
        Result := Points[i].IntColor
      else
        if (i = FPoints.Count - 2) and (Offset > Points[Points.Count - 1].Offset) then // last
        Result := Points[Points.Count - 1].IntColor
      else
        Result := vgInterpolateColor(Points[i].IntColor, Points[i + 1].IntColor, (Offset - Points[i].Offset) / (Points[i + 1].Offset - Points[i].Offset));
    end;
  end
  else
    Result := 0;
end;

procedure TvxGradient.PositionChanged(Sender: TObject);
begin
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

function TvxGradient.isLinearStored: Boolean;
begin
  Result := FStyle = vgLinearGradient;
end;

function TvxGradient.isRadialStored: Boolean;
begin
  Result := FStyle = vgRadialGradient;
end;

procedure TvxGradient.SetRadialTransform(const Value: TvxTransform);
begin
  FRadialTransform.Assign(Value);
end;

procedure TvxGradient.SetStartPosition(const Value: TvxPosition);
begin
  FStartPosition.Assign(Value);
end;

procedure TvxGradient.SetStopPosition(const Value: TvxPosition);
begin
  FStopPosition.Assign(Value);
end;

procedure TvxGradient.SetColor(const Value: string);
begin
  if FPoints.Count > 0 then
    Points[0].Color := Value;
end;

procedure TvxGradient.SetColor1(const Value: string);
begin
  if FPoints.Count > 1 then
    Points[1].Color := Value;
end;

procedure TvxGradient.SetStyle(const Value: TvxGradientStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

{ TvxBrushResource ==========================================================}

destructor TvxBrushResource.Destroy;
begin
  if FResource <> nil then
  begin
    FResource.RemoveFreeNotify(Self);
    FResource := nil;
  end;
  inherited;
end;

procedure TvxBrushResource.Assign(Source: TPersistent);
begin
  if Source is TvxBrushResource then
  begin
    Resource := TvxBrushResource(Source).Resource;
    FResourceName := TvxBrushResource(Source).ResourceName;
  end
  else
    inherited;
end;

procedure TvxBrushResource.SetResource(const Value: TvxBrushObject);
begin
  if FResource <> Value then
  begin
    if FResource <> nil then
      FResource.RemoveFreeNotify(Self);
    FResource := Value;
    if FResource <> nil then
    begin
      FResourceName := FResource.ResourceName;
      FResource.AddFreeNotify(Self);
    end;
  end;
end;

function TvxBrushResource.GetResourceName: string;
begin
  Result := FResourceName;
end;

procedure TvxBrushResource.SetResourceName(const Value: string);
begin
  if Value <> FResourceName then
  begin
    FResourceName := Value;
  end;
end;

function TvxBrushResource.GetBrush: TvxBrush;
var
  O: TvxObject;
begin
  Result := nil;
  if FResource <> nil then
  begin
    Result := TvxBrushObject(FResource).Brush;
  end
  else
    if FResourceName <> '' then
  begin
    O := FindResource(FResourceName);
    if O is TvxBrushObject then
      Resource := TvxBrushObject(O);
    if FResource <> nil then
      Result := TvxBrushObject(FResource).Brush;
  end;
end;

{ TvxBrushBitmap }

constructor TvxBrushBitmap.Create;
begin
  inherited Create;
  FBitmap := TvxBitmap.Create(0, 0);
end;

destructor TvxBrushBitmap.Destroy;
begin
  FBitmap.Free;
  inherited;
end;

procedure TvxBrushBitmap.Assign(Source: TPersistent);
begin
  if Source is TvxBrushBitmap then
  begin
    FWrapMode := TvxBrushBitmap(Source).FWrapMode;
    FBitmap.Assign(TvxBrushBitmap(Source).Bitmap);
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end
  else
    inherited;
end;

procedure TvxBrushBitmap.SetWrapMode(const Value: TvxWrapMode);
begin
  if FWrapMode <> Value then
  begin
    FWrapMode := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

procedure TvxBrushBitmap.SetBitmap(Value: TvxBitmap);
begin
  if Value <> nil then
    FBitmap.Assign(Value);
end;

{ TvxBrush ===================================================================}

constructor TvxBrush.Create;
begin
  inherited Create;
  FDefaultStyle := ADefaultStyle;
  FDefaultColor := ADefaultColor;
  FColor := ADefaultColor;
  FStyle := FDefaultStyle;
  FGradient := TvxGradient.Create;
  FGradient.OnChanged := GradientChanged;
  FVisual := TvxVisual.Create;
  FVisual.OnChanged := VisualChanged;
  FResource := TvxBrushResource.Create;
  FResource.OnChanged := ResourceChanged;
  FBitmap := TvxBrushBitmap.Create;
  FBitmap.OnChanged := BitmapChanged;
end;

destructor TvxBrush.Destroy;
begin
  FBitmap.Free;
  FVisual.Free;
  FResource.Free;
  FGradient.Free;
  inherited;
end;

procedure TvxBrush.Assign(Source: TPersistent);
var
  SaveChange: TNotifyEvent;
begin
  if Source is TvxBrush then
  begin
    SaveChange := FOnChanged;
    FOnChanged := nil;
    FDefaultStyle := (Source as TvxBrush).FDefaultStyle;
    FDefaultColor := (Source as TvxBrush).FDefaultColor;
    FColor := (Source as TvxBrush).SolidColor;
    FStyle := (Source as TvxBrush).Style;
    case FStyle of
      vgBrushGradient: FGradient.Assign((Source as TvxBrush).Gradient);
      vgBrushResource: FResource.Assign((Source as TvxBrush).Resource);
      vgBrushVisual: FVisual.Assign((Source as TvxBrush).Visual);
      vgBrushBitmap: FBitmap.Assign((Source as TvxBrush).Bitmap);
    end;
    FOnChanged := SaveChange;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end
  else
    inherited;
end;

procedure TvxBrush.GradientChanged(Sender: TObject);
begin
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

procedure TvxBrush.VisualChanged(Sender: TObject);
begin
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

procedure TvxBrush.ResourceChanged(Sender: TObject);
begin
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

procedure TvxBrush.BitmapChanged(Sender: TObject);
begin
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

function TvxBrush.isBitmapStored: Boolean;
begin
  Result := (FStyle = vgBrushBitmap);
end;

function TvxBrush.isColorStored: Boolean;
begin
  Result := (FStyle = vgBrushSolid) and (FColor <> FDefaultColor);
end;

function TvxBrush.isGradientStored: Boolean;
begin
  Result := FStyle = vgBrushGradient;
end;

function TvxBrush.isStyleStored: Boolean;
begin
  Result := FStyle <> FDefaultStyle;
end;

function TvxBrush.isVisualStored: Boolean;
begin
  Result := FStyle = vgBrushVisual;
end;

function TvxBrush.isResourceStored: Boolean;
begin
  Result := FStyle = vgBrushResource;
end;

procedure TvxBrush.SetResource(const Value: TvxBrushResource);
begin
  FResource := Value;
end;

procedure TvxBrush.SetGradient(const Value: TvxGradient);
begin
  FGradient.Assign(Value);
end;

procedure TvxBrush.SetVisual(const Value: TvxVisual);
begin
  FVisual := Value;
end;

function TvxBrush.GetColor: string;
begin
  Result := vgColorToStr(FColor);
end;

procedure TvxBrush.SetColor(const Value: string);
begin
  SolidColor := vgStrToColor(Value);
  if FStyle = vgBrushGradient then
    FGradient.Color := Value;
end;

function TvxBrush.GetSolidColor: TvxColor;
begin
  Result := FColor;
  if (Style = vgBrushResource) and (Resource <> nil) and (Resource.Brush <> nil) then
    Result := Resource.Brush.SolidColor;
end;

procedure TvxBrush.SetSolidColor(const Value: TvxColor);
begin
  if FColor <> Value then
  begin
    FColor := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

procedure TvxBrush.SetStyle(const Value: TvxBrushStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

{ TvxFont =====================================================================}

constructor TvxFont.Create;
begin
  inherited;
  FSize := 11;
  FFamily := 'Tahoma';
  FClearType := true;
end;

destructor TvxFont.Destroy;
begin
  inherited;
end;

procedure TvxFont.Assign(Source: TPersistent);
begin
  if Source is TvxFont then
  begin
    FFamily := (Source as TvxFont).Family;
    FSize := (Source as TvxFont).Size;
    FStyle := (Source as TvxFont).Style;
    FClearType := (Source as TvxFont).ClearType;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end
  else
    {$IFNDEF NOVCL}
    if Source is TFont then
  begin
    FFamily := TFont(Source).Name;
    FSize := Abs(TFont(Source).Height);
    if TFont(Source).Style = [] then
      FStyle := vgFontRegular;
    if TFont(Source).Style = [fsBold] then
      FStyle := vgFontBold;
    if TFont(Source).Style = [fsItalic] then
      FStyle := vgFontItalic;
    if TFont(Source).Style = [fsBold, fsItalic] then
      FStyle := vgFontBoldItalic;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end
  else
    {$ENDIF}
    inherited;
end;

procedure TvxFont.AssignTo(Dest: TPersistent);
begin
  {$IFNDEF NOVCL}
  if Dest is TFont then
  begin
    (Dest as TFont).Name := FFamily;
    (Dest as TFont).Height := -round(FSize);
    case Style of
      vgFontRegular: TFont(Dest).Style := [];
      vgFontBold: TFont(Dest).Style := [fsBold];
      vgFontItalic: TFont(Dest).Style := [fsItalic];
      vgFontBoldItalic: TFont(Dest).Style := [fsBold, fsItalic];
    end;
  end
  else
    {$ENDIF}
    inherited;
end;

function TvxFont.isSizeStored: Boolean;
begin
  Result := FSize <> 11;
end;

function TvxFont.isFamilyStored: Boolean;
begin
  Result := FFamily <> 'Tahoma';
end;

procedure TvxFont.SetFamily(const Value: string);
begin
  if FFamily <> Value then
  begin
    FFamily := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

procedure TvxFont.SetSize(const Value: single);
begin
  if FSize <> Value then
  begin
    FSize := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

procedure TvxFont.SetClearType(const Value: boolean);
begin
  if FClearType <> Value then
  begin
    FClearType := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

procedure TvxFont.SetStyle(const Value: TvxFontStyle);
begin
  if FStyle <> Value then
  begin
    FStyle := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

class function TvxFilter.GetFileTypes: string;
begin
  Result := '';
end;

class function TvxFilter.GetImageSize(const AFileName: string): TvxPoint;
begin
  Result := vgPoint(0, 0);
end;

{ TvxBitmap ===================================================================}

constructor TvxBitmap.Create(const AWidth, AHeight: integer; const APremulAlpha: boolean = true);
begin
  inherited Create;
  FWidth := AWidth;
  FHeight := AHeight;
  fFont := TFont.Create;
  fData := nil;
  Recreate;
end;

constructor TvxBitmap.CreateFromStream(const AStream: TStream);
begin
  Create(0, 0);
  LoadFromStream(AStream);
end;

constructor TvxBitmap.CreateFromBitmapAndMask(const Bitmap, Mask: TvxBitmap);
var
  i: integer;
begin
  Create(Bitmap.Width, Bitmap.Height);
  if (Bitmap.Width <> Mask.Width) or (Bitmap.Height <> Mask.Height) then
    Exit;
  for i := 0 to FHeight * FWidth - 1 do
  begin
    PvgColorRecArray(FBits)[i] := PvgColorRecArray(Bitmap.FBits)[i];
    PvgColorRecArray(FBits)[i].A := PvgColorRecArray(Mask.FBits)[i].R;
  end;
end;

destructor TvxBitmap.Destroy;
begin
  if Assigned(FOnDestroyHandle) then
    FOnDestroyHandle(Self);
  if FResource <> nil then
  begin
    FResource.RemoveFreeNotify(Self);
    FResource := nil;
  end;
  if Assigned(FCanvas) then
    FreeAndNil(FCanvas);
  Handle := 0;
  if FBits <> nil then
    FreeMem(FBits, FWidth * FHeight * SizeOf(TvxColor));
  inherited;
end;

procedure TvxBitmap.SetResource(const Value: TvxBitmapObject);
begin
  if FResource <> Value then
  begin
    if FResource <> nil then
      FResource.RemoveFreeNotify(Self);
    FResource := Value;
    if FResource <> nil then
    begin
      FResourceName := FResource.ResourceName;
      FResource.AddFreeNotify(Self);
    end
    else
      FResourceName := '';
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

function TvxBitmap.GetResourceName: string;
begin
  Result := FResourceName;
end;

procedure TvxBitmap.SetResourceName(const Value: string);
begin
  if Value <> FResourceName then
  begin
    FResourceName := Value;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

function TvxBitmap.GetBitmap: TvxBitmap;
var
  O: TvxObject;
begin
  Result := nil;
  if FResource <> nil then
  begin
    Result := TvxBitmapObject(FResource).Bitmap;
  end
  else
    if FResourceName <> '' then
  begin
    O := FindResource(FResourceName);
    if O is TvxBitmapObject then
      Resource := TvxBitmapObject(O);
    if FResource <> nil then
      Result := TvxBitmapObject(FResource).Bitmap;
  end;
end;

procedure TvxBitmap.SetSize(const AWidth, AHeight: integer);
begin
  if (FWidth <> AWidth) or (FHeight <> AHeight) then
  begin
    if FBits <> nil then
      FreeMem(FBits, FWidth * FHeight * SizeOf(TvxColor));
    FBits := nil;
    FWidth := AWidth;
    FHeight := AHeight;
    Recreate;
    BitmapChanged;
  end;
end;

procedure TvxBitmap.Recreate;
var
  i: integer;
begin
  if Assigned(FOnBitmapDestroy) then
    FOnBitmapDestroy(Self);
  if Assigned(FOnDestroyHandle) then
    FOnDestroyHandle(Self);
  FHandle := 0;
  if Assigned(FCanvas) then
    FreeAndNil(FCanvas);
  FCanvas := nil;
  if FBits <> nil then
    FreeMem(FBits);
  FBits := nil;

  if not IsEmpty then
  begin
    GetMem(FBits, FWidth * FHeight * SizeOf(TvxColor));
    Clear(0);
  end;
  FNeedUpdate := true;
  if Assigned(FOnBitmapCreate) then
    FOnBitmapCreate(Self);
end;

procedure TvxBitmap.Clear(const AColor: TvxColor);
begin
  if FBits <> nil then
  begin
    vgFillLongword(FBits, FWidth * FHeight, vgPremultyAlpha(AColor));
    BitmapChanged;
    FNeedUpdate := true;
  end;
end;

procedure TvxBitmap.ClearRect(const ARect: TvxRect;
  const AColor: TvxColor);
var
  R: TRect;
begin
  if FBits <> nil then
  begin
    R := Rect(Trunc(ARect.Left), Trunc(ARect.Top), Round(ARect.Right), Round(ARect.Bottom));
    if R.Left < 0 then
      R.Left := 0;
    if R.Top < 0 then
      R.Top := 0;
    if R.Right > FWidth then
      R.Right := FWidth;
    if R.Bottom > FHeight then
      R.Bottom := FHeight;
    if R.Bottom < R.Top then
      R.Bottom := R.Top;
    if R.Right < R.Left then
      R.Right := R.Left;
    if (R.Right < 0) or (R.Top < 0) or (R.Left > FWidth) or (R.Top > FHeight) then
      Exit;
    vgFillLongwordRect(FBits, FWidth, FHeight, R.Left, R.Top, R.Right, R.Bottom, vgPremultyAlpha(AColor));
    FNeedUpdate := true;
  end;
end;

function TvxBitmap.GetPixels(x, y: integer): TvxColor;
begin
  if (x >= 0) and (y >= 0) and (x < FWidth) and (y < FHeight) and (FBits <> nil) then
    Result := FBits[x + (y * FHeight)]
  else
    Result := 0;
end;

procedure TvxBitmap.BitmapChanged;
begin
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

function TvxBitmap.IsEmpty: boolean;
begin
  Result := FWidth * FHeight = 0;
end;

{$IFNDEF NOVCL}

procedure TvxBitmap.DrawGraphic(const Graphic: TGraphic; const DstRect: TvxRect);
var
  Bitmap: TBitmap;
  SL: PvgColorArray;
  i, j: integer;
begin
  {$IFNDEF FPC}
  {$IFNDEF UCL}
  { Create DIB copy }
  Bitmap := TBitmap.Create;
  try
    Bitmap.HandleType := bmDIB;
    Bitmap.PixelFormat := pf32bit;
    Bitmap.Width := FWidth;
    Bitmap.Height := FHeight;
    Bitmap.Canvas.Brush.Color := RGB(255, 0, 255);
    Bitmap.Canvas.StretchDraw(Rect(round(DstRect.left), round(DstRect.top), round(DstRect.right), round(DstRect.bottom)), Graphic);
    { Copy to bitmap }
    for j := 0 to FHeight - 1 do
    begin
      SL := Bitmap.Scanline[j];
      for i := 0 to FWidth - 1 do
        if (TvxColorRec(SL[i]).R = $FF) and (TvxColorRec(SL[i]).G = 0) and (TvxColorRec(SL[i]).B = $FF) then
          Continue
        else
          FBits[i + (j * Width)] := SL[i];
    end;
  finally
    Bitmap.Free;
  end;
  {$ENDIF}
  {$ENDIF}
end;
{$ENDIF}

procedure TvxBitmap.Assign(Source: TPersistent);
var
  SLine: PvgColorArray;
  SLine24: PvgColor24Array;
  i, j: integer;
begin
  if Source is TvxBitmap then
  begin
    if TvxBitmap(Source).ResourceBitmap <> nil then
    begin
      Resource := TvxBitmap(Source).Resource;
      FResourceName := TvxBitmap(Source).ResourceName;
      if Assigned(FOnChange) then
        FOnChange(Self);
    end
    else
    begin
      Resource := nil;
      FResourceName := '';
      SetSize(TvxBitmap(Source).Width, TvxBitmap(Source).Height);
      vgMoveLongword(TvxBitmap(Source).FBits, FBits, Width * Height);
      FNeedUpdate := true;
      if Assigned(FOnChange) then
        FOnChange(Self);
    end;
  end
  else
    {$IFNDEF NOVCL}
    {$IFNDEF FPC}
    {$IFNDEF UCL}
    if (Source is TBitmap) and ((Source as TBitmap).PixelFormat = pf32bit) and ((Source as TBitmap).HandleType = bmDIB) then
    with (Source as TBitmap) do
    begin
      Self.SetSize(Width, Height);
      for j := 0 to Height - 1 do
      begin
        SLine := Scanline[j];
        for i := 0 to Width - 1 do
        begin
          if Transparent and (SLine^[i] = ColorToRGB(TransparentColor)) then
            FBits[i + (j * Width)] := 0
          else
            FBits[i + (j * Width)] := SLine^[i];
        end;
      end;
      FNeedUpdate := true;
      if Assigned(FOnChange) then
        FOnChange(Self);
    end
  else
    if (Source is TBitmap) and ((Source as TBitmap).PixelFormat = pf24bit) then
    with (Source as TBitmap) do
    begin
      Self.SetSize(Width, Height);
      for j := 0 to Height - 1 do
      begin
        SLine24 := Scanline[j];
        for i := 0 to Width - 1 do
        begin
          if Transparent and (RGB(SLine24^[i].R, SLine24^[i].G, SLine24^[i].B) = ColorToRGB(TransparentColor)) then
            FBits[i + (j * Width)] := 0
          else
            FBits[i + (j * Width)] := $FF000000 + RGB(SLine24^[i].R, SLine24^[i].G, SLine24^[i].B);
        end;
      end;
      FNeedUpdate := true;
      if Assigned(FOnChange) then
        FOnChange(Self);
    end
  else
    if Source is TGraphic then
  begin
    SetSize(TGraphic(Source).Width, TGraphic(Source).Height);
    if FBits = nil then
      Exit;
    DrawGraphic(TGraphic(Source), vgRect(0, 0, FWidth, FHeight));
    vgFillAlpha(FBits, FWidth * FHeight, $FF);
    FNeedUpdate := true;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end
  else
    if Source is TPicture then
  begin
    with TPicture(Source) do
    begin
      // icons, metafiles etc...
      Self.SetSize(TPicture(Source).Graphic.Width, TPicture(Source).Graphic.Height);
      if FBits = nil then
        Exit;
      DrawGraphic(TPicture(Source).Graphic, vgRect(0, 0, FWidth, FHeight));
      vgFillAlpha(FBits, FWidth * FHeight, $FF);
      FNeedUpdate := true;
      if Assigned(FOnChange) then
        FOnChange(Self);
    end;
  end
  else
    {$ENDIF}
    {$ENDIF}
    {$ENDIF}
    { inherited }
    inherited;
end;

procedure TvxBitmap.AssignTo(Dest: TPersistent);
var
  i: integer;
  {$IFNDEF NOVCL}
  B: TBitmap;
  {$ENDIF}
begin
  {$IFNDEF NOVCL}
  {$IFNDEF FPC}
  {$IFNDEF UCL}
  if Dest is TPicture then
  begin
    B := TBitmap.Create;
    B.HandleType := bmDIB;
    B.PixelFormat := pf32bit;
    B.Width := FWidth;
    B.Height := FHeight;
    for i := 0 to FHeight - 1 do
      System.Move(Scanline[i]^, B.Scanline[i]^, Width * 4);
    TPicture(Dest).Assign(B);
    B.Free;
  end
  else
    if Dest is TBitmap then
  begin
    TBitmap(Dest).HandleType := bmDIB;
    TBitmap(Dest).PixelFormat := pf32bit;
    TBitmap(Dest).Width := FWidth;
    TBitmap(Dest).Height := FHeight;
    for i := 0 to FHeight - 1 do
      System.Move(Scanline[i]^, TBitmap(Dest).Scanline[i]^, Width * 4);
  end
  else
    {$ENDIF}
    {$ENDIF}
    {$ENDIF}
    inherited;
end;

procedure TvxBitmap.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineBinaryProperty('PNG', ReadBitmap, WriteBitmap, FWidth * FHeight > 0);
end;

procedure TvxBitmap.ReadBitmap(Stream: TStream);
begin
  LoadFromStream(Stream);
end;

procedure TvxBitmap.WriteBitmap(Stream: TStream);
begin
  SaveToStream(Stream);
end;

procedure TvxBitmap.DoLoaded(Sender: TObject);
begin
  if Assigned(FOnThreadLoaded) then
    FOnThreadLoaded(Self);
end;

procedure TvxBitmap.Rotate(const Angle: single);
var
  temp: TvxBitmap;
  M, M2: TvxMatrix;
  Pts: array[1..4] of TvxPoint;
  R: TvxRect;
begin
  if Angle = 0 then
    Exit;

  M := IdentityMatrix;
  M.m31 := -FWidth / 2;
  M.m32 := -FHeight / 2;
  M := vgMatrixMultiply(M, vgCreateRotationMatrix(vgDegToRad(Angle)));
  { calc new size }
  Pts[1] := vgPointFromVector(vgVectorTransform(vgVector(0, 0), M));
  Pts[2] := vgPointFromVector(vgVectorTransform(vgVector(FWidth, 0), M));
  Pts[3] := vgPointFromVector(vgVectorTransform(vgVector(FWidth, FHeight), M));
  Pts[4] := vgPointFromVector(vgVectorTransform(vgVector(0, FHeight), M));
  R := vgNormalizeRect(Pts);
  { translate }
  M2 := IdentityMatrix;
  M2.m31 := vgRectWidth(R) / 2;
  M2.m32 := vgRectHeight(R) / 2;
  M := vgMatrixMultiply(M, M2);
  { rotate }
  temp := TvxBitmap.Create(Trunc(vgRectWidth(R)), Trunc(vgRectHeight(R)));
  temp.Clear(0);
  temp.Canvas.BeginScene;
  temp.Canvas.SetMatrix(M);
  temp.Canvas.DrawBitmap(Self, vgRect(0, 0, FWidth, FHeight), vgRect(0, 0, FWidth, FHeight), 1);
  temp.Canvas.EndScene;
  Assign(temp);
  temp.Free;
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

//add by jiawen

{procedure TvxBitmap.TextOut(X, Y: Single; AText: string);
var
  R: TvxRect;
begin
  R.Left := X;
  R.Top := Y;
  R.Right := canvas.TextWidth(AText);
  R.Bottom := canvas.TextHeight(AText);
  //  Canvas.Fill.Color := vgColorToStr(clRed);
  Canvas.Fill.SolidColor := $FFFFFFFF;
//  Canvas.Fill.SolidColor := $FF000000;
  Canvas.FillText(R, R, AText, false, 1, vgTextAlignNear, vgTextAlignCenter);

  R.Left := X + 1;
  R.Top := Y + 1;
  Canvas.Fill.SolidColor := $FF000000;
//  Canvas.Fill.SolidColor := $FFFFFFFF;
  Canvas.FillText(R, R, AText, false, 1, vgTextAlignNear, vgTextAlignCenter);
end;  }

procedure TvxBitmap.FlipHorizontal;
var
  i: integer;
  tmp: PvgColorArray;
begin
  GetMem(tmp, Width * 4);
  for i := 0 to (Height - 1) div 2 do
  begin
    System.Move(Scanline[Height - 1 - i][0], tmp[0], Width * 4);
    System.Move(Scanline[i][0], Scanline[Height - 1 - i][0], Width * 4);
    System.Move(tmp[0], Scanline[i][0], Width * 4);
  end;
  if Assigned(FOnChange) then
    FOnChange(Self);
  FreeMem(tmp, Width * 4);
end;

procedure TvxBitmap.FlipVertical;
var
  i, j: integer;
  tmp: TvxColor;
begin
  for j := 0 to Height - 1 do
    for i := 0 to (Width - 1) div 2 do
    begin
      tmp := Scanline[j][Width - 1 - i];
      Scanline[j][Width - 1 - i] := Scanline[j][i];
      Scanline[j][i] := tmp;
    end;
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

procedure TvxBitmap.InvertAlpha;
var
  i, j: integer;
  Bits: PvgColorRecArray;
begin
  Bits := PvgColorRecArray(Startline);
  for j := 0 to Height - 1 do
    for i := 0 to Width - 1 do
    begin
      Bits[i + (j * Width)].Color := vgUnpremultyAlpha(Bits[i + (j * Width)].Color);
      TvxColorRec(Bits[(i) + ((j) * Width)]).A := $FF - TvxColorRec(Bits[(i) + ((j) * Width)]).A;
      Bits[i + (j * Width)].Color := vgPremultyAlpha(Bits[i + (j * Width)].Color);
    end;
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

procedure TvxBitmap.FillColor(const Color: TvxColor);
var
  Bits: PvgColorRecArray;
  i, j: integer;
  a: byte;
begin
  Bits := PvgColorRecArray(Startline);
  for j := 0 to Height - 1 do
  begin
    for i := 0 to Width - 1 do
    begin
      {$IFDEF FPC_BIG_ENDIAN}
      a := TvxColorRec(Bits[(i) + ((j) * Width)]).Color and $FF;
      {$ELSE}
      a := TvxColorRec(Bits[(i) + ((j) * Width)]).A;
      {$ENDIF}
      if a > 0 then
      begin
        bits[(i) + ((j) * Width)].Color := vgPremultyAlpha(vgOpacity(Color, a / $FF));
        {$IFDEF FPC_BIG_ENDIAN}
        ReverseBytes(@Bits[(i) + ((j) * Width)].Color, 4);
        {$ENDIF}
      end;
    end
  end;
  if Assigned(FOnChange) then
    FOnChange(Self);
  FNeedUpdate := true;
end;

function TvxBitmap.CreateMask: PByteArray;
var
  a: byte;
  Bits: PvgColorRecArray;
  i, j: integer;
begin
  GetMem(Result, Width * Height);
  FillChar(Result^, Width * Height, 0);
  Bits := PvgColorRecArray(Startline);
  for j := 0 to Height - 1 do
  begin
    for i := 0 to Width - 1 do
    begin
      {$IFDEF FPC_BIG_ENDIAN}
      a := TvxColorRec(Bits[(i) + ((j) * Width)]).Color and $FF;
      {$ELSE}
      a := TvxColorRec(Bits[(i) + ((j) * Width)]).A;
      {$ENDIF}
      if a > 0 then
      begin
        Result[i + (j * Width)] := a;
      end;
    end
  end;
end;

procedure TvxBitmap.ApplyMask(const Mask: PByteArray; const DstX: integer = 0; const DstY: integer = 0);
var
  Bits: PvgColorRecArray;
  i, j: integer;
begin
  Bits := PvgColorRecArray(Startline);
  for j := 0 to Height - 1 do
  begin
    for i := 0 to Width - 1 do
    begin
      if (i - DstX < 0) or (i - DstX > Width - 1) or (j - DstY < 0) or (j - DstY > Height - 1) then
        Continue;

      if mask[i - DstX + ((j - DstY) * Width)] > 0 then
      begin
        Bits[i + (j * Width)].Color := vgPremultyAlpha(vgOpacity(vgUnpremultyAlpha(Bits[i + (j * Width)].Color), ($FF - mask[i - DstX + ((j - DstY) * Width)]) / $FF))
      end;
      {$IFDEF FPC_BIG_ENDIAN}
      ReverseBytes(@Bits[(i) + ((j) * Width)].Color, 4);
      {$ENDIF}
    end
  end;
  if Assigned(FOnChange) then
    FOnChange(Self);
  FNeedUpdate := true;
end;

function TvxBitmap.CreateThumbnail(const Width, Height: integer): TvxBitmap;
begin
  Result := TvxBitmap.Create(Width, Height);
  Result.Canvas.BeginScene;
  Result.Canvas.DrawThumbnail(Self, Width, Height);
  Result.Canvas.EndScene;
end;

procedure TvxBitmap.LoadFromFile(const AFileName: string; const Rotate: single = 0);
var
  Filter: TvxFilter;
begin
  if not FileExists(AFileName) then
    Exit;
  Filter := DefaultFilterClass.Create;
  if Filter.LoadFromFile(AFileName, Rotate, Self) then
    if Assigned(FOnChange) then
      FOnChange(Self);
  Filter.Free;
end;

procedure TvxBitmap.LoadThumbnailFromFile(const AFileName: string; const AFitWidth, AFitHeight: single;
  const UseEmbedded: boolean = true);
var
  Filter: TvxFilter;
begin
  Filter := DefaultFilterClass.Create;
  if Filter.LoadThumbnailFromFile(AFileName, AFitWidth, AFitHeight, UseEmbedded, Self) then
    if Assigned(FOnChange) then
      FOnChange(Self);
  Filter.Free;
end;

procedure TvxBitmap.SaveToFile(const AFileName: string; const Params: string = '');
var
  Filter: TvxFilter;
begin
  Filter := DefaultFilterClass.Create;
  Filter.SaveToFile(AFileName, Self, Params);
  Filter.Free;
end;

procedure TvxBitmap.LoadFromStream(Stream: TStream);
var
  Filter: TvxFilter;
  S: TStream;
begin
  if Stream.Position > 0 then
  begin
    // need to create temp stream
    S := TMemoryStream.Create;
    S.CopyFrom(Stream, Stream.Size - Stream.Position);
    S.Position := 0;
    Filter := DefaultFilterClass.Create;
    if Filter.LoadFromStream(S, Self) then
      if Assigned(FOnChange) then
        FOnChange(Self);
    Filter.Free;
    S.Free;
  end
  else
  begin
    Filter := DefaultFilterClass.Create;
    if Filter.LoadFromStream(Stream, Self) then
      if Assigned(FOnChange) then
        FOnChange(Self);
    Filter.Free;
  end;
end;

procedure TvxBitmap.SaveToStream(Stream: TStream);
var
  i: integer;
  hasAlpha: boolean;
  Filter: TvxFilter;
begin
  { check alpha }
  hasAlpha := false;
  for i := 0 to FWidth * FHeight - 1 do
    if FBits[i] and $FF000000 <> $FF000000 then
    begin
      hasAlpha := true;
      Break;
    end;

  if hasAlpha then
  begin
    Filter := DefaultFilterClass.Create;
    Filter.SaveToStream(Stream, Self, 'png');
    Filter.Free;
  end
  else
  begin
    Filter := DefaultFilterClass.Create;
    Filter.SaveToStream(Stream, Self, 'jpeg', 'quality=100');
    Filter.Free;
  end;
end;

procedure TvxBitmap.SetHeight(const Value: integer);
begin
  if FHeight <> Value then
  begin
    FHeight := Value;
    Recreate;
  end;
end;

procedure TvxBitmap.SetWidth(const Value: integer);
begin
  if FWidth <> Value then
  begin
    FWidth := Value;
    Recreate;
  end;
end;

function TvxBitmap.GetCanvas: TvxCanvas;
begin
  if FCanvas = nil then
  begin
    FCanvas := DefaultCanvasClass.CreateFromBitmap(Self);
    FCanvas.SetMatrix(IdentityMatrix);
  end;
  Result := FCanvas;
end;

function TvxBitmap.GetScanline(y: integer): PvgColorArray;
begin
  Result := DefaultCanvasClass.GetBitmapScanline(Self, y);
end;

{ TvxPath =====================================================================}

constructor TvxPathData.Create;
begin
  inherited Create;
end;

destructor TvxPathData.Destroy;
begin
  if FResource <> nil then
  begin
    FResource.RemoveFreeNotify(Self);
    FResource := nil;
  end;
  inherited;
end;

procedure TvxPathData.Assign(Source: TPersistent);
begin
  if Source is TvxPathData then
  begin
    if TvxPathData(Source).ResourcePath <> nil then
    begin
      Resource := TvxPathData(Source).Resource;
      FResourceName := TvxPathData(Source).ResourceName;
      if Assigned(FOnChanged) then
        FOnChanged(Self);
    end
    else
    begin
      SetLength(PathData, Length(TvxPathData(Source).PathData));
      System.Move(TvxPathData(Source).PathData[0], PathData[0], SizeOf(TvxPathPoint) * Length(PathData));
      if Assigned(FOnChanged) then
        FOnChanged(Self);
    end;
  end
  else
    inherited
end;

procedure TvxPathData.SetResource(const Value: TvxPathObject);
begin
  if FResource <> Value then
  begin
    if FResource <> nil then
      FResource.RemoveFreeNotify(Self);
    FResource := Value;
    if FResource <> nil then
    begin
      FResourceName := FResource.ResourceName;
      FResource.AddFreeNotify(Self);
    end
    else
      FResourceName := '';
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

function TvxPathData.GetResourceName: string;
begin
  Result := FResourceName;
end;

procedure TvxPathData.SetResourceName(const Value: string);
begin
  if Value <> FResourceName then
  begin
    FResourceName := Value;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

function TvxPathData.GetPath: TvxPathData;
var
  O: TvxObject;
begin
  Result := nil;
  if FResource <> nil then
  begin
    Result := TvxPathObject(FResource).Path;
  end
  else
    if FResourceName <> '' then
  begin
    O := FindResource(FResourceName);
    if O is TvxPathObject then
      Resource := TvxPathObject(O);
    if FResource <> nil then
      Result := TvxPathObject(FResource).Path;
  end;
end;

procedure TvxPathData.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineBinaryProperty('Path', ReadPath, WritePath, Length(PathData) > 0);
end;

procedure TvxPathData.ReadPath(Stream: TStream);
var
  S: longint;
  i: integer;
  k: byte;
  p: TvxPoint;
begin
  Stream.Read(S, SizeOf(S));
  {$IFDEF FPC_BIG_ENDIAN}
  ReverseBytes(@S, 4);
  {$ENDIF}
  SetLength(PathData, S);
  if S > 0 then
  begin
    if (Stream.Size - 4) div S = 9 then
    begin
      for i := 0 to S - 1 do
      begin
        Stream.Read(k, 1);
        Stream.Read(p, SizeOf(p));
        {$IFDEF FPC_BIG_ENDIAN}
        ReverseBytes(@p.x, 4);
        ReverseBytes(@p.y, 4);
        {$ENDIF}
        PathData[i].Kind := TvxPathPointKind(k);
        PathData[i].Point := p;
      end;
    end
    else
    begin
      Stream.Read(PathData[0], S * SizeOf(TvxPathPoint));
      {$IFDEF FPC_BIG_ENDIAN}
      for i := 0 to S * 3 - 1 do
        ReverseBytes(@PvgColorArray(PathData)[i], 4);
      {$ENDIF}
    end;
  end;
end;

procedure TvxPathData.WritePath(Stream: TStream);
var
  S: longint;
begin
  S := Length(PathData);
  Stream.Write(S, SizeOf(S));
  if S > 0 then
    Stream.Write(PathData[0], S * SizeOf(TvxPathPoint));
end;

function TvxPathData.LastPoint: TvxPoint;
begin
  if Length(PathData) > 0 then
    Result := PathData[High(PathData)].Point
  else
    Result := vgPoint(0, 0);
end;

procedure TvxPathData.MoveTo(const P: TvxPoint);
begin
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointMoveTo;
  PathData[High(PathData)].Point := P;
  FStartPoint := PathData[High(PathData)].Point;
end;

procedure TvxPathData.MoveToRel(const P: TvxPoint);
begin
  with LastPoint do
  begin
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointMoveTo;
    PathData[High(PathData)].Point := vgPoint(x + P.x, y + P.y);
  end;
  FStartPoint := PathData[High(PathData)].Point;
end;

procedure TvxPathData.LineTo(const P: TvxPoint);
begin
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointLineTo;
  PathData[High(PathData)].Point := P;
end;

procedure TvxPathData.LineToRel(const P: TvxPoint);
begin
  with LastPoint do
  begin
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointLineTo;
    PathData[High(PathData)].Point := vgPoint(x + P.x, y + P.y);
  end;
end;

procedure TvxPathData.HLineTo(const x: single);
begin
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointLineTo;
  PathData[High(PathData)].Point := vgPoint(x, PathData[High(PathData) - 1].Point.y);
end;

procedure TvxPathData.HLineToRel(const x: single);
var
  LP: TvxPoint;
begin
  LP := LastPoint;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointLineTo;
  PathData[High(PathData)].Point := vgPoint(LP.x + x, LP.y);
end;

procedure TvxPathData.VLineTo(const y: single);
begin
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointLineTo;
  PathData[High(PathData)].Point := vgPoint(PathData[High(PathData) - 1].Point.x, y);
end;

procedure TvxPathData.VLineToRel(const y: single);
var
  LP: TvxPoint;
begin
  LP := LastPoint;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointLineTo;
  PathData[High(PathData)].Point := vgPoint(LP.x, LP.y + y);
end;

procedure TvxPathData.CurveTo(const ControlPoint1, ControlPoint2, EndPoint: TvxPoint);
begin
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointCurveTo;
  PathData[High(PathData)].Point := ControlPoint1;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointCurveTo;
  PathData[High(PathData)].Point := ControlPoint2;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointCurveTo;
  PathData[High(PathData)].Point := EndPoint;
end;

procedure TvxPathData.CurveToRel(const ControlPoint1, ControlPoint2, EndPoint: TvxPoint);
begin
  with LastPoint do
  begin
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointCurveTo;
    PathData[High(PathData)].Point := vgPoint(x + ControlPoint1.x, y + ControlPoint1.y);
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointCurveTo;
    PathData[High(PathData)].Point := vgPoint(x + ControlPoint2.x, y + ControlPoint2.y);
    ;
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointCurveTo;
    PathData[High(PathData)].Point := vgPoint(x + EndPoint.x, y + EndPoint.y);
    ;
  end;
end;

procedure TvxPathData.SmoothCurveTo(const ControlPoint2, EndPoint: TvxPoint);
var
  ControlPoint1: TvxPoint;
begin
  if Length(PathData) > 2 then
  begin
    ControlPoint1.x := LastPoint.x + (LastPoint.x - PathData[High(PathData)].Point.x);
    ControlPoint1.y := LastPoint.y + (LastPoint.y - PathData[High(PathData)].Point.y);
  end
  else
    ControlPoint1 := ControlPoint2;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointCurveTo;
  PathData[High(PathData)].Point := ControlPoint1;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointCurveTo;
  PathData[High(PathData)].Point := ControlPoint2;
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointCurveTo;
  PathData[High(PathData)].Point := EndPoint;
end;

procedure TvxPathData.SmoothCurveToRel(const ControlPoint2, EndPoint: TvxPoint);
var
  ControlPoint1: TvxPoint;
begin
  if Length(PathData) > 2 then
  begin
    ControlPoint1.x := LastPoint.x + (LastPoint.x - PathData[High(PathData)].Point.x);
    ControlPoint1.y := LastPoint.y + (LastPoint.y - PathData[High(PathData)].Point.y);
  end
  else
    ControlPoint1 := ControlPoint2;
  with LastPoint do
  begin
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointCurveTo;
    PathData[High(PathData)].Point := vgPoint(ControlPoint1.x, ControlPoint1.y);
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointCurveTo;
    PathData[High(PathData)].Point := vgPoint(x + ControlPoint2.x, y + ControlPoint2.y);
    ;
    SetLength(PathData, Length(PathData) + 1);
    PathData[High(PathData)].Kind := vgPathPointCurveTo;
    PathData[High(PathData)].Point := vgPoint(x + EndPoint.x, y + EndPoint.y);
    ;
  end;
end;

procedure TvxPathData.ClosePath;
begin
  SetLength(PathData, Length(PathData) + 1);
  PathData[High(PathData)].Kind := vgPathPointClose;
  PathData[High(PathData)].Point := FStartPoint;
end;

procedure TvxPathData.Clear;
begin
  SetLength(PathData, 0);
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

function TvxPathData.GetBounds: TvxRect;
var
  i: integer;
begin
  if Length(PathData) = 0 then
  begin
    Result := vgRect(0, 0, 0, 0);
    Exit;
  end;
  Result := vgRect($FFFF, $FFFF, -$FFFF, -$FFFF);
  for i := 0 to High(PathData) do
  begin
    if PathData[i].Kind = vgPathPointClose then
      Continue;

    if PathData[i].Point.X < Result.Left then
      Result.Left := PathData[i].Point.X;
    if PathData[i].Point.X > Result.Right then
      Result.Right := PathData[i].Point.X;
    if PathData[i].Point.Y < Result.Top then
      Result.Top := PathData[i].Point.Y;
    if PathData[i].Point.Y > Result.Bottom then
      Result.Bottom := PathData[i].Point.Y;
  end;
  // add small amount
  if vgRectWidth(Result) = 0 then
    Result.Right := Result.Left + 0.001;
  if vgRectHeight(Result) = 0 then
    Result.Bottom := Result.Top + 0.001;
end;

procedure TvxPathData.Scale(const scaleX, scaleY: single);
var
  i: integer;
begin
  if Length(PathData) > 0 then
  begin
    for i := 0 to High(PathData) do
      case PathData[i].Kind of
        vgPathPointMoveTo, vgPathPointLineTo, vgPathPointCurveTo:
          begin
            PathData[i].Point.x := PathData[i].Point.x * scaleX;
            PathData[i].Point.y := PathData[i].Point.y * scaleY;
          end;
        vgPathPointClose:
          begin
          end;
      end;
  end;
end;

procedure TvxPathData.Offset(const dX, dY: single);
var
  i: integer;
begin
  if Length(PathData) > 0 then
  begin
    for i := 0 to High(PathData) do
      case PathData[i].Kind of
        vgPathPointMoveTo, vgPathPointLineTo, vgPathPointCurveTo:
          begin
            PathData[i].Point.x := PathData[i].Point.x + dX;
            PathData[i].Point.y := PathData[i].Point.y + dY;
          end;
        vgPathPointClose:
          begin
          end;
      end;
  end;
end;

procedure TvxPathData.ApplyMatrix(const M: TvxMatrix);
var
  i: integer;
begin
  if Length(PathData) > 0 then
  begin
    for i := 0 to High(PathData) do
      case PathData[i].Kind of
        vgPathPointMoveTo, vgPathPointLineTo, vgPathPointCurveTo:
          begin
            with vgVectorTransform(vgVector(PathData[i].Point), M) do
              PathData[i].Point := vgPoint(x, y);
          end;
        vgPathPointClose:
          begin
          end;
      end;
  end;
end;

procedure TvxPathData.Flatten(const Flatness: single = 0.25);

  procedure CalculateBezierCoefficients(const Bezier: TvxCubicBezier; out ax, bx, cx, ay, by, cy: single);
  begin
    cx := 3.0 * (Bezier[1].x - Bezier[0].x);
    cy := 3.0 * (Bezier[1].y - Bezier[0].y);
    bx := 3.0 * (Bezier[2].x - Bezier[1].x) - cx;
    by := 3.0 * (Bezier[2].y - Bezier[1].y) - cy;
    ax := Bezier[3].x - Bezier[0].x - cx - bx;
    ay := Bezier[3].y - Bezier[0].y - cy - by;
  end;

  function PointOnBezier(const StartPoint: TvxPoint; const ax, bx, cx, ay, by, cy, T: single): TvxPoint;
  var
    tSqr: single;
    tCube: single;
  begin
    tSqr := t * t;
    tCube := tSqr * t;
    Result.x := (ax * tCube) + (bx * tSqr) + (cx * t) + StartPoint.x;
    Result.y := (ay * tCube) + (by * tSqr) + (cy * t) + StartPoint.y;
  end;

  function CreateBezier(const Bezier: TvxCubicBezier; const PointCount: integer): TvxPolygon;
  var
    ax: single;
    bx: single;
    cx: single;
    ay: single;
    by: single;
    cy: single;
    dT: single;
    T: single;
    i: Integer;
  begin
    if PointCount = 0 then
      exit;
    dT := 1.0 / (1.0 * PointCount - 1.0);
    T := 0.0;
    SetLength(Result, PointCount);
    CalculateBezierCoefficients(Bezier, ax, bx, cx, ay, by, cy);
    for i := 0 to PointCount - 1 do
    begin
      Result[i] := PointOnBezier(Bezier[0], ax, bx, cx, ay, by, cy, T);
      T := T + dT;
    end;
  end;

var
  i, j: integer;
  BPts: TvxPolygon;
  B: TvxCubicBezier;
  Len: single;
  SegCount: integer;
  OldPathData: array of TvxPathPoint;
  CurPoint: TvxPoint;
  f, s: single;
  Bounds, R: TvxRect;
begin
  { scale }
  if Length(PathData) > 0 then
  begin
    Bounds := GetBounds;
    R := Bounds;
    vgFitRect(R, vgRect(0, 0, 100, 100));
    s := vgMinFloat(vgRectWidth(Bounds) / 100, vgRectHeight(Bounds) / 100);
    f := Flatness * s;
    if f < 0.05 then
      f := 0.05;

    { copy data }
    SetLength(OldPathData, Length(PathData));
    System.Move(PathData[0], OldPathData[0], Length(PathData) * SizeOf(PathData[0]));
    SetLength(PathData, 0);

    i := 0;
    while i < Length(OldPathData) do
    begin
      case OldPathData[i].Kind of
        vgPathPointMoveTo:
          begin
            MoveTo(OldPathData[i].Point);
            CurPoint := OldPathData[i].Point;
          end;
        vgPathPointLineTo:
          begin
            LineTo(OldPathData[i].Point);
            CurPoint := OldPathData[i].Point;
          end;
        vgPathPointCurveTo:
          begin
            B[0] := CurPoint;
            B[1] := OldPathData[i].Point;
            Inc(i);
            B[2] := OldPathData[i].Point;
            Inc(i);
            B[3] := OldPathData[i].Point;
            Len := vgVectorLength(vgVectorSubtract(vgVector(B[1]), vgVector(B[3])));
            SegCount := round(Len / f);
            if SegCount < 2 then
              SegCount := 2;
            BPts := CreateBezier(B, SegCount);
            for j := 0 to High(BPts) do
            begin
              LineTo(BPts[j]);
            end;
            CurPoint := OldPathData[i].Point;
          end;
        vgPathPointClose:
          begin
            ClosePath;
          end;
      end;
      Inc(i);
    end;
    if Assigned(FOnChanged) then
      FOnChanged(Self);
  end;
end;

function TvxPathData.FlattenToPolygon(var Polygon: TvxPolygon; const Flatness: single = 0.25): TvxPoint;

  procedure CalculateBezierCoefficients(const Bezier: TvxCubicBezier; out ax, bx, cx, ay, by, cy: single);
  begin
    cx := 3.0 * (Bezier[1].x - Bezier[0].x);
    cy := 3.0 * (Bezier[1].y - Bezier[0].y);
    bx := 3.0 * (Bezier[2].x - Bezier[1].x) - cx;
    by := 3.0 * (Bezier[2].y - Bezier[1].y) - cy;
    ax := Bezier[3].x - Bezier[0].x - cx - bx;
    ay := Bezier[3].y - Bezier[0].y - cy - by;
  end;

  function PointOnBezier(const StartPoint: TvxPoint; const ax, bx, cx, ay, by, cy, T: single): TvxPoint;
  var
    tSqr: single;
    tCube: single;
  begin
    tSqr := t * t;
    tCube := tSqr * t;
    Result.x := (ax * tCube) + (bx * tSqr) + (cx * t) + StartPoint.x;
    Result.y := (ay * tCube) + (by * tSqr) + (cy * t) + StartPoint.y;
  end;

  function CreateBezier(const Bezier: TvxCubicBezier; const PointCount: integer): TvxPolygon;
  var
    ax: single;
    bx: single;
    cx: single;
    ay: single;
    by: single;
    cy: single;
    dT: single;
    T: single;
    i: Integer;
  begin
    if PointCount = 0 then
      exit;
    dT := 1.0 / (1.0 * PointCount - 1.0);
    T := 0.0;
    SetLength(Result, PointCount);
    CalculateBezierCoefficients(Bezier, ax, bx, cx, ay, by, cy);
    for i := 0 to PointCount - 1 do
    begin
      Result[i] := PointOnBezier(Bezier[0], ax, bx, cx, ay, by, cy, T);
      T := T + dT;
    end;
  end;

var
  i, j: integer;
  BPts: TvxPolygon;
  B: TvxCubicBezier;
  SP, CurPoint: TvxPoint;
  Len: single;
  SegCount: integer;
  f, s: single;
  Bounds, R: TvxRect;
begin
  Result := vgPoint(0, 0);
  SetLength(Polygon, 0);
  if Length(PathData) > 0 then
  begin
    Bounds := GetBounds;
    R := Bounds;
    vgFitRect(R, vgRect(0, 0, 100, 100));
    s := vgMinFloat(vgRectWidth(Bounds) / 100, vgRectHeight(Bounds) / 100);
    f := Flatness * s;
    if f < 0.05 then
      f := 0.05;

    i := 0;
    while i < Length(PathData) do
    begin
      case PathData[i].Kind of
        vgPathPointMoveTo:
          begin
            SetLength(Polygon, Length(Polygon) + 1);
            Polygon[High(Polygon)] := PathData[i].Point;
            CurPoint := PathData[i].Point;
            SP := CurPoint;
          end;
        vgPathPointLineTo:
          begin
            SetLength(Polygon, Length(Polygon) + 1);
            Polygon[High(Polygon)] := PathData[i].Point;
            CurPoint := PathData[i].Point;
          end;
        vgPathPointCurveTo:
          begin
            B[0] := CurPoint;
            B[1] := PathData[i].Point;
            Inc(i);
            B[2] := PathData[i].Point;
            Inc(i);
            B[3] := PathData[i].Point;
            Len := vgVectorLength(vgVectorSubtract(vgVector(B[1]), vgVector(B[3])));
            SegCount := round(Len / f);
            if SegCount < 2 then
              SegCount := 2;
            BPts := CreateBezier(B, SegCount);
            for j := 0 to High(BPts) do
            begin
              SetLength(Polygon, Length(Polygon) + 1);
              Polygon[High(Polygon)] := BPts[j];
            end;
            CurPoint := PathData[i].Point;
          end;
        vgPathPointClose:
          begin
            SetLength(Polygon, Length(Polygon) + 1);
            Polygon[High(Polygon)] := SP;
            SetLength(Polygon, Length(Polygon) + 1);
            Polygon[High(Polygon)] := ClosePolygon;
          end;
      end;
      Inc(i);
    end;
    with GetBounds do
      Result := vgPoint(Abs(Right - Left), Abs(Bottom - Top));
  end;
end;

procedure TvxPathData.AddEllipse(const ARect: TvxRect);
var
  cx, cy: single;
  px, py: single;
begin
  cx := (ARect.Left + ARect.Right) / 2;
  cy := (ARect.Top + ARect.Bottom) / 2;
  px := CurveKappa * (vgRectWidth(ARect) / 2);
  py := CurveKappa * (vgRectHeight(ARect) / 2);
  MoveTo(vgPoint(ARect.Left, cy));
  CurveTo(vgPoint(ARect.Left, cy - py), vgPoint(cx - px, ARect.Top), vgPoint(cx, ARect.Top));
  CurveTo(vgPoint(cx + px, ARect.Top), vgPoint(ARect.Right, cy - py), vgPoint(ARect.Right, cy));
  CurveTo(vgPoint(ARect.Right, cy + py), vgPoint(cx + px, ARect.Bottom), vgPoint(cx, ARect.Bottom));
  CurveTo(vgPoint(cx - px, ARect.Bottom), vgPoint(ARect.Left, cy + py), vgPoint(ARect.Left, cy));
end;

procedure TvxPathData.AddRectangle(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  R: TvxRect;
  x1, x2, y1, y2: single;
begin
  R := ARect;
  x1 := xRadius;
  if vgRectWidth(R) - (x1 * 2) < 0 then
    x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
  x2 := x1 / 2;
  y1 := yRadius;
  if vgRectHeight(R) - (y1 * 2) < 0 then
    y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
  y2 := y1 / 2;

  MoveTo(vgPoint(R.Left, R.Top + y1));
  if vgCornerTopLeft in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: LineTo(vgPoint(R.Left + x1, R.Top));
      vgCornerInnerRound: CurveTo(vgPoint(R.Left + x2, R.Top + y1), vgPoint(R.Left + x1, R.Top + y2),
          vgPoint(R.Left + x1, R.Top));
      vgCornerInnerLine:
        begin
          LineTo(vgPoint(R.Left + x2, R.Top + y1));
          LineTo(vgPoint(R.Left + x1, R.Top + y2));
          LineTo(vgPoint(R.Left + x1, R.Top));
        end;
    else
      CurveTo(vgPoint(R.Left, R.Top + (y2)), vgPoint(R.Left + x2, R.Top), vgPoint(R.Left + x1, R.Top))
    end;
  end
  else
  begin
    LineTo(vgPoint(R.Left, R.Top));
    LineTo(vgPoint(R.Left + x1, R.Top));
  end;
  LineTo(vgPoint(R.Right - x1, R.Top));
  if vgCornerTopRight in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: LineTo(vgPoint(R.Right, R.Top + y1));
      vgCornerInnerRound: CurveTo(vgPoint(R.Right - x1, R.Top + y2), vgPoint(R.Right - x2, R.Top + y1),
          vgPoint(R.Right, R.Top + y1));
      vgCornerInnerLine:
        begin
          LineTo(vgPoint(R.Right - x1, R.Top + y2));
          LineTo(vgPoint(R.Right - x2, R.Top + y1));
          LineTo(vgPoint(R.Right, R.Top + y1));
        end;
    else
      CurveTo(vgPoint(R.Right - x2, R.Top), vgPoint(R.Right, R.Top + (y2)), vgPoint(R.Right, R.Top + y1))
    end;
  end
  else
  begin
    LineTo(vgPoint(R.Right, R.Top));
    LineTo(vgPoint(R.Right, R.Top + y1));
  end;
  LineTo(vgPoint(R.Right, R.Bottom - y1));
  if vgCornerBottomRight in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: LineTo(vgPoint(R.Right - x1, R.Bottom));
      vgCornerInnerRound: CurveTo(vgPoint(R.Right - x2, R.Bottom - y1), vgPoint(R.Right - x1, R.Bottom - y2),
          vgPoint(R.Right - x1, R.Bottom));
      vgCornerInnerLine:
        begin
          LineTo(vgPoint(R.Right - x2, R.Bottom - y1));
          LineTo(vgPoint(R.Right - x1, R.Bottom - y2));
          LineTo(vgPoint(R.Right - x1, R.Bottom));
        end;
    else
      CurveTo(vgPoint(R.Right, R.Bottom - (y2)), vgPoint(R.Right - x2, R.Bottom), vgPoint(R.Right - x1, R.Bottom))
    end;
  end
  else
  begin
    LineTo(vgPoint(R.Right, R.Bottom));
    LineTo(vgPoint(R.Right - x1, R.Bottom));
  end;
  LineTo(vgPoint(R.Left + x1, R.Bottom));
  if vgCornerBottomLeft in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: LineTo(vgPoint(R.Left, R.Bottom - y1));
      vgCornerInnerRound: CurveTo(vgPoint(R.Left + x1, R.Bottom - y2), vgPoint(R.Left + x2, R.Bottom - y1),
          vgPoint(R.Left, R.Bottom - y1));
      vgCornerInnerLine:
        begin
          LineTo(vgPoint(R.Left + x1, R.Bottom - y2));
          LineTo(vgPoint(R.Left + x2, R.Bottom - y1));
          LineTo(vgPoint(R.Left, R.Bottom - y1));
        end;
    else
      CurveTo(vgPoint(R.Left + x2, R.Bottom), vgPoint(R.Left, R.Bottom - (y2)), vgPoint(R.Left, R.Bottom - y1))
    end;
  end
  else
  begin
    LineTo(vgPoint(R.Left, R.Bottom));
    LineTo(vgPoint(R.Left, R.Bottom - y1));
  end;
  ClosePath;
end;

procedure DrawArcWithBezier(Path: TvxPathData; CenterX, CenterY, RadiusX, RadiusY, StartAngle, SweepRange: single; UseMoveTo: boolean);
var
  Coord: array[0..3] of TvxPoint;
  pts: array[0..3] of TvxPoint;
  a, b, c, x, y: Double;
  ss, cc: Double;
  i: Integer;
begin
  if SweepRange = 0 then
  begin
    if UseMoveTo then
    begin
      if (Length(Path.PathData) = 0) then
        Path.MoveTo(vgPoint(CenterX + RadiusX * cos(StartAngle), CenterY - RadiusY * sin(StartAngle)))
      else
        Path.LineTo(vgPoint(CenterX + RadiusX * cos(StartAngle), CenterY - RadiusY * sin(StartAngle)));
    end;
    Path.LineTo(vgPoint(CenterX + RadiusX * cos(StartAngle), CenterY - RadiusY * sin(StartAngle)));
    Exit;
  end;
  b := sin(SweepRange / 2);
  c := cos(SweepRange / 2);
  a := 1 - c;
  x := a * 4.0 / 3.0;
  y := b - x * c / b;
  ss := sin(StartAngle + SweepRange / 2);
  cc := cos(StartAngle + SweepRange / 2);
  Coord[0] := vgPoint(c, -b);
  Coord[1] := vgPoint(c + x, -y);
  Coord[2] := vgPoint(c + x, y);
  Coord[3] := vgPoint(c, b);
  for i := 0 to 3 do
  begin
    pts[i] := vgPoint(CenterX + RadiusX * (Coord[i].x * cc - Coord[i].y * ss), Centery + RadiusY * (Coord[i].x * ss + Coord[i].y * cc));
  end;
  if UseMoveTo then
  begin
    if (Length(Path.PathData) = 0) then
      Path.MoveTo(pts[0])
    else
      Path.LineTo(pts[0]);
  end;
  Path.CurveTo(pts[1], pts[2], pts[3]);
end;

procedure TvxPathData.AddArc(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single);
const
  bezier_arc_angle_epsilon = 0.01;
var
  UseMoveTo: boolean;
  i: integer;
  f: single;
  total_sweep,
    local_sweep,
    prev_sweep: single;
  done: boolean;
begin
  StartAngle := vgDegToRad(StartAngle);
  SweepAngle := vgDegToRad(SweepAngle);

  i := trunc(StartAngle / (2.0 * cPi));
  f := StartAngle - (i * 2.0 * cPi);

  StartAngle := f;

  if SweepAngle >= 2.0 * cPi then
    SweepAngle := 2.0 * cPi;
  if SweepAngle <= -2.0 * cPi then
    SweepAngle := -2.0 * cPi;

  if Abs(SweepAngle) < 1E-10 then
  begin
    exit;
  end;

  total_sweep := 0.0;

  done := false;
  UseMoveTo := true;
  repeat
    if SweepAngle < 0.0 then
    begin
      prev_sweep := total_sweep;
      local_sweep := -cPi * 0.5;
      total_sweep := total_sweep - (cPi * 0.5);
      if total_sweep <= SweepAngle + bezier_arc_angle_epsilon then
      begin
        local_sweep := SweepAngle - prev_sweep;
        done := true;
      end;
    end
    else
    begin
      prev_sweep := total_sweep;
      local_sweep := cPi * 0.5;
      total_sweep := total_sweep + (pi * 0.5);
      if total_sweep >= SweepAngle - bezier_arc_angle_epsilon then
      begin
        local_sweep := SweepAngle - prev_sweep;
        done := true;
      end;
    end;
    DrawArcWithBezier(Self, Center.x, Center.y, Radius.x, Radius.y, StartAngle, local_sweep, UseMoveTo);
    UseMoveTo := false;
    StartAngle := StartAngle + local_sweep;
  until done;
end;

procedure TvxPathData.AddArcSvgPart(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single);
const
  bezier_arc_angle_epsilon = 0.01;
var
  UseMoveTo: boolean;
  i: integer;
  f: single;
  total_sweep,
    local_sweep,
    prev_sweep: single;
  done: boolean;
begin
  StartAngle := vgDegToRad(StartAngle);
  SweepAngle := vgDegToRad(SweepAngle);

  i := trunc(StartAngle / (2.0 * cPi));
  f := StartAngle - (i * 2.0 * cPi);

  StartAngle := f;

  if SweepAngle >= 2.0 * cPi then
    SweepAngle := 2.0 * cPi;
  if SweepAngle <= -2.0 * cPi then
    SweepAngle := -2.0 * cPi;

  if Abs(SweepAngle) < 1E-10 then
  begin
    exit;
  end;

  total_sweep := 0.0;

  done := false;
  UseMoveTo := false;
  repeat
    if SweepAngle < 0.0 then
    begin
      prev_sweep := total_sweep;
      local_sweep := -cPi * 0.5;
      total_sweep := total_sweep - (cPi * 0.5);
      if total_sweep <= SweepAngle + bezier_arc_angle_epsilon then
      begin
        local_sweep := SweepAngle - prev_sweep;
        done := true;
      end;
    end
    else
    begin
      prev_sweep := total_sweep;
      local_sweep := cPi * 0.5;
      total_sweep := total_sweep + (pi * 0.5);
      if total_sweep >= SweepAngle - bezier_arc_angle_epsilon then
      begin
        local_sweep := SweepAngle - prev_sweep;
        done := true;
      end;
    end;
    DrawArcWithBezier(Self, Center.x, Center.y, Radius.x, Radius.y, StartAngle, local_sweep, UseMoveTo);
    UseMoveTo := false;
    StartAngle := StartAngle + local_sweep;
  until done;
end;

procedure TvxPathData.AddArcSvg(const P1, Radius: TvxPoint; Angle: single; const LargeFlag, SweepFlag: boolean; const P2: TvxPoint);
var
  i: integer;
  m_radii_ok: boolean;
  v, p, n, sq,
    rx, ry,
    x0, y0,
    x1, y1,
    x2, y2,
    cx, cy,
    ux, uy,
    vx, vy,

  dx2, dy2,
    prx, pry,
    px1, py1,
    cx1, cy1,
    sx2, sy2,

  sign, coef,

  radii_check,
    start_angle,
    sweep_angle,

  cos_a, sin_a: single;
  tm: TvxMatrix;
  len: integer;
begin
  rx := Radius.X;
  ry := Radius.Y;
  x0 := P1.X;
  y0 := P1.Y;
  x2 := P2.X;
  y2 := P2.Y;
  angle := vgDegToRad(Angle);

  m_radii_ok := true;

  if rx < 0.0 then
    rx := -rx;

  if ry < 0.0 then
    ry := -rx;

  // Calculate the middle point between
  // the current and the final points
  dx2 := (x0 - x2) / 2.0;
  dy2 := (y0 - y2) / 2.0;

  // Convert angle from degrees to radians
  cos_a := cos(angle);
  sin_a := sin(angle);

  // Calculate (x1, y1)
  x1 := cos_a * dx2 + sin_a * dy2;
  y1 := -sin_a * dx2 + cos_a * dy2;

  // Ensure radii are large enough
  prx := rx * rx;
  pry := ry * ry;
  px1 := x1 * x1;
  py1 := y1 * y1;

  // Check that radii are large enough
  radii_check := px1 / prx + py1 / pry;

  if radii_check > 1.0 then
  begin
    rx := sqrt(radii_check) * rx;
    ry := sqrt(radii_check) * ry;
    prx := rx * rx;
    pry := ry * ry;

    if radii_check > 10.0 then
      m_radii_ok := false;

  end;

  // Calculate (cx1, cy1)
  if LargeFlag = SweepFlag then
    sign := -1.0
  else
    sign := 1.0;

  sq := (prx * pry - prx * py1 - pry * px1) / (prx * py1 + pry * px1);

  if sq < 0 then
    coef := sign * sqrt(0)
  else
    coef := sign * sqrt(sq);

  cx1 := coef * ((rx * y1) / ry);
  cy1 := coef * -((ry * x1) / rx);

  // Calculate (cx, cy) from (cx1, cy1)
  sx2 := (x0 + x2) / 2.0;
  sy2 := (y0 + y2) / 2.0;
  cx := sx2 + (cos_a * cx1 - sin_a * cy1);
  cy := sy2 + (sin_a * cx1 + cos_a * cy1);

  // Calculate the start_angle (angle1) and the sweep_angle (dangle)
  ux := (x1 - cx1) / rx;
  uy := (y1 - cy1) / ry;
  vx := (-x1 - cx1) / rx;
  vy := (-y1 - cy1) / ry;

  // Calculate the angle start
  n := sqrt(ux * ux + uy * uy);
  p := ux; // (1 * ux ) + (0 * uy )

  if uy < 0 then
    sign := -1.0
  else
    sign := 1.0;

  v := p / n;

  if v < -1.0 then
    v := -1.0;

  if v > 1.0 then
    v := 1.0;

  start_angle := sign * ArcCos(v);

  // Calculate the sweep angle
  n := sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));
  p := ux * vx + uy * vy;

  if ux * vy - uy * vx < 0 then
    sign := -1.0
  else
    sign := 1.0;

  v := p / n;

  if v < -1.0 then
    v := -1.0;

  if v > 1.0 then
    v := 1.0;

  sweep_angle := sign * ArcCos(v);

  if (not SweepFlag) and (sweep_angle > 0) then
    sweep_angle := sweep_angle - pi * 2.0
  else
    if SweepFlag and (sweep_angle < 0) then
    sweep_angle := sweep_angle + pi * 2.0;

  len := Length(PathData);
  AddArcSvgPart(vgPoint(0, 0), vgPoint(rx, ry), vgRadToDeg(start_angle), vgRadToDeg(sweep_angle));

  tm := IdentityMatrix;
  tm.m31 := cx;
  tm.m32 := cy;
  tm := vgMatrixMultiply(vgCreateRotationMatrix(Angle), tm);

  i := len;
  while i < Length(PathData) do
  begin
    with vgVectorTransform(vgVector(PathData[i].Point), tm) do
      PathData[i].Point := vgPoint(x, y);
    inc(i);
  end;
end;

function TvxPathData.IsEmpty: boolean;
begin
  Result := Length(PathData) = 0;
end;

function TvxPathData.GetPathString: AnsiString;
var
  i: integer;
begin
  Result := '';
  i := 0;
  while i < Length(PathData) do
  begin
    case PathData[i].Kind of
      vgPathPointMoveTo:
        Result := Result + 'M ' + vgFloatToStr(PathData[i].Point.X) + ',' + vgFloatToStr(PathData[i].Point.Y) + ' ';
      vgPathPointLineTo:
        Result := Result + 'L ' + vgFloatToStr(PathData[i].Point.X) + ',' + vgFloatToStr(PathData[i].Point.Y) + ' ';
      vgPathPointCurveTo:
        begin
          Result := Result + 'C ' + vgFloatToStr(PathData[i].Point.X) + ',' + vgFloatToStr(PathData[i].Point.Y) + ' ' +
            vgFloatToStr(PathData[i + 1].Point.X) + ',' + vgFloatToStr(PathData[i + 1].Point.Y) + ' ' +
            vgFloatToStr(PathData[i + 2].Point.X) + ',' + vgFloatToStr(PathData[i + 2].Point.Y) + ' ';
          Inc(i, 2);
        end;
      vgPathPointClose:
        Result := Result + 'Z ';
    end;
    Inc(i);
  end;
end;

function GetTok(const S: AnsiString; var Pos: integer): AnsiString;
var
  i: integer;
begin
  Result := '';
  if Pos > Length(S) then
    Exit;
  while (Pos <= Length(S)) and (S[Pos] in [' ']) do
    Inc(Pos);
  for i := Pos to Length(S) do
  begin
    if System.Pos(S[i], 'zmlchvsqtaZMLCHVSQTA') = 0 then
      Break;
    Result := Result + S[i];
  end;
  Pos := i;
end;

function GetNum(const S: AnsiString; var Pos: integer): AnsiString;
var
  i: integer;
begin
  Result := '';
  if Pos > Length(S) then
    Exit;
  while (Pos <= Length(S)) and (S[Pos] in [' ']) do
    Inc(Pos);
  for i := Pos to Length(S) do
  begin
    if (S[i] = 'e') then
    begin
      Result := Result + S[i];
      Continue;
    end;
    if (S[i] = '-') and (Length(Result) > 0) and (Result[Length(Result)] = 'e') then
    begin
      Result := Result + S[i];
      Continue;
    end;
    if (System.Pos(S[i], '0123456789.') = 0) and not ((i = Pos) and (S[i] = '-')) then
      Break;
    Result := Result + S[i];
  end;
  while S[Pos] in [' '] do
    Inc(Pos);
  Pos := i;
end;

function GetPoint(const S: AnsiString; var Pos: integer): TvxPoint;
var
  x, y: AnsiString;
begin
  Result := vgPoint(0, 0);
  if Pos > Length(S) then
    Exit;
  while (Pos <= Length(S)) and (S[Pos] in [',', ' ']) do
    Inc(Pos);
  x := GetNum(S, Pos);
  while (Pos <= Length(S)) and (S[Pos] in [',', ' ']) do
    Inc(Pos);
  y := GetNum(S, Pos);
  while (Pos <= Length(S)) and (S[Pos] in [',', ' ']) do
    Inc(Pos);

  Result := vgPoint(vgStrToFloat(x), vgStrToFloat(y));
end;

procedure TvxPathData.SetPathString(const Value: AnsiString);
const
  TokSep = ' '#10#13;
  TokStop = '0123456789-';
  NumSep = ' ,'#10#13;
  NumStop = 'zmlchvsqtaZMLCHVSQTA';
var
  S, toks: AnsiString;
  tok: AnsiChar;
  R, CP1, CP2: TvxPoint;
  angle: single;
  large, sweet: boolean;
  lastlen, pos, i: integer;
begin
  { remove #10#13 }
  for i := 1 to Length(Value) do
  begin
    if Value[i] in [#9, #10, #13] then
      Continue;
    S := S + Value[i];
  end;
  { }
  SetLength(PathData, 0);
  pos := 1;
  while S <> '' do
  begin
    lastlen := pos;
    toks := GetTok(S, pos);
    while toks <> '' do
    begin
      tok := toks[1];
      Delete(toks, 1, 1);
      try
        if (tok in ['z', 'Z']) then
        begin
          ClosePath;
        end;
        if (tok in ['M']) then
        begin
          MoveTo(GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            LineTo(GetPoint(S, pos));
          end;
        end;
        if (tok in ['m']) then
        begin
          MoveToRel(GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            LineToRel(GetPoint(S, pos));
          end;
        end;
        if (tok = 'L') then
        begin
          LineTo(GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            LineTo(GetPoint(S, pos));
          end;
        end;
        if (tok = 'l') then
        begin
          LineToRel(GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            LineToRel(GetPoint(S, pos));
          end;
        end;
        if (tok = 'C') then
        begin
          CP1 := GetPoint(S, pos);
          CP2 := GetPoint(S, pos);
          CurveTo(CP1, CP2, GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            CP1 := GetPoint(S, pos);
            CP2 := GetPoint(S, pos);
            CurveTo(CP1, CP2,
              GetPoint(S, pos)
              );
          end;
        end;
        if (tok = 'c') then
        begin
          CP1 := GetPoint(S, pos);
          CP2 := GetPoint(S, pos);
          CurveToRel(CP1, CP2, GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            CP1 := GetPoint(S, pos);
            CP2 := GetPoint(S, pos);
            CurveToRel(CP1, CP2, GetPoint(S, pos));
          end;
        end;
        if (tok = 'S') then
        begin
          CP2 := GetPoint(S, pos);
          SmoothCurveTo(CP2, GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            CP2 := GetPoint(S, pos);
            SmoothCurveTo(CP2, GetPoint(S, pos));
          end;
        end;
        if (tok = 's') then
        begin
          CP2 := GetPoint(S, pos);
          SmoothCurveToRel(CP2, GetPoint(S, pos));
          while (S <> '') and (S[pos] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-']) do
          begin
            { next points }
            CP2 := GetPoint(S, pos);
            SmoothCurveToRel(CP2, GetPoint(S, pos));
          end;
        end;
        if (tok = 'H') then
        begin
          // skip horizontal line
          HLineTo(vgStrToFloat(GetNum(S, Pos)));
        end;
        if (tok = 'h') then
        begin
          // skip horizontal line
          HLineToRel(vgStrToFloat(GetNum(S, Pos)));
        end;
        if (tok = 'V') then
        begin
          // skip vertical line
          VLineTo(vgStrToFloat(GetNum(S, Pos)));
        end;
        if (tok = 'v') then
        begin
          // skip vertical line
          VLineToRel(vgStrToFloat(GetNum(S, Pos)));
        end;
        if (tok = 'Q') then
        begin
          // skip quadratic bezier
          GetPoint(S, pos);
          GetPoint(S, pos);
        end;
        if (tok = 'q') then
        begin
          // skip quadratic bezier
          GetPoint(S, pos);
          GetPoint(S, pos);
        end;
        if (tok = 'T') then
        begin
          // skip show qudratic bezier
          GetPoint(S, pos);
        end;
        if (tok = 't') then
        begin
          // skip show qudratic bezier
          GetPoint(S, pos);
        end;
        if (tok = 'A') then
        begin
          // arc
          if Length(PathData) > 0 then
            CP1 := PathData[High(PathData)].Point
          else
            CP1 := vgPoint(0, 0);
          R := GetPoint(S, pos);
          angle := vgStrToFloat(GetNum(S, Pos));
          with GetPoint(S, pos) do
          begin
            large := X = 1;
            sweet := Y = 1;
          end;
          CP2 := GetPoint(S, pos);
          AddArcSvg(CP1, R, angle, large, sweet, CP2);
        end;
        if (tok = 'a') then
        begin
          // arc rel
          if Length(PathData) > 0 then
            CP1 := PathData[High(PathData)].Point
          else
            CP1 := vgPoint(0, 0);
          R := GetPoint(S, pos);
          angle := vgStrToFloat(GetNum(S, Pos));
          with GetPoint(S, pos) do
          begin
            large := X = 1;
            sweet := Y = 1;
          end;
          CP2 := GetPoint(S, pos);
          CP2.x := CP1.x + CP2.x;
          CP2.y := CP1.y + CP2.y;
          AddArcSvg(CP1, R, angle, large, sweet, CP2);
        end;
      except
      end;
    end;
    if lastlen = pos then
    begin
      Pos := 0;
      Break;
    end;
  end;
  if Assigned(FOnChanged) then
    FOnChanged(Self);
end;

{ TvxCanvas ===================================================================}

constructor TvxCanvas.Create(const AWidth, AHeight: integer);
begin
  inherited Create;
  FStroke := TvxBrush.Create(vgBrushSolid, $FF000000);
  FFill := TvxBrush.Create(vgBrushSolid, $FFFFFFFF);
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
  ResizeBuffer(AWidth, AHeight);
end;

constructor TvxCanvas.CreateFromBitmap(const ABitmap: TvxBitmap);
begin
  inherited Create;
  FWidth := ABitmap.Width;
  FHeight := ABitmap.Height;
  FStroke := TvxBrush.Create(vgBrushSolid, $FF000000);
  FFill := TvxBrush.Create(vgBrushSolid, $FFFFFFFF);
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
end;

destructor TvxCanvas.Destroy;
var
  i: integer;
begin
  if Length(FSaveData) > 0 then
  begin
    for i := 0 to High(FSaveData) do
    begin
      if FSaveData[i].Index = $FFFFFFFF then
        Continue;
      FSaveData[i].Stroke.Free;
      FSaveData[i].Fill.Free;
      FSaveData[i].Font.Free;
    end;
    SetLength(FSaveData, 0);
  end;
  FFont.Free;
  FStroke.Free;
  FFill.Free;
  FreeBuffer;
  inherited;
end;

procedure TvxCanvas.AssignTo(Dest: TPersistent);
var
  i: integer;
begin
  if Dest is TvxBitmap then
  begin
    TvxBitmap(Dest).SetSize(FWidth, FHeight);
    if FBuffered then
      for i := 0 to FHeight - 1 do
        System.Move(PvgColorArray(FBufferBits)[(i) * FWidth], TvxBitmap(Dest).Scanline[i]^, FWidth * 4);
  end
  else
    inherited;
end;

class function TvxCanvas.GetBitmapScanline(Bitmap: TvxBitmap;
  y: integer): PvgColorArray;
begin
  Result := nil;
end;

procedure TvxCanvas.SaveToStream(S: TStream);
var
  B: TvxBitmap;
begin
  if FBuffered then
  begin
    B := TvxBitmap.Create(FWidth, FHeight);
    vgMoveLongword(FBufferBits, B.StartLine, FWidth * FHeight);
    B.SaveToStream(S);
    B.Free;
  end;
end;

procedure TvxCanvas.SaveToBits(Bits: Pointer);
begin
  if FBuffered then
    vgMoveLongword(FBufferBits, Bits, FWidth * FHeight);
end;

function TvxCanvas.BeginScene: boolean;
begin
  Result := true;
end;

procedure TvxCanvas.EndScene;
begin
end;

procedure TvxCanvas.SetMatrix(const M: TvxMatrix);
begin
  FMatrix := M;
end;

procedure TvxCanvas.MultyMatrix(const M: TvxMatrix);
begin
end;

procedure TvxCanvas.FontChanged(Sender: TObject);
begin
end;

function TvxCanvas.LoadFontFromStream(AStream: TStream): boolean;
begin
end;

function TvxCanvas.TextHeight(const AText: WideString): single;
var
  R: TvxRect;
begin
  R := vgRect(0, 0, 10000, 10000);
  MeasureText(R, R, AText, false, vgTextAlignNear, vgTextAlignCenter);
  Result := vgRectHeight(R);
end;

function TvxCanvas.TextWidth(const AText: WideString): single;
var
  R: TvxRect;
begin
  R := vgRect(0, 0, 10000, 20);
  MeasureText(R, R, AText, false, vgTextAlignNear, vgTextAlignCenter);
  Result := vgRectWidth(R);
end;

procedure TvxCanvas.FillArc(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single; const AOpacity: single);
var
  P: TvxPathData;
begin
  P := TvxPathData.Create;
  P.AddArc(Center, Radius, StartAngle, SweepAngle);
  FillPath(P, P.Getbounds, AOpacity);
  P.Free;
end;

procedure TvxCanvas.DrawArc(const Center, Radius: TvxPoint; StartAngle, SweepAngle: single; const AOpacity: single);
var
  P: TvxPathData;
begin
  P := TvxPathData.Create;
  P.AddArc(Center, Radius, StartAngle, SweepAngle);
  DrawPath(P, P.Getbounds, AOpacity);
  P.Free;
end;

procedure TvxCanvas.SetStrokeDash(const Value: TvxStrokeDash);
begin
  if Value <> FStrokeDash then
  begin
    FStrokeDash := Value;
    case FStrokeDash of
      vgDashSolid:
        begin
          FDashOffset := 0;
          SetLength(FDash, 0);
        end;
      vgDashDash:
        begin
          FDashOffset := 0;
          SetLength(FDash, 2);
          FDash[0] := 1 * 3;
          FDash[1] := 1;
        end;
      vgDashDot:
        begin
          FDashOffset := 0;
          SetLength(FDash, 2);
          FDash[0] := 1;
          FDash[1] := 1;
        end;
      vgDashDashDot:
        begin
          FDashOffset := 0;
          SetLength(FDash, 4);
          FDash[0] := 1 * 3;
          FDash[1] := 1;
          FDash[2] := 1;
          FDash[3] := 1;
        end;
      vgDashDashDotDot:
        begin
          FDashOffset := 0;
          SetLength(FDash, 6);
          FDash[0] := 1 * 3;
          FDash[1] := 1;
          FDash[2] := 1;
          FDash[3] := 1;
          FDash[4] := 1;
          FDash[5] := 1;
        end;
      vgDashCustom: ;
    else
      FDashOffset := 0;
      SetLength(FDash, 0);
    end;
  end;
end;

procedure TvxCanvas.SetCustomDash(Dash: array of single; Offset: single);
var
  i: integer;
begin
  FStrokeDash := vgDashCustom;
  SetLength(FDash, Length(Dash));
  for i := 0 to High(Dash) do
    FDash[i] := Dash[i];
  FDashOffset := Offset;
end;

procedure TvxCanvas.FillPolygon(const Points: TvxPolygon; const AOpacity: single);
var
  i: integer;
  Path: TvxPathData;
begin
  Path := TvxPathData.Create;
  SetLength(Path.PathData, Length(Points));
  for i := 0 to High(Points) do
    with Path.PathData[i] do
    begin
      Kind := vgPathPointLineTo;
      if i = 0 then
        Kind := vgPathPointMoveTo;
      if (i > 0) and (Path.PathData[i - 1].Kind = vgPathPointClose) then
        Kind := vgPathPointMoveTo;
      if (Points[i].x = ClosePolygon.x) and (Points[i].y = ClosePolygon.y) then
      begin
        Kind := vgPathPointClose;
        Continue;
      end;
      if i = High(Points) then
        Kind := vgPathPointClose;
      Point := Points[i];
    end;
  FillPath(Path, Path.GetBounds, AOpacity);
  Path.Free;
end;

procedure TvxCanvas.DrawPolygon(const Points: TvxPolygon; const AOpacity: single);
var
  i: integer;
  Path: TvxPathData;
begin
  Path := TvxPathData.Create;
  SetLength(Path.PathData, Length(Points));
  for i := 0 to High(Points) do
    with Path.PathData[i] do
    begin
      Kind := vgPathPointLineTo;
      if (i = 0) then
        Kind := vgPathPointMoveTo;
      if (i > 0) and (Path.PathData[i - 1].Kind = vgPathPointClose) then
        Kind := vgPathPointMoveTo;
      if (Points[i].x = ClosePolygon.x) and (Points[i].y = ClosePolygon.y) then
      begin
        Kind := vgPathPointClose;
        Continue;
      end;
      Point := Points[i];
    end;
  DrawPath(Path, Path.GetBounds, AOpacity);
  Path.Free;
end;

procedure TvxCanvas.DrawRectSides(const ARect: TvxRect; const xRadius, yRadius: single; const ACorners: TvxCorners; const AOpacity: single;
  const ASides: TvxSides;
  const ACornerType: TvxCornerType = vgCornerRound);
var
  Path: TvxPathData;
  x1, x2, y1, y2: single;
  R: TvxRect;
begin
  R := ARect;
  x1 := xRadius;
  if vgRectWidth(R) - (x1 * 2) < 0 then
    x1 := (xRadius * (vgRectWidth(R) / (x1 * 2)));
  x2 := x1 / 2;
  y1 := yRadius;
  if vgRectHeight(R) - (y1 * 2) < 0 then
    y1 := (yRadius * (vgRectHeight(R) / (y1 * 2)));
  y2 := y1 / 2;
  Path := TvxPathData.Create;
  Path.MoveTo(vgPoint(R.Left, R.Top + y1));
  if vgCornerTopLeft in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: Path.LineTo(vgPoint(R.Left + x1, R.Top));
      vgCornerInnerRound: Path.CurveTo(vgPoint(R.Left + x2, R.Top + y1), vgPoint(R.Left + x1, R.Top + y2), vgPoint(R.Left + x1, R.Top));
      vgCornerInnerLine:
        begin
          Path.LineTo(vgPoint(R.Left + x2, R.Top + y1));
          Path.LineTo(vgPoint(R.Left + x1, R.Top + y2));
          Path.LineTo(vgPoint(R.Left + x1, R.Top));
        end;
    else
      Path.CurveTo(vgPoint(R.Left, R.Top + (y2)), vgPoint(R.Left + x2, R.Top), vgPoint(R.Left + x1, R.Top))
    end;
  end
  else
  begin
    if vgSideLeft in ASides then
      Path.LineTo(vgPoint(R.Left, R.Top))
    else
      Path.MoveTo(vgPoint(R.Left, R.Top));
    if vgSideTop in ASides then
      Path.LineTo(vgPoint(R.Left + x1, R.Top))
    else
      Path.MoveTo(vgPoint(R.Left + x1, R.Top));
  end;
  if not (vgSideTop in ASides) then
    Path.MoveTo(vgPoint(R.Right - x1, R.Top))
  else
    Path.LineTo(vgPoint(R.Right - x1, R.Top));
  if vgCornerTopRight in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: Path.LineTo(vgPoint(R.Right, R.Top + y1));
      vgCornerInnerRound: Path.CurveTo(vgPoint(R.Right - x1, R.Top + y2), vgPoint(R.Right - x2, R.Top + y1), vgPoint(R.Right, R.Top + y1));
      vgCornerInnerLine:
        begin
          Path.LineTo(vgPoint(R.Right - x1, R.Top + y2));
          Path.LineTo(vgPoint(R.Right - x2, R.Top + y1));
          Path.LineTo(vgPoint(R.Right, R.Top + y1));
        end;
    else
      Path.CurveTo(vgPoint(R.Right - x2, R.Top), vgPoint(R.Right, R.Top + (y2)), vgPoint(R.Right, R.Top + y1))
    end;
  end
  else
  begin
    if vgSideTop in ASides then
      Path.LineTo(vgPoint(R.Right, R.Top))
    else
      Path.MoveTo(vgPoint(R.Right, R.Top));
    if vgSideRight in ASides then
      Path.LineTo(vgPoint(R.Right, R.Top + y1))
    else
      Path.MoveTo(vgPoint(R.Right, R.Top + y1));
  end;
  if not (vgSideRight in ASides) then
    Path.MoveTo(vgPoint(R.Right, R.Bottom - y1))
  else
    Path.LineTo(vgPoint(R.Right, R.Bottom - y1));
  if vgCornerBottomRight in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: Path.LineTo(vgPoint(R.Right - x1, R.Bottom));
      vgCornerInnerRound: Path.CurveTo(vgPoint(R.Right - x2, R.Bottom - y1), vgPoint(R.Right - x1, R.Bottom - y2), vgPoint(R.Right - x1, R.Bottom));
      vgCornerInnerLine:
        begin
          Path.LineTo(vgPoint(R.Right - x2, R.Bottom - y1));
          Path.LineTo(vgPoint(R.Right - x1, R.Bottom - y2));
          Path.LineTo(vgPoint(R.Right - x1, R.Bottom));
        end;
    else
      Path.CurveTo(vgPoint(R.Right, R.Bottom - (y2)), vgPoint(R.Right - x2, R.Bottom), vgPoint(R.Right - x1, R.Bottom))
    end;
  end
  else
  begin
    if vgSideRight in ASides then
      Path.LineTo(vgPoint(R.Right, R.Bottom))
    else
      Path.MoveTo(vgPoint(R.Right, R.Bottom));
    if vgSideBottom in ASides then
      Path.LineTo(vgPoint(R.Right - x1, R.Bottom))
    else
      Path.MoveTo(vgPoint(R.Right - x1, R.Bottom));
  end;
  if not (vgSideBottom in ASides) then
    Path.MoveTo(vgPoint(R.Left + x1, R.Bottom))
  else
    Path.LineTo(vgPoint(R.Left + x1, R.Bottom));
  if vgCornerBottomLeft in ACorners then
  begin
    case ACornerType of
      // vgCornetRound - default
      vgCornerBevel: Path.LineTo(vgPoint(R.Left, R.Bottom - y1));
      vgCornerInnerRound: Path.CurveTo(vgPoint(R.Left + x1, R.Bottom - y2), vgPoint(R.Left + x2, R.Bottom - y1), vgPoint(R.Left, R.Bottom - y1));
      vgCornerInnerLine:
        begin
          Path.LineTo(vgPoint(R.Left + x1, R.Bottom - y2));
          Path.LineTo(vgPoint(R.Left + x2, R.Bottom - y1));
          Path.LineTo(vgPoint(R.Left, R.Bottom - y1));
        end;
    else
      Path.CurveTo(vgPoint(R.Left + x2, R.Bottom), vgPoint(R.Left, R.Bottom - (y2)), vgPoint(R.Left, R.Bottom - y1))
    end;
  end
  else
  begin
    if vgSideBottom in ASides then
      Path.LineTo(vgPoint(R.Left, R.Bottom))
    else
      Path.MoveTo(vgPoint(R.Left, R.Bottom));
    if vgSideLeft in ASides then
      Path.LineTo(vgPoint(R.Left, R.Bottom - y1))
    else
      Path.MoveTo(vgPoint(R.Left, R.Bottom - y1));
  end;
  if (vgSideLeft in ASides) then
  begin
    Path.LineTo(vgPoint(R.Left, R.Top + y1));
  end;
  DrawPath(Path, ARect, AOpacity);
  Path.Free;
end;

{ TvxAnimation ===================================================================}

type

  TvxAniThread = class(TvxTimer)
  private
    FAniList: TList;
    FStartTime, FTime, FDeltaTime: single;
    procedure OneStep;
    procedure DoSyncTimer(Sender: TObject);
  protected
  public
    constructor Create;
    destructor Destroy; override;
  end;

  {$IFDEF NOVCL}

function GetTickCount: single;
var
  H, M, S, MS: word;
begin
  DecodeTime(time, H, M, S, MS);
  Result := ((((H * 60 * 60) + (M * 60) + S) * 1000) + MS);
end;
{$ENDIF}

{ TvxAniThread }

constructor TvxAniThread.Create;
begin
  inherited Create(nil);
  Interval := Trunc(1000 / 30);
  OnTimer := DoSyncTimer;

  FAniList := TList.Create;
  FStartTime := GetTickCount / 1000;
end;

destructor TvxAniThread.Destroy;
begin
  FAniList.Free;
  inherited;
end;

procedure TvxAniThread.DoSyncTimer(Sender: TObject);
begin
  OneStep;
end;

procedure TvxAniThread.OneStep;
var
  i: integer;
  NewTime: single;
begin
  NewTime := (GetTickCount / 1000) - FStartTime;
  if NewTime <= FTime then
    Exit;
  FDeltaTime := NewTime - FTime;
  FTime := NewTime;
  if FAniList.Count > 0 then
  begin
    i := FAniList.Count - 1;
    while i >= 0 do
    begin
      if TvxAnimation(FAniList[i]).FRunning then
      begin
        if (TvxAnimation(FAniList[i]).BindingName <> '') and
          (CompareText(TvxAnimation(FAniList[i]).BindingName, 'caret') = 0) then
        begin
          TvxAnimation(FAniList[i]).Tag := TvxAnimation(FAniList[i]).Tag + 1;
          if TvxAnimation(FAniList[i]).Tag mod 3 = 0 then
          begin
            TvxAnimation(FAniList[i]).ProcessTick(FTime, FDeltaTime);
          end;
        end
        else
          TvxAnimation(FAniList[i]).ProcessTick(FTime, FDeltaTime);
      end;
      Dec(i);
      if i >= FAniList.Count then
        i := FAniList.Count - 1;
    end;
  end;
end;

constructor TvxAnimation.Create(AOwner: TComponent);
begin
  inherited;
  FEnabled := false;
  Duration := 0.2;
end;

destructor TvxAnimation.Destroy;
begin
  if aniThread <> nil then
  begin
    TvxAniThread(aniThread).FAniList.Remove(Self);
  end;
  inherited;
end;

procedure TvxAnimation.Loaded;
begin
  inherited;
  if not (Assigned(FScene) and (FScene.GetDesignTime)) and Enabled then
    Start;
end;

procedure TvxAnimation.SetEnabled(const Value: boolean);
begin
  if FEnabled <> Value then
  begin
    FEnabled := Value;
    if not (Assigned(Scene) and Scene.GetDesignTime) and not (csLoading in ComponentState) then
    begin
      if FEnabled then
        Start
      else
        Stop;
    end;
  end;
end;

function TvxAnimation.NormalizedTime: single;
begin
  if (FDuration > 0) and (FDelayTime <= 0) then
  begin
    case FInterpolation of
      vgInterpolationLinear: Result := vgInterpolateLinear(FTime, 0, 1, FDuration);
      vgInterpolationQuadratic: Result := vgInterpolateQuad(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationCubic: Result := vgInterpolateCubic(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationQuartic: Result := vgInterpolateQuart(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationQuintic: Result := vgInterpolateQuint(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationSinusoidal: Result := vgInterpolateSine(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationExponential: Result := vgInterpolateExpo(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationCircular: Result := vgInterpolateCirc(FTime, 0, 1, FDuration, FAnimationType);
      vgInterpolationElastic: Result := vgInterpolateElastic(FTime, 0, 1, FDuration, 0, 0, FAnimationType);
      vgInterpolationBack: Result := vgInterpolateBack(FTime, 0, 1, FDuration, 0, FAnimationType);
      vgInterpolationBounce: Result := vgInterpolateBounce(FTime, 0, 1, FDuration, FAnimationType);
    end;
  end
  else
    Result := 0;
end;

procedure TvxAnimation.ProcessAnimation;
begin
end;

procedure TvxAnimation.ProcessTick(time, deltaTime: single);
begin
  inherited;
  if Assigned(FScene) and (FScene.GetDesignTime) then
    Exit;
  if csDestroying in ComponentState then
    Exit;

  if (Parent <> nil) and (Parent.IsVisual) and (not TvxVisualObject(Parent).Visible) then
    Stop;

  if not FRunning then
    Exit;
  if FPause then
    Exit;

  if (FDelay > 0) and (FDelayTime <> 0) then
  begin
    if FDelayTime > 0 then
    begin
      FDelayTime := FDelayTime - deltaTime;
      if FDelayTime <= 0 then
      begin
        Start;
        FDelayTime := 0;
      end;
    end;
    Exit;
  end;

  if FInverse then
    FTime := FTime - deltaTime
  else
    FTime := FTime + deltaTime;
  if FTime >= FDuration then
  begin
    FTime := FDuration;
    if FLoop then
    begin
      if FAutoReverse then
      begin
        FInverse := true;
        FTime := FDuration;
      end
      else
        FTime := 0;
    end
    else
      FRunning := false;
  end
  else
    if FTime <= 0 then
  begin
    FTime := 0;
    if FLoop then
    begin
      if FAutoReverse then
      begin
        FInverse := false;
        FTime := 0;
      end
      else
        FTime := FDuration;
    end
    else
      FRunning := false;
  end;

  ProcessAnimation;
  if Assigned(FOnProcess) then
    FOnProcess(Self);

  if (FScene <> nil) then
    if not FRunning then
    begin
      if aniThread <> nil then
        TvxAniThread(aniThread).FAniList.Remove(Self);
      if Assigned(FOnFinish) then
        FOnFinish(Self);
    end;
end;

procedure TvxAnimation.Start;
begin
  if (Parent <> nil) and (Parent.IsVisual) and (not TvxVisualObject(Parent).Visible) then
    Exit;
  if (Abs(FDuration) < 0.001) or (FScene = nil) or (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    { imediatly animation }
    FDelayTime := 0;
    if FInverse then
    begin
      FTime := 0;
      FDuration := 1;
    end
    else
    begin
      FTime := 1;
      FDuration := 1;
    end;
    FRunning := true;
    ProcessAnimation;
    FRunning := false;
    FTime := 0;
    FDuration := 0.00001;
    if Assigned(FOnFinish) then
      FOnFinish(Self);
    FEnabled := false;
  end
  else
  begin
    FDelayTime := FDelay;
    FRunning := true;
    if FInverse then
      FTime := FDuration
    else
      FTime := 0;
    if FDelay = 0 then
      ProcessAnimation;

    if (FScene <> nil) then
    begin
      if aniThread = nil then
        aniThread := TvxAniThread.Create;

      if TvxAniThread(aniThread).FAniList.IndexOf(Self) < 0 then
        TvxAniThread(aniThread).FAniList.Add(Self);
    end;
    FEnabled := true;
  end;
end;

procedure TvxAnimation.Stop;
begin
  if not FRunning then
    Exit;

  if aniThread <> nil then
  begin
    TvxAniThread(aniThread).FAniList.Remove(Self);
  end;

  if FInverse then
    FTime := 0
  else
    FTime := FDuration;
  ProcessAnimation;
  FRunning := false;
  FEnabled := false;
  if Assigned(FOnFinish) then
    FOnFinish(Self);
end;

procedure TvxAnimation.StopAtCurrent;
begin
  if not FRunning then
    Exit;

  if aniThread <> nil then
  begin
    TvxAniThread(aniThread).FAniList.Remove(Self);
  end;

  if FInverse then
    FTime := 0
  else
    FTime := FDuration;
  FRunning := false;
  FEnabled := false;
  if Assigned(FOnFinish) then
    FOnFinish(Self);
end;

procedure TvxAnimation.StartTrigger(AInstance: TvxObject; ATrigger: string);
var
  StartValue: boolean;
  Line, Setter, Prop, Value: AnsiString;
begin
  if AInstance = nil then
    Exit;
  if (FTriggerInverse <> '') and (Pos(LowerCase(ATrigger), LowerCase(FTriggerInverse)) > 0) then
  begin
    Line := FTriggerInverse;
    Setter := vgGetToken(Line, ';');
    StartValue := false;
    while Setter <> '' do
    begin
      Prop := vgGetToken(Setter, '=');
      Value := Setter;
      if GetPropInfo(AInstance, Prop, [{$IFDEF FPC}tkBool{$ELSE}tkEnumeration{$ENDIF}]) <> nil then
      begin
        {$IFDEF FPC}
        StartValue := false;
        if (CompareText(Value, 'true') = 0) and (GetOrdProp(AInstance, Prop) > 0) then
          StartValue := true;
        if (CompareText(Value, 'false') = 0) and (GetOrdProp(AInstance, Prop) = 0) then
          StartValue := true;
        {$ELSE}
        StartValue := CompareText(GetEnumProp(AInstance, Prop), Value) = 0;
        {$ENDIF}
        if not StartValue then
          Break;
      end;
      Setter := vgGetToken(Line, ';');
    end;
    if StartValue then
    begin
      Inverse := true;
      Start;
      Exit;
    end;
  end;
  if (FTrigger <> '') and (Pos(LowerCase(ATrigger), LowerCase(FTrigger)) > 0) then
  begin
    Line := FTrigger;
    Setter := vgGetToken(Line, ';');
    StartValue := false;
    while Setter <> '' do
    begin
      Prop := vgGetToken(Setter, '=');
      Value := Setter;
      if GetPropInfo(AInstance, Prop, [{$IFDEF FPC}tkBool{$ELSE}tkEnumeration{$ENDIF}]) <> nil then
      begin
        {$IFDEF FPC}
        StartValue := false;
        if (CompareText(Value, 'true') = 0) and (GetOrdProp(AInstance, Prop) > 0) then
          StartValue := true;
        if (CompareText(Value, 'false') = 0) and (GetOrdProp(AInstance, Prop) = 0) then
          StartValue := true;
        {$ELSE}
        StartValue := CompareText(GetEnumProp(AInstance, Prop), Value) = 0;
        {$ENDIF}
        if not StartValue then
          Exit;
      end;
      Setter := vgGetToken(Line, ';');
    end;
    if StartValue then
    begin
      if FTriggerInverse <> '' then
        Inverse := false;
      Start;
    end;
  end;
end;

{ TvxEffect ===================================================================}

constructor TvxEffect.Create(AOwner: TComponent);
begin
  inherited;
  FEnabled := true;
end;

destructor TvxEffect.Destroy;
begin
  inherited;
end;

function TvxEffect.GetOffset: TvxPoint;
begin

end;

function TvxEffect.GetRect(const ARect: TvxRect): TvxRect;
begin
  Result := ARect;
end;

procedure TvxEffect.ApplyTrigger(AInstance: TvxObject; ATrigger: string);
var
  StartValue: boolean;
  Line, Setter, Prop, Value: AnsiString;
begin
  if FTrigger = '' then
    Exit;
  if AInstance = nil then
    Exit;
  if Pos(LowerCase(ATrigger), LowerCase(FTrigger)) = 0 then
    Exit;

  Line := FTrigger;
  Setter := vgGetToken(Line, ';');
  StartValue := false;
  while Setter <> '' do
  begin
    Prop := vgGetToken(Setter, '=');
    Value := Setter;
    if GetPropInfo(AInstance, Prop, [{$IFDEF FPC}tkBool{$ELSE}tkEnumeration{$ENDIF}]) <> nil then
    begin
      {$IFDEF FPC}
      StartValue := false;
      if (CompareText(Value, 'true') = 0) and (GetOrdProp(AInstance, Prop) > 0) then
        StartValue := true;
      if (CompareText(Value, 'false') = 0) and (GetOrdProp(AInstance, Prop) = 0) then
        StartValue := true;
      {$ELSE}
      StartValue := CompareText(GetEnumProp(AInstance, Prop), Value) = 0;
      {$ENDIF}
    end;
    Setter := vgGetToken(Line, ';');
  end;
  Enabled := StartValue;
end;

procedure TvxEffect.UpdateParentEffects;
var
  SaveEnabled: boolean;
begin
  if not (csLoading in ComponentState) then
    if (Parent <> nil) and (Parent.isVisual) then
    begin
      TvxVisualObject(Parent).UpdateEffects;
      TvxVisualObject(Parent).FRecalcUpdateRect := true;
      // update if enabled = false (erase effect )
      SaveEnabled := FEnabled;
      FEnabled := true;
      TvxVisualObject(Parent).Repaint;
      FEnabled := SaveEnabled;
    end;
end;

procedure TvxEffect.ProcessEffect(Canvas: TvxCanvas;
  const Visual: TvxBitmap; const Data: single);
begin
end;

procedure TvxEffect.SetEnabled(const Value: boolean);
begin
  if FEnabled <> Value then
  begin
    FEnabled := Value;
    if FEnabled then
    begin
      if (Parent <> nil) and (Parent.isVisual) then
        TvxVisualObject(Parent).RecalcHasEffect;
    end;
    UpdateParentEffects;
  end;
end;

{ TvxObject ==================================================================}

constructor TvxObject.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  AddResource(Self);
  FIndex := -1;
  FStored := true;
  FIsVisual := Self is TvxVisualObject;
  if FIsVisual then
    FVisual := TvxVisualObject(Self);
end;

destructor TvxObject.Destroy;
var
  i: integer;
begin
  if FScene <> nil then
  begin
    FScene.Notification(Self, opRemove);
  end;
  { NotifList }
  if FNotifyList <> nil then
  begin
    for i := FNotifyList.Count - 1 downto 0 do
    begin
      if (TObject(FNotifyList[i]) is TvxVisual) and (TvxVisual(FNotifyList[i]).VisualObject = Self) then
        TvxVisual(FNotifyList[i]).FVisualObject := nil;
      if (TObject(FNotifyList[i]) is TvxBrushResource) and (TvxBrushResource(FNotifyList[i]).Resource = Self) then
        TvxBrushResource(FNotifyList[i]).FResource := nil;
      if (TObject(FNotifyList[i]) is TvxPathData) and (TvxPathData(FNotifyList[i]).Resource = Self) then
        TvxPathData(FNotifyList[i]).FResource := nil;
      if (TObject(FNotifyList[i]) is TvxBitmap) and (TvxBitmap(FNotifyList[i]).Resource = Self) then
        TvxBitmap(FNotifyList[i]).FResource := nil;
      if TObject(FNotifyList[i]) is TComponent then
        THackComponent(FNotifyList[i]).Notification(Self, opRemove);
    end;
    FreeAndNil(FNotifyList);
  end;
  { Remove from ResorcesList }
  i := ResourceList.IndexOf(Self);
  if i >= 0 then
    ResourceList[i] := nil;
  { }
  if FParent <> nil then
    FParent.RemoveObject(Self)
  else
    if FScene <> nil then
    FScene.RemoveObject(Self);
  FScene := nil;
  DeleteChildren;
  inherited;
end;

procedure TvxObject.Release(Delay: single = 0.1);
var
  T: TTimer;
begin
  T := TTimer.Create(Application);
  T.OnTimer := DoReleaseTimer;
  T.Interval := round(Delay * 1000);
  T.Enabled := true;
end;

procedure TvxObject.DoReleaseTimer(Sender: TObject);
begin
  Free;
  TTimer(Sender).Enabled := false;
end;

function TvxObject.ItemClass: string;
begin
  Result := '';
end;

procedure TvxObject.AddFreeNotify(const AObject: TObject);
begin
  if FNotifyList = nil then
    FNotifyList := TList.Create;
  FNotifyList.Add(AObject);
end;

procedure TvxObject.RemoveFreeNotify(const AObject: TObject);
begin
  if FNotifyList <> nil then
    FNotifyList.Remove(AObject);
end;

procedure TvxObject.ReaderSetName(Reader: TReader; Component: TComponent;
  var Name: string);
begin
  Name := '';
end;

procedure TvxObject.ReaderError(Reader: TReader; const Message: string;
  var Handled: Boolean);
begin
  Handled := true;
end;

procedure TvxObject.LoadFromStream(const AStream: TStream);
var
  BinStream: TStream;
begin
  { store }
  BinStream := TMemoryStream.Create;
  try
    ObjectTextToBinary(AStream, BinStream);
    BinStream.Position := 0;
    LoadFromBinStream(BinStream);
  finally
    BinStream.Free;
  end;
end;

procedure TvxObject.SaveToStream(const Stream: TStream);
var
  BinStream: TStream;
begin
  { store }
  BinStream := TMemoryStream.Create;
  try
    BinStream.WriteComponent(Self);
    BinStream.Position := 0;
    ObjectBinaryToText(BinStream, Stream);
  finally
    BinStream.Free;
  end;
end;

procedure TvxObject.LoadFromBinStream(const AStream: TStream);
var
  R: TReader;
begin
  R := TReader.Create(AStream, 1024);
  R.OnError := ReaderError;
  try
    R.ReadRootComponent(Self);
  finally
    R.Free;
  end;
end;

procedure TvxObject.SaveToBinStream(const AStream: TStream);
begin
  AStream.WriteComponent(Self);
end;

procedure TvxObject.IntLoadFromBinStream(const AStream: TStream);
var
  R: TReader;
begin
  R := TReader.Create(AStream, 1024);
  R.OnSetName := ReaderSetName;
  R.OnError := ReaderError;
  try
    if not (csDesigning in ComponentState) then
    begin
      // need to force set unique name
      SetDesigning(true, false);
      R.ReadRootComponent(Self);
      SetDesigning(false, false);
    end
    else
      R.ReadRootComponent(Self);
  finally
    R.Free;
  end;
end;

procedure TvxObject.IntSaveToBinStream(const AStream: TStream);
var
  SaveName: string;
begin
  { store }
  SaveName := Name;
  Name := '';
  AStream.WriteComponent(Self);
  Name := SaveName;
end;

function TvxObject.Clone(const AOwner: TComponent): TvxObject;
var
  S: TStream;
  SaveName: string;
begin
  S := TMemoryStream.Create;
  try
    { store }
    SaveName := Name;
    Name := '';
    S.WriteComponent(Self);
    Name := SaveName;
    S.Position := 0;
    { load }
    Result := TvxObjectClass(ClassType).Create(AOwner);
    if Result <> nil then
      Result.IntLoadFromBinStream(S);
  finally
    S.Free;
  end;
end;

procedure TvxObject.CloneChildFromStream(AStream: TStream);
var
  i: integer;
  Obj: TvxObject;
begin
  Obj := CreateObjectFromStream(Self, AStream);
  if (Obj <> nil) and (Obj.FChildren <> nil) and (Obj.FChildren.Count > 0) then
  begin
    { delete self childs }
    DeleteChildren;
    { copy parent }
    for i := 0 to Obj.FChildren.Count - 1 do
    begin
      if TvxObject(Obj.FChildren[0]).isVisual then
        TvxVisualObject(Obj.FChildren[0]).Locked := true;
      TvxObject(Obj.FChildren[0]).Stored := false;
      TvxObject(Obj.FChildren[0]).Parent := Self;
    end;
    { realign to new size }
    if Obj.isVisual and (isVisual) then
    begin
      TvxVisualObject(Self).FLastWidth := TvxVisualObject(Obj).Width;
      TvxVisualObject(Self).FLastHeight := TvxVisualObject(Obj).Height;
      TvxVisualObject(Self).Realign;
    end;
    //    Obj.Free;
  end;
end;

procedure TvxVisualObject.SetLocked(const Value: boolean);
begin
  FLocked := Value;
end;

function TvxObject.GetScene: IvgScene;
begin
  if FScene <> nil then
    Result := FScene
  else
    if FParent <> nil then
  begin
    FScene := FParent.FScene;
    Result := FScene;
  end
  else
    Result := nil;
end;

function TvxObject.HasClipParent: TvxVisualObject;
var
  i: integer;
begin
  Result := nil;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if (TvxObject(FChildren[i]).IsVisual) and (TvxVisualObject(FChildren[i]).ClipParent) then
      begin
        Result := TvxVisualObject(FChildren[i]);
        Exit;
      end;
end;

function TvxVisualObject.GetEffectsRect: TvxRect;
var
  i: integer;
begin
  Result := LocalRect;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if (TvxObject(FChildren[i]) is TvxEffect) and (TvxEffect(FChildren[i]).Enabled) then
        Result := vgUnionRect(Result, TvxEffect(FChildren[i]).GetRect(LocalRect));
    end;
end;

procedure TvxVisualObject.RecalcHasEffect;
var
  i: integer;
begin
  FHasEffect := false;
  if FDisableEffect then
    Exit;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if (TvxObject(FChildren[i]) is TvxEffect) and (TvxEffect(FChildren[i]).Enabled) then
      begin
        if not FHasEffect then
        begin
          UpdateEffects;
          Repaint;
        end;
        FHasEffect := true;
        Break;
      end;
    end;
end;

function TvxVisualObject.HasDisablePaintEffect: boolean;
var
  i: integer;
begin
  Result := false;
  if FDisableEffect then
    Exit;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if (TvxObject(FChildren[i]) is TvxEffect) and (TvxEffect(FChildren[i]).Enabled) and (TvxEffect(FChildren[i]).DisablePaint) then
      begin
        Result := true;
        Exit;
      end;
end;

function TvxVisualObject.HasAfterPaintEffect: boolean;
var
  i: integer;
begin
  Result := false;
  if FDisableEffect then
    Exit;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if (TvxObject(FChildren[i]) is TvxEffect) and (TvxEffect(FChildren[i]).Enabled) and (TvxEffect(FChildren[i]).AfterPaint) then
      begin
        Result := true;
        Exit;
      end;
end;

{ Property animation }

procedure TvxObject.AnimateColor(const APropertyName, NewValue: string;
  Duration: single = 0.2; AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
var
  A: TvxColorAnimation;
begin
  A := TvxColorAnimation.Create(Self);
  A.Parent := Self;
  A.AnimationType := AType;
  A.Interpolation := AInterpolation;
  A.OnFinish := DoAniFinished;
  A.Duration := Duration;
  A.PropertyName := APropertyName;
  A.StartFromCurrent := true;
  A.StopValue := NewValue;
  A.Start;
end;

procedure TvxObject.AnimateFloat(const APropertyName: string;
  const NewValue: single; Duration: single = 0.2;
  AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
var
  A: TvxFloatAnimation;
begin
  A := TvxFloatAnimation.Create(Self);
  A.Parent := Self;
  A.AnimationType := AType;
  A.Interpolation := AInterpolation;
  A.OnFinish := DoAniFinished;
  A.Duration := Duration;
  A.PropertyName := APropertyName;
  A.StartFromCurrent := true;
  A.StopValue := NewValue;
  A.Start;
end;

procedure TvxObject.AnimateFloatDelay(const APropertyName: string; const NewValue: single; Duration: single = 0.2;
  Delay: single = 0.0; AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
var
  A: TvxFloatAnimation;
begin
  A := TvxFloatAnimation.Create(Self);
  A.Parent := Self;
  A.AnimationType := AType;
  A.Interpolation := AInterpolation;
  A.Delay := Delay;
  A.Duration := Duration;
  A.PropertyName := APropertyName;
  A.StartFromCurrent := true;
  A.StopValue := NewValue;
  A.Start;
end;

procedure TvxObject.AnimateFloatWait(const APropertyName: string;
  const NewValue: single; Duration: single = 0.2;
  AType: TvxAnimationType = vgAnimationIn; AInterpolation: TvxInterpolationType = vgInterpolationLinear);
var
  A: TvxFloatAnimation;
begin
  A := TvxFloatAnimation.Create(Self);
  A.Parent := Self;
  A.AnimationType := AType;
  A.Interpolation := AInterpolation;
  A.Duration := Duration;
  A.PropertyName := APropertyName;
  A.StartFromCurrent := true;
  A.StopValue := NewValue;
  A.Start;
  while A.FRunning do
  begin
    Application.ProcessMessages;
    Sleep(0);
  end;
  A.Free;
end;

procedure TvxObject.DoAniFinished(Sender: TObject);
begin
  TvxAnimation(Sender).Free;
end;

{ Animations }

procedure TvxObject.StartAnimation(const AName: WideString);
var
  i: integer;
  E: TvxAnimation;
begin
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if TvxObject(FChildren[i]) is TvxAnimation then
        if CompareText(TvxAnimation(FChildren[i]).Name, AName) = 0 then
        begin
          E := TvxAnimation(FChildren[i]);
          E.Start;
        end;
    end;
end;

procedure TvxObject.StopAnimation(const AName: WideString);
var
  i: integer;
  E: TvxAnimation;
begin
  if FChildren <> nil then
    for i := FChildren.Count - 1 downto 0 do
      if TvxObject(FChildren[i]) is TvxAnimation then
        if CompareText(TvxAnimation(FChildren[i]).Name, AName) = 0 then
        begin
          E := TvxAnimation(FChildren[i]);
          E.Stop;
        end;
end;

procedure TvxObject.StartTriggerAnimation(AInstance: TvxObject; ATrigger: string);
var
  i: integer;
begin
  StopTriggerAnimation(AInstance);
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if TvxObject(FChildren[i]) is TvxAnimation then
        TvxAnimation(FChildren[i]).StartTrigger(AInstance, ATrigger);
      { locked objects }
      if TvxObject(FChildren[i]).isVisual and TvxVisualObject(FChildren[i]).Locked and not TvxVisualObject(FChildren[i]).HitTest then
      begin
        TvxObject(FChildren[i]).StartTriggerAnimation(AInstance, ATrigger);
      end;
    end;
end;

procedure TvxObject.StartTriggerAnimationWait(AInstance: TvxObject; ATrigger: string);
var
  i: integer;
begin
  StopTriggerAnimation(AInstance);
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if TvxObject(FChildren[i]) is TvxAnimation then
      begin
        TvxAnimation(FChildren[i]).StartTrigger(AInstance, ATrigger);
        while TvxAnimation(FChildren[i]).Running do
        begin
          Application.ProcessMessages;
          Sleep(0);
        end;
      end;
      { locked objects }
      if TvxObject(FChildren[i]).isVisual and TvxVisualObject(FChildren[i]).Locked and not TvxVisualObject(FChildren[i]).HitTest then
      begin
        TvxObject(FChildren[i]).StartTriggerAnimationWait(AInstance, ATrigger);
      end;
    end;
end;

procedure TvxObject.StopTriggerAnimation(AInstance: TvxObject);
var
  i: integer;
  E: TvxAnimation;
begin
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if TvxObject(FChildren[i]) is TvxAnimation then
        if TvxAnimation(FChildren[i]).Trigger <> '' then
        begin
          E := TvxAnimation(FChildren[i]);
          E.Stop;
        end;
      { locked objects }
      if TvxObject(FChildren[i]).isVisual and TvxVisualObject(FChildren[i]).Locked and not TvxVisualObject(FChildren[i]).HitTest then
      begin
        TvxObject(FChildren[i]).StopTriggerAnimation(AInstance);
      end;
    end;
end;

procedure TvxObject.ApplyTriggerEffect(AInstance: TvxObject; ATrigger: string);
var
  i: integer;
begin
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if TvxObject(FChildren[i]) is TvxEffect then
        TvxEffect(FChildren[i]).ApplyTrigger(AInstance, ATrigger);
      { locked objects }
      if TvxObject(FChildren[i]).isVisual and TvxVisualObject(FChildren[i]).Locked and not TvxVisualObject(FChildren[i]).HitTest then
      begin
        TvxObject(FChildren[i]).ApplyTriggerEffect(AInstance, ATrigger);
      end;
    end;
end;

{ VCL }

procedure TvxObject.SetNewScene(AScene: IvgScene);
var
  i: integer;
begin
  FScene := AScene;
  if (FChildren <> nil) and (FChildren.Count > 0) then
    for i := 0 to FChildren.Count - 1 do
      TvxObject(FChildren[i]).SetNewScene(FScene);
end;

procedure TvxObject.ChangeParent;
begin
end;

procedure TvxObject.SetParent(const Value: TvxObject);
begin
  if Parent <> Value then
  begin
    if FParent <> nil then
      FParent.RemoveObject(Self)
    else
      if FScene <> nil then
      FScene.RemoveObject(Self);
    if Value <> nil then
    begin
      Value.AddObject(Self);
    end
    else
      FParent := Value;
  end;
end;

function TvxObject.GetChild(Index: integer): TvxObject;
begin
  if (FChildren <> nil) and (Index < FChildren.Count) then
    Result := TvxObject(FChildren[Index])
  else
    Result := nil;
end;

function TvxObject.GetChildrenCount: integer;
begin
  if (FChildren <> nil) then
    Result := FChildren.Count
  else
    Result := 0;
end;

procedure TvxObject.SetParentComponent(Value: TComponent);
var
  SI: IvgScene;
begin
  inherited;
  if FParent <> nil then
    FParent.RemoveObject(Self);

  if (Value <> nil) and (Value is TvxObject) then
  begin
    TvxObject(Value).AddObject(Self);
  end
  else
    if (THackComponent(Value).QueryInterface(IvgScene, SI) = 0) and (Assigned(SI)) then
  begin
    SI.AddObject(Self);
  end
end;

procedure TvxObject.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  i, j: Integer;
begin
  inherited;
  if (Self is TvxContent) then
    Exit;

  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if (TvxObject(FChildren[i]) is TvxContent) and (TvxContent(FChildren[i]).FChildren <> nil) then
      begin
        for j := 0 to TvxContent(FChildren[i]).FChildren.Count - 1 do
          if TvxObject(TvxContent(FChildren[i]).FChildren[j]).Stored then
            Proc(TComponent(TvxContent(FChildren[i]).FChildren[j]));
      end;
      if TvxObject(FChildren[i]).Stored then
      begin
        Proc(TComponent(FChildren[i]));
      end;
    end;
end;

function TvxObject.GetParentComponent: TComponent;
begin
  if (FParent <> nil) and (FParent is TvxPopup) and (TvxPopup(FParent).Parent <> nil) and (TvxPopup(FParent).Parent is TvxPopupItem) then
    Result := TvxContent(FParent).Parent
  else
    if (FParent <> nil) and (FParent is TvxContent) then
    Result := TvxContent(FParent).Parent
  else
    if (FParent <> nil) and (FParent is TvxComboListBox) then
    Result := TvxComboListBox(FParent).Parent
  else
    Result := FParent;
  if (Result = nil) and (FScene <> nil) then
    Result := FScene.GetComponent;
end;

function TvxObject.HasParent: Boolean;
begin
  Result := true;
end;

{ binding }

function TvxObject.GetData: Variant;
begin
  Result := Name;
end;

procedure TvxObject.SetData(const Value: Variant);
begin
end;

function TvxObject.GetBinding(Index: string): Variant;
var
  Obj: TvxObject;
begin
  Obj := FindBinding(Index);
  if Obj <> nil then
    Result := Obj.Data
  else
    Result := '';
end;

procedure TvxObject.SetBinding(Index: string; const Value: Variant);
var
  Obj: TvxObject;
begin
  Obj := FindBinding(Index);
  if Obj <> nil then
  begin
    try
      Obj.Data := Value;
    except
    end;
  end;
end;

function TvxObject.FindBinding(const ABinding: string): TvxObject;
var
  i: integer;
begin
  Result := nil;
  if CompareText(BindingName, ABinding) = 0 then
  begin
    Result := Self;
    Exit;
  end;
  if (FChildren <> nil) and (FChildren.Count > 0) then
  begin
    for i := 0 to FChildren.Count - 1 do
    begin
      if CompareText(TvxObject(FChildren[i]).BindingName, ABinding) = 0 then
      begin
        Result := TvxObject(FChildren[i]);
        Exit;
      end;
      Result := TvxObject(FChildren[i]).FindBinding(ABinding);
      if Result <> nil then
        Exit;
    end;
  end;
end;

procedure TvxObject.SetBindingName(const Value: string);
begin
  if FBindingName <> Value then
  begin
    FBindingName := Value;
  end;
end;

{  }

function TvxObject.FindResource(const AResource: string): TvxObject;
var
  i: integer;
begin
  Result := nil;
  if AResource = '' then
    Exit;
  if (FChildren <> nil) and (FChildren.Count > 0) then
  begin
    for i := 0 to FChildren.Count - 1 do
    begin
      if CompareText(TvxObject(FChildren[i]).ResourceName, AResource) = 0 then
      begin
        Result := TvxObject(FChildren[i]);
        Exit;
      end;
      if TvxObject(FChildren[i]) is TvxControl then
        Continue;

      Result := TvxObject(FChildren[i]).FindResource(AResource);
      if Result <> nil then
        Exit;
    end;
  end;
end;

procedure TvxObject.SetResourceName(const Value: string);
begin
  if FResourceName <> Value then
  begin
    FResourceName := Value;
  end;
end;

procedure TvxObject.SetStored(const Value: boolean);
var
  i: integer;
begin
  if FStored <> Value then
  begin
    FStored := Value;
    if (FChildren <> nil) and (FChildren.Count > 0) then
    begin
      for i := 0 to FChildren.Count - 1 do
      begin
        TvxObject(FChildren[i]).Stored := Value;
      end;
    end;
  end;
end;

procedure TvxObject.UpdateResource;
var
  i: integer;
begin
  if csLoading in ComponentState then
    Exit;
  if csDestroying in ComponentState then
    Exit;
  if (FChildren <> nil) and (FChildren.Count > 0) then
  begin
    for i := 0 to FChildren.Count - 1 do
    begin
      TvxObject(FChildren[i]).UpdateResource;
    end;
  end;
end;

procedure TvxObject.DeleteChildren;
var
  i: integer;
  Child: TvxObject;
begin
  if Assigned(FChildren) then
  begin
    for i := FChildren.Count - 1 downto 0 do
    begin
      Child := TvxObject(FChildren[i]);
      Child.FParent := nil;
      Child.SetNewScene(nil);
      Child.Free;
    end;
    FreeAndNil(FChildren);
  end;
end;

procedure TvxObject.AddObjectsToList(const AList: TList);
var
  i: integer;
begin
  AList.Add(Self);
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      TvxObject(FChildren[i]).AddObjectsToList(AList);
end;

procedure TvxObject.AddControlsToList(const AList: TList);
var
  i: integer;
begin
  if (Self is TvxControl) then
    AList.Add(Self);
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      TvxObject(FChildren[i]).AddControlsToList(AList);
end;

procedure TvxObject.AddObject(AObject: TvxObject);
begin
  if AObject = nil then
    Exit;
  if AObject.Parent <> nil then
    AObject.Parent := nil;
  if FChildren = nil then
  begin
    FChildren := TList.Create;
    FChildren.Capacity := 10;
  end;
  if FChildren.IndexOf(AObject) >= 0 then
    Exit;
  FChildren.Add(AObject);
  AObject.FParent := Self;
  AObject.SetNewScene(FScene);
  AObject.ChangeParent;
  if AObject.IsVisual and not (csLoading in ComponentState) then
  begin
  end;
  if IsVisual and AObject.IsVisual and (AObject.Visual.Align <> vaNone) then
    Self.Visual.FNeedAlign := true;
  if IsVisual and (AObject is TvxEffect) and (TvxEffect(AObject).Enabled) then
  begin
    Visual.FHasEffect := true;
    Visual.UpdateEffects;
  end;
  if IsVisual and AObject.IsVisual then
  begin
    if Visual.TempCanvas <> nil then
      AObject.Visual.TempCanvas := Visual.TempCanvas;
    if Self.IsVisual then
      TvxVisualObject(AObject).FUpdating := TvxVisualObject(Self).FUpdating;
    AObject.Visual.RecalcOpacity;
    AObject.Visual.RecalcAbsolute;
    AObject.Visual.RecalcUpdateRect;
    if Visual.FHasEffect then
    begin
      Visual.UpdateEffects;
      Visual.Repaint;
    end;
    if AObject.isVisual and (TvxVisualObject(AObject).Align <> vaNone) then
      TvxVisualObject(Self).Realign
    else
      TvxVisualObject(Self).Repaint;
    if TvxVisualObject(Self).FTabList = nil then
      TvxVisualObject(Self).FTabList := TList.Create;
    TvxVisualObject(Self).FTabList.Add(AObject);
  end;
end;

procedure TvxObject.Sort(Compare: TvxObjectSortCompare);
begin
  if FChildren <> nil then
    FChildren.Sort(TListSortCompare(Compare));
end;

function TvxObject.GetIndex: integer;
begin
  if (FIndex < 0) and (FParent <> nil) then
    FIndex := FParent.FChildren.IndexOf(Self);
  Result := FIndex;
end;

procedure TvxObject.SetIndex(Idx: integer);
var
  i: integer;
begin
  if (Parent <> nil) and (Parent.FChildren.IndexOf(Self) >= 0) then
  begin
    Parent.FChildren.Remove(Self);
    Parent.FChildren.Insert(Idx, Self);
    // recalc Index
    for i := 0 to Parent.FChildren.Count - 1 do
      TvxObject(Parent.FChildren[i]).FIndex := -1;
    if IsVisual and not (csLoading in ComponentState) and (Parent.IsVisual) then
      Parent.Visual.Realign;
  end;
end;

procedure TvxObject.Exchange(AObject1, AObject2: TvxObject);
var
  Idx: integer;
begin
  if (FChildren <> nil) and (AObject1.Parent = Self) and (AObject2.Parent = Self) then
  begin
    FChildren.Exchange(AObject1.Index, AObject2.Index);
    Idx := AObject1.FIndex;
    AObject1.FIndex := AObject2.Index;
    AObject2.FIndex := Idx;
    if IsVisual and not (csLoading in ComponentState) and (Parent.IsVisual) then
      Parent.Visual.Realign;
  end;
end;

procedure TvxObject.RemoveObject(AObject: TvxObject);
var
  i: integer;
begin
  if (FChildren <> nil) and (FChildren.IndexOf(AObject) < 0) then
    Exit;
  if IsVisual and AObject.IsVisual and (TvxVisualObject(Self).FTabList <> nil) then
  begin
    TvxVisualObject(AObject).FUpdating := 0;
    TvxVisualObject(Self).FTabList.Remove(AObject);
    {    if AObject.isVisual and (TvxVisualObject(AObject).Align <> vaNone) then
          TvxVisualObject(Self).Realign;}
  end;
  if IsVisual and AObject.IsVisual then
    AObject.Visual.Repaint;
  AObject.FParent := nil;
  AObject.SetNewScene(nil);
  // recalc Index
  if AObject.FIndex >= 0 then
    for i := AObject.FIndex to FChildren.Count - 1 do
      TvxObject(FChildren[i]).FIndex := -1;

  if FChildren <> nil then
    FChildren.Remove(AObject);
  if IsVisual then
    Visual.RecalcHasEffect;
  if IsVisual and AObject.IsVisual then
  begin
    TvxVisualObject(Self).RecalcNeedAlign;
    if AObject.Visual.TempCanvas <> nil then
      AObject.Visual.TempCanvas := nil;
  end;
end;

procedure TvxObject.BringToFront;
var
  i: integer;
begin
  if (Parent <> nil) and (Parent.FChildren <> nil) then
  begin
    Parent.FChildren.Remove(Self);
    Parent.FChildren.Add(Self);
    // recalc Index
    for i := 0 to Parent.FChildren.Count - 1 do
      TvxObject(Parent.FChildren[i]).FIndex := -1;
    if isVisual then
      TvxVisualObject(Self).Repaint;
  end;
end;

procedure TvxObject.SendToBack;
var
  i: integer;
begin
  if (Parent <> nil) and (Parent.FChildren <> nil) then
  begin
    Parent.FChildren.Remove(Self);
    Parent.FChildren.Insert(0, Self);
    // recalc Index
    for i := 0 to Parent.FChildren.Count - 1 do
      TvxObject(Parent.FChildren[i]).FIndex := -1;
    if Parent.IsVisual then
      TvxVisualObject(Parent).Realign;
  end;
end;

{ TvxVisualObject ==================================================================}

constructor TvxVisualObject.Create(AOwner: TComponent);
begin
  inherited;
  FTabOrder := -1;
  FEnabled := true;
  FRecalcEnabled := true;
  FOpacity := 1;
  FLocalMatrix := IdentityMatrix;
  FPosition := TvxPosition.Create(vgPoint(0, 0));
  FPosition.OnChange := MatrixChanged;
  FScale := TvxPosition.Create(vgPoint(1, 1));
  FScale.OnChange := MatrixChanged;
  FSkew := TvxPosition.Create(vgPoint(0, 0));
  FSkew.OnChange := MatrixChanged;
  FRotateCenter := TvxPosition.Create(vgPoint(0.5, 0.5));
  FRotateCenter.OnChange := MatrixChanged;
  FMargins := TvxBounds.Create(vgRect(0, 0, 0, 0));
  FMargins.OnChange := MarginsChanged;
  FPadding := TvxBounds.Create(vgRect(0, 0, 0, 0));
  FPadding.OnChange := PaddingChanged;
  FWidth := 50;
  FLastWidth := FWidth;
  FHeight := 50;
  FLastHeight := FHeight;
  FVisible := true;
  FHitTest := true;
  FRecalcAbsolute := true;
  FRecalcOpacity := true;
  FUpdateEffects := true;
  FRecalcUpdateRect := true;
  FCanFocused := false;
  FCanClipped := true;
end;

destructor TvxVisualObject.Destroy;
begin
  if FTabList <> nil then
    FreeAndNil(FTabList);
  if FEffectBitmap <> nil then
    FreeAndNil(FEffectBitmap);
  FMargins.Free;
  FPadding.Free;
  FRotateCenter.Free;
  FScale.Free;
  FSkew.Free;
  FPosition.Free;
  inherited;
end;

procedure TvxVisualObject.Loaded;
begin
  inherited;
  FLastWidth := FWidth;
  FLastHeight := FHeight;
  MatrixChanged(Self);
  if (FChildren <> nil) and (FChildren.Count > 0) then
    Realign;
  FixupTabList;
end;

procedure TvxVisualObject.DeleteChildren;
begin
  inherited;
  if FTabList <> nil then
    FreeAndNil(FTabList);
end;

procedure TvxVisualObject.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  {$IFNDEF NOVCL}
  if (Operation = opRemove) and (AComponent = FPopupMenu) then
    FPopupMenu := nil;
  {$ENDIF}
  if (Operation = opRemove) and (AComponent = FPopup) then
    FPopup := nil;
end;

{ matrix }

procedure TvxVisualObject.MatrixChanged(Sender: TObject);
var
  RotMatrix: TvxMatrix;
  M1, M2: TvxMatrix;
begin
  if (FScene <> nil) and (not FScene.GetDisableUpdate) and (not FInPaintTo) and (FUpdating = 0) then
    Repaint;
  FLocalMatrix := IdentityMatrix;
  FLocalMatrix.m31 := FPosition.X;
  FLocalMatrix.m32 := FPosition.Y;
  FLocalMatrix.m11 := FScale.X;
  FLocalMatrix.m22 := FScale.Y;
  if FRotateAngle <> 0 then
  begin
    M1 := IdentityMatrix;
    M1.m31 := -FRotateCenter.X * FWidth { * FScale.X};
    M1.m32 := -FRotateCenter.Y * FHeight { * FScale.Y};
    M2 := IdentityMatrix;
    M2.m31 := FRotateCenter.X * FWidth { * FScale.X};
    M2.m32 := FRotateCenter.Y * FHeight { * FScale.Y};
    RotMatrix := vgMatrixMultiply(M1, vgMatrixMultiply(vgCreateRotationMatrix(vgDegToRad(FRotateAngle)), M2));
    FLocalMatrix := vgMatrixMultiply(RotMatrix, FLocalMatrix);
  end;
  RecalcAbsolute;
  RecalcUpdateRect;
  UpdateEffects;
  if (FScene <> nil) and (not FScene.GetDisableUpdate) and (not FInPaintTo) and (FUpdating = 0) then
    Repaint;
end;

procedure TvxVisualObject.RecalcUpdateRect;
var
  i: integer;
begin
  if (Parent <> nil) and (Parent.IsVisual) and not (Parent.Visual.ClipChildren) and
    ((Position.X < 0) or (Position.Y < 0) or
    (Position.X + Width < Parent.Visual.Width) or
    (Position.Y + Height < Parent.Visual.Height))
    then
    Parent.Visual.FRecalcUpdateRect := true;

  FRecalcUpdateRect := true;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if not TvxObject(FChildren[i]).IsVisual then
        Continue;
      TvxVisualObject(FChildren[i]).RecalcUpdateRect;
    end;
end;

function TvxVisualObject.GetUpdateRect: TvxRect;
var
  R: TvxRect;
  P: TvxObject;
  i: integer;
begin
  if FRecalcUpdateRect then
  begin
    FRecalcUpdateRect := false;
    FUpdating := FUpdating + 1;
    FUpdateRect := AbsoluteRect;
    if (FScene <> nil) and not (FScene.GetDisableUpdate) then
    begin
      if not (csLoading in ComponentState) then
      begin
        P := Parent;
        while (P <> nil) and (P.IsVisual) do
        begin
          if TvxVisualObject(P).ClipChildren then
            vgIntersectRect(FUpdateRect, FUpdateRect, TvxVisualObject(P).UpdateRect);
          P := P.Parent;
        end;
        { focused }
        if CanFocused and IsFocused then
          vgInflateRect(FUpdateRect, 5, 5);
        { design }
        if (FScene <> nil) and (Self = FScene.GetSelected) then
        begin
          vgInflateRect(FUpdateRect, (GripSize) + 1, (GripSize) + 1);
          FUpdateRect.Top := FUpdateRect.Top - RotSize - GripSize;
        end;
        if (FScene <> nil) and (FScene.GetDesignPlaceObject = Self) then
        begin
          vgInflateRect(FUpdateRect, 1, 1);
          FUpdateRect.Top := FUpdateRect.Top - 20;
          if vgRectWidth(FUpdateRect) < 160 then
            FUpdateRect.Right := FUpdateRect.Left + 160;
        end;
        { Effects }
        if FHasEffect and not ClipChildren then
        begin
          R := GetEffectsRect;
          with R do
            R := vgNormalizeRect([LocaltoAbsolute(vgPoint(Left, Top)), LocaltoAbsolute(vgPoint(Right, Top)),
              LocaltoAbsolute(vgPoint(Right, Bottom)), LocaltoAbsolute(vgPoint(Left, Bottom))]);
          FUpdateRect := vgUnionRect(FUpdateRect, R);
        end;
        { Children }
        if not ClipChildren and (FChildren <> nil) then
        begin
          for i := 0 to FChildren.Count - 1 do
          begin
            if not TvxObject(FChildren[i]).IsVisual then
              Continue;
            if not TvxVisualObject(FChildren[i]).Visible then
              Continue;
            R := TvxVisualObject(FChildren[i]).UpdateRect;
            FUpdateRect := vgUnionRect(FUpdateRect, R);
          end;
        end;
      end;
    end;
    FUpdating := FUpdating - 1;
  end;
  Result := FUpdateRect;
end;

function TvxVisualObject.GetChildrenRect: TvxRect;
var
  i: integer;
begin
  Result := AbsoluteRect;
  { children }
  if not ClipChildren and (FChildren <> nil) then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).IsVisual and (TvxVisualObject(FChildren[i]).Visible) then
        Result := vgUnionRect(Result, TvxVisualObject(FChildren[i]).GetChildrenRect);
end;

function TvxVisualObject.GetAbsoluteWidth: single;
var
  V: TvxVector;
begin
  V := LocalToAbsoluteVector(vgVector(Width, Height));
  Result := V.X;
end;

function TvxVisualObject.GetAbsoluteHeight: single;
var
  V: TvxVector;
begin
  V := LocalToAbsoluteVector(vgVector(Width, Height));
  Result := V.Y;
end;

function TvxVisualObject.GetAbsoluteScale: TvxPoint;
var
  P: TvxObject;
begin
  Result := Scale.Point;
  P := Parent;
  while P <> nil do
  begin
    if P.IsVisual then
    begin
      Result.X := Result.X * P.Visual.Scale.X;
      Result.Y := Result.Y * P.Visual.Scale.Y;
    end;
    P := P.Parent;
  end;
end;

function TvxVisualObject.GetChildrenMatrix: TvxMatrix;
begin
  Result := IdentityMatrix;
end;

function TvxVisualObject.GetAbsoluteMatrix: TvxMatrix;
begin
  if FRecalcAbsolute then
  begin
    if (FParent <> nil) and (FParent.IsVisual) then
    begin
      FAbsoluteMatrix := vgMatrixMultiply(vgMatrixMultiply(FLocalMatrix, FParent.Visual.GetChildrenMatrix), FParent.Visual.AbsoluteMatrix);
    end
    else
      FAbsoluteMatrix := FLocalMatrix;

    Result := FAbsoluteMatrix;
    FRecalcAbsolute := false;
    if (FScene <> nil) and (not FScene.GetDisableUpdate) and (not FInPaintTo) and (FUpdating = 0) then
      Repaint;
  end
  else
  begin
    Result := FAbsoluteMatrix;
  end;
end;

function TvxVisualObject.GetInvertAbsoluteMatrix: TvxMatrix;
begin
  Result := AbsoluteMatrix;
  vgInvertMatrix(Result);
end;

procedure TvxVisualObject.RecalcAbsoluteNow;
var
  i: integer;
  Child: TvxVisualObject;
begin
  AbsoluteMatrix; // recalc
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if not TvxObject(FChildren[i]).isVisual then
        Continue;
      Child := TvxVisualObject(FChildren[i]);
      TvxVisualObject(Child).RecalcAbsoluteNow;
    end;
end;

procedure TvxVisualObject.RecalcAbsolute;
var
  i: integer;
  Child: TvxVisualObject;
begin
  FRecalcAbsolute := true;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if not TvxObject(FChildren[i]).isVisual then
        Continue;
      Child := TvxVisualObject(FChildren[i]);
      TvxVisualObject(Child).RecalcAbsolute;
    end;
end;

function TvxVisualObject.AbsoluteToLocalVector(P: TvxVector): TvxVector;
begin
  P.W := 0;
  Result := vgVectorTransform(P, InvertAbsoluteMatrix);
end;

function TvxVisualObject.LocalToAbsoluteVector(P: TvxVector): TvxVector;
begin
  P.W := 0;
  Result := vgVectorTransform(P, AbsoluteMatrix);
end;

function TvxVisualObject.AbsoluteToLocal(P: TvxPoint): TvxPoint;
var
  V: TvxVector;
begin
  V.X := P.X;
  V.Y := P.Y;
  V.W := 1;
  V := vgVectorTransform(V, InvertAbsoluteMatrix);
  Result.X := V.X;
  Result.Y := V.Y;
end;

function TvxVisualObject.LocalToAbsolute(P: TvxPoint): TvxPoint;
var
  V: TvxVector;
begin
  V.X := P.X;
  V.Y := P.Y;
  V.W := 1;
  V := vgVectorTransform(V, AbsoluteMatrix);
  Result := vgPoint(V.X, V.Y);
end;

{ Opacity }

function TvxVisualObject.GetAbsoluteOpacity: single;
begin
  if FRecalcOpacity then
  begin
    if (FParent <> nil) and (FParent.IsVisual) then
      FAbsoluteOpacity := FOpacity * FParent.Visual.AbsoluteOpacity
    else
      FAbsoluteOpacity := FOpacity;

    if not AbsoluteEnabled and (FScene <> nil) and ((FScene.GetRoot <> Self) and (FScene.GetRoot <> Parent)) then
      FAbsoluteOpacity := FAbsoluteOpacity * 0.8;

    Result := FAbsoluteOpacity;

    FRecalcOpacity := false;
  end
  else
  begin
    Result := FAbsoluteOpacity;
  end;
end;

procedure TvxVisualObject.RecalcOpacity;
var
  i: integer;
  Child: TvxVisualObject;
begin
  FRecalcOpacity := true;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if not TvxObject(FChildren[i]).isVisual then
        Continue;
      Child := TvxVisualObject(FChildren[i]);
      TvxVisualObject(Child).RecalcOpacity;
    end;
end;

{ methods }

procedure TvxVisualObject.CreateCaret;
var
  A: TvxFloatAnimation;
begin
  if FCaret = nil then
  begin
    FCaret := TvxRectangle.Create(Self);
    FCaret.Parent := Self;
    FCaret.Width := 3;
    FCaret.Height := 20;
    FCaret.Stored := false;
    FCaret.HitTest := false;
    FCaret.Locked := true;
    TvxRectangle(FCaret).Fill.Color := vcBlue;
    TvxRectangle(FCaret).Stroke.Style := vgBrushNone;
    if Assigned(FScene) and (FScene.GetAnimatedCaret) then
    begin
      A := TvxFloatAnimation.Create(Self);
      A.BindingName := 'caret';
      A.Parent := FCaret;
      A.StartValue := 1;
      A.Duration := 0.1;
      A.PropertyName := 'Opacity';
      A.StopValue := 0;
      A.AutoReverse := true;
      A.Loop := true;
      A.Enabled := false;
    end;
    FCaret.Visible := false;
  end;
end;

procedure TvxVisualObject.ShowCaretProc;
begin
  if FCaret = nil then
    CreateCaret;

  FCaret.Visible := true;
  if (FCaret.FindBinding('caret') <> nil) and not TvxFloatAnimation(FCaret.FindBinding('caret')).Running then
    TvxFloatAnimation(FCaret.FindBinding('caret')).Start;
end;

procedure TvxVisualObject.SetCaretPos(const APoint: TvxPoint);
begin
  if FCaret = nil then
    CreateCaret;
  FCaret.Position.Point := vgPoint(round(APoint.x), round(APoint.y));
end;

procedure TvxVisualObject.SetCaretSize(const ASize: TvxPoint);
begin
  if FCaret = nil then
    CreateCaret;
  FCaret.Width := ASize.X;
  FCaret.Height := ASize.Y;
end;

procedure TvxVisualObject.SetCaretColor(const AColor: TvxColor);
begin
  if FCaret = nil then
    CreateCaret;
  TvxRectangle(FCaret).Fill.SolidColor := AColor;
end;

procedure TvxVisualObject.HideCaret;
begin
  if FCaret <> nil then
    FCaret.Visible := false;
end;

function TvxVisualObject.PointInObject(X, Y: single): boolean;
var
  P: TvxPoint;
begin
  Result := false;
  P := AbsoluteToLocal(vgPoint(X, Y));
  if (P.X > 0) and (P.X < Width) and
    (P.Y > 0) and (P.Y < Height) then
  begin
    Result := true;
  end;
end;

function TvxVisualObject.CheckHitTest(const AHitTest: boolean): boolean;
begin
  Result := FHitTest;
  if ((Scene <> nil) and (Scene.GetDesignTime)) then
    Result := true;
  if (((Scene <> nil) and (Scene.GetDesignTime))) and FLocked then
    Result := false;
  if (((Scene <> nil) and (Scene.GetDesignTime))) and FDesignHide then
    Result := false;
end;

function TvxVisualObject.FindTarget(const APoint: TvxPoint; const Data: TvxDragObject): TvxVisualObject;
var
  i: integer;
  Obj, NewObj: TvxVisualObject;
  Accept: boolean;
begin
  if not Visible and not (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    Result := nil;
    Exit;
  end;
  if (Self is TvxControl) and not TvxControl(Self).AbsoluteEnabled and not (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    Result := nil;
    Exit;
  end;

  if FChildren <> nil then
    for i := FChildren.Count - 1 downto 0 do
    begin
      if not TvxObject(FChildren[i]).IsVisual then
        Continue;
      Obj := TvxVisualObject(FChildren[i]);
      if (not Obj.Visible) and not (((FScene <> nil) and FScene.GetDesignTime)) then
        Continue;
      if FDesignHide and (((FScene <> nil) and FScene.GetDesignTime)) then
        Continue;
      if ClipChildren and not PointInObject(APoint.X, APoint.Y) then
        Continue;

      NewObj := Obj.FindTarget(APoint, Data);
      if NewObj <> nil then
      begin
        Result := NewObj;
        Exit;
      end;
    end;

  Result := nil;
  Accept := false;
  DragOver(Data, APoint, Accept);
  if PointInObject(APoint.X, APoint.Y) and CheckHitTest(HitTest) and (Accept) then
    Result := Self;
end;

function TvxVisualObject.ObjectByPoint(X, Y: single): TvxVisualObject;
var
  i: integer;
  Obj, NewObj: TvxVisualObject;
begin
  if not Visible and not (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    Result := nil;
    Exit;
  end;
  if (Self is TvxControl) and not TvxControl(Self).AbsoluteEnabled and not (Assigned(FScene) and (FScene.GetDesignTime)) then
  begin
    Result := nil;
    Exit;
  end;
  if ClipChildren and not PointInObject(X, Y) then
  begin
    Result := nil;
    Exit;
  end;
  if FChildren <> nil then
    for i := FChildren.Count - 1 downto 0 do
    begin
      if not TvxObject(FChildren[i]).IsVisual then
        Continue;
      Obj := TvxVisualObject(FChildren[i]);
      if (not Obj.Visible) and not (((FScene <> nil) and FScene.GetDesignTime)) then
        Continue;
      if FDesignHide and (((FScene <> nil) and FScene.GetDesignTime)) then
        Continue;

      NewObj := Obj.ObjectByPoint(X, Y);
      if NewObj <> nil then
      begin
        Result := NewObj;
        Exit;
      end;
    end;

  Result := nil;
  if PointInObject(X, Y) and CheckHitTest(HitTest) then
    Result := Self;
end;

function TvxVisualObject.GetCanvas: TvxCanvas;
begin
  if FTempCanvas <> nil then
    Result := FTempCanvas
  else
    if FScene <> nil then
    Result := FScene.GetCanvas
  else
    Result := nil;
end;

procedure TvxVisualObject.BeforePaint;
begin
end;

procedure TvxVisualObject.ApplyResource;
begin
end;

procedure TvxVisualObject.Paint;
begin
end;

procedure TvxVisualObject.AfterPaint;
begin
end;

procedure TvxVisualObject.SetInPaintTo(value: boolean);
var
  i: integer;
begin
  FInPaintTo := value;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).isVisual then
        TvxVisualObject(FChildren[i]).SetInPaintTo(value);
end;

procedure TvxVisualObject.PaintTo(const ACanvas: TvxCanvas; const ARect: TvxRect; const AParent: TvxObject = nil);
var
  SaveIndex: integer;
  SaveTempCanvas: TvxCanvas;
  SaveDisableAlign: boolean;
  SavePos: TvxPoint;
  SaveScale: TvxPoint;
  SaveParent: TvxObject;
  SaveRotate: single;
begin
  if FScene = nil then
    Exit;
  if Width * Height = 0 then
    Exit;

  FScene.SetDisableUpdate(true);
  SaveDisableAlign := FDisableAlign;
  FDisableAlign := true;
  SetInPaintTo(true);
  try
    SaveTempCanvas := TempCanvas;
    TempCanvas := ACanvas;
    SaveIndex := TempCanvas.SaveCanvas;
    { save }
    SavePos := Position.Point;
    SaveScale := Scale.Point;
    SaveParent := FParent;
    SaveRotate := RotateAngle;
    FParent := AParent;
    FPosition.FX := ARect.Left;
    FPosition.FY := ARect.Top;
    FScale.FX := vgRectWidth(ARect) / Width;
    FScale.FY := vgRectHeight(ARect) / Height;
    FRotateAngle := 0;
    MatrixChanged(Self);

    { paint }
    TempCanvas.SetMatrix(AbsoluteMatrix);
    BeforePaint;
    Paint;
    AfterPaint;
    PaintChildren;

    { restore }
    FRotateAngle := SaveRotate;
    FPosition.FX := SavePos.X;
    FPosition.FY := SavePos.Y;
    FScale.FX := SaveScale.X;
    FScale.FY := SaveScale.Y;
    FParent := SaveParent;
    MatrixChanged(Self);
    RecalcUpdateRect;
    RecalcAbsoluteNow;
    RecalcOpacity;
    RecalcEnabled;
  finally
    SetInPaintTo(false);
    FDisableAlign := SaveDisableAlign;
    TempCanvas.RestoreCanvas(SaveIndex);
    TempCanvas := SaveTempCanvas;
    FScene.SetDisableUpdate(false);
  end;
end;

procedure TvxVisualObject.UpdateEffects;
var
  P: TvxObject;
begin
  if FHasEffect then
  begin
    FUpdateEffects := true;
  end;
  P := Parent;
  while P <> nil do
  begin
    if P.IsVisual then
      P.Visual.UpdateEffects;
    P := P.Parent;
  end;
end;

procedure TvxVisualObject.ApplyEffect;
var
  i, State, State2: integer;
  M: TvxMatrix;
  R: TvxRect;
  Effect: TvxEffect;
  EffectRect: TvxRect;
begin
  if FChildren = nil then
    Exit;
  if FScene = nil then
    Exit;
  if FDisableEffect then
    Exit;
  if not FHasEffect then
    Exit;

  State := Canvas.SaveCanvas;
  if not FUpdateEffects then
  begin
    if FEffectBitmap <> nil then
    begin
      Canvas.SetMatrix(AbsoluteMatrix);
      for i := 0 to FChildren.Count - 1 do
        if (TvxObject(FChildren[i]) is TvxEffect) and (TvxEffect(FChildren[i]).Enabled) then
        begin
          Effect := TvxEffect(FChildren[i]);
          EffectRect := Effect.GetRect(vgRect(0, 0, Width, Height));
          Canvas.DrawBitmap(FEffectBitmap, vgRect(0, 0, FEffectBitmap.Width, FEffectBitmap.Height), EffectRect, AbsoluteOpacity, RotateAngle = 0);
        end;
    end;
  end
  else
  begin
    for i := 0 to FChildren.Count - 1 do
      if (TvxObject(FChildren[i]) is TvxEffect) and (TvxEffect(FChildren[i]).Enabled) then
      begin
        Effect := TvxEffect(FChildren[i]);
        EffectRect := Effect.GetRect(vgRect(0, 0, Width, Height));
        with GetAbsoluteScale do
          vgMultiplyRect(EffectRect, X, Y);
        if FEffectBitmap = nil then
        begin
          { create }
          FEffectBitmap := TvxBitmap.Create(trunc(vgRectWidth(EffectRect)), trunc(vgRectHeight(EffectRect)));
        end
        else
          if (FEffectBitmap.Width <> trunc(vgRectWidth(EffectRect))) or
          (FEffectBitmap.Height <> trunc(vgRectHeight(EffectRect))) then
        begin
          { resize }
          FEffectBitmap.SetSize(trunc(vgRectWidth(EffectRect)), trunc(vgRectHeight(EffectRect)));
        end;
        { Paint Self }
        State2 := FEffectBitmap.Canvas.SaveCanvas;
        M := IdentityMatrix;
        FEffectBitmap.Canvas.BeginScene;
        FEffectBitmap.Canvas.Clear(0);
        FEffectBitmap.Canvas.SetMatrix(M);
        R := vgRect(Effect.GetOffset.X, Effect.GetOffset.Y, (Effect.GetOffset.X + Width), (Effect.GetOffset.Y + Height));
        with GetAbsoluteScale do
          vgMultiplyRect(R, X, Y);

        PaintTo(FEffectBitmap.Canvas, R);

        FEffectBitmap.Canvas.EndScene;
        FEffectBitmap.Canvas.RestoreCanvas(State2);
        { apply effects }
        with GetAbsoluteScale do
        begin
          Effect.ProcessEffect(FEffectBitmap.Canvas, FEffectBitmap, X);
          { draw effectBitmap }
          vgMultiplyRect(EffectRect, 1 / X, 1 / Y);
        end;
        Canvas.SetMatrix(AbsoluteMatrix);
        Canvas.DrawBitmap(FEffectBitmap, vgRect(0, 0, FEffectBitmap.Width, FEffectBitmap.Height), EffectRect, AbsoluteOpacity, RotateAngle = 0);
      end;
    FUpdateEffects := false;
  end;
  Canvas.RestoreCanvas(State);
end;

procedure TvxVisualObject.PaintChildren;
var
  i, j: integer;
  R: TvxRect;
  State, State2, State3: cardinal;
  ClipParentObject: TvxVisualObject;
  AllowPaint: boolean;
begin
  if FScene = nil then
    Exit;
  if FChildren <> nil then
  begin
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).IsVisual and
        ((TvxVisualObject(FChildren[i]).Visible) or
        (not TvxVisualObject(FChildren[i]).Visible and (Assigned(FScene) and (FScene.GetDesignTime)) and not TvxVisualObject(FChildren[i]).Locked)) then
        with TvxVisualObject(FChildren[i]) do
        begin
          if (((Scene <> nil) and (Scene.GetDesignTime))) and FDesignHide then
            Continue;
          if (vgRectWidth(UpdateRect) = 0) or (vgRectHeight(UpdateRect) = 0) then
            Continue;

          FScene := Self.FScene;
          if Self.ClipChildren and not vgIntersectRect(Self.UpdateRect, UpdateRect) then
            Continue;

          AllowPaint := false;
          if (Assigned(FScene) and (FScene.GetDesignTime)) or FInPaintTo then
            AllowPaint := true;
          if not AllowPaint then
          begin
            R := vgUnionRect(GetChildrenRect, UpdateRect);
            for j := 0 to FScene.GetUpdateRectsCount - 1 do
              if vgIntersectRect(FScene.GetUpdateRect(j), R) then
              begin
                AllowPaint := true;
                Break;
              end;
          end;

          if AllowPaint then
          begin
            if Self.FClipChildren and CanClipped then
            begin
              State := Canvas.SaveCanvas;
              Canvas.SetMatrix(Self.AbsoluteMatrix);
              Canvas.IntersectClipRect(Self.ClipRect);
            end
            else
              State := InvalideCanvasState;
            Canvas.SetMatrix(AbsoluteMatrix);
            BeforePaint;
            if FHasEffect and not HasAfterPaintEffect then
              ApplyEffect;
            Canvas.SetMatrix(AbsoluteMatrix);
            if not HasDisablePaintEffect then
            begin
              ClipParentObject := HasClipParent;
              if ClipParentObject <> nil then
              begin
                State3 := Canvas.SaveCanvas;

                Canvas.SetMatrix(ClipParentObject.AbsoluteMatrix);
                Canvas.ExcludeClipRect(ClipParentObject.LocalRect);
                Canvas.SetMatrix(AbsoluteMatrix);

                if ClipChildren then
                begin
                  // Clip self
                  State2 := Canvas.SaveCanvas;
                  Canvas.SetMatrix(AbsoluteMatrix);
                  Canvas.IntersectClipRect(ClipRect);
                  if Assigned(FOnBeforePaint) then
                  begin
                    FOnBeforePaint(TvxVisualObject(Self.FChildren[i]), Canvas, LocalRect);
                    Canvas.SetMatrix(AbsoluteMatrix);
                  end;
                  Paint;
                  Canvas.RestoreCanvas(State2);
                end
                else
                begin
                  if Assigned(FOnBeforePaint) then
                  begin
                    FOnBeforePaint(TvxVisualObject(Self.FChildren[i]), Canvas, LocalRect);
                    Canvas.SetMatrix(AbsoluteMatrix);
                  end;
                  Paint;
                end;
                Canvas.RestoreCanvas(State3);
                PaintChildren;
                if Assigned(FOnPaint) then
                begin
                  Canvas.SetMatrix(AbsoluteMatrix);
                  FOnPaint(TvxVisualObject(Self.FChildren[i]), Canvas, LocalRect);
                end;
              end
              else
              begin
                if ClipChildren then
                begin
                  // Clip self
                  State2 := Canvas.SaveCanvas;
                  Canvas.SetMatrix(AbsoluteMatrix);
                  Canvas.IntersectClipRect(ClipRect);
                  if Assigned(FOnBeforePaint) then
                  begin
                    FOnBeforePaint(TvxVisualObject(Self.FChildren[i]), Canvas, LocalRect);
                    Canvas.SetMatrix(AbsoluteMatrix);
                  end;
                  Paint;
                  Canvas.RestoreCanvas(State2);
                end
                else
                begin
                  if Assigned(FOnBeforePaint) then
                  begin
                    FOnBeforePaint(TvxVisualObject(Self.FChildren[i]), Canvas, LocalRect);
                    Canvas.SetMatrix(AbsoluteMatrix);
                  end;
                  Paint;
                end;
                PaintChildren;
                if Assigned(FOnPaint) then
                begin
                  Canvas.SetMatrix(AbsoluteMatrix);
                  FOnPaint(TvxVisualObject(Self.FChildren[i]), Canvas, LocalRect);
                end;
              end;
            end;
            AfterPaint;
            // design selection
            if (vgDesigner <> nil) and (Assigned(Self.Scene)) and (Self.GetOwner <> nil) and
              (Self.FChildren[i] <> Scene.GetSelected) and (vgDesigner.IsSelected(Self.Scene.GetOwner, TvxVisualObject(Self.FChildren[i]))) then
            begin
              Canvas.SetMatrix(AbsoluteMatrix);
              Canvas.Stroke.Style := vgBrushSolid;
              Canvas.Stroke.SolidColor := $B200CC5A;
              Canvas.StrokeCap := vgCapFlat;
              Canvas.StrokeJoin := vgJoinMiter;
              Canvas.StrokeDash := vgDashDash;
              Canvas.StrokeThickness := 1;
              R := vgRect(0, 0, Width, Height);
              vgInflateRect(R, -1, -1);
              Canvas.DrawRect(R, 1, 1, AllCorners, 1);
              Canvas.StrokeDash := vgDashSolid;
            end;
            // drag highlight
            if IsDragOver and not DragDisableHighlight then
            begin
              Canvas.SetMatrix(AbsoluteMatrix);
              Canvas.Stroke.Style := vgBrushSolid;
              Canvas.Stroke.SolidColor := $B2005ACC;
              Canvas.StrokeCap := vgCapFlat;
              Canvas.StrokeJoin := vgJoinMiter;
              Canvas.StrokeDash := vgDashSolid;
              Canvas.StrokeThickness := 3;
              R := vgRect(0, 0, Width, Height);
              vgInflateRect(R, -1, -1);
              Canvas.DrawRect(R, 1, 1, AllCorners, 1);
              Canvas.StrokeDash := vgDashSolid;
            end;
            if State <> InvalideCanvasState then
            begin
              Canvas.RestoreCanvas(State);
            end;
          end;
          if HasAfterPaintEffect then
          begin
            Canvas.SetMatrix(AbsoluteMatrix);
            ApplyEffect;
          end;
          {$IFDEF BOUNDS}
          State3 := Canvas.SaveCanvas;
          Canvas.ResetClipRect;
          Canvas.SetMatrix(IdentityMatrix);
          Canvas.Stroke.Style := vgBrushSolid;
          Canvas.Stroke.Color := '#FF00FF00';
          Canvas.StrokeThickness := 1;
          R := AbsoluteRect;
          Canvas.DrawRect(R, 0, 0, Allcorners, 0.5);
          Canvas.RestoreCanvas(State3);
          {$ENDIF}
        end;
  end;
  {$IFDEF DRAWFOCUSED}
  if Canfocused and IsFocused then
  begin
    State3 := Canvas.SaveCanvas;
    Canvas.ResetClipRect;
    Canvas.SetMatrix(AbsoluteMatrix);
    R := localRect;
    Canvas.Stroke.Style := vgBrushsolid;
    Canvas.Stroke.Color := vcRed;
    Canvas.StrokeThickness := 1;
    Canvas.DrawRect(R, 1, 1, Allcorners, AbsoluteOpacity);
    Canvas.RestoreCanvas(State3);
  end;
  {$ENDIF}
end;

function TvxVisualObject.CheckParentVisible: boolean;
var
  P: TvxObject;
begin
  P := Self;
  Result := false;
  while P <> nil do
  begin
    if P.IsVisual and not TvxVisualObject(P).Visible then
      Exit;
    P := P.Parent;
  end;
  Result := true;
end;

procedure TvxVisualObject.InvalidateRect(ARect: TvxRect);
begin
  if not Visible and (FScene <> nil) and (not FScene.GetDesignTime) then
    Exit;
  if FScene = nil then
    Exit;
  if (((Scene <> nil) and (Scene.GetDesignTime))) and FDesignHide then
    Exit;
  ;
  if FScene.GetDisableUpdate then
    Exit;
  if not (((Scene <> nil) and (Scene.GetDesignTime))) and not CheckParentVisible then
    Exit;
  ;
  ARect.TopLeft := LocalToAbsolute(ARect.TopLeft);
  ARect.BottomRight := LocalToAbsolute(ARect.BottomRight);
  FScene.AddUpdateRect(ARect);
end;

procedure TvxVisualObject.Repaint;
begin
  if not Visible and (FScene <> nil) and (not FScene.GetDesignTime) then
    Exit;
  if FScene = nil then
    Exit;
  if (((Scene <> nil) and (Scene.GetDesignTime))) and FDesignHide then
    Exit;
  ;
  if FScene.GetDisableUpdate then
    Exit;
  if not (((Scene <> nil) and (Scene.GetDesignTime))) and not CheckParentVisible then
    Exit;
  ;
  if FUpdating > 0 then
    Exit;
  if HasDisablePaintEffect then
    FUpdateEffects := true;
  FScene.AddUpdateRect(UpdateRect);
end;

procedure TvxVisualObject.Lock;
var
  i: integer;
begin
  Locked := true;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).isVisual then
        TvxVisualObject(FChildren[i]).Lock;
end;

{ bounds }

function TvxVisualObject.GetLocalRect: TvxRect;
begin
  Result := vgRect(0, 0, FWidth, FHeight);
end;

function TvxVisualObject.GetAbsoluteRect: TvxRect;
begin
  Result := vgNormalizeRect([LocalToAbsolute(vgPoint(0, 0)), LocalToAbsolute(vgPoint(Width, 0)),
    LocalToAbsolute(vgPoint(Width, Height)), LocalToAbsolute(vgPoint(0, Height))]);
end;

function TvxVisualObject.GetClipRect: TvxRect;
begin
  Result := vgRect(0, 0, Width, Height);
end;

function TvxVisualObject.GetBoundsRect: TvxRect;
begin
  Result := vgRect(0, 0, Width, Height);
end;

function TvxVisualObject.GetParentedRect: TvxRect;
begin
  Result := vgRect(0, 0, Width, Height);
  vgOffsetRect(Result, Position.X, Position.Y);
end;

procedure TvxVisualObject.SetBoundsRect(const Value: TvxRect);
var
  P: TvxPoint;
begin
  Repaint;
  FWidth := Value.Right - Value.Left;
  FHeight := Value.Bottom - Value.Top;
  P := LocalToAbsolute(vgPoint(Value.Left + FRotateCenter.X * FWidth, Value.Top + FRotateCenter.Y * FHeight));
  if (Parent <> nil) and (Parent.isVisual) then
    P := TvxVisualObject(Parent).AbsoluteToLocal(P);
  FPosition.FX := P.X - FScale.X * FRotateCenter.X * FWidth;
  FPosition.FY := P.Y - FScale.Y * FRotateCenter.Y * FHeight;
  if (FWidth < 0) then
  begin
    FWidth := Abs(FWidth);
    FScale.X := -FScale.X;
  end;
  if (FHeight < 0) then
  begin
    FHeight := Abs(FHeight);
    FScale.Y := -FScale.Y;
  end;
  MatrixChanged(Self);
  Realign;
end;

{ }

procedure TvxVisualObject.PaddingChanged(Sender: TObject);
begin
  if (FParent <> nil) and (FParent.isVisual) then
    TvxVisualObject(FParent).Realign;
end;

procedure TvxVisualObject.MarginsChanged(Sender: TObject);
begin
  Realign;
end;

procedure TvxVisualObject.DesignInsert;
begin

end;

procedure TvxVisualObject.DesignSelect;
begin

end;

procedure TvxVisualObject.DesignClick;
begin

end;

type

  TvxAlignInfo = record
    AlignList: TList;
    ControlIndex: Integer;
    Align: TvxAlign;
    Scratch: Integer;
  end;

procedure TvxVisualObject.BeginUpdate;
var
  i: integer;
begin
  FUpdating := FUpdating + 1;
  for i := 0 to ChildrenCount - 1 do
    if TvxObject(FChildren[i]).IsVisual then
      TvxVisualObject(FChildren[i]).BeginUpdate;
end;

procedure TvxVisualObject.EndUpdate;
var
  i: integer;
begin
  FUpdating := FUpdating - 1;
  for i := 0 to ChildrenCount - 1 do
    if TvxObject(FChildren[i]).IsVisual then
      TvxVisualObject(FChildren[i]).EndUpdate;
  if FUpdating = 0 then
    Realign;
end;

procedure TvxVisualObject.RecalcNeedAlign;
var
  i: integer;
begin
  FNeedAlign := false;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
    begin
      if not (TvxObject(FChildren[i]).IsVisual) then
        Continue;
      if TvxVisualObject(FChildren[i]).Align <> vaNone then
      begin
        FNeedAlign := true;
        Break;
      end;
    end;
end;

procedure TvxVisualObject.Realign;
var
  i: integer;
  R: TvxRect;
  AlignList: TList;

  function InsertBefore(C1, C2: TvxVisualObject; AAlign: TvxAlign): Boolean;
  begin
    Result := False;
    case AAlign of
      vaTop, vaMostTop: Result := C1.Position.Y < C2.Position.Y;
      vaBottom, vaMostBottom: Result := (C1.Position.Y + C1.Height) >= (C2.Position.Y + C2.Height);
      vaLeft, vaMostLeft: Result := C1.Position.X < C2.Position.X;
      vaRight, vaMostRight: Result := (C1.Position.X + C1.Width) >= (C2.Position.X + C2.Width);
    end;
  end;

  procedure DoPosition(Control: TvxVisualObject; AAlign: TvxAlign; AlignInfo: TvxAlignInfo);
  var
    NewLeft, NewTop, NewWidth, NewHeight: single;
    cR, mR: TvxRect;
    fitScale: single;
  begin
    with R do
    begin
      NewWidth := Right - Left;
      if (NewWidth < 0) or (AAlign in [vaLeft, vaRight, vaVertical, vaMostLeft, vaMostRight, vaTopLeft, vaTopRight, vaBottomLeft, vaBottomRight]) then
        NewWidth := Control.Width + Control.Padding.Left + Control.Padding.Right;
      NewHeight := Bottom - Top;
      if (NewHeight < 0) or (AAlign in [vaTop, vaBottom, vaMostTop, vaMostBottom, vaHorizontal, vaTopLeft, vaTopRight, vaBottomLeft, vaBottomRight]) then
        NewHeight := Control.Height + Control.Padding.Top + Control.Padding.Bottom;
      NewLeft := Left;
      NewTop := Top;
      if (AAlign in [vaVertical]) then
        NewLeft := Control.Position.X + Control.Padding.Left;
      if (AAlign in [vaHorizontal]) then
        NewTop := Control.Position.Y + Control.Padding.Top;
      case AAlign of
        vaTop, vaMostTop:
          Top := Top + NewHeight;
        vaBottom, vaMostBottom:
          begin
            Bottom := Bottom - NewHeight;
            NewTop := Bottom;
          end;
        vaLeft, vaMostLeft:
          Left := Left + NewWidth;
        vaRight, vaMostRight:
          begin
            Right := Right - NewWidth;
            NewLeft := Right;
          end;
        vaContents:
          begin
            NewLeft := 0;
            NewTop := 0;
            NewWidth := Width;
            NewHeight := Height;
            Control.FPosition.FX := NewLeft + Control.Padding.Left;
            Control.FPosition.FY := NewTop + Control.Padding.Top;
            Control.FWidth := NewWidth - Control.Padding.Left - Control.Padding.Right;
            Control.FHeight := NewHeight - Control.Padding.Top - Control.Padding.Bottom;
            Control.MatrixChanged(Self);
            Control.Realign;
            Exit;
          end;
        vaFit, vaFitLeft, vaFitRight:
          begin
            mR := vgRect(Margins.Left, Margins.Top, Width - Margins.Right, Height - Margins.Bottom);
            cR := vgRect(Control.FPosition.FX - Control.Padding.Left, Control.FPosition.FY - Control.Padding.Top,
              Control.FPosition.FX + Control.FWidth + Control.Padding.Right,
              Control.FPosition.FY + Control.FHeight + Control.Padding.Bottom);
            fitScale := vgFitRect(cR, mR);
            if fitScale < 1 then
            begin
              cR.Left := cR.Left / fitScale;
              cR.Right := cR.Right / fitScale;
              cR.Top := cR.Top / fitScale;
              cR.Bottom := cR.Bottom / fitScale;
              vgRectCenter(cR, mR);
              if AAlign = vaFitLeft then
                vgOffsetRect(cR, mR.Left - cR.Left, 0);
              if AAlign = vaFitRight then
                vgOffsetRect(cR, mR.Right - cR.Right, 0);
              NewLeft := cR.Left;
              NewTop := cR.Top;
              NewWidth := cR.Right - cR.Left;
              NewHeight := cR.Bottom - cR.Top;
            end
            else
            begin
              if AAlign = vaFitLeft then
                vgOffsetRect(cR, mR.Left - cR.Left, 0);
              if AAlign = vaFitRight then
                vgOffsetRect(cR, mR.Right - cR.Right, 0);
              NewLeft := cR.Left;
              NewTop := cR.Top;
              NewWidth := cR.Right - cR.Left;
              NewHeight := cR.Bottom - cR.Top;
            end;
            Control.FPosition.FX := NewLeft + Control.Padding.Left;
            Control.FPosition.FY := NewTop + Control.Padding.Top;
            Control.FWidth := NewWidth - Control.Padding.Left - Control.Padding.Right;
            Control.FHeight := NewHeight - Control.Padding.Top - Control.Padding.Bottom;
            Control.MatrixChanged(Self);
            Control.Realign;
            Exit;
          end;
        vaCenter:
          begin
            NewLeft := Left + Trunc((NewWidth - (Control.Width + Control.Padding.Left + Control.Padding.Right)) / 2);
            NewWidth := (Control.Width + Control.Padding.Left + Control.Padding.Right);
            NewTop := Top + Trunc((NewHeight - (Control.Height + Control.Padding.Top + Control.Padding.Bottom)) / 2);
            NewHeight := (Control.Height + Control.Padding.Top + Control.Padding.Bottom);
          end;
        vaHorzCenter:
          begin
            NewLeft := Left + Trunc((NewWidth - (Control.Width + Control.Padding.Left + Control.Padding.Right)) / 2);
            NewWidth := (Control.Width + Control.Padding.Left + Control.Padding.Right);
          end;
        vaVertCenter:
          begin
            NewTop := Top + Trunc((NewHeight - (Control.Height + Control.Padding.Top + Control.Padding.Bottom)) / 2);
            NewHeight := (Control.Height + Control.Padding.Top + Control.Padding.Bottom);
          end;
        vaTopRight:
          begin
            Control.Position.X := Control.Position.X + (FWidth - FLastWidth);
            Exit;
          end;
        vaBottomLeft:
          begin
            Control.Position.Y := Control.FPosition.Y + (FHeight - FLastHeight);
            Exit;
          end;
        vaBottomRight:
          begin
            Control.Position.SetPoint(vgPoint(Control.Position.X + (FWidth - FLastWidth), Control.FPosition.Y + (FHeight - FLastHeight)));
            Exit;
          end;
      end;
    end;

    if (AALign = vaScale) then
    begin
      if (FLastWidth > 0) and (FLastHeight > 0) and (FWidth > 0) and (FHeight > 0) then
      begin
        Control.FPosition.FX := Control.FPosition.X * (FWidth / FLastWidth);
        Control.FPosition.FY := Control.FPosition.Y * (FHeight / FLastHeight);
        Control.FWidth := Control.FWidth * (FWidth / FLastWidth);
        Control.FHeight := Control.FHeight * (FHeight / FLastHeight);
        Control.MatrixChanged(Self);
        Control.Realign;
      end;
      Exit;
    end
    else
    begin
      Control.FPosition.FX := NewLeft + Control.Padding.Left;
      Control.FPosition.FY := NewTop + Control.Padding.Top;
      if (Control.FWidth <> NewWidth - Control.Padding.Left - Control.Padding.Right) or
        (Control.FHeight <> NewHeight - Control.Padding.Top - Control.Padding.Bottom) then
      begin
        Control.FWidth := NewWidth - Control.Padding.Left - Control.Padding.Right;
        Control.FHeight := NewHeight - Control.Padding.Top - Control.Padding.Bottom;
        Control.Realign;
      end;
      Control.MatrixChanged(Self);
    end;

    { Adjust client rect if control didn't resize as we expected }
    if (Control.Width + Control.Padding.Left + Control.Padding.Right <> NewWidth) or
      (Control.Height + Control.Padding.Top + Control.Padding.Bottom <> NewHeight) then
      with R do
        case AAlign of
          vaTop:
            Top := Top - (NewHeight - (Control.Height + Control.Padding.Left + Control.Padding.Right));
          vaBottom:
            Bottom := Bottom + (NewHeight - (Control.Height + Control.Padding.Top + Control.Padding.Bottom));
          vaLeft:
            Left := Left - (NewWidth - (Control.Width + Control.Padding.Left + Control.Padding.Right));
          vaRight:
            Right := Right + (NewWidth - (Control.Width + Control.Padding.Top + Control.Padding.Bottom));
          vaClient:
            begin
              Right := Right + NewWidth - (Control.Width + Control.Padding.Left + Control.Padding.Right);
              Bottom := Bottom + NewHeight - (Control.Height + Control.Padding.Top + Control.Padding.Bottom);
            end;
        end;
  end;

  procedure DoAlign(AAlign: TvxAlign);
  var
    I, J: Integer;
    Control: TvxVisualObject;
    AlignInfo: TvxAlignInfo;
  begin
    AlignList.Clear;
    for I := 0 to FChildren.Count - 1 do
    begin
      if not TvxObject(FChildren[i]).isVisual then
        Continue;
      Control := TvxVisualObject(FChildren[i]);
      if (Control.Align = AAlign) and (Control.Visible) then
      begin
        J := 0;
        while (J < AlignList.Count) and not InsertBefore(Control, TvxVisualObject(AlignList[J]), AAlign) do
          Inc(J);
        AlignList.Insert(J, Control);
      end;
    end;
    for I := 0 to AlignList.Count - 1 do
    begin
      AlignInfo.AlignList := AlignList;
      AlignInfo.ControlIndex := I;
      AlignInfo.Align := AAlign;
      DoPosition(TvxVisualObject(AlignList[I]), AAlign, AlignInfo);
    end;
  end;

begin
  if csDestroying in ComponentState then
    Exit;
  if ((FWidth > -2) and (FWidth < 2)) or ((FHeight > -2) and (FHeight < 2)) then
    Exit;
  if FDisableDefaultAlign then
    Exit;
  if FDisableAlign then
    Exit;
  if FUpdating > 0 then
    Exit;
  if csLoading in ComponentState then
  begin
    FLastWidth := FWidth;
    FLastHeight := FHeight;
    Exit;
  end;
  if ((FLastWidth <> FWidth) or (FLastHeight <> FHeight)) and FHasEffect then
  begin
    UpdateEffects;
  end;
  if not FNeedAlign then
    Exit;
  if FChildren = nil then
    Exit;
  if FChildren.Count = 0 then
    Exit;

  FDisableAlign := true;
  try
    R := vgRect(0, 0, FWidth, FHeight);
    R := FMargins.MarginRect(R);
    AlignList := TList.Create;
    try
      DoAlign(vaMostTop);
      DoAlign(vaMostBottom);
      DoAlign(vaMostLeft);
      DoAlign(vaMostRight);
      DoAlign(vaTop);
      DoAlign(vaBottom);
      DoAlign(vaLeft);
      DoAlign(vaRight);
      DoAlign(vaClient);
      DoAlign(vaHorizontal);
      DoAlign(vaVertical);
      DoAlign(vaContents);
      DoAlign(vaCenter);
      DoAlign(vaHorzCenter);
      DoAlign(vaVertCenter);
      DoAlign(vaScale);
      DoAlign(vaFit);
      DoAlign(vaFitLeft);
      DoAlign(vaFitRight);
      // Move anchored controls
      // DoAlign(vaTopLeft); nothing to move
      DoAlign(vaTopRight);
      DoAlign(vaBottomLeft);
      DoAlign(vaBottomRight);
    finally
      AlignList.Free;
    end;
    FLastWidth := FWidth;
    FLastHeight := FHeight;
    Repaint;
  finally
    FDisableAlign := false;
  end;
end;

{ events }

procedure TvxVisualObject.KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
var
  VP: TvxPoint;
begin
  if (Key = VK_APPS) then
  begin
    VP := LocalToAbsolute(vgPoint(Width / 2, Height / 2));
    VP := Scene.LocalToScreen(VP);
    ContextMenu(VP);
  end
  else
    if Assigned(FOnKeyDown) then
    FOnKeyDown(Self, Key, KeyChar, Shift);
end;

procedure TvxVisualObject.KeyUp(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  if Assigned(FOnKeyUp) then
    FOnKeyUp(Self, Key, KeyChar, Shift);
end;

procedure TvxVisualObject.DialogKey(var Key: Word; Shift: TShiftState);
var
  i: integer;
begin
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).isVisual and (TvxVisualObject(FChildren[i]).Visible) and TvxVisualObject(FChildren[i]).Enabled then
      begin
        TvxVisualObject(FChildren[i]).DialogKey(Key, Shift);
        if Key = 0 then
          Break;
      end;
end;

procedure TvxVisualObject.Capture;
begin
  if (FScene <> nil) then
  begin
    FScene.SetCaptured(Self);
  end;
end;

procedure TvxVisualObject.ReleaseCapture;
begin
  if (FScene <> nil) and (FScene.GetCaptured = Self) then
  begin
    FScene.SetCaptured(nil);
  end;
end;

procedure TvxVisualObject.MouseEnter;
begin
  FIsMouseOver := true;
  StartTriggerAnimation(Self, 'IsMouseOver');
  ApplyTriggerEffect(Self, 'IsMouseOver');
  if Assigned(FOnMouseEnter) then
    FOnMouseEnter(Self);
end;

procedure TvxVisualObject.MouseLeave;
begin
  FIsMouseOver := false;
  StartTriggerAnimation(Self, 'IsMouseOver');
  ApplyTriggerEffect(Self, 'IsMouseOver');
  if Assigned(FOnMouseLeave) then
    FOnMouseLeave(Self);
end;

function TvxVisualObject.EnterFocusChildren(AObject: TvxVisualObject): boolean;
begin
  Result := false;
end;

procedure TvxVisualObject.EnterFocus;
var
  P: TvxObject;
begin
  if not CanFocused then
    Exit;

  P := Parent;
  while P <> nil do
  begin
    if P.IsVisual then
      if P.Visual.EnterFocusChildren(Self) then
        Break;
    P := P.Parent;
  end;
  FIsFocused := true;
  FRecalcUpdateRect := true;
  Repaint;
  if Assigned(FOnEnterFocus) then
    FOnEnterFocus(Self);
  if DisableFocusEffect then
    Exit;
  if GlobalDisableFocusEffect then
    Exit;
  StartTriggerAnimation(Self, 'IsFocused');
  ApplyTriggerEffect(Self, 'IsFocused');
end;

procedure TvxVisualObject.SetNewScene(AScene: IvgScene);
begin
  if (AScene = nil) and (FIsFocused) then
    KillFocus;
  inherited;
end;

procedure TvxVisualObject.KillFocus;
begin
  if not CanFocused then
    Exit;

  FRecalcUpdateRect := true;
  Repaint;
  FIsFocused := false;
  if Assigned(FOnKillFocus) then
    FOnKillFocus(Self);
  if DisableFocusEffect then
    Exit;
  if GlobalDisableFocusEffect then
    Exit;
  StartTriggerAnimation(Self, 'IsFocused');
  ApplyTriggerEffect(Self, 'IsFocused');
end;

procedure TvxVisualObject.SetFocus;
var
  C: boolean;
begin
  if not CanFocused then
    Exit;
  if Assigned(FOnCanFocused) then
  begin
    C := true;
    FOnCanFocused(Self, C);
    if not C then
      Exit;
  end;
  FScene.SetFocused(Self);
end;

procedure TvxVisualObject.ContextMenu(const ScreenPosition: TvxPoint);
begin
  {$IFNDEF NOVCL}
  if FPopupMenu <> nil then
  begin
    FPopupMenu.PopupComponent := Self;
    FPopupMenu.Popup(round(ScreenPosition.X), round(ScreenPosition.Y));
    Exit;
  end;
  {$ENDIF}
  if FPopup <> nil then
  begin
    FPopup.StaysOpen := false;
    FPopup.PopupModal;
  end;
end;

procedure TvxVisualObject.Click;
begin
  if Assigned(FOnClick) then
    FOnClick(Self);
end;

procedure TvxVisualObject.DblClick;
begin
  if Assigned(FOnDblClick) then
    FOnDblClick(Self);
end;

function TvxVisualObject.MakeScreenshot: TvxBitmap;
begin
  Result := TvxBitmap.Create(round(Width), round(Height));
  Result.Clear(0);

  Result.Canvas.BeginScene;
  PaintTo(Result.Canvas, vgRect(0, 0, Result.Width, Result.Height));
  Result.Canvas.EndScene;
end;

procedure TvxVisualObject.BeginAutoDrag;
var
  B, S: TvxBitmap;
  R: TvxRect;
begin
  S := MakeScreenshot;
  if (S.Width > 512) or (S.Height > 512) then
  begin
    R := vgRect(0, 0, S.Width, S.Height);
    vgFitRect(R, vgRect(0, 0, 512, 512));
    B := TvxBitmap.Create(round(vgRectWidth(R)), round(vgRectHeight(R)));
    B.Canvas.BeginScene;
    B.Canvas.DrawBitmap(S, vgRect(0, 0, S.Width, S.Height), vgRect(0, 0, B.Width, B.Height), 0.7, true);
    B.Canvas.EndScene;
  end
  else
  begin
    B := TvxBitmap.Create(S.Width, S.Height);
    B.Canvas.BeginScene;
    B.Canvas.DrawBitmap(S, vgRect(0, 0, B.width, B.Height), vgRect(0, 0, B.width, B.Height), 0.7, true);
    B.Canvas.EndScene;
  end;
  FScene.BeginVCLDrag(Self, B);
  B.Free;
  S.Free;
end;

procedure TvxVisualObject.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  VP: TvxPoint;
begin
  if (ssDouble in Shift) and (((FScene <> nil) and (FScene.GetDesignTime))) then
    FScene.SetDesignRoot(Self);
  if (Assigned(FScene) and not (FScene.GetDesignTime)) and CanFocused and not FIsFocused and (FScene <> nil) and (FScene.GetFocused <> Self) then
    SetFocus;
  if Assigned(FOnMouseDown) then
    FOnMouseDown(Self, Button, Shift, X, Y);
  if (Button = mbRight) then
  begin
    VP := LocalToAbsolute(vgPoint(X, Y));
    VP := Scene.LocalToScreen(VP);
    ContextMenu(VP);
    Exit;
  end;
  if FAutoCapture then
    Capture;
  if (ssDouble in Shift) then
  begin
    DblClick;
    FDoubleClick := true;
  end
  else
    if Button = mbLeft then
  begin
    FPressed := true;
  end;
end;

procedure TvxVisualObject.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  if Assigned(FOnMouseMove) then
    FOnMouseMove(Self, Shift, X, Y, Dx, Dy);
end;

procedure TvxVisualObject.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  ReleaseCapture;
  if Assigned(FOnMouseUp) then
    FOnMouseUp(Self, Button, Shift, X, Y);
  if FPressed and not (FDoubleClick) and vgPtInRect(vgPoint(X, Y), LocalRect) then
  begin
    FPressed := false;
    Click;
  end;
  FPressed := false;
  FDoubleClick := false;
end;

procedure TvxVisualObject.MouseWheel(Shift: TShiftState; WheelDelta: integer; var Handled: boolean);
begin
  if Assigned(FOnMouseWheel) then
    if FScene <> nil then
      FOnMouseWheel(Self, Shift, WheelDelta, FScene.GetMousePos, Handled)
    else
      FOnMouseWheel(Self, Shift, WheelDelta, vgPoint(0, 0), Handled);
end;

procedure TvxVisualObject.DragEnter(const Data: TvxDragObject; const Point: TvxPoint);
begin
  FIsDragOver := true;
  Repaint;
  StartTriggerAnimation(Self, 'IsDragOver');
  ApplyTriggerEffect(Self, 'IsDragOver');
  if Assigned(OnDragEnter) then
    OnDragEnter(Self, Data, Point);
end;

procedure TvxVisualObject.DragLeave;
begin
  FIsDragOver := false;
  Repaint;
  StartTriggerAnimation(Self, 'IsDragOver');
  ApplyTriggerEffect(Self, 'IsDragOver');
  if Assigned(OnDragLeave) then
    OnDragLeave(Self);
end;

procedure TvxVisualObject.DragOver(const Data: TvxDragObject; const Point: TvxPoint; var Accept: Boolean);
begin
  if Assigned(OnDragOver) then
    OnDragOver(Self, Data, Point, Accept);
end;

procedure TvxVisualObject.DragDrop(const Data: TvxDragObject; const Point: TvxPoint);
begin
  FIsDragOver := false;
  Repaint;
  StartTriggerAnimation(Self, 'IsDragOver');
  ApplyTriggerEffect(Self, 'IsDragOver');
  if Assigned(OnDragDrop) then
    OnDragDrop(Self, Data, Point);
end;

procedure TvxVisualObject.DragEnd;
begin
  // Call mouse up - for effects - inside control
  if DragMode = vgDragAutomatic then
    MouseUp(mbLeft, [ssLeft], $FFFF, $FFFF);
  if Assigned(OnDragEnd) then
    OnDragEnd(Self);
end;

{ controls }

procedure TvxVisualObject.SetEnabled(const Value: boolean);
begin
  if FEnabled <> Value then
  begin
    FEnabled := Value;
    RecalcEnabled;
    RecalcOpacity;
    Repaint;
  end;
end;

function TvxVisualObject.GetAbsoluteEnabled: boolean;
begin
  if FRecalcEnabled then
  begin
    if (FParent <> nil) and (FParent.IsVisual) and (not FParent.Visual.AbsoluteEnabled) then
      FAbsoluteEnabled := false
    else
      FAbsoluteEnabled := FEnabled;

    Result := FAbsoluteEnabled;
    FRecalcEnabled := false;

    if not Result and Assigned(FScene) and CanFocused and IsFocused then
      FScene.SetFocused(nil);
  end
  else
  begin
    Result := FAbsoluteEnabled;
  end;
end;

procedure TvxVisualObject.RecalcEnabled;
var
  i: integer;
begin
  FRecalcEnabled := true;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).IsVisual then
        TvxVisualObject(FChildren[i]).RecalcEnabled;
end;

{ properties }

procedure TvxVisualObject.SetTempCanvas(const Value: TvxCanvas);
var
  i: integer;
begin
  FTempCanvas := Value;
  if (FChildren <> nil) and (FChildren.Count > 0) then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).IsVisual then
        TvxVisualObject(FChildren[i]).TempCanvas := Value;
end;

procedure TvxVisualObject.SetHitTest(const Value: boolean);
begin
  FHitTest := Value;
end;

procedure TvxVisualObject.SetClipChildren(const Value: boolean);
begin
  if FClipChildren <> Value then
  begin
    FClipChildren := Value;
    Repaint;
  end;
end;

procedure TvxVisualObject.SetAlign(const Value: TvxAlign);
begin
  if FAlign <> Value then
  begin
    FAlign := Value;
    if (FParent <> nil) and (FParent.IsVisual) then
    begin
      FParent.Visual.FNeedAlign := true;
      if not (csLoading in ComponentState) then
        FParent.Visual.Realign;
    end;
  end;
end;

procedure TvxVisualObject.SetVisible(const Value: boolean);
begin
  if FVisible <> Value then
  begin
    if FVisible then
    begin
      if FScene <> nil then
        FScene.AddUpdateRect(UpdateRect);
    end;
    FVisible := Value;
    if not (csLoading in ComponentState) then
    begin
      if (Parent <> nil) and (Parent.IsVisual) and (Align <> vaNone) then
        TvxVisualObject(Parent).Realign;
    end;
    if FVisible then
    begin
      RecalcUpdateRect;
      if FScene <> nil then
        FScene.AddUpdateRect(UpdateRect);
      StartTriggerAnimation(Self, 'IsVisible');
    end
    else
      if CanFocused and FIsFocused then
      FScene.SetFocused(nil);
  end;
end;

procedure TvxVisualObject.SetPosition(const Value: TvxPosition);
begin
  FPosition.Assign(Value);
end;

procedure TvxVisualObject.SetRotateAngle(const Value: single);
begin
  if FRotateAngle <> Value then
  begin
    FRotateAngle := vgNormalizeAngle(Value);
    MatrixChanged(Self);
  end;
end;

procedure TvxVisualObject.SetBounds(X, Y, AWidth, AHeight: single);
var
  SizeChanged: boolean;
begin
  Repaint;
  SizeChanged := false;
  if (FHeight <> AHeight) then
  begin
    FHeight := AHeight;
    if (FHeight < 0) and (((FScene <> nil) and (FScene.GetDesignTime))) then
    begin
      FHeight := Abs(FHeight);
      FScale.Y := -FScale.Y;
    end;
    SizeChanged := true;
  end;
  if (FWidth <> AWidth) then
  begin
    FWidth := AWidth;
    if (FWidth < 0) and (((FScene <> nil) and (FScene.GetDesignTime))) then
    begin
      FWidth := Abs(FWidth);
      FScale.X := -FScale.X;
    end;
    SizeChanged := true;
  end;

  if (X <> FPosition.X) or (Y <> FPosition.Y) then
  begin
    FPosition.FX := X;
    FPosition.FY := Y;
    MatrixChanged(Self);
  end;

  if not (csLoading in ComponentState) and (SizeChanged) then
  begin
    if (Parent <> nil) and (Parent.IsVisual) and (Align <> vaNone) then
    begin
      TvxVisualObject(Parent).Realign;
    end;
    if (FChildren <> nil) then
      Realign;
  end;
  if not (csLoading in ComponentState) then
  begin
    RecalcUpdateRect;
    Repaint;
  end;
end;

procedure TvxVisualObject.SetSizeWithoutChange(AWidth, AHeight: single);
begin
  FWidth := AWidth;
  FLastWidth := AWidth;
  FHeight := AHeight;
  FLastHeight := AHeight;
end;

procedure TvxVisualObject.SetHeight(const Value: single);
begin
  if FHeight <> Value then
  begin
    Repaint;
    FHeight := Value;
    if (FHeight < 0) and (((FScene <> nil) and (FScene.GetDesignTime))) then
    begin
      FHeight := Abs(FHeight);
      FScale.Y := -FScale.Y;
    end;
    if not (csLoading in ComponentState) and (FScene <> nil) then
    begin
      UpdateEffects;
      RecalcUpdateRect;
      if (Parent <> nil) and (Parent.IsVisual) and ((Align <> vaNone) or (Parent is TvxScrollContent)) then
      begin
        TvxVisualObject(Parent).Realign;
      end;
      if (FChildren <> nil) then
        Realign;
    end;
  end;
end;

procedure TvxVisualObject.SetWidth(const Value: single);
begin
  if FWidth <> Value then
  begin
    Repaint;
    FWidth := Value;
    if (FWidth < 0) and (((FScene <> nil) and (FScene.GetDesignTime))) then
    begin
      FWidth := Abs(FWidth);
      FScale.X := -FScale.X;
    end;
    if not (csLoading in ComponentState) and (FScene <> nil) then
    begin
      UpdateEffects;
      RecalcUpdateRect;
      if (Parent <> nil) and (Parent.IsVisual) and ((Align <> vaNone) or (Parent is TvxScrollContent)) then
      begin
        TvxVisualObject(Parent).Realign;
      end;
      if (FChildren <> nil) then
        Realign;
    end;
  end;
end;

function TvxVisualObject.isOpacityStored: Boolean;
begin
  Result := FOpacity <> 1;
end;

procedure TvxVisualObject.SetOpacity(const Value: single);
begin
  if FOpacity <> Value then
  begin
    FOpacity := Value;
    if FOpacity < 0 then
      FOpacity := 0;
    if FOpacity > 1 then
      FOpacity := 1;
    RecalcOpacity;
    Repaint;
  end;
end;

procedure TvxVisualObject.UpdateDesignHide(const Value: boolean);
var
  i: integer;
begin
  FDesignHide := Value;
  for i := 0 to ChildrenCount - 1 do
  begin
    if Children[i].IsVisual then
      Children[i].Visual.UpdateDesignHide(Value);
  end;
end;

procedure TvxVisualObject.SetDesignHide(const Value: boolean);
begin
  if FDesignHide <> Value then
  begin
    FDesignHide := Value;
    if (FScene <> nil) and FScene.GetDesignTime and (Parent <> nil) then
    begin
      if FDesignHide and (Scene.GetSelected = Self) and (vgDesigner <> nil) then
        vgDesigner.SelectObject(Owner, Parent.Visual, []);
      Parent.Visual.Repaint;
    end;
  end;
end;

procedure TvxVisualObject.SetCursor(const Value: TCursor);
begin
  if FCursor <> Value then
  begin
    FCursor := Value;
  end;
end;

procedure TvxVisualObject.FixupTabList;
var
  I, J: Integer;
  List: TList;
  Control: TvxVisualObject;
begin
  if not Assigned(Scene) then
    Exit;
  if FTabList = nil then
    Exit;
  List := TList.Create;
  try
    List.Count := FTabList.Count;
    for i := 0 to FTabList.Count - 1 do
    begin
      Control := TvxVisualObject(FTabList[i]);
      j := Control.FTabOrder;
      if (j >= 0) and (j < FTabList.Count) then
        List[j] := Control;
    end;
    for I := 0 to FTabList.Count - 1 do
    begin
      Control := TvxVisualObject(List[I]);
      if Control <> nil then
        Control.UpdateTabOrder(I);
    end;
  finally
    List.Free;
  end;
end;

procedure TvxVisualObject.GetTabOrderList(List: TList; Children: boolean);
var
  i: integer;
  Control: TvxVisualObject;
begin
  if FTabList <> nil then
    for I := 0 to FTabList.Count - 1 do
    begin
      Control := TvxVisualObject(FTabList[I]);
      List.Add(Control);
      if Children then
        Control.GetTabOrderList(List, Children);
    end;
end;

function TvxVisualObject.GetTabOrder: TTabOrder;
begin
  if (FParent <> nil) and (FParent.IsVisual) and (FParent.Visual.FTabList <> nil) then
    Result := TvxVisualObject(FParent).FTabList.IndexOf(Self)
  else
    Result := -1;
end;

procedure TvxVisualObject.UpdateTabOrder(Value: TTabOrder);
var
  CurIndex, Count: Integer;
begin
  CurIndex := GetTabOrder;
  if CurIndex >= 0 then
  begin
    Count := TvxVisualObject(FParent).FTabList.Count;
    if Value < 0 then
      Value := 0;
    if Value >= Count then
      Value := Count - 1;
    if Value <> CurIndex then
    begin
      TvxVisualObject(FParent).FTabList.Delete(CurIndex);
      TvxVisualObject(FParent).FTabList.Insert(Value, Self);
    end;
  end;
end;

procedure TvxVisualObject.SetTabOrder(const Value: TTabOrder);
begin
  if csLoading in ComponentState then
    FTabOrder := Value
  else
    UpdateTabOrder(Value);
end;

{ TvxBrushObject ============================================================}

constructor TvxBrushObject.Create(AOwner: TComponent);
begin
  inherited;
  FBrush := TvxBrush.Create(vgBrushSolid, $FFFFFFFF);
end;

destructor TvxBrushObject.Destroy;
begin
  FreeAndNil(FBrush);
  inherited;
end;

procedure TvxBrushObject.SetName(const NewName: TComponentName);
begin
  inherited;
  if FResourceName = '' then
    FResourceName := Name;
end;

{ TvxPathObject ============================================================}

constructor TvxPathObject.Create(AOwner: TComponent);
begin
  inherited;
  FPath := TvxPathData.Create();
end;

destructor TvxPathObject.Destroy;
begin
  FreeAndNil(FPath);
  inherited;
end;

procedure TvxPathObject.SetName(const NewName: TComponentName);
begin
  inherited;
  if FResourceName = '' then
    FResourceName := Name;
end;

{ TvxBitmapObject ============================================================}

constructor TvxBitmapObject.Create(AOwner: TComponent);
begin
  inherited;
  FBitmap := TvxBitmap.Create(1, 1);
end;

destructor TvxBitmapObject.Destroy;
begin
  FreeAndNil(FBitmap);
  inherited;
end;

procedure TvxBitmapObject.SetName(const NewName: TComponentName);
begin
  inherited;
  if FResourceName = '' then
    FResourceName := Name;
end;

{ TvxControl ===================================================================}

constructor TvxControl.Create(AOwner: TComponent);
begin
  inherited;
  FHelpType := htContext;
  FNeedResource := true;
end;

destructor TvxControl.Destroy;
var
  i: integer;
begin
  {$IFNDEF NOVCL}
  if FActionLink <> nil then
  begin
    FActionLink.Free;
    FActionLink := nil;
  end;
  {$ENDIF}
  if FBindingObjects <> nil then
  begin
    for i := FBindingObjects.Count - 1 downto 0 do
      RemoveBindingObject(TvxControl(FBindingObjects[i]));
    FreeAndNil(FBindingObjects);
  end;
  inherited;
end;

procedure TvxControl.Loaded;
begin
  inherited;
  if Assigned(FScene) and (FScene.GetActiveControl = Self) then
    SetFocus;
end;

procedure TvxControl.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (FBindingSource = AComponent) then
    BindingSource := nil;
  if (Operation = opRemove) and (FBindingObjects <> nil) and (FBindingObjects.IndexOf(AComponent) >= 0) then
    FBindingObjects.Remove(AComponent);
  {$IFNDEF NOVCL}
  if (Operation = opRemove) and (AComponent = Action) then
    Action := nil;
  {$ENDIF}
end;

procedure TvxControl.SetData(const Value: Variant);
begin
end;

procedure TvxControl.AddBindingObject(AObject: TvxControl);
begin
  if FBindingObjects = nil then
    FBindingObjects := TList.Create;
  if FBindingObjects.IndexOf(AObject) < 0 then
  begin
    AObject.AddFreeNotify(Self);
    FBindingObjects.Add(AObject);

    ToBindingObjects;
  end;
end;

procedure TvxControl.RemoveBindingObject(AObject: TvxControl);
begin
  if FBindingObjects = nil then
    Exit;
  if FBindingObjects.IndexOf(AObject) >= 0 then
  begin
    AObject.RemoveFreeNotify(Self);
    FBindingObjects.Remove(AObject);
  end;
end;

procedure TvxControl.SetBindingSource(const Value: TvxControl);
begin
  if FBindingSource <> Value then
  begin
    if FBindingSource <> nil then
      FBindingSource.RemoveBindingObject(Self);
    FBindingSource := Value;
    if FBindingSource <> nil then
      FBindingSource.AddBindingObject(Self);
  end;
end;

procedure TvxControl.ToBindingObjects;
var
  i: integer;
begin
  if FBindingObjects = nil then
    Exit;
  for i := 0 to FBindingObjects.Count - 1 do
    TvxObject(FBindingObjects[i]).Data := Data;
end;

function TvxControl.FindResource(const AResource: string): TvxObject;
begin
  Result := nil;
  if FResourceLink <> nil then
    Result := FResourceLink.FindResource(AResource);
  if Result = nil then
    Result := inherited FindResource(AResource);
end;

function TvxControl.GetResourceObject: TvxVisualObject;
var
  Obj: TvxObject;
  ResourceObject: TvxVisualObject;
  S: TStream;
  StyleName: string;
begin
  ResourceObject := nil;
  if (FResource <> '') and (FResource = FResourceName) then
  begin
    Result := ResourceObject;
    Exit; // Stack Overflow
  end;
  if (FResource <> '') then
  begin
    { style }
    Obj := nil;
    if Assigned(FScene) and (FScene.GetStyle <> nil) and (FScene.GetStyle.FRoot <> nil) then
      Obj := TvxVisualObject(FScene.GetStyle.FRoot.FindResource(FResource));
    if Obj = nil then
      if DefaultStyles <> nil then
        Obj := TvxVisualObject(DefaultStyles.FindResource(FResource));
    if Obj = nil then
      Obj := dcm_vgcore.FindResource(FResource);
    if (Obj <> nil) and (Obj.isVisual) then
    begin
      ResourceObject := TvxVisualObject(Obj.Clone(Self));
      ResourceObject.ResourceName := '';
    end;
  end;
  if ResourceObject = nil then
  begin
    { default }
    if DefaultStyles = nil then
    begin
      { load default styles }
      {$IFDEF FPC}
      if System.FindResource(HInstance, PChar('defaultvxstyle'), RT_RCDATA) <> 0 then
        {$ELSE}
      if Windows.FindResource(HInstance, PChar('defaultvxstyle'), RT_RCDATA) <> 0 then
        {$ENDIF}
      begin
        S := TResourceStream.Create(HInstance, 'defaultvxstyle', RT_RCDATA);
        DefaultStyles := CreateObjectFromBinStream(nil, S);
        S.Free;
      end;
    end;
    if Assigned(FScene) and (FScene.GetStyle <> nil) and (FScene.GetStyle.FRoot <> nil) then
    begin
      if FResource <> '' then
      begin
        StyleName := FResource;
        ResourceObject := TvxVisualObject(FScene.GetStyle.FRoot.FindResource(StyleName));
        if ResourceObject <> nil then
          ResourceObject := TvxVisualObject(ResourceObject.Clone(Self));
      end;
      if ResourceObject = nil then
      begin
        StyleName := ClassName + 'style';
        Delete(StyleName, 1, 3);
        ResourceObject := TvxVisualObject(FScene.GetStyle.FRoot.FindResource(StyleName));
        if ResourceObject <> nil then
          ResourceObject := TvxVisualObject(ResourceObject.Clone(Self))
      end;
    end;
    if (ResourceObject = nil) and (DefaultStyles <> nil) then
    begin
      if FResource <> '' then
      begin
        StyleName := FResource;
        ResourceObject := TvxVisualObject(DefaultStyles.FindResource(StyleName));
        if ResourceObject <> nil then
          ResourceObject := TvxVisualObject(ResourceObject.Clone(Self));
      end;
      if ResourceObject = nil then
      begin
        StyleName := ClassName + 'style';
        Delete(StyleName, 1, 3);
        ResourceObject := TvxVisualObject(DefaultStyles.FindResource(StyleName));
        if ResourceObject <> nil then
          ResourceObject := TvxVisualObject(ResourceObject.Clone(Self))
        else
        begin
          // try parent Class
          StyleName := ClassParent.ClassName + 'style';
          Delete(StyleName, 1, 3);
          ResourceObject := TvxVisualObject(DefaultStyles.FindResource(StyleName));
          if ResourceObject <> nil then
            ResourceObject := TvxVisualObject(ResourceObject.Clone(Self));
        end;
      end;
    end;
  end;
  Result := ResourceObject;
end;

procedure CallLoaded(Obj: TvxObject);
var
  i: integer;
begin
  Obj.Loaded;
  for i := 0 to Obj.ChildrenCount - 1 do
    CallLoaded(Obj.Children[i]);
end;

procedure TvxControl.ApplyResource;
var
  ResourceObject: TvxVisualObject;
  SaveUpdate: boolean;
begin
  if FNeedResource then
  begin
    inherited;
    FNeedResource := false;
    ResourceObject := GetResourceObject;
    if ResourceObject <> nil then
    begin
      if csLoading in ResourceObject.ComponentState then
        CallLoaded(ResourceObject);
      if (FScene <> nil) and (csLoading in ComponentState) then
      begin
        SaveUpdate := FScene.GetDisableUpdate;
        FScene.SetDisableUpdate(true);
      end;
      if FResourceLink <> nil then
      begin
        FreeStyle;
        FResourceLink.Free;
        FResourceLink := nil;
      end;
      ResourceObject.FAlign := vaContents;
      ResourceObject.DesignHide := false;
      FResourceLink := ResourceObject;
      AddObject(ResourceObject);
      { bring to front }
      FChildren.Remove(ResourceObject);
      FChildren.Insert(0, ResourceObject);
      { }
      ResourceObject.Stored := false;
      ResourceObject.Lock;
      ApplyStyle;
      if (FScene <> nil) and (csLoading in ComponentState) then
      begin
        FScene.SetDisableUpdate(SaveUpdate);
      end;
      FUpdateEffects := true;
      if Assigned(FOnApplyResource) then
        FOnApplyResource(Self);
    end;
  end;
end;

procedure TvxControl.UpdateResource;
begin
  if csLoading in ComponentState then
    Exit;
  if csDestroying in ComponentState then
    Exit;
  inherited;
  FNeedResource := true;
  ApplyResource;
end;

procedure TvxControl.ApplyStyle;
var
  NewT: WideString;
begin
  if FIsFocused and CanFocused and not FDisableFocusEffect and not GlobalDisableFocusEffect then
  begin
    FRecalcUpdateRect := true;
    Repaint;
    StartTriggerAnimation(Self, 'IsFocused');
    ApplyTriggerEffect(Self, 'IsFocused');
  end;
  { translate }
  if FAutoTranslate and ShowHint and (Hint <> '') then
  begin
    NewT := Translate(Hint); // need for collection texts
    if (FScene <> nil) and not (FScene.GetDesignTime) then
      Hint := NewT;
  end;
end;

procedure TvxControl.FreeStyle;
begin
end;

procedure TvxControl.EnterFocus;
begin
  ApplyResource;
  inherited;
end;

procedure TvxControl.BeforePaint;
begin
  inherited;
  ApplyResource;
end;

procedure TvxControl.Paint;
begin
  inherited;
end;

procedure TvxControl.SetResource(const Value: string);
begin
  FResource := Value;
  FNeedResource := true;
  if not (csLoading in ComponentState) and (FUpdating = 0) then
  begin
    ApplyResource;
  end;
end;

procedure TvxControl.InitiateAction;
begin
  {$IFNDEF NOVCL}
  if FActionLink <> nil then
    FActionLink.Update;
  {$ENDIF}
end;

procedure TvxControl.ActionChange(Sender: TObject; CheckDefaults: Boolean);
begin
  {$IFNDEF NOVCL}
  if Sender is TCustomAction then
    with TCustomAction(Sender) do
    begin
      if Self is TvxTextControl then
        if not CheckDefaults or (TvxTextControl(Self).Text = '') or (TvxTextControl(Self).Text = Self.Name) then
          TvxTextControl(Self).Text := Caption;
      if not CheckDefaults or (Self.Enabled = True) then
        Self.Enabled := Enabled;
      if not CheckDefaults or (Self.Hint = '') then
        Self.Hint := Hint;
      if not CheckDefaults or (Self.Visible = True) then
        Self.Visible := Visible;
      if not CheckDefaults or not Assigned(Self.OnClick) then
        Self.OnClick := OnExecute;
    end;
  {$ENDIF}
end;

procedure TvxControl.DoActionChange(Sender: TObject);
begin
  {$IFNDEF NOVCL}
  if Sender = Action then
    ActionChange(Sender, False);
  {$ENDIF}
end;

function TvxControl.GetAction: TBasicAction;
begin
  {$IFNDEF NOVCL}
  if FActionLink <> nil then
    Result := FActionLink.Action
  else
    Result := nil;
  {$ENDIF}
end;

procedure TvxControl.SetAction(Value: TBasicAction);
begin
  {$IFNDEF NOVCL}
  if Value = nil then
  begin
    FActionLink.Free;
    FActionLink := nil;
  end
  else
  begin
    if FActionLink = nil then
      FActionLink := TvxControlActionLink.Create(Self);
    FActionLink.Action := Value;
    FActionLink.OnChange := DoActionChange;
    ActionChange(Value, csLoading in Value.ComponentState);
    Value.FreeNotification(Self);
  end;
  {$ENDIF}
end;

function TvxControl.IsHelpContextStored: Boolean;
begin
  {$IFNDEF NOVCL}
  Result := (FActionLink = nil) or not FActionLink.IsHelpContextLinked;
  {$ELSE}
  Result := true;
  {$ENDIF}
end;

procedure TvxControl.SetHelpContext(const Value: THelpContext);
begin
  if not (csLoading in ComponentState) then
    FHelpType := htContext;
  FHelpContext := Value;
end;

procedure TvxControl.SetHelpKeyword(const Value: string);
begin
  if not (csLoading in ComponentState) then
    FHelpType := htKeyword;
  FHelpKeyword := Value;
end;

{ TvxBackground ===============================================================}

constructor TvxBackground.Create(AOwner: TComponent);
begin
  inherited;
  FFill := TvxBrush.Create(vgBrushNone, $FFE0E0E0);
  FFill.OnChanged := FillChanged;
end;

destructor TvxBackground.Destroy;
begin
  FFill.Free;
  inherited;
end;

procedure TvxBackground.FillChanged(Sender: TObject);
begin
  Repaint;
end;

procedure TvxBackground.Paint;
begin
  if FFill.Style <> vgBrushNone then
  begin
    Canvas.Fill.Assign(FFill);
    Canvas.FillRect(LocalRect, 0, 0, AllCorners, AbsoluteOpacity);
  end
end;

procedure TvxBackground.PaintChildren;
begin
  if FFill.Style <> vgBrushNone then
  begin
    if (FResourceLink <> nil) then
      FResourceLink.Visual.FVisible := false;
    inherited;
    if FResourceLink <> nil then
      FResourceLink.Visual.FVisible := true;
  end
  else
    if (Parent = nil) and (FScene <> nil) and (FScene.GetRoot = Self) and (FScene.GetTransparency) then
  begin
    if FResourceLink <> nil then
      FResourceLink.Visual.FVisible := false;
    inherited;
    if FResourceLink <> nil then
      FResourceLink.Visual.FVisible := true;
  end
  else
    inherited;
end;

procedure TvxBackground.SetFill(const Value: TvxBrush);
begin
  FFill.Assign(Value);
end;

{ TvxContent ==================================================================}

constructor TvxContent.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxContent.Destroy;
begin
  inherited;
end;

function TvxContent.GetParentComponent: TComponent;
begin
  Result := inherited GetParentComponent;
end;

procedure TvxContent.Realign;
begin
  if (Parent <> nil) and not (csLoading in Parent.ComponentState) then
    inherited;
  if not FParentAligning and not (csLoading in ComponentState) then
  begin
    FParentAligning := true;
    if (Parent <> nil) and (Parent.IsVisual) and not (csLoading in Parent.ComponentState) then
      TvxVisualObject(Parent).Realign;
    FParentAligning := false;
  end;
end;

procedure TvxContent.Paint;
begin
  inherited;
end;

{ TvxDesigner =================================================================}

procedure TvxDesigner.CallDesignSelect(AObject: TObject);
var
  i: integer;
begin
  if FScenes <> nil then
    for i := 0 to FScenes.Count - 1 do
    begin
      IvgScene(FScenes[i]).DoDesignSelect(AObject);
      IvgScene(FScenes[i]).AddUpdateRect(vgRect(0, 0, 10000, 10000));
    end;
end;

function TvxDesigner.AddMethod(MethodName: string): TMethod;
begin
  Result.Data := nil;
  Result.Code := nil;
end;

function TvxDesigner.GetMethodName(Method: TMethod): string;
begin
  Result := '';
end;

procedure TvxDesigner.AddObject(AObject: TvxObject);
begin
end;

procedure TvxDesigner.DeleteObject(AObject: TvxObject);
begin
end;

procedure TvxDesigner.AddScene(const Scene: IvgScene);
begin
  if FScenes = nil then
    FScenes := TList.Create;
  if FScenes.IndexOf(Pointer(Scene)) < 0 then
    FScenes.Add(Pointer(Scene));
end;

procedure TvxDesigner.RemoveScene(const Scene: IvgScene);
begin
  FScenes.Remove(Pointer(Scene));
  if FScenes.Count = 0 then
    FreeAndNil(FScenes);
end;

procedure TvxDesigner.EditStyle(const Res: TvxResources; const ASelected: string);
begin
end;

{ TvxResources ================================================================}

constructor TvxResources.Create(AOwner: TComponent);
begin
  inherited;
  FResource := TStringList.Create;
  TStringList(FResource).OnChange := DoResourceChanged;
  FSceneList := TList.Create;
end;

destructor TvxResources.Destroy;
begin
  if FRoot <> nil then
    FreeAndNil(FRoot);
  FreeAndNil(FSceneList);
  FreeAndNil(FResource);
  inherited;
end;

procedure TvxResources.Loaded;
begin
  inherited;
  if FFileName = '' then
    Exit;
  if FileExists(ExtractFilePath(ParamStr(0)) + FFileName) then
    FResource.LoadFromFile(ExtractFilePath(ParamStr(0)) + FFileName)
  else
    if FileExists(FFileName) then
    FResource.LoadFromFile(FFileName);
end;

procedure TvxResources.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineBinaryProperty('ResourcesBin', ReadResources, WriteResources, FRoot <> nil);
end;

procedure TvxResources.ReadResources(Stream: TStream);
begin
  if (FRoot <> nil) then
  begin
    FreeAndNil(FRoot);
  end;

  FRoot := CreateObjectFromBinStream(nil, Stream);
  if FRoot <> nil then
  begin
    if FRoot.IsVisual then
      FRoot.Visual.UpdateDesignHide(false);
    UpdateScenes;
  end;
end;

procedure TvxResources.WriteResources(Stream: TStream);
begin
  if FRoot <> nil then
    FRoot.SaveToBinStream(Stream);
end;

procedure TvxResources.FillStrings;
var
  M: TMemoryStream;
  SaveChanged: TNotifyEvent;
begin
  if FRoot <> nil then
  begin
    M := TMemoryStream.Create;
    FRoot.SaveToStream(M);
    M.Position := 0;
    SaveChanged := TStringList(FResource).OnChange;
    TStringList(FResource).OnChange := nil;
    TStringList(FResource).LoadFromStream(M);
    TStringList(FResource).OnChange := SaveChanged;
    M.Free;
  end;
end;

procedure TvxResources.UpdateScenes;
var
  i: integer;
begin
  for i := 0 to FSceneList.Count - 1 do
    IvgScene(FSceneList[i]).UpdateResource;
end;

procedure TvxResources.DoResourceChanged(Sender: TObject);
var
  S: TStream;
begin
  if (FRoot <> nil) then
  begin
    FreeAndNil(FRoot);
  end;

  S := TMemoryStream.Create;
  try
    TStringList(FResource).SaveToStream(S);
    if S.Position > 0 then
    begin
      S.Position := 0;
      FRoot := CreateObjectFromStream(nil, S);
      if FRoot.IsVisual then
        FRoot.Visual.UpdateDesignHide(false);
    end;
  finally
    S.Free;
  end;
  UpdateScenes;
end;

procedure TvxResources.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
end;

procedure TvxResources.SetFileName(const Value: string);
begin
  if FFileName <> Value then
  begin
    FFileName := Value;
    if not (csLoading in ComponentState) then
    begin
      if FileExists(ExtractFilePath(ParamStr(0)) + FFileName) then
        FResource.LoadFromFile(ExtractFilePath(ParamStr(0)) + FFileName)
      else
        if FileExists(FFileName) then
        FResource.LoadFromFile(FFileName);
    end;
  end;
end;

procedure TvxResources.SetResource(const Value: TStrings);
begin
  FResource.Assign(Value);
end;

procedure TvxResources.AddSceneUpdater(const Scene: IvgScene);
begin
  FSceneList.Add(Pointer(Scene));
end;

procedure TvxResources.RemoveSceneUpdater(const Scene: IvgScene);
begin
  if FSceneList <> nil then
    FSceneList.Remove(Pointer(Scene));
end;

{ TvxLang ================================================================}

{$IFDEF WINDOWS}

procedure GetLanguageIDs(var Lang, FallbackLang: string);
var
  Buffer: array[1..4] of {$IFDEF Wince}WideChar{$ELSE}char{$ENDIF};
  Country: string;
  UserLCID: LCID;
begin
  //defaults
  Lang := '';
  FallbackLang := '';
  UserLCID := GetUserDefaultLCID;
  if GetLocaleInfo(UserLCID, LOCALE_SABBREVLANGNAME, @Buffer[1], 4) <> 0 then
    FallbackLang := lowercase(copy(Buffer, 1, 2));
  if GetLocaleInfo(UserLCID, LOCALE_SABBREVCTRYNAME, @Buffer[1], 4) <> 0 then
  begin
    Country := copy(Buffer, 1, 2);

    // some 2 letter codes are not the first two letters of the 3 letter code
    // there are probably more, but first let us see if there are translations
    if (Buffer = 'PRT') then
      Country := 'PT';

    Lang := FallbackLang + '_' + Country;
  end;
end;

{$ELSE}

procedure GetLanguageIDs(var Lang, FallbackLang: string);
begin
  lang := GetEnvironmentVariable('LC_ALL');
  if Length(lang) = 0 then
  begin
    lang := GetEnvironmentVariable('LC_MESSAGES');
    if Length(lang) = 0 then
    begin
      lang := GetEnvironmentVariable('LANG');
      if Length(lang) = 0 then
        exit; // no language defined via environment variables
    end;
  end;
  FallbackLang := Copy(lang, 1, 2);
end;
{$ENDIF}

function ReadString(S: TStream): WideString;
var
  L: Integer;
begin
  L := 0;
  S.Read(L, SizeOf(L));
  SetLength(Result, L);
  S.Read(Pointer(Result)^, L * 2);
end;

procedure WriteString(S: TStream; Value: WideString);
var
  L: Integer;
begin
  L := Length(Value);
  S.Write(L, SizeOf(L));
  S.Write(Pointer(Value)^, L * 2);
end;

constructor TvxLang.Create(AOwner: TComponent);
begin
  inherited;
  FOriginal := TvxWideStringList.Create;
  FResources := TvxWideStringList.Create;
  FAutoSelect := true;
  FStoreInForm := true;
end;

destructor TvxLang.Destroy;
var
  i: integer;
begin
  for i := 0 to FResources.Count - 1 do
    TvxWideStrings(FResources.Objects[i]).Free;
  FResources.Free;
  FOriginal.Free;
  inherited;
end;

procedure TvxLang.Loaded;
var
  L: string;
begin
  inherited;
  if (FFileName <> '') and (FileExists(ExtractFileName(ParamStr(0)) + FFileName)) then
    LoadFromFile(ExtractFileName(ParamStr(0)) + FFileName);
  if FAutoSelect then
    GetLanguageIDs(L, FLang);
  if FLang <> '' then
    LoadLangFromStrings(LangStr[FLang]);
end;

procedure TvxLang.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineBinaryProperty('ResourcesBin', ReadResources, WriteResources, StoreInForm and (FResources.Count > 0));
end;

procedure TvxLang.ReadResources(Stream: TStream);
var
  Len: cardinal;
  i: integer;
  N: WideString;
  Str: TvxWideStrings;
begin
  FOriginal.Text := ReadString(Stream);
  Stream.Read(Len, 4);
  for i := 0 to Len - 1 do
  begin
    N := ReadString(Stream);
    Str := TvxWideStringList.Create;
    Str.Sorted := true;
    TvxWideStringList(Str).CaseSensitive := true;
    Str.Text := ReadString(Stream);
    FResources.AddObject(N, Str);
  end;
end;

procedure TvxLang.WriteResources(Stream: TStream);
var
  Len: cardinal;
  i: integer;
begin
  WriteString(Stream, FOriginal.Text);
  Len := FResources.Count;
  Stream.Write(Len, 4);
  for i := 0 to Len - 1 do
  begin
    WriteString(Stream, FResources[i]);
    WriteString(Stream, TvxWideStrings(FResources.Objects[i]).Text);
  end;
end;

procedure TvxLang.LoadFromFile(AFileName: string);
var
  S: TFileStream;
begin
  if FileExists(AFileName) then
  begin
    S := TFileStream.Create(AFileName, fmOpenRead);
    ReadResources(S);
    S.Free;
  end;
end;

procedure TvxLang.SaveToFile(AFileName: string);
var
  S: TFileStream;
begin
  S := TFileStream.Create(AFileName, fmCreate);
  WriteResources(S);
  S.Free;
end;

procedure TvxLang.AddLang(AName: WideString);
var
  Idx: integer;
  Str: TvxWideStrings;
begin
  Idx := FResources.IndexOf(AName);
  if Idx < 0 then
  begin
    Str := TvxWideStringList.Create;
    Str.Sorted := true;
    TvxWideStringList(Str).CaseSensitive := true;
    FResources.AddObject(AName, Str);
  end;
end;

function TvxLang.GetLangStr(Index: WideString): TvxWideStrings;
var
  Idx: integer;
begin
  Idx := FResources.IndexOf(Index);
  if Idx >= 0 then
    Result := TvxWideStrings(FResources.Objects[Idx])
  else
    Result := nil;
end;

procedure TvxLang.SetLang(const Value: string);
begin
  FLang := Value;
  if not (csLoading in ComponentState) then
  begin
    if FLang = 'en' then
      ResetLang
    else
      LoadLangFromStrings(LangStr[FLang]);
  end;
end;

{$IFNDEF NOVCL}
{ TvxControlActionLink }

procedure TvxControlActionLink.AssignClient(AClient: TObject);
begin
  FClient := AClient as TvxControl;
end;

function TvxControlActionLink.DoShowHint(var HintStr: string): Boolean;
begin
  Result := True;
  if Action is TCustomAction then
  begin
    if TCustomAction(Action).DoHint(HintStr) and Application.HintShortCuts and
      (TCustomAction(Action).ShortCut <> scNone) then
    begin
      {      if HintStr <> '' then
              HintStr := Format('%s (%s)', [HintStr, ShortCutToText(TCustomAction(Action).ShortCut)]);}
    end;
  end;
end;

function TvxControlActionLink.IsCaptionLinked: Boolean;
begin
  Result := inherited IsCaptionLinked and
    (FClient is TvxTextControl) and (TvxTextControl(FClient).Text = (Action as TCustomAction).Caption);
end;

function TvxControlActionLink.IsEnabledLinked: Boolean;
begin
  Result := inherited IsEnabledLinked and
    (FClient.Enabled = (Action as TCustomAction).Enabled);
end;

function TvxControlActionLink.IsHintLinked: Boolean;
begin
  Result := inherited IsHintLinked and
    (FClient.Hint = (Action as TCustomAction).Hint);
end;

function TvxControlActionLink.IsVisibleLinked: Boolean;
begin
  Result := inherited IsVisibleLinked and
    (FClient.Visible = (Action as TCustomAction).Visible);
end;

function TvxControlActionLink.IsOnExecuteLinked: Boolean;
begin
  Result := inherited IsOnExecuteLinked and
    (@FClient.OnClick = @Action.OnExecute);
end;

function TvxControlActionLink.IsHelpLinked: Boolean;
begin
  Result := inherited IsHelpLinked and
    (FClient.HelpContext = TCustomAction(Action).HelpContext) and
    (FClient.HelpKeyword = TCustomAction(Action).HelpKeyword) and
    (FClient.HelpType = TCustomAction(Action).HelpType);
end;

procedure TvxControlActionLink.SetHelpKeyword(const Value: string);
begin
  if IsHelpLinked then
    FClient.HelpKeyword := Value;
end;

procedure TvxControlActionLink.SetHelpContext(Value: THelpContext);
begin
  if IsHelpLinked then
    FClient.HelpContext := Value;
end;

procedure TvxControlActionLink.SetHelpType(Value: THelpType);
begin
  if IsHelpLinked then
    FClient.HelpType := Value;
end;

procedure TvxControlActionLink.SetCaption(const Value: string);
begin
  if IsCaptionLinked then
    TvxTextControl(FClient).Text := Value;
end;

procedure TvxControlActionLink.SetEnabled(Value: Boolean);
begin
  if IsEnabledLinked then
    FClient.Enabled := Value;
end;

procedure TvxControlActionLink.SetHint(const Value: string);
begin
  if IsHintLinked then
    FClient.Hint := Value;
end;

procedure TvxControlActionLink.SetVisible(Value: Boolean);
begin
  if IsVisibleLinked then
    FClient.Visible := Value;
end;

procedure TvxControlActionLink.SetOnExecute(Value: TNotifyEvent);
begin
  if IsOnExecuteLinked then
    FClient.OnClick := Value;
end;
{$ENDIF}

var
  FTarget: TvxVisualObject = nil;

  {$IFNDEF NOVCL}
  { TvxFrame ====================================================================}

constructor TvxFrame.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxFrame.Destroy;
begin
  if not (Assigned(FScene) and (FScene.GetDesignTime)) then
    if (FSceneObject <> nil) and (FChildren <> nil) and (FChildren.Count > 0) then
    begin
      FSceneObject.AddObject(TvxObject(FChildren[0]));
      FSceneObject.FOpenInFrame := nil;
      if FSceneObject.FCloneFrame <> nil then
        FreeAndNil(FSceneObject.FCloneFrame);
    end;
  if FBuffer <> nil then
    FBuffer.Free;
  inherited;
end;

procedure TvxFrame.Loaded;
begin
  inherited;
end;

procedure TvxFrame.GetChildren(Proc: TGetChildProc; Root: TComponent);
begin
end;

procedure TvxFrame.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSceneObject) then
    SceneObject := nil;
end;

procedure TvxFrame.Paint;
var
  Obj: TvxObject;
  CloneFrame: TForm;
  SaveR: TvxRect;
begin
  if FNeedClone then
  begin
    FNeedClone := false;
    if not (Assigned(FScene) and (FScene.GetDesignTime)) and (FSceneObject <> nil) then
    begin
      { clone Owner first - if already opened }
      if (FSceneObject <> nil) and (FSceneObject.FOpenInFrame <> nil) then
      begin
        Application.CreateForm(TComponentClass(FSceneObject.Owner.ClassType), CloneFrame);
        if CloneFrame <> nil then
        begin
          FSceneObject := TvxCustomScene(CloneFrame.FindComponent(FSceneObject.Name));
          if FSceneObject <> nil then
          begin
            FSceneObject.FCloneFrame := CloneFrame;
          end;
        end
        else
          FSceneObject := nil;
      end;
      { open }
      if (FSceneObject <> nil) and (FSceneObject.FOpenInFrame = nil) and (FSceneObject.Root <> nil) then
      begin
        FSceneObject.FOpenInFrame := Self;
        Obj := FSceneObject.Root;
        Obj.Parent := Self;
        if Obj.isVisual then
        begin
          TvxVisualObject(Obj).Align := vaClient;
          Realign;
        end;
      end;
    end;
  end;
  if (FScene <> nil) and (Assigned(FScene) and (FScene.GetDesignTime)) and (SceneObject <> nil) and (SceneObject.Root <> nil) then
  begin
    Obj := SceneObject.Root;
    if Obj.isVisual then
    begin
      if FBuffer = nil then
        FBuffer := TvxBitmap.Create(Round(Width), Round(Height));
      if (FBuffer.Width <> Trunc(Width)) or (FBuffer.Height <> Trunc(Height)) then
        FBuffer.SetSize(Trunc(Width), Trunc(Height));
      FBuffer.Clear(0);
      SaveR := TvxVisualObject(Obj).ParentedRect;
      TvxVisualObject(Obj).SetBounds(0, 0, Width, Height);
      TvxVisualObject(Obj).PaintTo(FBuffer.Canvas, LocalRect);
      Canvas.DrawBitmap(FBuffer, vgRect(0, 0, FBuffer.Width, FBuffer.Height),
        vgRect(0, 0, FBuffer.Width - 1, FBuffer.Height - 1), 1);
      TvxVisualObject(Obj).SetBounds(SaveR.Left, SaveR.Top, vgRectWidth(SaveR), vgRectHeight(SaveR));
    end;
  end;
end;

procedure TvxFrame.SetSceneObject(const Value: TvxCustomScene);
var
  Obj: TvxObject;
begin
  if FSceneObject <> Value then
  begin
    if Assigned(FScene) and (Value = FScene.GetComponent) then
      Exit;

    if not (Assigned(FScene) and (FScene.GetDesignTime)) and (FSceneObject <> nil) then
    begin
      if (FSceneObject <> nil) and (FChildren <> nil) and (FChildren.Count > 0) then
      begin
        FSceneObject.AddObject(TvxObject(FChildren[0]));
        FSceneObject.FOpenInFrame := nil;
        if (FSceneObject.FCloneFrame <> nil) and not (csDestroying in FSceneObject.ComponentState) then
          FreeAndNil(FSceneObject.FCloneFrame);
      end;
    end;

    FSceneObject := Value;

    if not (Assigned(FScene) and (FScene.GetDesignTime)) and (FSceneObject <> nil) then
    begin
      { clone Owner first - if already opened }
      if (FSceneObject <> nil) and (FSceneObject.FOpenInFrame <> nil) then
      begin
        FNeedClone := true;
        Exit;
      end;
      { open }
      if (FSceneObject <> nil) and (FSceneObject.FOpenInFrame = nil) and (FSceneObject.Root <> nil) then
      begin
        FSceneObject.FOpenInFrame := Self;
        Obj := FSceneObject.Root;
        Obj.Parent := Self;
        if Obj.isVisual then
        begin
          TvxVisualObject(Obj).Align := vaClient;
          Realign;
        end;
      end;
    end;
    if Assigned(FScene) and (FScene.GetDesignTime) then
      Repaint;
  end;
end;

{$IFDEF WINDOWS}
type

  PBlendFunction = ^TBlendFunction;
  _BLENDFUNCTION = packed record
    BlendOp: BYTE;
    BlendFlags: BYTE;
    SourceConstantAlpha: BYTE;
    AlphaFormat: BYTE;
  end;
  TBlendFunction = _BLENDFUNCTION;
  BLENDFUNCTION = _BLENDFUNCTION;

const

  WS_EX_LAYERED = $00080000;
  LWA_COLORKEY = $00000001;
  LWA_ALPHA = $00000002;
  ULW_COLORKEY = $00000001;
  ULW_ALPHA = $00000002;
  ULW_OPAQUE = $00000004;

var
  User32Lib: THandle;
  SetLayeredWindowAttributes: function(hwnd: HWND; crKey: COLORREF; bAlpha: BYTE;
    dwFlags: DWORD): BOOL; stdcall;
  UpdateLayeredWindow: function(hWnd: HWND; hdcDst: HDC; pptDst: PPOINT;
    psize: PSIZE; hdcSrc: HDC; pptSrc: PPOINT; crKey: COLORREF;
    pblend: PBlendFunction; dwFlags: DWORD): BOOL; stdcall;
  PrintWindow: function(hwnd: HWND; hdcBlt: HDC; nFlags: DWORD): BOOL; stdcall;
  {$ENDIF}

  {$IFDEF DARWIN}

function WndEventHandler(inHandlerCallRef: EventHandlerCallRef;
  inEvent: EventRef;
  inUserData: Pointer): OSStatus; stdcall;
var
  myContext: CGContextRef;
  myRect: CGRect;
  rgnCode: WindowRegionCode;
  rgn: RgnHandle;
  bool: longbool;
begin
  Result := CallNextEventHandler(inHandlerCallRef, inEvent);
  Result := eventNotHandledErr;
  if GetEventClass(inEvent) = kEventClassControl then
  begin
    case GetEventKind(inEvent) of
      kEventControlDraw:
        begin
          GetEventParameter(inEvent,
            kEventParamCGContextRef,
            typeCGContextRef,
            nil,
            sizeof(CGContextRef),
            nil,
            @myContext);
          if myContext <> nil then
          begin
            myRect := CGRectFromRect(vgRect(0, 0, TvxCustomScene(inUserData).Parent.Width, TvxCustomScene(inUserData).Parent.Height));
            CGContextClearRect(myContext, myRect);
          end;
          Result := noErr;
        end;
    end;
  end;
  if GetEventClass(inEvent) = kEventClassWindow then
  begin
    case GetEventKind(inEvent) of
      kEventWindowGetRegion:
        begin
          TvxCustomScene(inUserData).Invalidate;
          // which region code is being queried?
{          GetEventParameter(inEvent, kEventParamWindowRegionCode, typeWindowRegionCode, nil, sizeof(rgnCode), nil, @rgnCode);
          // if it is the opaque region code then set the region to Empty and return noErr to stop the propagation
   if (rgnCode = kWindowOpaqueRgn) then
   begin
     GetEventParameter(inEvent, kEventParamRgnHandle, typeQDRgnHandle, nil, sizeof(rgn), nil, @rgn);
            SetEmptyRgn(rgn);
            Result := noErr;
   end;}
          Result := noErr;
        end;
    end;
  end;
end;

type
  byte8array = array[1..8] of byte;

function RegionToRectsCallback(message: UInt16; rgn: RgnHandle; const rect_: byte8array; data: Pointer): OSStatus; cdecl;
var
  R: TvxRect;
begin
  if (message = kQDRegionToRectsMsgParse) then
  begin
    {$IFDEF FPC_BIG_ENDIAN}
    R := vgRect(rect_[4] or (rect_[3] shl 8), rect_[2] or (rect_[1] shl 8), rect_[8] or (rect_[7] shl 8), rect_[6] or (rect_[5] shl 8));
    {$ELSE}
    R := vgRect(rect_[3] or (rect_[4] shl 8), rect_[1] or (rect_[2] shl 8), rect_[7] or (rect_[8] shl 8), rect_[5] or (rect_[6] shl 8));
    {$ENDIF}
    SetLength(TvxCustomScene(data).FUpdateRects, Length(TvxCustomScene(data).FUpdateRects) + 1);
    TvxCustomScene(data).FUpdateRects[High(TvxCustomScene(data).FUpdateRects)] := R;
  end;
  Result := noErr;
end;

function CreateFileURLFromPasteboard(inPasteboard: PasteboardRef): TvxDragObject;
var
  inIndex: CFIndex;
  inCount: ItemCount;
  item: PasteboardItemID;
  fileURL: CFURLRef;
  fileURLData: CFDataRef;
  info: LSItemInfoRecord;
  uti: CFStringRef;
begin
  Fillchar(Result, sizeOf(Result), 0);

  if PasteboardGetItemCount(inPasteboard, inCount) <> noErr then
    Exit;
  SetLength(Result.Files, inCount);
  for inIndex := 1 to inCount do
  begin
    if PasteboardGetItemIdentifier(inPasteboard, inIndex, item) <> noErr then
      Exit;
    if PasteboardCopyItemFlavorData(inPasteboard, item, kUTTypeFileURL, fileURLData) <> noErr then
      Exit;

    // create the file URL with the dragged data
    fileURL := CFURLCreateAbsoluteURLWithBytes(kCFAllocatorDefault, CFDataGetBytePtr(fileURLData), CFDataGetLength(fileURLData), kCFStringEncodingMacRoman, nil, true);
    if fileURL <> nil then
    begin
      uti := CFURLCopyFileSystemPath(fileURL, kCFURLPOSIXPathStyle);
      Result.Files[inIndex - 1] := CFStringToStr(uti);
      CFRelease(uti);
      CFRelease(fileURL);
    end;
    CFRelease(fileURLData);

    if inIndex = 1 then
      Result.Data := Result.Files[inIndex - 1];
  end;
end;

function CtrlEventHandler(inHandlerCallRef: EventHandlerCallRef;
  inEvent: EventRef;
  inUserData: Pointer): OSStatus; stdcall;
var
  myContext: CGContextRef;
  myRect: CGRect;
  rgn: RgnHandle;
  bool: longbool;
  proc: RegionToRectsUPP;
  err: OSStatus;
  Part: ControlPartCode;
  drag: DragRef;
  pasteboard: PasteboardRef;
  str: string;
  mouseP: MacOSAll.Point;
  P: TvxPoint;
  NewTarget: TvxVisualObject;
  Data: TvxDragObject;
  Accept: boolean;
begin
  Result := CallNextEventHandler(inHandlerCallRef, inEvent);
  Result := eventNotHandledErr;
  if GetEventClass(inEvent) = kEventClassControl then
  begin
    case GetEventKind(inEvent) of
      kEventControlDraw:
        begin
          GetEventParameter(inEvent, kEventParamCGContextRef, typeCGContextRef, nil, sizeof(CGContextRef), nil, @myContext);
          GetEventParameter(inEvent, kEventParamRgnHandle, typeQDRgnHandle, nil, sizeof(rgn), nil, @rgn);
          if rgn <> nil then
          begin
            proc := NewRegionToRectsUPP(@RegionToRectsCallback);
            { clear rects }
            SetLength(TvxCustomScene(inUserData).FUpdateRects, 0);
            err := QDRegionToRects(rgn, kQDParseRegionFromBottomRight, proc, inUserData);
            DisposeRegionToRectsUPP(proc);
          end;
          { draw }
          if TvxCustomScene(inUserData).Canvas.FBuffered then
            TvxCustomScene(inUserData).Canvas.Parent := THandle(myContext)
          else
            TvxCustomScene(inUserData).Canvas.Handle := THandle(myContext);
          {          if TvxCustomScene(inUserData).Transparency then
                      CGContextClearRect(myContext, CGRectFromRect(vgRect(0, 0, TvxCustomScene(inUserData).Width, TvxCustomScene(inUserData).Height)));}
          TvxCustomScene(inUserData).Draw;
          if TvxCustomScene(inUserData).Canvas.FBuffered then
            TvxCustomScene(inUserData).Canvas.Parent := 0
          else
            TvxCustomScene(inUserData).Canvas.Handle := 0;
          Result := noErr;
        end;
      kEventControlDragEnter:
        begin
          bool := true;
          SetEventParameter(inEvent, kEventParamControlWouldAcceptDrop, typeBoolean, sizeof(bool), @bool);
          Result := noErr;
        end;
      kEventControlDragWithin:
        begin
          GetEventParameter(inEvent, kEventParamDragRef, typeDragRef, nil, sizeof(DragRef), nil, @drag);
          if drag <> nil then
          begin
            GetDragPasteboard(drag, pasteboard);
            if pasteboard <> nil then
            begin
              if TvxCustomScene(inUserData).Root = nil then
                Exit;

              Data := CreateFileURLFromPasteboard(pasteboard);

              GetDragMouse(drag, mouseP, mouseP);
              with TvxCustomScene(inUserData).ScreenToClient(Point(mouseP.h, mouseP.v)) do
                P := vgPoint(X, Y);
              NewTarget := TvxCustomScene(inUserData).Root.Visual.FindTarget(P, Data);
              if (NewTarget <> FTarget) then
              begin
                if FTarget <> nil then
                  FTarget.DragLeave;
                FTarget := NewTarget;
                if FTarget <> nil then
                begin
                  FTarget.DragEnter(Data, P);
                end;
              end;
              if FTarget = nil then
                Accept := false;
            end;
          end;
          Result := noErr;
        end;
      kEventControlDragLeave:
        begin
          if FTarget <> nil then
            FTarget.DragLeave;
          FTarget := nil;
          Result := noErr;
        end;
      kEventControlDragReceive:
        begin
          GetEventParameter(inEvent, kEventParamDragRef, typeDragRef, nil, sizeof(DragRef), nil, @drag);
          if drag <> nil then
          begin
            GetDragPasteboard(drag, pasteboard);
            if pasteboard <> nil then
            begin
              if TvxCustomScene(inUserData).Root = nil then
                Exit;

              Data := CreateFileURLFromPasteboard(pasteboard);
              if FTarget <> nil then
                FTarget.DragDrop(Data, P);
            end;
          end;
          FTarget := nil;
          Result := noErr;
        end;
    end;
  end;
end;

var
  EventKinds: array[0..20] of EventTypeSpec;
  WndEventHandlerUPP: EventHandlerUPP;
  {$ENDIF}

  {$IFDEF WINDOWS}

function WndCallback(Ahwnd: HWND; uMsg: UINT; wParam: WParam; lParam: LParam): LRESULT; stdcall;
{$IFDEF FPC}
var
  Win: TWinControl;
  {$ENDIF}
begin
  {$IFDEF FPC}
  Win := FindControl(Ahwnd);
  if (Win is TvxCustomScene) then
  begin
    if not (csDestroying in Win.ComponentState) then
    begin
      if (uMsg = WM_PAINT) or (uMsg = WM_ADDUPDATERECT) then
      begin
        Result := Win.Perform(uMsg, wParam, lParam);
        exit;
      end;
    end;
    result := CallWindowProcW(@TvxCustomScene(Win).PrevWndProc, Ahwnd, uMsg, WParam, LParam);
    Exit;
  end;
  {$ENDIF}
  result := CallWindowProcW(@DefWindowProcW, Ahwnd, uMsg, WParam, LParam);
end;
{$ENDIF}

{ TvxCustomScene ==============================================================}

constructor TvxCustomScene.Create(AOwner: TComponent);
begin
  inherited;
  AddScene(Self);
  ShowHint := true;
  FAnimatedCaret := true;
  FDesignTime := csDesigning in ComponentState;
  ControlStyle := ControlStyle - [csAcceptsControls] + [csActionClient];
  OnDragOver := DoDragOver;
  OnDragDrop := DoDragDrop;
  ControlStyle := ControlStyle + [csCaptureMouse, csOpaque, csDoubleClicks];
  FSnapToLines := true;
  FAlignRoot := true;
  FCanvas := DefaultCanvasClass.Create(Width, Height);
  FCanvas.Scene := Self;
  FFill := TvxBrush.Create(vgBrushNone, $FF000000);
  FFill.OnChanged := FillChanged;
  DesignPopupEnabled := true;
  FSnapGridSize := 1;
  Width := 100;
  Height := 100;
  if vgDesigner <> nil then
    vgDesigner.AddScene(Self);
  vgSceneCount := vgSceneCount + 1;
end;

destructor TvxCustomScene.Destroy;
begin
  if FHovered <> nil then
  begin
    TvxVisualObject(FHovered).RemoveFreeNotify(Self);
    FHovered := nil;
  end;
  if FFocused <> nil then
  begin
    TvxVisualObject(FFocused).RemoveFreeNotify(Self);
    FFocused := nil;
  end;
  if FStyle <> nil then
    FStyle.RemoveSceneUpdater(Self);
  if vgSceneCount = 0 then
  begin
    if aniThread <> nil then
    begin
      aniThread.Free;
    end;
    aniThread := nil;
  end;
  if FDesignPopup <> nil then
    FreeAndnil(FDesignPopup);
  if vgDesigner <> nil then
    vgDesigner.RemoveScene(Self);
  vgSceneCount := vgSceneCount - 1;
  if FOpenInFrame <> nil then
    FOpenInFrame.SceneObject := nil;
  DeleteChildren;
  if FChildren <> nil then
    FreeAndNil(FChildren);
  FreeAndNil(FFill);
  FreeAndNil(FCanvas);
  RemoveScene(Self);
  inherited;
end;

procedure TvxCustomScene.CreateHandle;
{$IFDEF LINUX}
var
  screen: PGdkScreen;
  colormap: PGdkColormap;
  {$ENDIF}
begin
  inherited;
  {$IFDEF FPCWIN} // fpc lazarus
  PrevWndProc := Windows.WNDPROC(SetWindowLongPtrW(Self.Handle, GWL_WNDPROC, PtrInt(@WndCallback)));
  {$ENDIF}
  {$IFNDEF UCL}
  {$IFDEF WINDOWS}
  SetWindowLongW(Handle, GWL_WNDPROC, GetWindowLong(Handle, GWL_WNDPROC));
  Canvas.Parent := Handle;
  {$ENDIF}
  {$IFDEF LINUX}
  Canvas.Parent := Integer(GetFixedWidget(pgtkwidget(Handle)));
  {$ENDIF}
  {$ENDIF}
  Canvas.ResizeBuffer(Width, Height);
  RealignRoot;
  AddUpdateRect(vgRect(0, 0, Width, Height));
  { Add Hook }
  {$IFNDEF UCL}
  if FTransparency and not (GetDesignTime) then
  begin
    if Parent is TCustomForm then
    begin
      {$IFDEF LINUX}
      screen := gtk_widget_get_screen(pgtkwidget(Parent.Handle));
      colormap := gdk_screen_get_rgba_colormap(screen);
      if colormap <> nil then
        gtk_widget_set_colormap(pgtkwidget(Parent.Handle), colormap);
      { Set Paint by App }
      gtk_widget_set_app_paintable(pgtkwidget(Parent.Handle), true);
      {$ENDIF}
      {$IFDEF WINDOWS}
      if FTransparency and not (GetDesignTime) and (Parent is TCustomForm) then
        SetWindowLong(Parent.Handle, GWL_EXSTYLE, GetWindowLong(Parent.Handle, GWL_EXSTYLE) or WS_EX_LAYERED);
      UpdateLayer;
      AddUpdateRect(vgRect(0, 0, $FFFF, $FFFF));
      {$ENDIF}
      {$IFDEF DARWIN}
      WndEventHandlerUPP := NewEventHandlerUPP(EventHandlerProcPtr(Pointer(@WndEventHandler)));
      EventKinds[0].eventClass := kEventClassControl;
      EventKinds[0].eventKind := kEventControlDraw;
      InstallEventHandler(GetControlEventTarget(TCarbonWindow(TCustomForm(Parent).Handle).Widget), WndEventHandlerUPP, 1, @EventKinds[0], Self, nil);
      EventKinds[0].eventClass := kEventClassWindow;
      EventKinds[0].eventKind := kEventWindowGetRegion;
      InstallEventHandler(GetWindowEventTarget(TCarbonWindow(TCustomForm(Parent).Handle).Window), WndEventHandlerUPP, 1, @EventKinds[0], Self, nil);
      SetWindowAlpha(TCarbonWindow(TCustomForm(Parent).Handle).Window, 0.999);
      ReshapeCustomWindow(TCarbonWindow(TCustomForm(Parent).Handle).Window);
      {$ENDIF}
    end
  end;
  {$IFDEF DARWIN}
  SetControlDragTrackingEnabled(TCarbonWidget(Handle).Widget, true);
  if Parent is TCustomForm then
    SetAutomaticControlDragTrackingEnabledForWindow(TCarbonWindow(TCustomForm(Parent).Handle).Window, true);
  WndEventHandlerUPP := NewEventHandlerUPP(EventHandlerProcPtr(Pointer(@CtrlEventHandler)));
  EventKinds[0].eventClass := kEventClassControl;
  EventKinds[0].eventKind := kEventControlDraw;
  EventKinds[1].eventClass := kEventClassControl;
  EventKinds[1].eventKind := kEventControlDragEnter;
  EventKinds[2].eventClass := kEventClassControl;
  EventKinds[2].eventKind := kEventControlDragReceive;
  EventKinds[3].eventClass := kEventClassControl;
  EventKinds[3].eventKind := kEventControlDragWithin;
  EventKinds[4].eventClass := kEventClassControl;
  EventKinds[4].eventKind := kEventControlDragLeave;
  InstallEventHandler(GetControlEventTarget(TCarbonWidget(Handle).Widget), WndEventHandlerUPP, 5, @EventKinds[0], Self, nil);
  {$ELSE}
  {$ENDIF}
  {$ENDIF}
end;

{$IFDEF WINDOWS}

procedure TvxCustomScene.CreateWnd;
begin
  inherited;
  {$IFNDEF UCL}
  {$IFDEF WINDOWS}
  RegisterDragDrop(Handle, Self);
  {$ENDIF}
  {$ENDIF}
end;

procedure TvxCustomScene.DestroyWnd;
begin
  {$IFDEF windows}
  if Canvas <> nil then
    Canvas.Handle := 0;
  {$ENDIF}
  {$IFNDEF UCL}
  {$IFDEF WINDOWS}
  if HandleAllocated then
    RevokeDragDrop(Handle);
  {$ENDIF}
  {$IFDEF FPCWIN} // fpc lazarus
  if PtrInt(SetWindowLongPtrW(Self.Handle, GWL_WNDPROC, PtrInt(@WndCallback))) = PtrInt(@WndCallback) then
    SetWindowLongPtrW(Self.Handle, GWL_WNDPROC, PtrInt(@PrevWndProc));
  {$ENDIF}
  {$ENDIF}
  inherited;
end;

{$ENDIF}

procedure TvxCustomScene.Loaded;
begin
  inherited;
  FLoadCursor := Cursor;
  if FSnapToLines then
    FSnapToGrid := false;
  FShowTimer := TvxTimer.Create(Self);
  FShowTimer.Interval := 1;
  FShowTimer.OnTimer := DoShowTimer;
end;

procedure TvxCustomScene.InitiateAction;
  procedure TraverseClients(Container: TvxVisualObject);
  var
    I: Integer;
    Control: TvxVisualObject;
  begin
    if Container.CheckParentVisible then
      for I := 0 to Container.ChildrenCount - 1 do
      begin
        if not Container.Children[I].IsVisual then
          Continue;
        Control := Container.Children[I].Visual;
        if (Control is TvxControl) and Control.Visible and (TvxControl(Control).Action <> nil) then
          TvxControl(Control).InitiateAction;
        TraverseClients(Control);
      end;
  end;
begin
  inherited;
  if Root <> nil then
    TraverseClients(TvxVisualObject(Root));
end;

procedure TvxCustomScene.CreateEmbedded(const AWidth, AHeight: integer; AOnFlush: TNotifyEvent);
begin
  FOnFlush := AOnFlush;
  Width := AWidth;
  Height := AHeight;
  Canvas.ResizeBuffer(AWidth, AHeight);
  RealignRoot;
  AddUpdateRect(vgRect(0, 0, AWidth, AHeight));
end;

procedure TvxCustomScene.EmbeddedMouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  MouseDown(Button, Shift, X, Y);
end;

procedure TvxCustomScene.EmbeddedMouseMove(Shift: TShiftState; X, Y: Integer);
begin
  MouseMove(Shift, X, Y);
end;

procedure TvxCustomScene.EmbeddedMouseUp(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
  MouseUp(Button, Shift, X, Y);
end;

function TvxCustomScene.EmbeddedMouseWheel(Shift: TShiftState; WheelDelta: Integer): Boolean;
var
  MousePos: TPoint;
begin
  Result := DoMouseWheel(Shift, WheelDelta, MousePos);
end;

procedure TvxCustomScene.EmbeddedKeyUp(var Key: Word; var Char: System.WideChar; Shift: TShiftState);
begin
  UnicodeKeyUp(Key, Char, Shift);
end;

procedure TvxCustomScene.EmbeddedKeyDown(var Key: Word; var Char: System.WideChar; Shift: TShiftState);
begin
  UnicodeKeyDown(Key, Char, Shift);
end;

procedure TvxCustomScene.DoShowTimer(Sender: TObject);
begin
  FShowTimer.Enabled := false;
  {$IFDEF DARWIN}
  HIViewSetNeedsDisplay(HiViewRef(TCarbonWidget(Handle).Widget), true);
  {$ENDIF}
  {$IFDEF WINDOWS}
  AddUpdateRect(vgRect(0, 0, $FFFF, $FFFF));
  {$ENDIF}
  FShowTimer.Free;
end;

procedure TvxCustomScene.UpdateBuffer;
begin
  {$IFDEF DARWIN}
  HIViewSetNeedsDisplay(HiViewRef(TCarbonWidget(Handle).Widget), true);
  {$ENDIF}
  {$IFDEF WINDOWS}
  SetLength(FUpdateRects, 1);
  FUpdateRects[0] := vgRect(0, 0, Width, Height);
  Draw;
  {$ENDIF}
end;

procedure TvxCustomScene.UpdateLayer;
{$IFNDEF UCL}
{$IFDEF WINDOWS}
var
  Blend: TBLENDFUNCTION;
  Origin, Size, BitmapOrigin: Windows.TPoint;
  i, j: integer;
  SaveBits: PvgColorRecArray;
  {$ENDIF}
  {$ENDIF}
begin
  {$IFNDEF UCL}
  {$IFDEF WINDOWS}
  if (GetDesignTime) then
    Exit;
  if not (Owner is TWinControl) then
    Exit;
  if Parent.Handle = 0 then
    Exit;

  Origin := Point(Parent.Left + Left, Parent.Top + Top);
  Size := Point(Width, Height);
  { Update }
  with Blend do
  begin
    BlendOp := AC_SRC_OVER;
    AlphaFormat := $01; //AC_SRC_ALPHA;
    BlendFlags := 0;
    SourceConstantAlpha := $FF;
  end;
  BitmapOrigin := Point(0, 0);

  { VCL }
  if ControlCount > 0 then
  begin
    // save alpha
    GetMem(SaveBits, Width * Height * 4);
    vgMoveLongword(Canvas.FBufferBits, SaveBits, Width * Height);
    // paint
    PaintControls(Canvas.Handle, nil);
    // restore alpha
    for j := 0 to Height - 1 do
      for i := 0 to Width - 1 do
        PvgColorRecArray(Canvas.FBufferBits)[i + (j * Width)].A := SaveBits[i + (j * Width)].A;
    FreeMem(SaveBits, Width * Height * 4);
  end;

  UpdateLayeredWindow(Parent.Handle, 0, @Origin, @Size, Canvas.Handle, @BitmapOrigin, $00000000, @Blend, ULW_ALPHA);
  {$ENDIF}
  {$ENDIF}
end;

procedure TvxCustomScene.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  i: Integer;
begin
  inherited;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]).Stored then
        Proc(FChildren[i]);
end;

procedure TvxCustomScene.AddUpdateRect(R: TvxRect);
{$IFDEF WINDOWS}
var
  WR: TRect;
  {$ENDIF}
  {$IFDEF LINUX}
var
  GR: TGdkRectangle;
  {$ENDIF}
begin
  if FDisableUpdate then
    Exit;
  if csLoading in ComponentState then
    Exit;
  if not Assigned(FOnFlush) and not HandleAllocated then
    Exit;
  if csDestroying in ComponentState then
    Exit;
  if (Canvas.FBuffered) and (Canvas.FBufferBits = nil) then
    Exit;
  if (vgRectWidth(R) = 0) or (vgRectHeight(R) = 0) then
    Exit;

  R := vgRect(Trunc(R.Left), Trunc(R.Top), Trunc(R.Right) + 1, Trunc(R.Bottom) + 1);
  if not vgIntersectRect(R, vgRect(0, 0, Width, Height)) then
    Exit;

  if Assigned(FOnFlush) then
  begin
    { not use WM_PAINT in embedded mode }
    {$IFDEF WINDOWS}
    SetLength(FUpdateRects, Length(FUpdateRects) + 1);
    FUpdateRects[High(FUpdateRects)] := R;
    PostMessage(Handle, WM_ADDUPDATERECT, 0, 0); // only for layered
    {$ENDIF}
    Exit;
  end;
  {$IFDEF LINUX}
  GR.x := Trunc(R.Left);
  GR.y := Trunc(R.Top);
  GR.width := Trunc(vgRectWidth(R));
  GR.height := Trunc(vgRectHeight(R));
  SetLength(FUpdateRects, Length(FUpdateRects) + 1);
  FUpdateRects[High(FUpdateRects)] := R;
  if HandleAllocated and GDK_IS_WINDOW(pgtkwidget(Handle)^.window) then
    gdk_window_invalidate_rect(pgtkwidget(Handle)^.window, @GR, true);
  {$ENDIF}
  {$IFDEF DARWIN}
  HIViewSetNeedsDisplayInRect(HiViewRef(TCarbonWidget(Handle).Widget), CGRectFromRect(R), true);
  {$ENDIF}
  {$IFDEF WINDOWS}
  if Transparency and (Parent is TCustomForm) and not FDEsigntime then
  begin
    SetLength(FUpdateRects, Length(FUpdateRects) + 1);
    FUpdateRects[High(FUpdateRects)] := R;
    PostMessage(Handle, WM_ADDUPDATERECT, 0, 0); // only for layered
  end
  else
  begin
    WR := Rect(Trunc(R.Left), Trunc(R.Top), Trunc(R.Right), Trunc(R.Bottom));
    Windows.InvalidateRect(Handle, @WR, false);
  end;
  {$ENDIF}
end;

{$IFDEF WINDOWS}
type
  TParentControl = class(TWinControl);

procedure GetControls(X, Y, W, H: Integer;
  Control: TCustomControl; Dest: TCanvas);
var
  I, Count, SaveIndex: Integer;
  DC: HDC;
  R, SelfR, CtlR: TRect;
  Ctrl: TControl;
begin
  Count := Control.ControlCount;
  DC := Dest.Handle;
  SelfR := Bounds(0, 0, W, H);
  // Copy images of controls
  for I := 0 to Count - 1 do
  begin
    Ctrl := Control.Controls[I];
    if (Ctrl <> nil) and (Ctrl is TCustomControl)
      then
    begin
      with Ctrl do
      begin
        CtlR := Bounds(X + Left, Y + Top, Width, Height);
        if Bool(IntersectRect(R, SelfR, CtlR)) and Visible then
        begin
          SaveIndex := SaveDC(DC);
          SetViewportOrgEx(DC, Left + X, Top + Y, nil);
          IntersectClipRect(DC, 0, 0, Width, Height);
          Perform(WM_PAINT, DC, 0);
          RestoreDC(DC, SaveIndex);
          if TCustomControl(Ctrl).ControlCount <> 0
            then
            GetControls(Left + X, Top + Y, W, H,
              TCustomControl(Ctrl), Dest);
        end;
      end;
    end;
  end;
end;

procedure DrawParentImage(Control: TControl; DestDC: HDC);
var
  I, Count, X, Y, SaveIndex: Integer;
  Dest: TCanvas;
  R, SelfR, CtlR: TRect;
  Ctrl: TControl;
begin
  if Control.Parent = nil then
    Exit;
  Count := Control.Parent.ControlCount;
  Dest := TCanvas.Create;
  try
    Dest.Handle := DestDC;
    SelfR := Bounds(Control.Left, Control.Top, Control.Width, Control.Height);
    X := -Control.Left;
    Y := -Control.Top;
    // Copy parent control image
    if Control.Parent is TForm then
    begin
      SaveIndex := SaveDC(DestDC);
      SetViewportOrgEx(DestDC, X, Y, nil);
      IntersectClipRect(DestDC, 0, 0, Control.Parent.ClientWidth,
        Control.Parent.ClientHeight);
      if (Control.Parent is TForm) and
        (TForm(Control.Parent).FormStyle = fsMDIForm)
        then
      begin
        SendMessage(TForm(Control.Parent).ClientHandle, WM_ERASEBKGND, DestDC, 0);
      end
      else
        SendMessage(Control.Parent.Handle, WM_ERASEBKGND, DestDC, 0);
      RestoreDC(DestDC, SaveIndex);
    end
    else
    begin
      SaveIndex := SaveDC(DestDC);
      SetViewportOrgEx(DestDC, X, Y, nil);
      IntersectClipRect(DestDC, 0, 0, Control.Parent.ClientWidth,
        Control.Parent.ClientHeight);
      TParentControl(Control.Parent).Perform(WM_ERASEBKGND, DestDC, 0);
      TParentControl(Control.Parent).Perform(WM_PAINT, DestDC, 0);
      RestoreDC(DestDC, SaveIndex);
    end;

    // Copy images of controls
    for I := 0 to Count - 1 do
    begin
      Ctrl := Control.Parent.Controls[I];
      if Ctrl = Control then
        Break;
      if (Ctrl <> nil) and
        ((Ctrl is TGraphicControl) or (Ctrl is TCustomControl))
        then
        with Ctrl do
        begin
          CtlR := Bounds(Left, Top, Width, Height);
          if Bool(IntersectRect(R, SelfR, CtlR)) and Visible then
          begin
            SaveIndex := SaveDC(DestDC);
            SetViewportOrgEx(DestDC, Left + X, Top + Y, nil);
            IntersectClipRect(DestDC, 0, 0, Width, Height);
            Perform(WM_PAINT, DestDC, 0);
            RestoreDC(DestDC, SaveIndex);
            if Ctrl is TCustomControl then
              GetControls(Left + X, Top + Y,
                Control.Width, Control.Height,
                TCustomControl(Ctrl), Dest);
          end;
        end;
    end;
  finally
    Dest.Handle := 0;
    Dest.Free;
  end;
end;
{$ENDIF}

procedure TvxCustomScene.Draw;
var
  i, j: integer;
  R: TvxRect;
  Rgn, NRgn: Cardinal;
  ScaleMatrix: TvxMatrix;
begin
  if not (FDesignTime) and (FOpenInFrame <> nil) then
    Exit;
  if FDrawing then
    Exit;
  if Length(FUpdateRects) > 0 then
  begin
    FDrawing := true;
    try
      { Split rects if rects too more }
      if (Length(FUpdateRects) > 20) then
      begin
        for i := 1 to High(FUpdateRects) do
          FUpdateRects[0] := vgUnionRect(FUpdateRects[0], FUpdateRects[i]);
        SetLength(FUpdateRects, 1);
      end;
      { draw back }
      if Canvas.BeginScene then
      begin
        Canvas.ResetClipRect;
        ScaleMatrix := IdentityMatrix;
        Canvas.SetMatrix(ScaleMatrix);
        Canvas.SetClipRects(FUpdateRects);

        if FTransparency and not (Parent is TCustomForm) then
        begin
          if FFill.Style = vgBrushNone then
          begin
            { apply cliprgn }
            {$IFDEF WINDOWS}
            j := SaveDC(Canvas.Handle);
            with FUpdateRects[0] do
              Rgn := CreateRectRgn(trunc(left), trunc(top), trunc(right), trunc(bottom));
            for i := 1 to High(FUpdateRects) do
            begin
              with FUpdateRects[i] do
                NRgn := CreateRectRgn(trunc(left), trunc(top), trunc(right), trunc(bottom));
              CombineRgn(Rgn, Rgn, NRgn, RGN_OR);
              DeleteObject(NRgn);
            end;
            SelectClipRgn(Canvas.Handle, Rgn);
            DrawParentImage(Self, Canvas.Handle);
            RestoreDC(Canvas.Handle, j);
            {$ENDIF}
          end
          else
          begin
            Canvas.Fill.Assign(FFill);
            Canvas.FillRect(vgRect(-1, -1, Width + 1, Height + 1), 0, 0, AllCorners, 1);
          end;
        end
        else
        begin
          if (FFill.Style = vgBrushNone) or ((FFill.SolidColor and $FF000000 = 0) and (FFill.Style = vgBrushSolid)) then
          begin
            for i := 0 to High(FUpdateRects) do
            begin
              if FTransparency then
                Canvas.ClearRect(FUpdateRects[i], 0)
              else
                Canvas.ClearRect(FUpdateRects[i], FFill.SolidColor and $FFFFFF);
            end;
          end
          else
          begin
            Canvas.Fill.Assign(FFill);
            Canvas.FillRect(vgRect(-1, -1, Width + 1, Height + 1), 0, 0, AllCorners, 1);
          end;
        end;
        { reset }
        Canvas.StrokeThickness := 1;
        Canvas.StrokeCap := vgCapFlat;
        Canvas.StrokeJoin := vgJoinMiter;
        Canvas.StrokeDash := vgDashSolid;
        Canvas.Stroke.Style := vgBrushSolid;
        Canvas.Fill.Style := vgBrushSolid;
        if FChildren <> nil then
          for i := 0 to FChildren.Count - 1 do
          begin
            if not (TvxObject(FChildren[i]).IsVisual) then
              Continue;
            if not TvxVisualObject(FChildren[i]).Visible then
              Continue;

            ScaleMatrix := IdentityMatrix;
            for j := 0 to High(FUpdateRects) do
              if vgIntersectRect(FUpdateRects[j], TvxVisualObject(FChildren[i]).UpdateRect) then
              begin
                Canvas.SetMatrix(vgMatrixMultiply(ScaleMatrix, TvxVisualObject(FChildren[i]).AbsoluteMatrix));
                TvxVisualObject(FChildren[i]).BeforePaint;
                TvxVisualObject(FChildren[i]).Paint;
                TvxVisualObject(FChildren[i]).AfterPaint;
                TvxVisualObject(FChildren[i]).PaintChildren;
                if Assigned(TvxVisualObject(FChildren[i]).OnPaint) then
                begin
                  Canvas.SetMatrix(vgMatrixMultiply(ScaleMatrix, TvxVisualObject(FChildren[i]).AbsoluteMatrix));
                  TvxVisualObject(FChildren[i]).OnPaint(TvxVisualObject(FChildren[i]), Canvas, TvxVisualObject(FChildren[i]).LocalRect);
                end;
                Break;
              end;
          end;

        { grid }
        if FSnapGridShow and (FSnapGridSize <> 0) then
        begin
          ScaleMatrix := IdentityMatrix;
          Canvas.SetMatrix(ScaleMatrix);
          Canvas.Stroke.Style := vgBrushSolid;
          Canvas.StrokeThickness := 1;
          {        for i := Trunc((-FDesignScroll.X) / (FSnapGridSize)) - 1 to Trunc((-FDesignScroll.X + Width) / (FSnapGridSize)) + 1 do
                  begin
                    if i mod 5 = 0 then
                      Canvas.Stroke.SolidColor := $50505050
                    else
                      Canvas.Stroke.SolidColor := $50303030;
                    Canvas.DrawLine(vgPoint(i * FSnapGridSize + 0.5, -FDesignScroll.Y + 0.5), vgPoint(i * FSnapGridSize + 0.5, -FDesignScroll.Y + Height + 0.5), 1);
                  end;
                  for j := Trunc((-FDesignScroll.Y) / (FSnapGridSize)) - 1 to Trunc((-FDesignScroll.Y + Height) / (FSnapGridSize)) + 1 do
                  begin
                    if j mod 5 = 0 then
                      Canvas.Stroke.SolidColor := $50505050
                    else
                      Canvas.Stroke.SolidColor := $50303030;
                    Canvas.DrawLine(vgPoint(-FDesignScroll.X + 0.5, j * FSnapGridSize + 0.5), vgPoint(-FDesignScroll.X + Width + 0.5, j * FSnapGridSize + 0.5), 1)
                  end;}
        end;
        { design }
        if (FSelected <> nil) and not FSelected.DisableDesignResize then
        begin
          Canvas.Fill.Style := vgBrushSolid;
          Canvas.Fill.SolidColor := $FFFFFFFF;
          Canvas.StrokeThickness := 1;
          Canvas.Stroke.Style := vgBrushSolid;
          Canvas.Stroke.SolidColor := $FF1072C5;
          ScaleMatrix := dcm_vgcore.IdentityMatrix;
          Canvas.SetMatrix(vgMatrixMultiply(ScaleMatrix, FSelected.AbsoluteMatrix));
          R := FSelected.BoundsRect;
          vgInflateRect(R, -0.5, -0.5);
          Canvas.StrokeDash := vgDashDash;
          Canvas.DrawRect(R, 0, 0, AllCorners, 1);
          Canvas.StrokeDash := vgDashSolid;
          begin
            { rotate }
            if FRotateHot then
              Canvas.Fill.SolidColor := $FFFF0000
            else
              Canvas.Fill.SolidColor := $FFFFFFFF;
            R := FSelected.BoundsRect;
            vgInflateRect(R, -0.5, -0.5);
            Canvas.DrawLine(vgPoint((R.Left + R.Right) / 2, R.Top), vgPoint((R.Left + R.Right) / 2, R.Top - RotSize), 1);
            Canvas.Fillellipse(vgRect((R.Left + R.Right) / 2 - (GripSize), R.Top - RotSize - (GripSize),
              (R.Left + R.Right) / 2 + (GripSize), R.Top - RotSize + (GripSize)), Opaque);
            Canvas.DrawEllipse(vgRect((R.Left + R.Right) / 2 - (GripSize), R.Top - RotSize - (GripSize),
              (R.Left + R.Right) / 2 + (GripSize), R.Top - RotSize + (GripSize)), Opaque);
            { angles }
            if FLeftTopHot then
              Canvas.Fill.SolidColor := $FFFF0000
            else
              Canvas.Fill.SolidColor := $FFFFFFFF;
            R := FSelected.BoundsRect;
            vgInflateRect(R, -0.5, -0.5);
            Canvas.Fillellipse(vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize)), Opaque);
            Canvas.DrawEllipse(vgRect(R.Left - (GripSize), R.Top - (GripSize), R.Left + (GripSize), R.Top + (GripSize)), Opaque);

            if FRightTopHot then
              Canvas.Fill.SolidColor := $FFFF0000
            else
              Canvas.Fill.SolidColor := $FFFFFFFF;
            R := FSelected.BoundsRect;
            vgInflateRect(R, -0.5, -0.5);
            Canvas.Fillellipse(vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize)), Opaque);
            Canvas.DrawEllipse(vgRect(R.Right - (GripSize), R.Top - (GripSize), R.Right + (GripSize), R.Top + (GripSize)), Opaque);

            if FLeftBottomHot then
              Canvas.Fill.SolidColor := $FFFF0000
            else
              Canvas.Fill.SolidColor := $FFFFFFFF;
            R := FSelected.BoundsRect;
            vgInflateRect(R, -0.5, -0.5);
            Canvas.Fillellipse(vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize)), Opaque);
            Canvas.DrawEllipse(vgRect(R.Left - (GripSize), R.Bottom - (GripSize), R.Left + (GripSize), R.Bottom + (GripSize)), Opaque);

            if FRightBottomHot then
              Canvas.Fill.SolidColor := $FFFF0000
            else
              Canvas.Fill.SolidColor := $FFFFFFFF;
            R := FSelected.BoundsRect;
            vgInflateRect(R, -0.5, -0.5);
            Canvas.FillEllipse(vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize)), Opaque);
            Canvas.DrawEllipse(vgRect(R.Right - (GripSize), R.Bottom - (GripSize), R.Right + (GripSize), R.Bottom + (GripSize)), Opaque);
            { lines }
            if FSelected.Width > GripSize * 4 then
            begin
              if FTopHot then
                Canvas.Fill.SolidColor := $FFFF0000
              else
                Canvas.Fill.SolidColor := $FFFFFFFF;
              R := FSelected.BoundsRect;
              vgInflateRect(R, -0.5, -0.5);
              Canvas.FillRect(vgRect(R.Left + vgRectWidth(R) / 2 - (GripSize), R.Top - (GripSize), R.Left + vgRectWidth(R) / 2 + (GripSize), R.Top + (GripSize)), 0, 0, [], Opaque);
              Canvas.DrawRect(vgRect(R.Left + vgRectWidth(R) / 2 - (GripSize), R.Top - (GripSize), R.Left + vgRectWidth(R) / 2 + (GripSize), R.Top + (GripSize)), 0, 0, [], Opaque);
              if FBottomHot then
                Canvas.Fill.SolidColor := $FFFF0000
              else
                Canvas.Fill.SolidColor := $FFFFFFFF;
              R := FSelected.BoundsRect;
              vgInflateRect(R, -0.5, -0.5);
              Canvas.FillRect(vgRect(R.Left + vgRectWidth(R) / 2 - (GripSize), R.Bottom - (GripSize), R.Left + vgRectWidth(R) / 2 + (GripSize), R.Bottom + (GripSize)), 0, 0, [], Opaque);
              Canvas.DrawRect(vgRect(R.Left + vgRectWidth(R) / 2 - (GripSize), R.Bottom - (GripSize), R.Left + vgRectWidth(R) / 2 + (GripSize), R.Bottom + (GripSize)), 0, 0, [], Opaque);
            end;
            if FSelected.Height > GripSize * 4 then
            begin
              if FLeftHot then
                Canvas.Fill.SolidColor := $FFFF0000
              else
                Canvas.Fill.SolidColor := $FFFFFFFF;
              R := FSelected.BoundsRect;
              vgInflateRect(R, -0.5, -0.5);
              Canvas.FillRect(vgRect(R.Left - (GripSize), R.Top + vgRectHeight(R) / 2 - (GripSize), R.Left + (GripSize), R.Top + vgRectHeight(R) / 2 + (GripSize)), 0, 0, [], Opaque);
              Canvas.DrawRect(vgRect(R.Left - (GripSize), R.Top + vgRectHeight(R) / 2 - (GripSize), R.Left + (GripSize), R.Top + vgRectHeight(R) / 2 + (GripSize)), 0, 0, [], Opaque);
              if FRightHot then
                Canvas.Fill.SolidColor := $FFFF0000
              else
                Canvas.Fill.SolidColor := $FFFFFFFF;
              R := FSelected.BoundsRect;
              vgInflateRect(R, -0.5, -0.5);
              Canvas.FillRect(vgRect(R.Right - (GripSize), R.Top + vgRectHeight(R) / 2 - (GripSize), R.Right + (GripSize), R.Top + vgRectHeight(R) / 2 + (GripSize)), 0, 0, [], Opaque);
              Canvas.DrawRect(vgRect(R.Right - (GripSize), R.Top + vgRectHeight(R) / 2 - (GripSize), R.Right + (GripSize), R.Top + vgRectHeight(R) / 2 + (GripSize)), 0, 0, [], Opaque);
            end;
            { grid lines }
            if (FMoving or FLeftTop or FRightTop or FLeftBottom or FRightBottom or FTop or FBottom or FLeft or FRight) and
              (Length(FDesignGridLines) > 0) and (FSelected.Parent <> nil) and (FSelected.Parent.IsVisual) then
            begin
              ScaleMatrix := dcm_vgcore.IdentityMatrix;
              Canvas.SetMatrix(vgMatrixMultiply(ScaleMatrix, TvxVisualObject(FSelected.Parent).AbsoluteMatrix));
              Canvas.StrokeDash := vgDashDash;
              for i := 0 to High(FDesignGridLines) do
              begin
                if (FDesignGridLines[i].Position.Y + round(FDesignGridLines[i].Height / 2)) = (FSelected.Position.Y + round(FSelected.Height / 2)) then
                begin
                  Canvas.DrawLine(vgPoint(FSelected.Position.X + 0.5, Trunc(FSelected.Position.Y + (FSelected.Height / 2)) + 0.5),
                    vgPoint(FDesignGridLines[i].Position.X + 0.5, Trunc(FSelected.Position.Y + (FSelected.Height / 2)) + 0.5), 1);
                end;
                if (FDesignGridLines[i].Position.X + round(FDesignGridLines[i].Width / 2)) = (FSelected.Position.X + round(FSelected.Width / 2)) then
                begin
                  Canvas.DrawLine(vgPoint(Trunc(FSelected.Position.X + (FSelected.Width / 2)) + 0.5, FSelected.Position.Y + 0.5),
                    vgPoint(Trunc(FDesignGridLines[i].Position.X + (FDesignGridLines[i].Width / 2)) + 0.5, FDesignGridLines[i].Position.Y + 0.5), 1);
                end;
                if (FSelected.Position.X = FDesignGridLines[i].Position.X) or (FSelected.Position.Y = FDesignGridLines[i].Position.Y) then
                begin
                  Canvas.DrawLine(vgPoint(FSelected.Position.X + 0.5, FSelected.Position.Y + 0.5), vgPoint(FDesignGridLines[i].Position.X + 0.5, FDesignGridLines[i].Position.Y + 0.5), 1);
                end;
                if (FSelected.Position.X + FSelected.Width = FDesignGridLines[i].Position.X) then
                begin
                  Canvas.DrawLine(vgPoint(FDesignGridLines[i].Position.X + 0.5, FSelected.Position.Y + 0.5), vgPoint(FDesignGridLines[i].Position.X + 0.5, FDesignGridLines[i].Position.Y + 0.5), 1);
                end;
                if (FSelected.Position.Y + FSelected.Height = FDesignGridLines[i].Position.Y) then
                begin
                  Canvas.DrawLine(vgPoint(FSelected.Position.X + 0.5, FDesignGridLines[i].Position.Y + 0.5), vgPoint(FDesignGridLines[i].Position.X + 0.5, FDesignGridLines[i].Position.Y + 0.5), 1);
                end;
                if (FSelected.Position.X = FDesignGridLines[i].Position.X + FDesignGridLines[i].Width) then
                begin
                  Canvas.DrawLine(vgPoint(FDesignGridLines[i].Position.X + FDesignGridLines[i].Width + 0.5, FSelected.Position.Y + 0.5),
                    vgPoint(FDesignGridLines[i].Position.X + FDesignGridLines[i].Width + 0.5, FDesignGridLines[i].Position.Y + 0.5), 1);
                end;
                if (FSelected.Position.Y = FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height) then
                begin
                  Canvas.DrawLine(vgPoint(FSelected.Position.X + 0.5, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height + 0.5),
                    vgPoint(FDesignGridLines[i].Position.X + 0.5, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height + 0.5), 1);
                end;
                if (FSelected.Position.X + FSelected.Width = FDesignGridLines[i].Position.X + FDesignGridLines[i].Width) then
                begin
                  Canvas.DrawLine(vgPoint(FDesignGridLines[i].Position.X + FDesignGridLines[i].Width + 0.5, FSelected.Position.Y + 0.5),
                    vgPoint(FDesignGridLines[i].Position.X + FDesignGridLines[i].Width + 0.5, FDesignGridLines[i].Position.Y + 0.5), 1);
                end;
                if (FSelected.Position.Y + FSelected.Height = FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height) then
                begin
                  Canvas.DrawLine(vgPoint(FSelected.Position.X + 0.5, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height + 0.5),
                    vgPoint(FDesignGridLines[i].Position.X + 0.5, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height + 0.5), 1);
                end;
              end;
              Canvas.StrokeDash := vgDashSolid;
            end;
          end;
          { place message }
          if FDesignPlaceObject <> nil then
          begin
            ScaleMatrix := dcm_vgcore.IdentityMatrix;
            Canvas.SetMatrix(ScaleMatrix);

            R := FDesignPlaceObject.AbsoluteRect;
            Canvas.Stroke.SolidColor := $FF5B91DE;
            Canvas.DrawRect(R, 0, 0, AllCorners, 1);
            Canvas.Font.Family := 'Tahoma';
            Canvas.Font.Style := vgFontRegular;
            Canvas.Font.Size := 9;
            R.Bottom := R.Top;
            R.Top := R.Bottom - 19;
            R.Right := R.Left + 160;
            Canvas.Fill.SolidColor := $FF5B91DE;
            Canvas.FillRect(R, 0, 0, AllCorners, 1);
            Canvas.Fill.SolidColor := $FFFFFFFF;
            vgInflateRect(R, -2, -2);
            if FDesignPlaceObject.Name <> '' then
              Canvas.FillText(R, R, 'ALT-drag to place into [' + FDesignPlaceObject.Name + ']', false, 1, vgTextAlignNear, vgTextAlignCenter)
            else
              Canvas.FillText(R, R, 'ALT-drag to place into [' + FDesignPlaceObject.ClassName + ']', false, 1, vgTextAlignNear, vgTextAlignCenter);
          end;
        end;
        { design modes }
        if FDesignTime then
        begin
          ScaleMatrix := IdentityMatrix;
          Canvas.SetMatrix(ScaleMatrix);

          Canvas.Stroke.SolidColor := $FF5B91DE;
          Canvas.Font.Family := 'Tahoma';
          Canvas.Font.Style := vgFontRegular;
          Canvas.Font.Size := 9;
          R := vgRect(0, 0, 200, 17);
        end;
        { debug }
        if ShowUpdateRects then
          with Canvas do
          begin
            ResetClipRect;
            ScaleMatrix := IdentityMatrix;
            Canvas.SetMatrix(ScaleMatrix);
            Stroke.Style := vgBrushSolid;
            Stroke.Color := '#9000FF00';
            StrokeThickness := 1;
            Fill.Style := vgBrushNone;
            for i := 0 to High(FUpdateRects) do
            begin
              R := FUpdateRects[i];
              DrawRect(FUpdateRects[i], 0, 0, AllCorners, 0.5);
            end;
          end;
        {$IFDEF UPDATERECT}
        if not ShowUpdateRects then
          with Canvas do
          begin
            ResetClipRect;
            ScaleMatrix := IdentityMatrix;
            Canvas.SetMatrix(ScaleMatrix);
            Stroke.Style := vgBrushSolid;
            Stroke.Color := '#A000FF00';
            StrokeThickness := 1;
            Fill.Style := vgBrushNone;
            for i := 0 to High(FUpdateRects) do
            begin
              R := FUpdateRects[i];
              DrawRect(FUpdateRects[i], 0, 0, AllCorners, 0.5);
            end;
          end;
        {$ENDIF}
        Canvas.EndScene;
      end;

      if Assigned(OnFlush) then
        OnFlush(Self)
      else
      begin
        { buffer }
        {$IFDEF WINDOWS}
        if (not FTransparency) or (FTransparency and not (Parent is TCustomForm)) or (FDesignTime) then
          {$ENDIF}
        begin
          for i := 0 to High(FUpdateRects) do
          begin
            R := FUpdateRects[i];
            {$IFDEF WINDOWS}
            Canvas.FlushBufferRect(0, 0, FDC, FUpdateRects[i]);
            {$ELSE}
            Canvas.FlushBufferRect(0, 0, 0, R);
            {$ENDIF}
          end;
        end;
        { Transparancy }
        {$IFDEF WINDOWS}
        if FTransparency and (Parent is TCustomForm) then
          UpdateLayer;
        {$ENDIF}
      end;
    finally
      setLength(FUpdateRects, 0);
      FDrawing := false;
    end;
  end;
end;

{ Drag and Drop }

type
  THackControl = class(TCustomControl);

procedure TvxCustomScene.BeginVCLDrag(Source: TObject; ABitmap: TvxBitmap);
begin
  VCLDragSource := TCustomControl.Create(Self);
  VCLDragSource.Parent := Self;
  VCLDragSource.Width := 0;
  VCLDragSource.Height := 0;
  VCLDragSource.Tag := Integer(Source);
  VCLDragSource.BeginDrag(true, -1);
  THackControl(VCLDragSource).OnEndDrag := EndDragEvent;
end;

procedure TvxCustomScene.EndDragEvent(Sender, Target: TObject; X, Y: Integer);
begin
  if TObject(Pointer(VCLDragSource.Tag)) is TvxVisualObject then
    TvxVisualObject(Pointer(VCLDragSource.Tag)).DragEnd;
  VCLDragSource.Tag := 0;
end;

procedure TvxCustomScene.DoDragOver(Sender, Source: TObject; X, Y: Integer; State: TDragState;
  var Accept: Boolean);
var
  P: TvxPoint;
  NewTarget: TvxVisualObject;
  Data: TvxDragObject;
begin
  Accept := false;
  if Root = nil then
    Exit;

  FillChar(Data, SizeOf(Data), 0);
  if (VCLDragSource <> nil) and (VCLDragSource.Tag <> 0) then
    Data.Source := TvxObject(VCLDragSource.Tag)
  else
    Data.Source := Source;

  P := vgPoint(X, Y);
  NewTarget := Root.Visual.FindTarget(P, Data);

  if (VCLDragSource <> nil) and (NewTarget = TvxObject(VCLDragSource.Tag)) then
  begin
    if FTarget <> nil then
      TvxVisualObject(FTarget).DragLeave;
    FTarget := nil;
    Accept := false;
    Exit;
  end;

  if FTarget <> nil then
  begin
    TvxVisualObject(FTarget).DragOver(Data, P, Accept);
  end;
  if (NewTarget <> FTarget) then
  begin
    if FTarget <> nil then
      TvxVisualObject(FTarget).DragLeave;
    FTarget := NewTarget;
    if FTarget <> nil then
    begin
      TvxVisualObject(FTarget).DragEnter(Data, P);
    end;
  end;
  if FTarget = nil then
    Accept := false;
end;

procedure TvxCustomScene.DoDragDrop(Sender, Source: TObject;
  X, Y: Integer);
var
  Data: TvxDragObject;
begin
  if FTarget <> nil then
  begin
    FillChar(Data, SizeOf(Data), 0);
    if (VCLDragSource <> nil) and (VCLDragSource.Tag <> 0) then
      Data.Source := TvxObject(VCLDragSource.Tag)
    else
      Data.Source := Source;
    TvxVisualObject(FTarget).DragDrop(Data, vgPoint(X, Y));
  end;
  FTarget := nil;
end;

{$IFDEF WINDOWS}

const
  IID_IDropTargetHelper: TGUID = (
    D1: $4657278B; D2: $411B; D3: $11D2; D4: ($83, $9A, $00, $C0, $4F, $D9, $18, $D0));
  SID_IDropTargetHelper = '{4657278B-411B-11d2-839A-00C04FD918D0}';
  CLSID_DragDropHelper: TGUID = (
    D1: $4657278A; D2: $411B; D3: $11D2; D4: ($83, $9A, $00, $C0, $4F, $D9, $18, $D0));

type
  {_$EXTERNALSYM IDropTargetHelper}
  IDropTargetHelper = interface(IUnknown)
    [SID_IDropTargetHelper]
    function DragEnter(hwndTarget: HWND; const DataObj: IDataObject;
      var pt: TPoint; dwEffect: Longint): HResult; stdcall;
    function DragLeave: HResult; stdcall;
    function DragOver(var pt: TPoint; dwEffect: longInt): HResult; stdcall;
    function Drop(const DataObj: IDataObject; var pt: TPoint;
      dwEffect: longInt): HResult; stdcall;
    function Show(Show: BOOL): HResult; stdcall;
  end;

var
  FDropTargetHelper: IDropTargetHelper;
  FDataObj: IDataObject;

function TvxCustomScene.GetDataObject: TvxDragObject;
var
  formatEtc: TFORMATETC;
  stgMedium: TSTGMEDIUM;
  str: wideString;
  drop: HDrop;
  i, numFiles: integer;
  buffer: array[0..MAX_PATH] of widechar;
begin
  FillChar(Result, SizeOf(Result), 0);
  if not Assigned(FDataObj) then
    Exit;
  // get file name first
  with formatEtc do
  begin
    cfFormat := CF_HDROP;
    ptd := nil;
    dwAspect := DVASPECT_CONTENT;
    lindex := -1;
    tymed := TYMED_HGLOBAL;
  end;
  { Get the data }
  str := '';
  if FDataObj.GetData(formatEtc, stgMedium) = S_OK then
  begin
    try
      {Lock the global memory handle to get a pointer to the data}
      drop := HDrop(GlobalLock(stgMedium.hGlobal));
      { Replace Text }
      numFiles := DragQueryFile(drop, $FFFFFFFF, nil, 0);
      SetLength(Result.Files, numFiles);
      for i := 0 to numFiles - 1 do
      begin
        DragQueryFileW(drop, i, @buffer, sizeof(buffer));
        Result.Files[i] := buffer;
        if i = 0 then
          Result.Data := Result.Files[0];
      end;
    finally
      {Finished with the pointer}
      GlobalUnlock(stgMedium.hGlobal);
      {Free the memory}
      ReleaseStgMedium({$IFDEF FPC}@{$ENDIF}stgMedium);
    end;
  end
  else
  begin
    // get text
    formatEtc.cfFormat := CF_UNICODETEXT;
    if FDataObj.GetData(formatEtc, stgMedium) = S_OK then
    begin
      try
        {Lock the global memory handle to get a pointer to the data}
        str := PWideChar(GlobalLock(stgMedium.hGlobal));
        Result.Data := str;
      finally
        {Finished with the pointer}
        GlobalUnlock(stgMedium.hGlobal);
        {Free the memory}
        ReleaseStgMedium({$IFDEF FPC}@{$ENDIF}stgMedium);
      end;
    end
  end;
end;

function TvxCustomScene.DragEnter(const dataObj: IDataObject; grfKeyState: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF};
  pt: TPoint; var dwEffect: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}): HResult;
begin
  try
    if (Root = nil) and not (Root.IsVisual) then
    begin
      dwEffect := DROPEFFECT_NONE;
      Result := E_UNEXPECTED;
      Exit;
    end;
    FDataObj := dataObj;
    Result := S_OK;
    dwEffect := DROPEFFECT_NONE;
    if (Succeeded(CoCreateInstance(CLSID_DragDropHelper, nil, CLSCTX_INPROC_SERVER,
      IDropTargetHelper, FDropTargetHelper))) and
      (FDropTargetHelper <> nil) then
    begin
      if (Failed(FDropTargetHelper.DragEnter(Handle, DataObj, pt, dwEffect))) then
        FDropTargetHelper := nil;
    end;
  except
    dwEffect := DROPEFFECT_NONE;
    Result := E_UNEXPECTED;
  end;
end;

function TvxCustomScene.DragOver(grfKeyState: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}; pt: TPoint;
  var dwEffect: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}): HResult;
var
  P: TvxPoint;
  NewTarget: TvxVisualObject;
begin
  try
    dwEffect := DROPEFFECT_NONE;
    Result := S_OK;
    with ScreenToClient(pt) do
      P := vgPoint(X, Y);
    NewTarget := Root.Visual.FindTarget(P, GetDataObject);
    if (NewTarget <> FTarget) then
    begin
      if FTarget <> nil then
        TvxVisualObject(FTarget).DragLeave;
      FTarget := NewTarget;
      if FTarget <> nil then
      begin
        TvxVisualObject(FTarget).DragEnter(GetDataObject, P);
      end;
    end;
    if NewTarget <> nil then
      dwEffect := DROPEFFECT_LINK;
    if FDropTargetHelper <> nil then
      FDropTargetHelper.DragOver(pt, dwEffect);
  except
    dwEffect := DROPEFFECT_NONE;
    Result := E_UNEXPECTED;
  end;
end;

function TvxCustomScene.DragLeave: HResult;
begin
  if FTarget <> nil then
    TvxVisualObject(FTarget).DragLeave;
  if (FDropTargetHelper <> nil) then
    FDropTargetHelper.DragLeave;
  FTarget := nil;
  FDropTargetHelper := nil;
  FDataObj := nil;
  Result := S_OK;
end;

function TvxCustomScene.Drop(const dataObj: IDataObject; grfKeyState: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}; pt: TPoint;
  var dwEffect: {$IFDEF FPC}DWORD{$ELSE}Longint{$ENDIF}): HResult;
var
  P: TvxPoint;
begin
  try
    if (dataObj = nil) then
      Exit;
    if FTarget <> nil then
    begin
      with ScreenToClient(pt) do
        P := vgPoint(X, Y);
      TvxVisualObject(FTarget).DragDrop(GetDataObject, P);
    end;
    if (FDropTargetHelper <> nil) then
      FDropTargetHelper.Drop(DataObj, pt, dwEffect)
  finally
    FDataObj := nil;
    FDropTargetHelper := nil;
  end;
end;

procedure TvxCustomScene.WMAddUpdateRect(var Msg: TMessage);
  procedure ProcessUpdateMessages;
  var
    Msg: TMsg;
  begin
    while PeekMessage(Msg, Handle, WM_ADDUPDATERECT, WM_ADDUPDATERECT, PM_REMOVE) do
    begin
      if Msg.message = WM_QUIT then
      begin
        { Repost WM_QUIT messages }
        PostQuitMessage(Msg.WParam);
        Break;
      end;
    end;
  end;
begin
  ProcessUpdateMessages;
  Draw;
end;

{$ENDIF}

{$IFDEF LINUX}

procedure TvxCustomScene.EraseBackground(DC: HDC);
begin
end;
{$ENDIF}

procedure TvxCustomScene.Paint;
begin
  {$IFDEF LINUX}
  Canvas.Handle := Integer(gdk_cairo_create(TGtkDeviceContext(inherited Canvas.Handle).Drawable));

  if FTransparency then
  begin
    cairo_set_operator(Pcairo_t(Canvas.Handle), CAIRO_OPERATOR_SOURCE);
    cairo_set_source_rgba(Pcairo_t(Canvas.Handle), 0, 0, 0, 0);
    cairo_paint(Pcairo_t(Canvas.Handle));
    cairo_set_operator(Pcairo_t(Canvas.Handle), CAIRO_OPERATOR_OVER);
  end;
  //  if Length(FUpdateRects) = 0 then
  begin
    // update all area
    SetLength(FUpdateRects, 1);
    FUpdateRects[0] := vgRect(0, 0, Width, Height);
  end;
  Draw;
  cairo_destroy(Pcairo_t(Canvas.Handle));
  Canvas.Handle := 0;
  {$ENDIF}
end;

function TvxCustomScene.ObjectByPoint(X, Y: single): TvxVisualObject;
var
  i: integer;
  Obj, NewObj: TvxObject;
begin
  Result := nil;
  for i := Count - 1 downto 0 do
  begin
    Obj := Children[i];
    if not (Obj.IsVisual) then
      Exit;
    if not TvxVisualObject(Obj).Visible and not (FDesignTime) then
      Continue;

    NewObj := TvxVisualObject(Obj).ObjectByPoint(X, Y);
    if NewObj <> nil then
    begin
      Result := TvxVisualObject(NewObj);
      Exit;
    end;
  end;
end;

procedure TvxCustomScene.CMShowingChanged(var Message: {$IFDEF FPC}TLMessage{$ELSE}TMessage{$ENDIF});
begin
  inherited;
  AddUpdateRect(vgRect(0, 0, Width, Height));
end;

procedure TvxCustomScene.CMDesignHitTest(var Msg: {$IFDEF FPC}TLMMouse{$ELSE}TWMMouse{$ENDIF});
var
  Obj: TvxVisualObject;
  P: TvxPoint;
begin
  inherited;

  if (FChildren = nil) or (FChildren.Count = 0) then
  begin
    Msg.Result := 1;
    Exit;
  end;

  P := vgPoint(Msg.XPos, Msg.YPos);
  if (FMoving or FLeftTop or FRightTop or FLeftBottom or FRightBottom) then
  begin
    Msg.Result := 1;
    Exit;
  end;
  Obj := ObjectByPoint(P.X, P.Y);
  if Obj = nil then
  begin
    if (FSelected <> nil) and (vgPtInRect(vgPoint(P.X, P.Y), FSelected.AbsoluteRect)) then
      Msg.Result := 1
    else
      Msg.Result := 0
  end
  else
  begin
    Msg.Result := 1;
  end;
end;

procedure TvxCustomScene.CMHintShow(var Message: {$IFDEF FPC}TLMessage{$ELSE}TMessage{$ENDIF});
var
  Obj: TvxVisualObject;
begin
  inherited;
  with TCMHintShow(Message).HintInfo^ do
  begin
    Obj := ObjectByPoint(CursorPos.X, CursorPos.Y);
    if (Obj <> nil) and (Obj.ShowHint) then
    begin
      HintStr := Obj.Hint;
      with Obj.AbsoluteRect do
        CursorRect := Rect(Trunc(Left), Trunc(Top), Trunc(Right), Trunc(Bottom));
    end
    else
    begin
      HintStr := '';
    end;
  end;
end;

{$IFDEF WINDOWS}

procedure TvxCustomScene.CMMouseLeave(var Message: TMessage);
begin
  inherited;
  if FHovered <> nil then
  begin
    TvxVisualObject(FHovered).MouseInObject := false;
    TvxVisualObject(FHovered).MouseLeave;
    TvxVisualObject(FHovered).RemoveFreeNotify(Self);
    FHovered := nil;
  end;
end;

type
  PRgnRects = ^TRgnRects;
  TRgnRects = array[0..0] of TRect;

procedure TvxCustomScene.WMEraseBkgnd(var Msg: TWMEraseBkgnd);
var
  rgnStatus: integer;
  rgn: HRgn;
begin
  if (Msg.DC <> 0) and (Canvas <> nil) then
  begin
    rgn := CreateRectRgn(0, 0, 1, 1);
    rgnStatus := GetUpdateRgn(Handle, rgn, false);
    if (rgnStatus = 1) then
    begin
      Canvas.FlushBuffer(0, 0, Msg.DC);
    end;
    DeleteObject(rgn);
  end;
  Msg.Result := 1;
end;

procedure TvxCustomScene.WMPaint(var Msg: TWMPaint);
var
  i, rgnStatus: integer;
  rgn: HRgn;
  rgnSize: integer;
  rgnData: PRgnData;
  R: windows.TRect;
begin
  if FDrawing then
    Exit;
  rgn := CreateRectRgn(0, 0, 1, 1);
  rgnStatus := GetUpdateRgn(Handle, rgn, false);
  if (rgnStatus = 2) or (rgnStatus = 3) then
  begin
    rgnSize := GetRegionData(rgn, $FFFF, nil);
    if rgnSize > 0 then
    begin
      GetMem(rgnData, rgnSize);
      rgnSize := GetRegionData(rgn, rgnSize, rgnData);
      if rgnSize = rgnSize then
      begin
        SetLength(FUpdateRects, rgnData.rdh.nCount);
        for i := 0 to rgnData.rdh.nCount - 1 do
        begin
          R := PRgnRects(@rgnData.buffer[0])[i];
          with R do
            FUpdateRects[i] := vgRect(left, top, right, bottom);
        end;
      end;
      FreeMem(rgnData, rgnSize);

      FDC := GetDC(Handle);
      Draw;
      ReleaseDC(Handle, FDC);
      FDC := 0;

      {$IFDEF FPC}
      FDrawing := true;
      Msg.result := CallWindowProcW(@PrevWndProc, Handle, Msg.Msg, TMessage(Msg).WParam, TMessage(Msg).LParam);
      FDrawing := false;
      {$ELSE}
      inherited;
      {$ENDIF}
    end
    else
    begin
      {$IFDEF FPC}
      FDrawing := true;
      Msg.result := CallWindowProcW(@PrevWndProc, Handle, Msg.Msg, TMessage(Msg).WParam, TMessage(Msg).LParam);
      FDrawing := false;
      {$ELSE}
      inherited;
      {$ENDIF}
    end;
  end
  else
  begin
    {$IFDEF FPC}
    FDrawing := true;
    Msg.result := CallWindowProcW(@PrevWndProc, Handle, Msg.Msg, TMessage(Msg).WParam, TMessage(Msg).LParam);
    FDrawing := false;
    {$ELSE}
    inherited;
    {$ENDIF}
  end;
  DeleteObject(rgn);
end;

{$IFNDEF FPC}

procedure TvxCustomScene.WMGetDlgCode(var Msg: TWMGetDlgCode);
begin
  inherited;
  Msg.Result := DLGC_WANTTAB or dlgc_WantArrows or DLGC_WANTCHARS;
end;

procedure TvxCustomScene.WMKeyDown(var Message: TWMKeyDown);
var
  ShiftState: TShiftState;
  Ch: WideChar;
  NewKey: word;
begin
  inherited;
  with Message do
  begin
    Ch := #0;
    NewKey := Message.CharCode;
    ShiftState := KeyDataToShiftState(KeyData);
    UnicodeKeyDown(NewKey, Ch, ShiftState);
  end;
end;

procedure TvxCustomScene.WMKeyUp(var Message: TWMKeyUp);
var
  ShiftState: TShiftState;
  Ch: WideChar;
  NewKey: word;
begin
  inherited;
  with Message do
  begin
    Ch := #0;
    NewKey := Message.CharCode;
    ShiftState := KeyDataToShiftState(KeyData);
    UnicodeKeyUp(NewKey, Ch, ShiftState);
  end;
end;

procedure TvxCustomScene.WMChar(var Message: TWMChar);
var
  ShiftState: TShiftState;
  Ch: WideChar;
  NewKey: word;
begin
  with Message do
  begin
    Ch := Widechar(CharCode);
    ShiftState := KeyDataToShiftState(KeyData);
    case Ch of
      #1: // ctrl+c
        begin
          Ch := 'a';
          UnicodeKeyDown(NewKey, Ch, ShiftState);
          UnicodeKeyUp(NewKey, Ch, ShiftState);
        end;
      #3: // ctrl+c
        begin
          Ch := 'c';
          UnicodeKeyDown(NewKey, Ch, ShiftState);
          UnicodeKeyUp(NewKey, Ch, ShiftState);
        end;
      #$16: // ctrl+v
        begin
          Ch := 'v';
          UnicodeKeyDown(NewKey, Ch, ShiftState);
          UnicodeKeyUp(NewKey, Ch, ShiftState);
        end;
      #$18: // ctrl+x
        begin
          Ch := 'x';
          UnicodeKeyDown(NewKey, Ch, ShiftState);
          UnicodeKeyUp(NewKey, Ch, ShiftState);
        end;
      #$1A: // ctrl+z
        begin
          Ch := 'z';
          UnicodeKeyDown(NewKey, Ch, ShiftState);
          UnicodeKeyUp(NewKey, Ch, ShiftState);
        end;
      #13:
        begin
        end;
    else
      NewKey := 0;
      UnicodeKeyDown(NewKey, Ch, ShiftState);
    end;
  end;
  inherited;
end;

procedure AssignToLogFont(var LogFont: TLogFont; Font: TvxFont);
var
  ppi: Integer;
  b: TBitmap;
begin
  FillChar(LogFont, sizeof(LogFont), 0);
  b := TBitmap.Create;
  b.Width := 1;
  b.Height := 1;
  b.Canvas.Font.Name := Font.Family;
  with LogFont do
  begin
    ppi := b.Canvas.Font.PixelsPerInch;
    lfHeight := -MulDiv(trunc(Font.size), ppi, 72);
    if Font.Style in [vgFontBoldItalic, vgFontBold] then
      lfWeight := FW_BOLD
    else
      lfWeight := FW_NORMAL;
    lfItalic := Byte(Font.Style in [vgFontBoldItalic, vgFontItalic]);
    lfUnderline := 0;
    lfStrikeOut := 0;
    StrPCopy(lfFaceName, b.Canvas.Font.Name);
    lfQuality := DEFAULT_QUALITY;
    lfOutPrecision := OUT_DEFAULT_PRECIS;
    lfClipPrecision := CLIP_DEFAULT_PRECIS;
    lfPitchAndFamily := DEFAULT_PITCH;
  end;
  b.Free;
end;

procedure TvxCustomScene.WMImeStartComposition(var Message: TMessage);
var
  IMC: HIMC;
  LogFont: TLogFont;
  CF: TCompositionForm;
begin
  Message.Result := 1;
  inherited;
  IMC := ImmGetContext(Handle);
  if IMC <> 0 then
  begin
    if (Focused <> nil) and (Focused is TvxTextControl) then
      AssignToLogFont(LogFont, TvxTextControl(Focused).Font);
    ImmSetCompositionFont(IMC, @LogFont);
    CF.dwStyle := CFS_RECT;
    CF.rcArea := ClientRect;
    if Focused <> nil then
    begin
      with Focused.LocalToAbsolute(vgPoint(0, 0)) do
        CF.ptCurrentPos := Point(trunc(x), trunc(y));
      if Focused is TvxTextBox then
      begin
        CF.ptCurrentPos.X := CF.ptCurrentPos.X + Trunc(TvxTextBox(Focused).ContentRect.Left);
        CF.ptCurrentPos.Y := CF.ptCurrentPos.Y + Trunc(TvxTextBox(Focused).ContentRect.Top);
        CF.ptCurrentPos.X := CF.ptCurrentPos.X + Trunc(TvxTextBox(Focused).GetCharX(TvxTextBox(Focused).CaretPosition));
      end;
      if Focused is TvxMemo then
      begin
        with TvxMemo(Focused).GetPositionPoint(TvxMemo(Focused).CaretPosition) do
        begin
          CF.ptCurrentPos.X := CF.ptCurrentPos.X + Trunc(x);
          CF.ptCurrentPos.Y := CF.ptCurrentPos.Y + Trunc(y);
        end;
      end;
    end;
    if (GetKeyboardLayout(0) and $FFFF) = $0412 then
    begin // Special support for Korean IME
      CF.rcArea.TopLeft := CF.ptCurrentPos;
      OffsetRect(CF.rcArea, 0, 1);
    end;
    ImmSetCompositionWindow(IMC, @CF);
    ImmReleaseContext(Handle, IMC);
  end;
end;

procedure TvxCustomScene.WMImeComposition(var Message: TMessage);
var
  i: integer;
  IMC: HIMC;
  s: WideString;
  Size: Integer;
  key: word;
  char: widechar;
begin
  if (Message.LParam and GCS_RESULTSTR) <> 0 then
  begin
    IMC := ImmGetContext(Handle);
    if IMC <> 0 then
    begin
      begin
        try
          Size := ImmGetCompositionStringW(IMC, GCS_RESULTSTR, nil, 0);
          SetLength(s, Size div 2);
          FillChar(PChar(s)^, Size, 0);
          ImmGetCompositionStringW(IMC, GCS_RESULTSTR, PWideChar(s), Size);
        finally
          ImmReleaseContext(Handle, IMC);
        end;
      end;
      for i := 1 to Length(s) do
      begin
        key := 0;
        char := s[i];
        UnicodeKeyDown(key, char, []);
      end;
      Message.Result := 0;
    end;
    if (GetKeyboardLayout(0) and $FFFF) = $0412 then // Special support for Korean IME
      PostMessage(Handle, WM_IME_STARTCOMPOSITION, 0, 0);
  end
  else
    inherited;
end;

{$ENDIF}

{$ENDIF}

procedure TvxCustomScene.UnicodeKeyDown(var Key: Word; var Char: System.WideChar;
  Shift: TShiftState);
var
  List: TList;
  i, CurIdx: integer;
  Found: boolean;
  O: TComponent;
begin
  { dialog key }
  if (Key = VK_ESCAPE) or (Key = VK_RETURN) or (Key = VK_LEFT) or (Key = VK_RIGHT) or (Key = VK_UP) or (Key = VK_DOWN) or
    (Key = VK_HOME) or (Key = VK_END) or (Key = VK_ADD) or (Key = VK_SUBTRACT) then
  begin
    TvxVisualObject(Root).DialogKey(Key, Shift);
    if Key = 0 then
      Exit;
  end;
  { modal }
  if (Key = VK_ESCAPE) then
  begin
    O := Owner;
    while O <> nil do
    begin
      if (O is TCustomForm) and (fsModal in TCustomForm(O).FormState) then
      begin
        TCustomForm(O).ModalResult := mrCancel;
        Key := 0;
        Break;
      end;
      O := O.Owner;
    end;
    if Key = 0 then
      Exit;
  end;
  { change focus }
  if (Key = VK_TAB) and (Root <> nil) then
  begin
    Key := 0;
    List := TList.Create;
    TvxVisualObject(Root).GetTabOrderList(List, true);

    Found := false;
    if ssShift in Shift then
    begin
      { second search in first part of list }
      if FFocused <> nil then
        CurIdx := List.IndexOf(FFocused) - 1
      else
        CurIdx := List.Count - 1;
      if CurIdx > 0 then
        for i := CurIdx - 1 downto 0 do
          if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
          begin
            TvxVisualObject(List[i]).SetFocus;
            Found := true;
            Break;
          end;
      { first search in last part of list }
      if not Found then
        if (List.Count > 2) and (CurIdx < List.Count) then
          for i := List.Count - 1 downto CurIdx do
            if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
            begin
              TvxVisualObject(List[i]).SetFocus;
              Break;
            end;
    end
    else
    begin
      if FFocused <> nil then
        CurIdx := List.IndexOf(FFocused) + 1
      else
        CurIdx := 0;
      { first search in last part of list }
      if (List.Count > 2) and (CurIdx < List.Count) then
        for i := CurIdx to List.Count - 1 do
          if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
          begin
            TvxVisualObject(List[i]).SetFocus;
            Found := true;
            Break;
          end;
      { second search in first part of list }
      if not Found then
        if CurIdx > 0 then
          for i := 0 to CurIdx - 1 do
            if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
            begin
              TvxVisualObject(List[i]).SetFocus;
              Break;
            end;
    end;
    List.Free;
    Exit;
  end;
  { focused handler }
  if FFocused <> nil then
  begin
    TvxVisualObject(FFocused).KeyDown(Key, Char, Shift);
  end;
end;

procedure TvxCustomScene.UnicodeKeyUp(var Key: Word; var Char: System.WideChar;
  Shift: TShiftState);
begin
  if FDesignTime or (FDesignTime) then
  begin
    if (Key = VK_DELETE) and (FSelected <> nil) then
    begin
      FSelected.Free;
      FSelected := nil;
    end;
  end;
  { focused handler }
  if FFocused <> nil then
  begin
    TvxVisualObject(FFocused).KeyUp(Key, Char, Shift);
  end;
end;

procedure TvxCustomScene.DeleteChildren;
var
  Child: TvxObject;
begin
  if Assigned(FChildren) then
  begin
    while FChildren.Count > 0 do
    begin
      Child := TvxObject(FChildren[0]);
      FChildren.Delete(0);
      TvxVisualObject(Child).FParent := nil;
      TvxVisualObject(Child).FScene := nil;
      Child.Free;
    end;
    FreeAndNil(FChildren);
  end;
end;

procedure TvxCustomScene.AddObject(AObject: TvxObject);
begin
  if AObject = nil then
    Exit;
  if AObject.Parent <> nil then
    AObject.Parent := nil;
  if FChildren = nil then
    FChildren := TList.Create;
  FChildren.Add(AObject);
  TvxVisualObject(AObject).SetNewScene(Self);
  if AObject.IsVisual and not (csDestroying in ComponentState) then
  begin
    TvxVisualObject(AObject).RecalcUpdateRect;
    TvxVisualObject(AObject).RecalcAbsolute;
    TvxVisualObject(AObject).Repaint;
    RealignRoot;
  end;
end;

procedure TvxCustomScene.RemoveObject(AObject: TvxObject);
begin
  if FChildren <> nil then
  begin
    Invalidate;
    TvxVisualObject(AObject).SetNewScene(nil);
    Notification(AObject, opRemove);
    FChildren.Remove(AObject);
  end;
end;

function TvxCustomScene.GetCount: integer;
begin
  if FChildren <> nil then
    Result := FChildren.Count
  else
    Result := 0;
end;

function TvxCustomScene.GetChildrenObject(Index: integer): TvxObject;
begin
  if FChildren <> nil then
    Result := TvxObject(FChildren[Index])
  else
    Result := nil;
end;

procedure TvxCustomScene.SetChildren(Index: integer; const Value: TvxObject);
begin
end;

procedure TvxCustomScene.BeginDrag;
var
  P: TPoint;
begin
  if (Parent <> nil) and (Parent.Tag = $FFFF) then
    Exit; // Disable for popup

  FDragging := true;

  GetCursorPos(P);
  P := TWinControl(Owner).ScreenToClient(P);
  FDownPos := vgPoint(P.X, P.Y);
  MouseCapture;
end;

procedure TvxCustomScene.BeginResize;
var
  P: TPoint;
begin
  FResizing := true;
  GetCursorPos(P);
  P := TWinControl(Owner).ScreenToClient(P);
  FDownPos := vgPoint(P.X, P.Y);
  FResizeSize := Point(TWinControl(Owner).Width, TWinControl(Owner).Height);
  MouseCapture;
end;

function TvxCustomScene.SnapToGridValue(Value: single): single;
begin
  if (DesignSnapToGrid) and (DesignSnapGridSize <> 0) then
    Result := Trunc(Value / DesignSnapGridSize) * DesignSnapGridSize
  else
    Result := Value;
end;

procedure TvxCustomScene.AddUpdateRectsFromGridLines;
  procedure IntAddUpdateRect(const R: TvxRect);
  var
    i: integer;
  begin
    for i := 0 to High(FUpdateRects) do
      with FUpdateRects[i] do
        if (R.Left = Left) and (R.Top = Top) and (R.Right = Right) and (R.Bottom = Bottom) then
        begin
          Exit;
        end;
    AddUpdateRect(R);
  end;
var
  i: integer;
begin
  { Add grip lines }
  if FDesignTime and (FSelected <> nil) and not FSelected.DisableDesignResize and
    (FMoving or FLeftTop or FRightTop or FLeftBottom or FRightBottom or FTop or FBottom or FLeft or FRight) and
    (Length(FDesignGridLines) > 0) and (FSelected.Parent <> nil) and (FSelected.Parent.IsVisual) then
  begin
    for i := 0 to High(FDesignGridLines) do
    begin
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FSelected.Position.X - 1, FSelected.Position.Y + (FSelected.Height / 2) - 1,
        FDesignGridLines[i].Position.X + 1, FDesignGridLines[i].Position.Y + (FDesignGridLines[i].Height / 2) + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FSelected.Position.X + (FSelected.Width / 2) - 1, FSelected.Position.Y - 1,
        FDesignGridLines[i].Position.X + (FDesignGridLines[i].Width / 2) + 1, FDesignGridLines[i].Position.Y + 1)));

      IntAddUpdateRect(vgNormalizeRect2(vgRect(FSelected.Position.X - 1, FSelected.Position.Y - 1, FDesignGridLines[i].Position.X + 1, FDesignGridLines[i].Position.Y + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FDesignGridLines[i].Position.X - 1, FSelected.Position.Y - 1, FDesignGridLines[i].Position.X + 1, FDesignGridLines[i].Position.Y + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FSelected.Position.X - 1, FDesignGridLines[i].Position.Y - 1, FDesignGridLines[i].Position.X + 1, FDesignGridLines[i].Position.Y + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FDesignGridLines[i].Position.X + FDesignGridLines[i].Width - 1, FSelected.Position.Y - 1,
        FDesignGridLines[i].Position.X + FDesignGridLines[i].Width + 1, FDesignGridLines[i].Position.Y + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FSelected.Position.X - 1, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height - 1,
        FDesignGridLines[i].Position.X + 1, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FDesignGridLines[i].Position.X + FDesignGridLines[i].Width - 1, FSelected.Position.Y - 1,
        FDesignGridLines[i].Position.X + FDesignGridLines[i].Width + 1, FDesignGridLines[i].Position.Y + 1)));
      IntAddUpdateRect(vgNormalizeRect2(vgRect(FSelected.Position.X - 1, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height - 1,
        FDesignGridLines[i].Position.X + 1, FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height + 1)));
    end;
  end;
end;

procedure TvxCustomScene.SnapToGridLines(AllowChangePosition: boolean);
  procedure AddGridLine(const Obj: TvxVisualObject);
  var
    i: integer;
  begin
    for i := 0 to High(FDesignGridLines) do
      if FDesignGridLines[i] = Obj then
        Exit;
    SetLength(FDesignGridLines, Length(FDesignGridLines) + 1);
    FDesignGridLines[High(FDesignGridLines)] := Obj;
  end;
const
  SnapLineSize = 2;
var
  i: integer;
begin
  if (DesignSnapToLines) and (FSelected.Parent <> nil) then
    for i := 0 to FSelected.Parent.ChildrenCount - 1 do
    begin
      if TvxObject(FSelected.Parent.Children[i]) = FSelected then
        Continue;
      if not TvxObject(FSelected.Parent.Children[i]).isVisual then
        Continue;
      with TvxVisualObject(FSelected.Parent.Children[i]) do
      begin
        if (Abs((Position.Y + round(Height / 2)) - (FSelected.Position.Y + round(FSelected.Height / 2))) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.Y := FMousePos.Y + ((Position.Y + round(Height / 2)) - (FSelected.Position.Y + round(FSelected.Height / 2)));
            FSelected.Position.Y := (Position.Y + round(Height / 2) - round(FSelected.Height / 2));
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs((Position.X + round(Width / 2)) - (FSelected.Position.X + round(FSelected.Width / 2))) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.X := FMousePos.X + ((Position.X + round(Width / 2)) - (FSelected.Position.X + round(FSelected.Width / 2)));
            FSelected.Position.X := (Position.X + round(Width / 2) - round(FSelected.Width / 2));
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs(Position.X - FSelected.Position.X) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.X := FMousePos.X + (Position.X - FSelected.Position.X);
            FSelected.Position.X := Position.X;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs(Position.Y - FSelected.Position.Y) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.Y := FMousePos.Y + (Position.Y - FSelected.Position.Y);
            FSelected.Position.Y := Position.Y;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs(Position.X - (FSelected.Position.X + FSelected.Width)) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.X := FMousePos.X + (Position.X - (FSelected.Position.X + FSelected.Width));
            FSelected.Position.X := Position.X - FSelected.Width;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs(Position.Y - (FSelected.Position.Y + FSelected.Height)) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.Y := FMousePos.Y + (Position.Y - (FSelected.Position.Y + FSelected.Height));
            FSelected.Position.Y := Position.Y - FSelected.Height;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs((Position.X + Width) - FSelected.Position.X) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.X := FMousePos.X + ((Position.X + Width) - FSelected.Position.X);
            FSelected.Position.X := Position.X + Width;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs((Position.Y + Height) - FSelected.Position.Y) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.Y := FMousePos.Y + ((Position.Y + Height) - FSelected.Position.Y);
            FSelected.Position.Y := Position.Y + Height;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs((Position.X + Width) - (FSelected.Position.X + FSelected.Width)) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.X := FMousePos.X + ((Position.X + Width) - (FSelected.Position.X + FSelected.Width));
            FSelected.Position.X := Position.X + Width - FSelected.Width;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
        if (Abs((Position.Y + Height) - (FSelected.Position.Y + FSelected.Height)) < SnapLineSize) then
        begin
          if AllowChangePosition then
          begin
            FMousePos.Y := FMousePos.Y + ((Position.Y + Height) - (FSelected.Position.Y + FSelected.Height));
            FSelected.Position.Y := Position.Y + Height - FSelected.Height;
          end;
          AddGridLine(TvxVisualObject(FSelected.Parent.Children[i]));
          Continue;
        end;
      end;
    end;
  AddUpdateRectsFromGridLines;
end;

function TvxCustomScene.SnapPointToGridLines(const APoint: TvxPoint): TvxPoint;
var
  i: integer;
begin
  Result := APoint;
  if not DesignSnapToLines then
    Exit;
  if FSelected = nil then
    Exit;
  if FSelected.Parent = nil then
    Exit;
  SnapToGridLines(false);
  if Length(FDesignGridLines) > 0 then
  begin
    Result := FSelected.LocalToAbsolute(APoint);
    Result := TvxVisualObject(FSelected.Parent).AbsoluteToLocal(Result);
    for i := 0 to High(FDesignGridLines) do
    begin
      if Abs(Result.X - FDesignGridLines[i].Position.X) < (4) then
        Result.X := FDesignGridLines[i].Position.X;
      if Abs(Result.Y - FDesignGridLines[i].Position.Y) < (4) then
        Result.Y := FDesignGridLines[i].Position.Y;
      if Abs(Result.X - (FDesignGridLines[i].Position.X + FDesignGridLines[i].Width)) < (4) then
        Result.X := FDesignGridLines[i].Position.X + FDesignGridLines[i].Width;
      if Abs(Result.Y - (FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height)) < (4) then
        Result.Y := FDesignGridLines[i].Position.Y + FDesignGridLines[i].Height;
    end;
    Result := TvxVisualObject(FSelected.Parent).LocalToAbsolute(Result);
    Result := FSelected.AbsolutetoLocal(Result);
  end;
end;

procedure TvxCustomScene.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: Integer);
var
  P: TvxPoint;
  R: TvxRect;
  Obj: TvxVisualObject;
  SG: IvgSizeGrip;
  i: integer;
begin
  inherited;
  if not (FDesignTime) and not Assigned(FOnFlush) and not (csDesigning in ComponentState) then
    SetFocus;
  { translate coord }
  FUnsnapMousePos := vgPoint(x, y);
  FMousePos := vgPoint(SnapToGridValue(x), SnapToGridValue(y));
  FDownPos := FMousePos;
  SetLength(FDesignGridLines, 0);
  { design }
  if FDesignTime then
  begin
    { Create root }
    if ((FChildren = nil) or (FChildren.Count = 0)) then
    begin
      Obj := TvxBackground.Create(Owner);
      if vgDesigner <> nil then
        Obj.Name := vgDesigner.UniqueName(Owner, 'Root');
      AddObject(Obj);
      RealignRoot;
    end;
    { Popup }
    if Button = mbRight then
      OpenDesignPopup;
    { Resize }
    if (FSelected <> nil) and (not FSelected.DisableDesignResize) then
    begin
      P := FSelected.AbsoluteToLocal(vgPoint(FUnsnapMousePos.X, FUnsnapMousePos.Y));
      R := vgRect(FSelected.Width / 2 - (GripSize), -RotSize - (GripSize),
        (FSelected.Width) / 2 + (GripSize), -RotSize + (GripSize));
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FRotate := true;
        FMoving := false;
        Exit;
      end;
      P := FSelected.AbsoluteToLocal(vgPoint(FUnsnapMousePos.X, FUnsnapMousePos.Y));
      R := vgRect(-GripSize, -GripSize, GripSize, GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FLeftTop := true;
        FMoving := false;
        Exit;
      end;
      R := FSelected.BoundsRect;
      R := vgRect(R.Right - GripSize, -GripSize, R.Right + GripSize, GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FRightTop := true;
        FMoving := false;
        Exit;
      end;
      R := FSelected.BoundsRect;
      R := vgRect(-GripSize, R.Bottom - GripSize, GripSize, R.Bottom + GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FLeftBottom := true;
        FMoving := false;
        Exit;
      end;
      R := FSelected.BoundsRect;
      R := vgRect(R.Right - GripSize, R.Bottom - GripSize, R.Right + GripSize, R.Bottom + GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FRightBottom := true;
        FMoving := false;
        Exit;
      end;

      R := FSelected.BoundsRect;
      R := vgRect(vgRectWidth(R) / 2 - GripSize, -GripSize, vgRectWidth(R) / 2 + GripSize, GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FTop := true;
        FMoving := false;
        Exit;
      end;
      R := FSelected.BoundsRect;
      R := vgRect(vgRectWidth(R) / 2 - GripSize, R.Bottom - GripSize, vgRectWidth(R) / 2 + GripSize, R.Bottom + GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FBottom := true;
        FMoving := false;
        Exit;
      end;
      R := FSelected.BoundsRect;
      R := vgRect(-GripSize, vgRectHeight(R) / 2 - GripSize, GripSize, vgRectHeight(R) / 2 + GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FLeft := true;
        FMoving := false;
        Exit;
      end;
      R := FSelected.BoundsRect;
      R := vgRect(R.Right - GripSize, vgRectHeight(R) / 2 - GripSize, R.Right + GripSize, vgRectHeight(R) / 2 + GripSize);
      if vgPtInRect(P, R) then
      begin
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, FSelected, []);
        if Assigned(FDesignChangeSelection) then
          FDesignChangeSelection(Self);
        FRight := true;
        FMoving := false;
        Exit;
      end;
    end;
    { Change Selected }
    Obj := ObjectByPoint(FUnsnapMousePos.X, FUnsnapMousePos.Y);
    if (Obj <> nil) and (Obj = FSelected) and (ssDouble in Shift) then
    begin
      TvxVisualObject(Obj).DesignClick;
    end;
    if (Obj <> nil) then
    begin
      if (ssCtrl in Shift) and (Obj <> Selected) then
      begin
        { check is exists }
        for i := 0 to High(FSelection) do
          if FSelection[i] = Obj then
          begin
            FSelection[i] := Selected;
            Obj := nil;
          end;
        if Obj <> nil then
        begin
          SetLength(FSelection, Length(FSelection) + 1);
          FSelection[High(FSelection)] := Obj;
        end;
        if vgDesigner <> nil then
          vgDesigner.SelectObject(Owner, Selected, FSelection);
        Exit;
      end;
      SetLength(FSelection, 0);
      if FSelected <> nil then
      begin
        TvxVisualObject(FSelected).RecalcUpdateRect;
        FSelected.Repaint;
      end;
      FSelected := Obj;
      TvxVisualObject(FSelected).DesignSelect;
      { Select in IDE }
      if vgDesigner <> nil then
        vgDesigner.SelectObject(Owner, Obj, []);
      if Assigned(FDesignChangeSelection) then
        FDesignChangeSelection(Self);
      { }
      TvxVisualObject(FSelected).RecalcUpdateRect;
      FSelected.Repaint;

      if (Obj = FSelected) then
        FMoving := true;
    end;
    Exit;
  end;
  { event }
  if not FDesignTime then
  begin
    Obj := TvxVisualObject(ObjectByPoint(FMousePos.X, FMousePos.Y));
    if (Obj <> nil) then
    begin
      if (TvxVisualObject(Obj).QueryInterface(IvgSizeGrip, SG) = 0) and (Assigned(SG)) then
      begin
        BeginResize;
      end
      else
      begin
        P := Obj.AbsoluteToLocal(vgPoint(FMousePos.X, FMousePos.Y));
        TvxVisualObject(Obj).MouseDown(Button, Shift, P.X, P.Y);
        if (TvxVisualObject(Obj).FDragMode = vgDragAutomatic) then
        begin
          TvxVisualObject(Obj).BeginAutoDrag;
        end;
      end;
    end
    else
      BeginDrag;
  end;
end;

procedure TvxCustomScene.MouseMove(Shift: TShiftState; X, Y: Integer);
var
  R: TvxRect;
  P, P1: TvxPoint;
  Obj: TvxVisualObject;
  SG: IvgSizeGrip;
  NewCursor: TCursor;
  i: integer;
begin
  inherited;
  NewCursor := FLoadCursor;
  { drag }
  if FDragging then
  begin
    with TWinControl(Owner) do
      SetBounds(Round(Left + (X - FDownPos.X)), Round(Top + (Y - FDownPos.Y)), Width, Height);
    Exit;
  end;
  if FResizing then
  begin
    FResizeSize.X := Round(FResizeSize.X + (X - FUnsnapMousePos.X));
    FResizeSize.Y := Round(FResizeSize.Y + (Y - FUnsnapMousePos.Y));
    with TWinControl(Owner) do
      SetBounds(Left, Top, FResizeSize.X, FResizeSize.Y);
    Cursor := crSizeNWSE;
    FUnsnapMousePos := vgPoint(x, y);
    Exit;
  end;
  { translate coord }
  FMousePos := vgPoint(SnapToGridValue(x), SnapToGridValue(y));
  FUnsnapMousePos := vgPoint(x, y);
  { design }
  if FDesignTime then
  begin
    { change cursor }
    if (FSelected <> nil) then
    begin
      P := FSelected.AbsoluteToLocal(vgPoint(FUnsnapMousePos.X, FUnsnapMousePos.Y));
      R := vgRect(FSelected.Width / 2 - (GripSize), -RotSize - (GripSize),
        (FSelected.Width) / 2 + (GripSize), -RotSize + (GripSize));
      if FRotateHot <> vgPtInRect(P, R) then
      begin
        FRotateHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      P := FSelected.AbsoluteToLocal(vgPoint(FUnsnapMousePos.X, FUnsnapMousePos.Y));
      R := vgRect(-GripSize, -GripSize, GripSize, GripSize);
      if FLeftTopHot <> vgPtInRect(P, R) then
      begin
        FLeftTopHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      R := FSelected.BoundsRect;
      R := vgRect(R.Right - GripSize, -GripSize, R.Right + GripSize, GripSize);
      if FRightTopHot <> vgPtInRect(P, R) then
      begin
        FRightTopHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      R := FSelected.BoundsRect;
      R := vgRect(-GripSize, R.Bottom - GripSize, GripSize, R.Bottom + GripSize);
      if FLeftBottomHot <> vgPtInRect(P, R) then
      begin
        FLeftBottomHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      R := FSelected.BoundsRect;
      R := vgRect(R.Right - GripSize, R.Bottom - GripSize, R.Right + GripSize, R.Bottom + GripSize);
      if FRightBottomHot <> vgPtInRect(P, R) then
      begin
        FRightBottomHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;

      R := FSelected.BoundsRect;
      R := vgRect(vgRectWidth(R) / 2 - GripSize, -GripSize, vgRectWidth(R) / 2 + GripSize, GripSize);
      if FTopHot <> vgPtInRect(P, R) then
      begin
        FTopHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      R := FSelected.BoundsRect;
      R := vgRect(vgRectWidth(R) / 2 - GripSize, R.Bottom - GripSize, vgRectWidth(R) / 2 + GripSize, R.Bottom + GripSize);
      if FBottomHot <> vgPtInRect(P, R) then
      begin
        FBottomHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      R := FSelected.BoundsRect;
      R := vgRect(-GripSize, vgRectHeight(R) / 2 - GripSize, GripSize, vgRectHeight(R) / 2 + GripSize);
      if FLeftHot <> vgPtInRect(P, R) then
      begin
        FLeftHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
      R := FSelected.BoundsRect;
      R := vgRect(R.Right - GripSize, vgRectHeight(R) / 2 - GripSize, R.Right + GripSize, vgRectHeight(R) / 2 + GripSize);
      if FRightHot <> vgPtInRect(P, R) then
      begin
        FRightHot := vgPtInRect(P, R);
        R.TopLeft := FSelected.LocaltoAbsolute(R.TopLeft);
        R.BottomRight := FSelected.LocaltoAbsolute(R.BottomRight);
        vgInflateRect(R, 2, 2);
        AddUpdateRect(R);
      end;
    end;
    { resize and move }
    if (ssLeft in Shift) and (FSelected <> nil) and (FMoving) then
    begin
      P := vgPoint(FUnsnapMousePos.X - FDownPos.X, FUnsnapMousePos.Y - FDownPos.Y);
      if (FSelected.Parent <> nil) and (FSelected.Parent.IsVisual) then
      begin
        with TvxVisualObject(FSelected.Parent).AbsoluteToLocalVector(vgVector(P.X, P.Y)) do
          P := vgPoint(X, Y);
      end
      else
      begin
        with FSelected.AbsoluteToLocalVector(vgVector(P.X, P.Y)) do
          P := vgPoint(X, Y);
      end;
      FSelected.Position.X := SnapToGridValue(FSelected.Position.X + P.X);
      FSelected.Position.Y := SnapToGridValue(FSelected.Position.Y + P.Y);
      { lines grid }
      SnapToGridLines(true);
      { check place }
      TvxVisualObject(FSelected).FLocked := true;
      Obj := TvxVisualObject(ObjectByPoint(FUnsnapMousePos.X, FUnsnapMousePos.Y));
      TvxVisualObject(FSelected).FLocked := false;
      { select }
      if (Obj <> nil) and (Obj <> FSelected.Parent) and (Obj <> FSelected) then
      begin
        if FDesignPlaceObject <> nil then
          FDesignPlaceObject.Repaint;
        FDesignPlaceObject := Obj;
        if FDesignPlaceObject <> nil then
        begin
          TvxVisualObject(FDesignPlaceObject).RecalcUpdateRect;
          FDesignPlaceObject.Repaint;
        end;
        if (ssAlt in Shift) then
        begin
          P := FSelected.LocalToAbsolute(vgPoint(0, 0));
          FSelected.Parent := FDesignPlaceObject;
          P := FDesignPlaceObject.AbsoluteToLocal(P);
          FSelected.Position.X := P.X;
          FSelected.Position.Y := P.Y;
        end;
      end
      else
      begin
        if FDesignPlaceObject <> nil then
          FDesignPlaceObject.Repaint;
        FDesignPlaceObject := nil;
      end;
    end;
    if (ssLeft in Shift) and (FSelected <> nil) then
    begin
      if (ssLeft in Shift) and (FSelected <> nil) and (FRotate) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P1 := FSelected.AbsoluteToLocal(FDownPos);
        if vgVectorCrossProductZ(vgVector(P.X - (FSelected.Width / 2), P.Y - (FSelected.Height / 2)),
          vgVector(P1.X - (FSelected.Width / 2), P1.Y - (FSelected.Height / 2))) < 0
          then
          FSelected.RotateAngle := FSelected.RotateAngle + vgRadToDeg(ArcCos(vgVectorAngleCosine(vgVector(P.X - (FSelected.Width / 2), P.Y - (FSelected.Height / 2)),
            vgVector(P1.X - (FSelected.Width / 2), P1.Y - (FSelected.Height / 2)))))
        else
          FSelected.RotateAngle := FSelected.RotateAngle - vgRadToDeg(ArcCos(vgVectorAngleCosine(vgVector(P.X - (FSelected.Width / 2), P.Y - (FSelected.Height / 2)),
            vgVector(P1.X - (FSelected.Width / 2), P1.Y - (FSelected.Height / 2)))));
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FLeftTop) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(P.X, P.Y,
          R.Right, R.Bottom);
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FRightTop) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(R.Left, P.Y,
          P.X, R.Bottom);
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FLeftBottom) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(P.X, R.Top,
          R.Right, P.Y);
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FRightBottom) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(R.Left, R.Top, P.X, P.Y);
      end;

      if (ssLeft in Shift) and (FSelected <> nil) and (FTop) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(R.Left, P.Y, R.Right, R.Bottom);
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FBottom) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(R.Left, R.Top, R.Right, P.Y);
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FLeft) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(P.X, R.Top, R.Right, R.Bottom);
      end;
      if (ssLeft in Shift) and (FSelected <> nil) and (FRight) then
      begin
        R := FSelected.BoundsRect;
        P := FSelected.AbsoluteToLocal(FMousePos);
        P := SnapPointToGridLines(P);
        FSelected.BoundsRect := vgRect(R.Left, R.Top, P.X, R.Bottom);
      end;
      FDownPos := FMousePos;
    end;
    Exit;
  end;
  { event }
  if not FDesignTime then
  begin
    if (FCaptured <> nil) then
    begin
      P := FCaptured.AbsoluteToLocal(vgPoint(FMousePos.X, FMousePos.Y));
      TvxVisualObject(FCaptured).MouseMove(Shift, P.X, P.Y, 0, 0);
      Exit;
    end;
    Obj := TvxVisualObject(ObjectByPoint(FMousePos.X, FMousePos.Y));
    if (Obj <> nil) then
    begin
      if (Obj.ShowHint) then
        Hint := Obj.Hint
      else
        Hint := '';

      if ((TvxVisualObject(Obj).QueryInterface(IvgSizeGrip, SG) = 0) and Assigned(SG)) then
        NewCursor := crSizeNWSE
      else
        NewCursor := Obj.Cursor;

      if (Obj <> FHovered) then
      begin
        if FHovered <> nil then
        begin
          TvxVisualObject(FHovered).MouseInObject := false;
          TvxVisualObject(FHovered).MouseLeave;
          TvxVisualObject(FHovered).RemoveFreeNotify(Self);
        end;
        FHovered := Obj;
        TvxVisualObject(FHovered).MouseInObject := true;
        TvxVisualObject(FHovered).MouseEnter;
        TvxVisualObject(FHovered).AddFreeNotify(Self);
      end;

      P := Obj.AbsoluteToLocal(vgPoint(FMousePos.X, FMousePos.Y));
      TvxVisualObject(Obj).MouseMove(Shift, P.X, P.Y, 0, 0);
    end
    else
    begin
      if FHovered <> nil then
      begin
        TvxVisualObject(FHovered).MouseInObject := false;
        TvxVisualObject(FHovered).MouseLeave;
        TvxVisualObject(FHovered).RemoveFreeNotify(Self);
        FHovered := nil;
      end;
    end;
  end;
  Cursor := NewCursor;
  FDownPos := FMousePos;
end;

procedure TvxCustomScene.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: Integer);
var
  P: TvxPoint;
  Obj: TvxVisualObject;
begin
  inherited;
  { design }
  if FDesignPlaceObject <> nil then
    FDesignPlaceObject.Repaint;
  FDesignPlaceObject := nil;
  AddUpdateRectsFromGridLines;
  SetLength(FDesignGridLines, 0);
  if (FSelected <> nil) and FMoving then
  begin
    if (FSelected.Parent <> nil) and (TvxObject(FSelected.Parent).IsVisual) then
      TvxVisualObject(FSelected.Parent).Realign;
    if (vgDesigner <> nil) then
      vgDesigner.Modified(Owner);
    if FSelected.Parent = nil then
      RealignRoot;
  end;
  if (FSelected <> nil) and (FLeftTop or FLeftBottom or FLeftBottom or FRightBottom) then
  begin
    if (FSelected.Parent <> nil) and (TvxObject(FSelected.Parent).IsVisual) then
      TvxVisualObject(FSelected.Parent).Realign;
    if (vgDesigner <> nil) then
      vgDesigner.Modified(Owner);
    if FSelected.Parent = nil then
      RealignRoot;
  end;
  FMoving := false;
  FLeftTop := false;
  FLeftBottom := false;
  FRightTop := false;
  FRightBottom := false;
  FTop := false;
  FBottom := false;
  FLeft := false;
  FRight := false;
  FRotate := false;
  { drag }
  if FDragging then
  begin
    FDragging := false;
    //    ReleaseCapture;
  end;
  if FResizing then
  begin
    FResizing := false;
    //    ReleaseCapture;
  end;
  { event }
  if not FDesignTime then
  begin
    if (FCaptured <> nil) then
    begin
      P := FCaptured.AbsoluteToLocal(vgPoint(FMousePos.X, FMousePos.Y));
      TvxVisualObject(FCaptured).MouseUp(Button, Shift, P.X, P.Y);
      Exit;
    end;
    Obj := TvxVisualObject(ObjectByPoint(FMousePos.X, FMousePos.Y));
    if (Obj <> nil) then
    begin
      P := Obj.AbsoluteToLocal(vgPoint(FMousePos.X, FMousePos.Y));
      TvxVisualObject(Obj).MouseUp(Button, Shift, P.X, P.Y);
    end;
  end;
end;

function TvxCustomScene.DoMouseWheel(Shift: TShiftState; WheelDelta: Integer;
  MousePos: TPoint): Boolean;
var
  Obj: TvxVisualObject;
begin
  {$IFNDEF FPC}
  MousePos := ScreenToClient(MousePos);
  {$ENDIF}
  Result := inherited DoMouseWheel(Shift, WheelDelta, MousePos);
  { event }
  if not FDesignTime then
  begin
    {$IFDEF DARWIN}
    //    WheelDelta := WheelDelta * 40;
    {$ENDIF}
    if (FCaptured <> nil) then
    begin
      TvxVisualObject(FCaptured).MouseWheel(Shift, WheelDelta, Result);
      Exit;
    end;
    Obj := TvxVisualObject(ObjectByPoint(FMousePos.X, FMousePos.Y));
    while (Obj <> nil) do
    begin
      TvxVisualObject(Obj).MouseWheel(Shift, WheelDelta, Result);
      if Result then
        Break;
      if (Obj.Parent <> nil) and (Obj.Parent.IsVisual) then
        Obj := TvxVisualObject(Obj.Parent)
      else
        Obj := nil;
    end;
  end;
end;

{$IFDEF FPC}

procedure TvxCustomScene.KeyDown(var Key: Word; Shift: TShiftState);
var
  List: TList;
  i, CurIdx: integer;
  Found: boolean;
  K: Word;
  O: TComponent;
  Ch, Char: System.WideChar;
begin
  inherited;
  {$IFDEF FPC}
  FShift := Shift;
  if ssMeta in Shift then
  begin
    K := 0;
    case Key of
      67: // ctrl+c
        begin
          Ch := 'c';
          UnicodeKeyDown(K, Ch, [ssCtrl]);
          UnicodeKeyUp(K, Ch, [ssCtrl]);
          Exit;
        end;
      86: // ctrl+v
        begin
          Ch := 'v';
          UnicodeKeyDown(K, Ch, [ssCtrl]);
          UnicodeKeyUp(K, Ch, [ssCtrl]);
          Exit;
        end;
      88: // ctrl+x
        begin
          Ch := 'x';
          UnicodeKeyDown(K, Ch, [ssCtrl]);
          UnicodeKeyUp(K, Ch, [ssCtrl]);
          Exit;
        end;
      99: // ctrl+z
        begin
          Ch := 'z';
          UnicodeKeyDown(K, Ch, [ssCtrl]);
          UnicodeKeyUp(K, Ch, [ssCtrl]);
          Exit;
        end;
    end;
  end;
  { dialog key }
  if (Key = VK_ESCAPE) or (Key = VK_RETURN) or (Key = VK_LEFT) or (Key = VK_RIGHT) or (Key = VK_UP) or (Key = VK_DOWN) or
    (Key = VK_HOME) or (Key = VK_END) or (Key = VK_ADD) or (Key = VK_SUBTRACT) then
  begin
    TvxVisualObject(Root).DialogKey(Key, Shift);
    if Key = 0 then
      Exit;
  end;
  { modal }
  if (Key = VK_ESCAPE) then
  begin
    O := Owner;
    while O <> nil do
    begin
      if (O is TCustomForm) and (fsModal in TCustomForm(O).FormState) then
      begin
        TCustomForm(O).ModalResult := mrCancel;
        Key := 0;
        Break;
      end;
      O := O.Owner;
    end;
    if Key = 0 then
      Exit;
  end;
  { change focus }
  if (Key = VK_TAB) and (Root <> nil) then
  begin
    Key := 0;
    List := TList.Create;
    TvxVisualObject(Root).GetTabOrderList(List, true);

    Found := false;
    if ssShift in Shift then
    begin
      { second search in first part of list }
      if FFocused <> nil then
        CurIdx := List.IndexOf(FFocused) - 1
      else
        CurIdx := List.Count - 1;
      if CurIdx > 0 then
        for i := CurIdx - 1 downto 0 do
          if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
          begin
            TvxVisualObject(List[i]).SetFocus;
            Found := true;
            Break;
          end;
      { first search in last part of list }
      if not Found then
        if (List.Count > 2) and (CurIdx < List.Count) then
          for i := List.Count - 1 downto CurIdx do
            if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
            begin
              TvxVisualObject(List[i]).SetFocus;
              Break;
            end;
    end
    else
    begin
      if FFocused <> nil then
        CurIdx := List.IndexOf(FFocused) + 1
      else
        CurIdx := 0;
      { first search in last part of list }
      if (List.Count > 2) and (CurIdx < List.Count) then
        for i := CurIdx to List.Count - 1 do
          if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
          begin
            TvxVisualObject(List[i]).SetFocus;
            Found := true;
            Break;
          end;
      { second search in first part of list }
      if not Found then
        if CurIdx > 0 then
          for i := 0 to CurIdx - 1 do
            if TvxObject(List[i]).isVisual and (TvxVisualObject(List[i]).CheckParentVisible) and (TvxVisualObject(List[i]).CanFocused) and (TvxVisualObject(List[i]).AbsoluteEnabled) then
            begin
              TvxVisualObject(List[i]).SetFocus;
              Break;
            end;
    end;
    List.Free;
    Exit;
  end;
  { focused handler }
  if FFocused <> nil then
  begin
    Char := #0;
    FFocused.KeyDown(Key, Char, Shift);
  end;
  {$ENDIF}
end;

procedure TvxCustomScene.UTF8KeyPress(var UTF8Key: TUTF8Char);
var
  S: System.WideChar;
  K: word;
  C: System.WideChar;
begin
  K := 0;
  C := UTF8ToUTF16(UTF8Key)[1];
  case C of
    #3: // ctrl+c
      begin
        C := 'c';
        UnicodeKeyDown(K, C, FShift);
        UnicodeKeyUp(K, C, FShift);
      end;
    #$16: // ctrl+v
      begin
        C := 'v';
        UnicodeKeyDown(K, C, FShift);
        UnicodeKeyUp(K, C, FShift);
      end;
    #$18: // ctrl+x
      begin
        C := 'x';
        UnicodeKeyDown(K, C, FShift);
        UnicodeKeyUp(K, C, FShift);
      end;
    #$1A: // ctrl+z
      begin
        C := 'z';
        UnicodeKeyDown(K, C, FShift);
        UnicodeKeyUp(K, C, FShift);
      end;
  else
    UnicodeKeyDown(K, C, FShift);
    UnicodeKeyUp(K, C, FShift);
  end;
  UTF8Key := '';
end;

procedure TvxCustomScene.KeyPress(var Key: char);
begin
  inherited KeyPress(Key);
end;

procedure TvxCustomScene.KeyUp(var Key: Word; Shift: TShiftState);
var
  Char: system.WideChar;
begin
  inherited;
  FShift := [];
  if FDesignTime then
  begin
    if (Key = VK_DELETE) and (FSelected <> nil) then
    begin
      FSelected.Free;
      FSelected := nil;
    end;
  end;
  { focused handler }
  if FFocused <> nil then
  begin
    Char := #0;
    FFocused.KeyUp(Key, char, Shift);
  end;
end;
{$ENDIF}

procedure TvxCustomScene.RealignRoot;
begin
  if (FChildren <> nil) and (FChildren.Count > 0) and (TvxObject(FChildren[0]).isVisual) then
    with TvxVisualObject(FChildren[0]) do
    begin
      if (RotateAngle = 90) or (RotateAngle = -90) or (RotateAngle = -270) or (RotateAngle = 270) then
        SetBounds((Self.Width - Self.Height) / 2, -(Self.Width - Self.Height) / 2, Self.Height / Scale.Y, Self.Width / Scale.X)
      else
        SetBounds(0, 0, Self.Width / Scale.X, Self.Height / Scale.Y);
    end;
end;

procedure TvxCustomScene.SetBounds(ALeft, ATop, AWidth, AHeight: Integer);
begin
  inherited;
  if (Canvas <> nil) and (HandleAllocated) then
  begin
    Canvas.ResizeBuffer(AWidth, AHeight);
    RealignRoot;
  end;
end;

procedure TvxCustomScene.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FActiveControl) then
    FActiveControl := nil;
  if (Operation = opRemove) and (AComponent = FCaptured) then
    FCaptured := nil;
  if (Operation = opRemove) and (AComponent = FSelected) then
    FSelected := nil;
  if (Operation = opRemove) and (AComponent = FHovered) then
    FHovered := nil;
  if (Operation = opRemove) and (AComponent = FFocused) then
    FFocused := nil;
  if (Operation = opRemove) and (AComponent = FDesignPlaceObject) then
    FDesignPlaceObject := nil;
  if (Operation = opRemove) and (AComponent = FStyle) then
    Style := nil;
  if (Operation = opRemove) and (AComponent = FOpenInFrame) then
    FOpenInFrame := nil;
end;

procedure TvxCustomScene.SetFill(const Value: TvxBrush);
begin
  FFill.Assign(Value);
end;

procedure TvxCustomScene.FillChanged(Sender: TObject);
begin
  SetLength(FUpdateRects, 0);
  AddUpdateRect(vgRect(0, 0, Width, Height));
end;

procedure TvxCustomScene.SetSnapGridShow(const Value: boolean);
begin
  if FSnapGridShow <> Value then
  begin
    FSnapGridShow := Value;
    SetLength(FUpdateRects, 0);
    AddUpdateRect(vgRect(0, 0, Width, Height));
  end;
end;

procedure TvxCustomScene.SetSnapGridSize(const Value: single);
begin
  if FSnapGridSize <> Value then
  begin
    FSnapGridSize := Value;
    if FSnapGridSize < 0.01 then
      FSnapGridSize := 0.01;
    if FsnapGridShow then
      Repaint;
  end;
end;

procedure TvxCustomScene.InsertObject(const ClassName: string);
var
  P: TPoint;
  Obj: TvxObject;
  OldSel: TvxVisualObject;
  InsertPos: TvxPoint;
begin
  if GetClass(ClassName) <> nil then
  begin
    if GetClass(ClassName).InheritsFrom(TvxObject) then
    begin
      if (FSelected = nil) and (Root <> nil) and (Root.IsVisual) then
        FSelected := Root.Visual;
      if FSelected <> nil then
      begin
        try
          Obj := TvxObjectClass(GetClass(ClassName)).Create(Owner);
          OldSel := FSelected;
          FSelected.AddObject(Obj);
          if vgDesigner <> nil then
          begin
            Obj.Name := vgDesigner.UniqueName(Owner, Obj.ClassName);
            vgDesigner.AddObject(Obj);
          end;
          if vgDesigner <> nil then
          begin
            vgDesigner.SelectObject(Owner, Obj, []);
            if Assigned(FDesignChangeSelection) then
              FDesignChangeSelection(Self);
            vgDesigner.Modified(Owner);
          end;
          if Obj.IsVisual then
          begin
            if GetPropInfo(Obj.ClassInfo, 'Text', [tkString, tkLString, tkWString]) <> nil then
              SetStrProp(Obj, 'Text', Copy(Obj.ClassName, 4, Length(Obj.ClassName)));
            if (Owner is TWinControl) and (FPopupPos.X > 0) then
            begin
              if Pos('Item', Obj.ClassName) = 0 then
              begin
                P := ScreenToClient(FPopupPos);
                InsertPos := OldSel.AbsoluteToLocal(vgPoint(P.X, P.Y));
                if vgPtInRect(vgPoint(P.X, P.Y), vgRect(0, 0, Width, Height)) then
                begin
                  TvxVisualObject(Obj).Position.X := InsertPos.X;
                  TvxVisualObject(Obj).Position.Y := InsertPos.Y;
                end;
              end;
            end;
            FPopupPos := Point(-1, -1);
            FSelected := TvxVisualObject(Obj);
            TvxVisualObject(FSelected).DesignSelect;
            TvxVisualObject(FSelected).DesignInsert;
          end;
          if OldSel.IsVisual then
            OldSel.Visual.Realign;
        finally
        end;
      end
      else
        if (FChildren = nil) or (FChildren.Count = 0) then
      begin
        { insert root object }
        try
          Obj := TvxObjectClass(GetClass(ClassName)).Create(Owner);
          if vgDesigner <> nil then
            Obj.Name := vgDesigner.UniqueName(Owner, Obj.ClassName);
          AddObject(Obj);
          if vgDesigner <> nil then
          begin
            vgDesigner.SelectObject(Owner, Obj, []);
            if Assigned(FDesignChangeSelection) then
              FDesignChangeSelection(Self);
            vgDesigner.Modified(Owner);
          end;
          if Obj.IsVisual then
          begin
            if (Owner is TWinControl) and (FPopupPos.X > 0) then
            begin
              P := TWinControl(Owner).ScreenToClient(FPopupPos);
              InsertPos := vgPoint(P.X, P.Y);
              TvxVisualObject(Obj).Position.X := P.X;
              TvxVisualObject(Obj).Position.Y := P.Y;
            end;
            FPopupPos := Point(-1, -1);
            FSelected := TvxVisualObject(Obj);
            TvxVisualObject(FSelected).DesignSelect;
          end;
        finally
        end;
      end;
    end
    else
    begin
      FInsertObject := ClassName;
    end;
  end
  else
    FInsertObject := '';
end;

procedure TvxCustomScene.Resize;
begin
  inherited;
end;

procedure TvxCustomScene.doDesignPopupDesignHide(Sender: TObject);
begin
  if (FSelected <> nil) and (FSelected <> Root) then
  begin
    FSelected.DesignHide := not FSelected.DesignHide;
    if FSelected.DesignHide and (FSelected.Parent.IsVisual) then
    begin
      FSelected := TvxVisualObject(FSelected.Parent);
    end;
    AddUpdateRect(vgRect(0, 0, Width, Height));
  end;
end;

procedure TvxCustomScene.doDesignPopupDel(Sender: TObject);
var
  Obj: TvxVisualObject;
begin
  if (FSelected <> nil) and (FSelected <> Root) then
  begin
    Obj := FSelected;
    if (Obj.Parent <> nil) and (Obj.Parent.IsVisual) then
    begin
      FSelected := TvxVisualObject(Obj.Parent);
      TvxVisualObject(FSelected).DesignSelect;
    end
    else
    begin
      FSelected := TvxVisualObject(Root);
      if FSelected <> nil then
        TvxVisualObject(FSelected).DesignSelect;
    end;
    Obj.Free;
  end;
end;

procedure TvxCustomScene.doDesignPopupAddItem(Sender: TObject);
begin
  if FSelected <> nil then
  begin
    InsertObject(TMenuItem(Sender).Hint);
  end
end;

{$IFDEF FPC}

function StripHotkey(S: string): string;
begin
  Result := S;
end;
{$ENDIF}

procedure TvxCustomScene.doDesignPopupAdd(Sender: TObject);
var
  S: string;
begin
  S := StripHotkey(TMenuItem(Sender).Caption);
  if (S <> '') then
    S := 'Tvx' + S;
  InsertObject(S);
end;

procedure TvxCustomScene.doDesignPopupReorder(Sender: TObject);
begin
  if FSelected = nil then
    Exit;

  if StripHotkey(TMenuItem(Sender).Caption) = 'Bring to front' then
    FSelected.BringToFront;
  if StripHotkey(TMenuItem(Sender).Caption) = 'Send to back' then
    FSelected.SendToBack;
end;

procedure TvxCustomScene.doDesignPopupGrid(Sender: TObject);
begin
  case TMenuItem(Sender).Tag of
    1: FSnapGridShow := TMenuItem(Sender).Checked;
    2:
      begin
        FSnapToGrid := TMenuItem(Sender).Checked;
        FSnapToLines := not FSnapToGrid;
      end;
    3:
      begin
        FSnapToLines := TMenuItem(Sender).Checked;
        FSnapToGrid := not FSnapToLines;
      end;
    4:
      begin
        FSnapToLines := false;
        FSnapToGrid := false;
      end;
  end;
  SetLength(FUpdateRects, 0);
  AddUpdateRect(vgRect(0, 0, Width, Height));
end;

var
  ClipboardText: AnsiString;

procedure TvxCustomScene.doDesignPopupCopy(Sender: TObject);
var
  S: TStringStream;
begin
  if FSelected <> nil then
  begin
    S := TStringStream.Create('');
    FSelected.SaveToStream(S);
    ClipboardText := S.DataString;
    S.Free;
  end;
end;

procedure TvxCustomScene.doDesignPopupPaste(Sender: TObject);
  procedure SetUniqueName(Obj: TvxObject);
  var
    i: integer;
  begin
    Obj.Name := vgDesigner.UniqueName(Owner, Obj.ClassName);
    if Obj.IsVisual and Obj.Visual.Locked then
      Exit;
    for i := 0 to Obj.ChildrenCount - 1 do
      SetUniqueName(Obj.Children[i]);
  end;
var
  S: TStringStream;
  Result: TvxObject;
begin
  if ClipboardText <> '' then
  begin
    S := TStringStream.Create(ClipboardText);
    Result := CreateObjectFromStream(Owner, S);
    if FSelected <> nil then
      Result.Parent := FSelected
    else
      Result.Parent := Root;
    if vgDesigner <> nil then
    begin
      SetUniqueName(Result);
      vgDesigner.SelectObject(Owner, Result, []);
    end;
    S.Free;
  end;
end;

procedure TvxCustomScene.doDesignPopupLoadFromFile(Sender: TObject);
var
  S: TStream;
  Result: TvxObject;
  Open: TOpenDialog;
begin
  Open := TOpenDialog.Create(nil);
  Open.Filter := 'VGScene Files|*.vgscene;*.vg';
  if Open.Execute then
  begin
    S := TFileStream.Create(Open.FileName, fmOpenRead);
    Result := CreateObjectFromStream(Owner, S);
    if FSelected <> nil then
      Result.Parent := FSelected
    else
      Result.Parent := Root;
    if vgDesigner <> nil then
      Result.Name := vgDesigner.UniqueName(Owner, Result.ClassName);
    S.Free;
  end;
  Open.Free;
end;

procedure TvxCustomScene.doDesignPopupCreateStyle(Sender: TObject);
var
  R: TvxResources;
  CurrentRes, Link: TvxVisualObject;
  LinkedList: TList;
  i: integer;
begin
  { Edit Style }
  if FSelected = nil then
    Exit;
  if not Assigned(FSelected.Scene) then
    Exit;

  if (FSelected.Scene.GetStyle = nil) then
  begin
    // Create style
    R := TvxResources.Create(FSelected.Scene.GetOwner);
    R.Root := TvxBackground.Create(nil);
    if vgDesigner <> nil then
      R.Name := vgDesigner.UniqueName(Owner, R.ClassName);
    FSelected.Scene.SetStyle(R);
  end
  else
    R := FSelected.Scene.GetStyle;

  if (TvxControl(FSelected).Resource = '') and (vgDesigner <> nil) then
  begin
    TvxControl(FSelected).Resource := vgDesigner.UniqueName(Owner, FSelected.Name + 'Style');
  end;
  if (R.Root = nil) then
  begin
    R.Root := TvxBackground.Create(nil);
    if vgDesigner <> nil then
      R.Name := vgDesigner.UniqueName(Owner, R.ClassName);
  end;
  if (R.Root.FindResource(TvxControl(FSelected).Resource) = nil) then
  begin
    // Clone Resource from Current
    CurrentRes := TvxControl(FSelected).GetResourceObject;
    if CurrentRes = nil then
      Exit;
    CurrentRes.Align := vaNone;
    CurrentRes.Parent := R.Root;
    if vgDesigner <> nil then
    begin
      CurrentRes.ResourceName := vgDesigner.UniqueName(Owner, FSelected.Name + 'Style');
      TvxControl(FSelected).Resource := CurrentRes.ResourceName;
    end
    else
    begin
      CurrentRes.ResourceName := FSelected.Name;
      TvxControl(FSelected).Resource := CurrentRes.ResourceName;
    end;

    // Add linked object to resource - like ListBox with ScrollBar
    LinkedList := TList.Create;
    TvxControl(CurrentRes).AddControlsToList(LinkedList);
    for i := 0 to LinkedList.Count - 1 do
    begin
      if R.Root.FindResource(TvxControl(LinkedList[i]).Resource) = nil then
      begin
        Link := TvxControl(LinkedList[i]).GetResourceObject;
        Link.Align := vaNone;
        Link.Parent := R.Root;
        if vgDesigner <> nil then
        begin
          Link.ResourceName := vgDesigner.UniqueName(Owner, FSelected.Name + TvxControl(LinkedList[i]).ResourceName);
          TvxControl(LinkedList[i]).Resource := Link.ResourceName;
        end;
      end;
    end;
    LinkedList.Free;
  end;

  if vgDesigner <> nil then
  begin
    // Edit Style
    vgDesigner.EditStyle(R, TvxControl(FSelected).Resource);
  end;
end;

procedure TvxCustomScene.doDesignPopupEditStyle(Sender: TObject);
var
  R: TvxResources;
  CurrentRes, Link: TvxVisualObject;
  LinkedList: TList;
  i: integer;
  StyleName: string;
begin
  { Edit Style }
  if FSelected = nil then
    Exit;
  if not Assigned(FSelected.Scene) then
    Exit;

  if (FSelected.Scene.GetStyle = nil) then
  begin
    // Create style
    R := TvxResources.Create(FSelected.Scene.GetOwner);
    R.Root := TvxBackground.Create(nil);
    if vgDesigner <> nil then
      R.Name := vgDesigner.UniqueName(Owner, R.ClassName);
    FSelected.Scene.SetStyle(R);
  end
  else
    R := FSelected.Scene.GetStyle;

  // Clone Resource from Current
  StyleName := TvxControl(FSelected).Resource;
  if StyleName = '' then
  begin
    StyleName := FSelected.ClassName + 'Style';
    Delete(StyleName, 1, 3);
  end;
  if (R.Root = nil) then
  begin
    R.Root := TvxBackground.Create(nil);
    if vgDesigner <> nil then
      R.Name := vgDesigner.UniqueName(Owner, R.ClassName);
  end;
  if (R.Root.FindResource(StyleName) = nil) then
  begin
    CurrentRes := TvxControl(FSelected).GetResourceObject;
    if CurrentRes = nil then
      Exit;
    CurrentRes.Align := vaNone;
    CurrentRes.Parent := R.Root;

    // Add linked object to resource - like ListBox with ScrollBar
    LinkedList := TList.Create;
    TvxControl(CurrentRes).AddControlsToList(LinkedList);
    for i := 0 to LinkedList.Count - 1 do
    begin
      StyleName := TvxControl(LinkedList[i]).Resource;
      if StyleName = '' then
      begin
        StyleName := TvxControl(LinkedList[i]).ClassName + 'Style';
        Delete(StyleName, 1, 3);
      end;
      if R.Root.FindResource(StyleName) = nil then
      begin
        Link := TvxControl(LinkedList[i]).GetResourceObject;
        Link.Align := vaNone;
        Link.ResourceName := StyleName;
        Link.Parent := R.Root;
      end;
    end;
    LinkedList.Free;
  end;

  if vgDesigner <> nil then
  begin
    // Edit Style
    StyleName := TvxControl(FSelected).Resource;
    if StyleName = '' then
    begin
      StyleName := FSelected.ClassName + 'Style';
      Delete(StyleName, 1, 3);
    end;
    vgDesigner.EditStyle(R, StyleName);
  end;
end;

procedure TvxCustomScene.doDesignTabOrderBtnClick(Sender: TObject);
var
  Obj: TvxVisualObject;
begin
  if TvxButton(Sender).Text = 'Up' then
  begin
    Obj := TvxVisualObject(TvxListbox(TvxButton(Sender).TagObject).Selected.TagObject);
    Obj.TabOrder := Obj.TabOrder - 1;
  end;
  if TvxButton(Sender).Text = 'Down' then
  begin
    Obj := TvxVisualObject(TvxListbox(TvxButton(Sender).TagObject).Selected.TagObject);
    Obj.TabOrder := Obj.TabOrder + 1;
  end;
  doDesignTabOrderRebuildList(TvxListbox(TvxButton(Sender).TagObject));
end;

procedure TvxCustomScene.doDesignTabOrderRebuildList(ListBox: TvxVisualObject);
var
  Item: TvxListboxItem;
  List: TvxListBox;
  Idx, i: integer;
  L: TList;
begin
  if FSelected = nil then
    Exit;
  if FSelected.Parent = nil then
    Exit;
  if not FSelected.Parent.IsVisual then
    Exit;
  List := TvxListBox(Listbox);
  if List.Selected <> nil then
    Idx := TvxVisualObject(List.Selected.TagObject).TabOrder
  else
    Idx := 0;
  { add taborder list }
  List.BeginUpdate;
  List.Clear;
  L := TList.Create;
  TvxVisualObject(FSelected.Parent).GetTabOrderList(L, false);
  for i := 0 to L.Count - 1 do
  begin
    Item := TvxListboxItem.Create(List.Owner);
    Item.Parent := List;
    Item.Text := TvxVisualObject(L[i]).Name;
    if Item.Text = '' then
      Item.Text := TvxVisualObject(L[i]).ClassName;
    Item.TagObject := TvxVisualObject(L[i]);
  end;
  L.Free;
  List.EndUpdate;
  List.ItemIndex := Idx;
end;

procedure TvxCustomScene.doDesignPopupTabOrder(Sender: TObject);
var
  Form: TForm;
  Scene: TDicomScene;
  Wnd: TvxHudWindow;
  List: TvxListbox;
  BtnUp, BtnDown: TvxButton;
begin
  if FSelected = nil then
    Exit;
  if FSelected.Parent = nil then
    Exit;
  if not FSelected.Parent.IsVisual then
    Exit;

  Form := TForm.CreateNew(Application, 0);
  Form.BorderStyle := bsNone;
  Form.Position := poScreenCenter;
  Form.SetBounds(0, 0, 300, 400);
  Scene := TDicomScene.Create(Form);
  Scene.Parent := Form;
  Scene.Align := alClient;
  Scene.Transparency := true;
  Wnd := TvxHudWindow.Create(Form);
  Wnd.ShowSizeGrip := false;
  Wnd.Text := 'TabOrder Editor';
  Scene.AddObject(Wnd);

  BtnUp := TvxHudButton.Create(Form);
  BtnUp.Parent := Wnd;
  BtnUp.SetBounds(Form.Width - 70, 50, 50, 26);
  BtnUp.Text := 'Up';
  BtnUp.OnClick := doDesignTabOrderBtnClick;
  BtnDown := TvxHudButton.Create(Form);
  BtnDown.Parent := Wnd;
  BtnDown.SetBounds(Form.Width - 70, 90, 50, 26);
  BtnDown.Text := 'Down';
  BtnDown.OnClick := doDesignTabOrderBtnClick;

  List := TvxHudListbox.Create(Form);
  List.Parent := Wnd;
  List.Align := vaClient;
  List.Padding.Rect := vgRect(26, 45, 86, 33);
  List.HideSelectionUnfocused := false;
  List.ItemHeight := 20;

  Form.SetBounds(0, 0, 300, 400);
  BtnUp.TagObject := List;
  BtnDown.TagObject := List;
  doDesignTabOrderRebuildList(List);
  List.ItemIndex := FSelected.TabOrder;
  Form.ShowModal;
  Form.Free;
end;

procedure TvxCustomScene.OpenDesignPopup;
var
  i, j: integer;
  S, T: AnsiString;
  OItem, SItem, Item: TMenuItem;
  CatList: TStringList;
begin
  if not DesignPopupEnabled then
    Exit;
  if FDesignPopup <> nil then
  begin
    FDesignPopup.Free;
    FDesignPopup := nil;
  end;
  if FDesignPopup = nil then
  begin
    FDesignPopup := TPopupMenu.Create(Self);
    {$IFNDEF FPC}
    //    FDesignPopup.OwnerDraw := true;
    {$ENDIF}
    if ObjectList <> nil then
    begin
      { item }
      if (FSelected <> nil) and (FSelected.ItemClass <> '') then
      begin
        S := FSelected.ItemClass;
        T := vgGetToken(S, ';');
        while T <> '' do
        begin
          if Pos('Tvx', T) = 1 then
            Delete(T, 1, 3);
          Item := NewItem('Add ' + T, 0, false, true, doDesignPopupAddItem, 0, '');
          Item.Hint := 'Tvx' + T;
          FDesignPopup.Items.Add(Item);
          T := vgGetToken(S, ';');
        end;
      end;
      { add }
      Item := NewItem('Add object', 0, false, true, nil, 0, '');
      { add categories }
      for i := 0 to ObjectList.Count - 1 do
      begin
        if Item.Find(ObjectList[i]) = nil then
        begin
          SItem := NewItem(ObjectList[i], 0, false, true, nil, 0, '');
          Item.Add(SItem);
        end;
      end;
      { add controls to list and sort }
      CatList := TStringList.Create;
      CatList.Sorted := true;
      for i := 0 to ObjectList.Count - 1 do
      begin
        S := TvxObjectClass(ObjectList.Objects[i]).ClassName;
        if Pos('Tvx', S) = 1 then
          Delete(S, 1, 3);
        CatList.Add(S);
      end;
      { add objects }
      for i := 0 to CatList.Count - 1 do
      begin
        OItem := NewItem(CatList[i], 0, false, true, doDesignPopupAdd, 0, '');
        OItem.Tag := $FF;
        for j := 0 to ObjectList.Count - 1 do
        begin
          S := TvxObjectClass(ObjectList.Objects[j]).ClassName;
          if Pos('Tvx', S) = 1 then
            Delete(S, 1, 3);
          if S = CatList[i] then
          begin
            SItem := Item.Find(ObjectList[j]);
            Break;
          end;
        end;
        if SItem <> nil then
          SItem.Add(OItem);
      end;
      CatList.Free;
      FDesignPopup.Items.Add(Item);
      { Delete }
      Item := NewItem('Delete object', 0, false, true, doDesignPopupDel, 0, '');
      FDesignPopup.Items.Add(Item);
      { Delete }
      Item := NewItem('Load From File...', 0, false, true, doDesignPopupLoadFromFile, 0, '');
      FDesignPopup.Items.Add(Item);
      if FSelected <> nil then
      begin
        { Design Hide }
        Item := NewItem('Hide in Design-time', 0, FSelected.DesignHide, true, doDesignPopupDesignHide, 0, '');
        {$IFDEF KS_COMPILER6_UP}
        Item.AutoCheck := true;
        {$ENDIF}
        FDesignPopup.Items.Add(Item);

        { Edit Style }
        {if (FSelected is TvxControl) and (TvxControl(FSelected).GetResourceObject <> nil) then
        begin
          Item := NewItem('Edit Default Style...', 0, false, true, doDesignPopupEditStyle, 0, '');
          FDesignPopup.Items.Add(Item);
          Item := NewItem('Edit Custom Style...', 0, false, true, doDesignPopupCreateStyle, 0, '');
          FDesignPopup.Items.Add(Item);
        end;}
        { TabOrder }
        if (FSelected.IsVisual) and (FSelected.CanFocused) then
        begin
          Item := NewItem('Tab Order...', 0, false, true, doDesignPopupTabOrder, 0, '');
          FDesignPopup.Items.Add(Item);
        end;
      end;
      { Reorder }
      Item := NewItem('Order', 0, false, true, nil, 0, '');
      SItem := NewItem('Bring to front', 0, false, true, doDesignPopupReorder, 0, '');
      Item.Add(SItem);
      SItem := NewItem('Send to back', 0, false, true, doDesignPopupReorder, 0, '');
      Item.Add(SItem);
      FDesignPopup.Items.Add(Item);
      { Edit }
      Item := NewItem('Edit', 0, false, true, nil, 0, '');
      SItem := NewItem('Copy to clipboard', 0, false, true, doDesignPopupCopy, 0, '');
      Item.Add(SItem);
      SItem := NewItem('Paste from clipboard', 0, false, true, doDesignPopupPaste, 0, '');
      Item.Add(SItem);
      FDesignPopup.Items.Add(Item);
      { Grid }
      Item := NewItem('Grid', 0, false, true, nil, 0, '');
      SItem := NewItem('Show snap grid', 0, FSnapGridShow, true, doDesignPopupGrid, 0, '');
      SItem.Tag := 1;
      {$IFDEF KS_DELPHI6_UP}
      SItem.AutoCheck := true;
      {$ENDIF}
      Item.Add(SItem);
      SItem := NewItem('Snap to grid', 0, FSnapToGrid, true, doDesignPopupGrid, 0, '');
      SItem.Tag := 2;
      SItem.RadioItem := true;
      {$IFDEF KS_DELPHI6_UP}
      SItem.AutoCheck := true;
      {$ENDIF}
      Item.Add(SItem);
      SItem := NewItem('Snap to lines', 0, FSnapToLines, true, doDesignPopupGrid, 0, '');
      SItem.Tag := 3;
      SItem.RadioItem := true;
      {$IFDEF KS_DELPHI6_UP}
      SItem.AutoCheck := true;
      {$ENDIF}
      Item.Add(SItem);
      SItem := NewItem('Snap disabled', 0, not FSnapToLines or not FSnapToLines, true, doDesignPopupGrid, 0, '');
      SItem.Tag := 4;
      SItem.RadioItem := true;
      {$IFDEF KS_DELPHI6_UP}
      SItem.AutoCheck := true;
      {$ENDIF}
      Item.Add(SItem);
      FDesignPopup.Items.Add(Item);
    end;
  end;
  GetCursorPos(FPopupPos);
  FDesignPopup.Popup(FPopupPos.X, FPopupPos.Y);
end;

procedure TvxCustomScene.DefineProperties(Filer: TFiler);
begin
  inherited DefineProperties(Filer);
  Filer.DefineProperty('DesignSnapGridShow', ReadDesignSnapGridShow, WriteDesignSnapGridShow, true);
  Filer.DefineProperty('DesignSnapToGrid', ReadDesignSnapToGrid, WriteDesignSnapToGrid, true);
  Filer.DefineProperty('DesignSnapToLines', ReadDesignSnapToLines, WriteDesignSnapToLines, true);
end;

procedure TvxCustomScene.ReadDesignSnapGridShow(Reader: TReader);
begin
  FSnapGridShow := Reader.ReadBoolean;
  if not (FDesignTime) then
    FSnapGridShow := false;
end;

procedure TvxCustomScene.ReadDesignSnapToGrid(Reader: TReader);
begin
  FSnapToGrid := Reader.ReadBoolean;
end;

procedure TvxCustomScene.ReadDesignSnapToLines(Reader: TReader);
begin
  FSnapToLines := Reader.ReadBoolean;
end;

procedure TvxCustomScene.WriteDesignSnapGridShow(Writer: TWriter);
begin
  Writer.WriteBoolean(FSnapGridShow);
end;

procedure TvxCustomScene.WriteDesignSnapToGrid(Writer: TWriter);
begin
  Writer.WriteBoolean(FSnapToGrid);
end;

procedure TvxCustomScene.WriteDesignSnapToLines(Writer: TWriter);
begin
  Writer.WriteBoolean(FSnapToLines);
end;

function TvxCustomScene.GetStyle: TvxResources;
begin
  Result := FStyle;
end;

function TvxCustomScene.GetRoot: TvxObject;
begin
  if (FChildren <> nil) and (FChildren.Count > 0) then
    Result := TvxObject(FChildren[0])
  else
    Result := nil;
end;

procedure TvxCustomScene.SetFocused(const Value: TvxVisualObject);
begin
  if FFocused <> Value then
  begin
    if FFocused <> nil then
    begin
      TvxVisualObject(FFocused).KillFocus;
      TvxVisualObject(FFocused).RemoveFreeNotify(Self);
    end;
    FFocused := Value;
    if FFocused <> nil then
    begin
      TvxVisualObject(FFocused).EnterFocus;
      TvxVisualObject(FFocused).AddFreeNotify(Self);
    end;
  end;
end;

procedure TvxCustomScene.DoDesignSelect(AObject: TObject);
begin
  if (AObject <> nil) and (AObject is TvxVisualObject) and (TvxVisualObject(AObject).FScene.GetComponent = Self) then
  begin
    FSelected := TvxVisualObject(AObject);
    TvxVisualObject(FSelected).DesignSelect;
    AddUpdateRect(vgRect(0, 0, 10000, 10000));
    Draw;
  end;
end;

procedure TvxCustomScene.SetActiveControl(AControl: TvxControl);
begin
  if AControl <> FActiveControl then
  begin
    FActiveControl := AControl;
    if (FActiveControl <> nil) and not (csLoading in ComponentState) then
      FActiveControl.SetFocus;
  end;
end;

procedure TvxCustomScene.SetTransparency(const Value: boolean);
begin
  if FTransparency <> Value then
  begin
    FTransparency := Value;
    AddUpdateRect(vgRect(0, 0, 10000, 10000));
  end;
end;

procedure TvxCustomScene.SetSelected(const Value: TvxVisualObject);
begin
  if FSelected <> Value then
  begin
    if FSelected <> nil then
      FSelected.Repaint;
    FSelected := Value;
    if FSelected <> nil then
      FSelected.Repaint;
    if Assigned(FDesignChangeSelection) then
      FDesignChangeSelection(Self);
    AddUpdateRect(vgRect(0, 0, Width, Height));
    Draw;
  end;
end;

function TvxCustomScene.GetActiveControl: TvxControl;
begin
  Result := FActiveControl;
end;

function TvxCustomScene.GetDisableUpdate: boolean;
begin
  Result := FDisableUpdate;
end;

function TvxCustomScene.GetDesignTime: boolean;
begin
  Result := FDesignTime;
end;

function TvxCustomScene.GetCanvas: TvxCanvas;
begin
  Result := FCanvas;
end;

function TvxCustomScene.GetOwner: TComponent;
begin
  Result := Owner;
end;

function TvxCustomScene.GetComponent: TComponent;
begin
  Result := Self;
end;

function TvxCustomScene.GetSelected: TvxVisualObject;
begin
  Result := FSelected;
end;

function TvxCustomScene.GetDesignPlaceObject: TvxVisualObject;
begin
  Result := FDesignPlaceObject;
end;

procedure TvxCustomScene.SetDisableUpdate(Value: boolean);
begin
  FDisableUpdate := Value;
end;

function TvxCustomScene.GetUpdateRectsCount: integer;
begin
  Result := Length(FUpdateRects);
end;

function TvxCustomScene.GetUpdateRect(const Index: integer): TvxRect;
begin
  Result := FUpdateRects[Index];
end;

function TvxCustomScene.GetAnimatedCaret: boolean;
begin
  Result := FAnimatedCaret;
end;

function TvxCustomScene.LocalToScreen(const Point: TvxPoint): TvxPoint;
begin
  with ClientToScreen(Classes.Point(trunc(Point.x), trunc(Point.y))) do
    Result := vgPoint(x, y);
end;

function TvxCustomScene.GetCaptured: TvxVisualObject;
begin
  Result := FCaptured;
end;

procedure TvxCustomScene.SetCaptured(const Value: TvxVisualObject);
begin
  FCaptured := Value;
  if Assigned(FCaptured) then
    if not Assigned(FOnFlush) then
      MouseCapture := true;
  if not Assigned(FCaptured) then
    if not Assigned(FOnFlush) then
      MouseCapture := false;
end;

function TvxCustomScene.GetTransparency: boolean;
begin
  Result := FTransparency;
end;

function TvxCustomScene.GetFocused: TvxVisualObject;
begin
  Result := FFocused;
end;

procedure TvxCustomScene.SetDesignRoot(const Value: TvxVisualObject);
begin
  FDesignRoot := Value;
end;

function TvxCustomScene.GetMousePos: TvxPoint;
begin
  Result := FMousePos;
end;

procedure TvxCustomScene.UpdateResource;
begin
  if Root <> nil then
    Root.UpdateResource;
end;

procedure TvxCustomScene.SetStyle(const Value: TvxResources);
begin
  if FStyle <> Value then
  begin
    if FStyle <> nil then
      FStyle.RemoveSceneUpdater(Self);
    FStyle := Value;
    if FStyle <> nil then
      FStyle.AddSceneUpdater(Self);
    UpdateResource;
  end;
end;

function TvxCustomScene.ShowKeyboardForControl(AObject: TvxObject): boolean;
begin
  Result := false;
end;

function TvxCustomScene.HideKeyboardForControl(AObject: TvxObject): boolean;
begin
  Result := false;
end;

{$ENDIF}

var
  PopupList: TList;

procedure CloseAllPopups;
var
  i: integer;
begin
  { close other popups }
  if (PopupList.Count > 0) then
  begin
    for i := PopupList.Count - 1 downto 0 do
      TvxPopup(PopupList[i]).ClosePopup;
  end;
end;

{$IFNDEF NOVCL}

{ TvxPopupForm }
type

  TvxPopupForm = class(TCustomForm)
  private
    FOwnerForm: TCustomForm;
    FPopup: TvxPopup;
    FNoFree: boolean;
    {$IFNDEF FPC}
    procedure CMShowingChanged(var Message: TMessage); message CM_SHOWINGCHANGED;
    procedure WMActivate(var Msg: TWMActivate); message WM_ACTIVATE;
    procedure WMMouseActivate(var Msg: TWMMouseActivate); message WM_MOUSEACTIVATE;
    {$ELSE}
    procedure WMDeactivate(var Msg: TLMActivate); message LM_DEACTIVATE;
    {$ENDIF}
  protected
    procedure DoClose(var Action: TCloseAction); override;
    procedure CreateParams(var Params: TCreateParams); override;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  published
  end;

constructor TvxPopupForm.Create(AOwner: TComponent);
begin
  inherited CreateNew(AOwner{$IFDEF FPC}, 0{$ENDIF});
  Tag := $FFFF;
  BorderStyle := bsNone;
  FormStyle := fsStayOnTop;
  Position := poDesigned;
end;

destructor TvxPopupForm.Destroy;
begin
  if FPopup <> nil then
    FPopup.ClosePopup;
  inherited;
end;

procedure TvxPopupForm.CreateParams(var Params: TCreateParams);
begin
  inherited;
  with Params do
  begin
    {$IFNDEF FPC}
    WindowClass.Style := WindowClass.Style or CS_SAVEBITS;
    {$ENDIF}
  end;
end;

{$IFNDEF FPC}

procedure TvxPopupForm.CMShowingChanged(var Message: TMessage);
const
  ShowFlags: array[Boolean] of UINT = (
    SWP_NOSIZE or SWP_NOMOVE or SWP_NOZORDER or SWP_NOACTIVATE or SWP_HIDEWINDOW,
    SWP_NOSIZE or SWP_NOMOVE or SWP_NOZORDER or SWP_NOACTIVATE or SWP_SHOWWINDOW);
begin
  { Must override TCustomForm/TForm's CM_SHOWINGCHANGED handler so that the
    form doesn't get activated when Visible is set to True. }
  SetWindowPos(WindowHandle, 0, 0, 0, 0, 0, ShowFlags[Showing]);
end;

procedure TvxPopupForm.WMActivate(var Msg: TWMActivate);
var
  C: TWinControl;
begin
  if (FOwnerForm <> nil) then
  begin
    { Activate OwnerForm }
    SendMessage(FOwnerForm.Handle, WM_NCACTIVATE, 1, 0);
  end;
  if (Msg.Active = WA_INACTIVE) and (FPopup <> nil) and (not FPopup.StaysOpen) then
  begin
    C := FindControl(Msg.ActiveWindow);
    if (C <> nil) and (C is TvxPopupForm) and (not TvxPopupForm(C).FPopup.StaysOpen) then
    begin
      if (PopupList.IndexOf(TvxPopupForm(C).FPopup) >= 0) and (PopupList.IndexOf(FPopup) > PopupList.IndexOf(TvxPopupForm(C).FPopup)) then
        FPopup.ClosePopup;
      Exit;
    end;
    CloseAllPopups;
  end;
end;

procedure TvxPopupForm.WMMouseActivate(var Msg: TWMMouseActivate);
begin
  if (FOwnerForm <> nil) then
  begin
    { Activate OwnerForm }
    Msg.Result := MA_NOACTIVATE;
    //    SendMessage(FOwnerForm.Handle, WM_NCACTIVATE, 1, 0);
  end;
end;
{$ELSE}

procedure TvxPopupForm.WMDeactivate(var Msg: TLMActivate);
var
  C: TWinControl;
begin
  inherited;
  if (not Msg.Active) and (FPopup <> nil) and (not FPopup.StaysOpen) then
  begin
    C := FindControl(Msg.ActiveWindow);
    if (C <> nil) and (C is TvxPopupForm) and (not TvxPopupForm(C).FPopup.StaysOpen) then
    begin
      if (PopupList.IndexOf(TvxPopupForm(C).FPopup) >= 0) and (PopupList.IndexOf(FPopup) > PopupList.IndexOf(TvxPopupForm(C).FPopup)) then
        FPopup.ClosePopup;
      Exit;
    end;
    CloseAllPopups;
  end;
end;

{$ENDIF}

procedure TvxPopupForm.DoClose(var Action: TCloseAction);
begin
  inherited;
  Action := caFree;
  if (FPopup <> nil) then
  begin
    FNoFree := true;
    FPopup.ClosePopup;
  end;
end;

{$ENDIF}

{ TvxPopup }

constructor TvxPopup.Create(AOwner: TComponent);
begin
  inherited;
  {$IFDEF NOVCL}
  {$IFDEF DARWIN}
  FPlacementScene := vgPlacementSceneTarget;
  {$ENDIF}
  {$ENDIF}
  FPlacementRectangle := TvxBounds.Create(vgRect(0, 0, 0, 0));
  Visible := false;
  CanFocused := true;
end;

destructor TvxPopup.Destroy;
begin
  ClosePopup;
  FPlacementRectangle.Free;
  inherited;
end;

procedure TvxPopup.Paint;
var
  R: TvxRect;
begin
  inherited;
  if Assigned(Scene) and Scene.GetDesignTime then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
  end;
end;

procedure TvxPopup.ApplyPlacement;
var
  Target: TvxVisualObject;
  AbsolutePos, LocalPos: TvxPoint;
  Pos: TPoint;
begin
  Target := PlacementTarget;

  if (Target = nil) and (Parent <> nil) then
    Target := Parent.Visual;
  if Target = nil then
  begin
    case Placement of
      vgPlacementBottom:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left + HorizontalOffset, FPlacementRectangle.bottom + VerticalOffset);
        end;
      vgPlacementTop:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left + HorizontalOffset, FPlacementRectangle.top - Height - VerticalOffset);
        end;
      vgPlacementLeft:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left - Width - HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementRight:
        begin
          LocalPos := vgPoint(FPlacementRectangle.right + HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementBottomCenter:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left + HorizontalOffset, FPlacementRectangle.bottom + VerticalOffset);
        end;
      vgPlacementTopCenter:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left + HorizontalOffset, FPlacementRectangle.top - Height - VerticalOffset);
        end;
      vgPlacementLeftCenter:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left - Width - HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementRightCenter:
        begin
          LocalPos := vgPoint(FPlacementRectangle.right + HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementCenter:
        begin
          LocalPos := vgPoint(FPlacementRectangle.left + (FPlacementRectangle.right - FPlacementRectangle.left - Width) / 2,
            FPlacementRectangle.top + (FPlacementRectangle.bottom - FPlacementRectangle.top - Height) / 2);
          LocalPos.X := LocalPos.X + HorizontalOffset;
          LocalPos.Y := LocalPos.Y + VerticalOffset;
        end;
      vgPlacementAbsolute:
        begin
          {$IFNDEF NOVCL}
          if FPlacementScene = vgPlacementSceneNew then
          begin
            FPopupForm.Left := Round(FPlacementRectangle.Left);
            FPopupForm.Top := Round(FPlacementRectangle.Top);
          end;
          if FPlacementScene = vgPlacementSceneTarget then
          begin
            {            FPopupForm.Left := Round(FPlacementRectangle.Left);
                        FPopupForm.Top := Round(FPlacementRectangle.Top);}
          end;
          {$ENDIF}
          Exit;
        end;
      vgPlacementMouse:
        begin
          if IsOpen then
            Exit;
          {$IFNDEF NOVCL}
          GetCursorPos(Pos);
          if FPlacementScene = vgPlacementSceneNew then
          begin
            FPopupForm.Left := Pos.X;
            FPopupForm.Top := Pos.Y;
          end;
          if FPlacementScene = vgPlacementSceneTarget then
          begin
          end;
          {$ENDIF}
          Exit;
        end;
      vgPlacementMouseCenter:
        begin
          if IsOpen then
            Exit;
          {$IFNDEF NOVCL}
          GetCursorPos(Pos);
          if FPlacementScene = vgPlacementSceneNew then
          begin
            FPopupForm.Left := Pos.X - round(Width / 2);
            FPopupForm.Top := Pos.Y;
          end;
          if FPlacementScene = vgPlacementSceneTarget then
          begin
          end;
          {$ENDIF}
          Exit;
        end;
    end;
    Pos := Point(Trunc(LocalPos.X), Trunc(LocalPos.Y));
  end
  else
  begin
    case Placement of
      vgPlacementBottom:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(HorizontalOffset, Target.Height + VerticalOffset)
          else
            LocalPos := vgPoint(FPlacementRectangle.left + HorizontalOffset, FPlacementRectangle.bottom + VerticalOffset);
        end;
      vgPlacementTop:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(HorizontalOffset, -Height - HorizontalOffset)
          else
            LocalPos := vgPoint(FPlacementRectangle.left + HorizontalOffset, FPlacementRectangle.top - Height - VerticalOffset);
        end;
      vgPlacementLeft:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(-Width - HorizontalOffset, VerticalOffset)
          else
            LocalPos := vgPoint(FPlacementRectangle.left - Width - HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementRight:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(Target.Width + HorizontalOffset, VerticalOffset)
          else
            LocalPos := vgPoint(FPlacementRectangle.right + HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementBottomCenter:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(HorizontalOffset - (Width / 2) + (Target.Width / 2), Target.Height + VerticalOffset)
          else
            LocalPos := vgPoint((FPlacementRectangle.left + FPlacementRectangle.right) / 2 - (Width / 2) + HorizontalOffset,
              FPlacementRectangle.bottom + VerticalOffset);
        end;
      vgPlacementTopCenter:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(HorizontalOffset - (Width / 2) + (Target.Width / 2), -Height - HorizontalOffset)
          else
            LocalPos := vgPoint((FPlacementRectangle.left + FPlacementRectangle.right) / 2 - (Width / 2) + HorizontalOffset,
              FPlacementRectangle.top - Height - VerticalOffset);
        end;
      vgPlacementLeftCenter:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(-Width - HorizontalOffset, VerticalOffset - (Height / 2) + (Target.Height / 2))
          else
            LocalPos := vgPoint(FPlacementRectangle.left - Width - HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementRightCenter:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint(Target.Width + HorizontalOffset, VerticalOffset - (Height / 2) + (Target.Height / 2))
          else
            LocalPos := vgPoint(FPlacementRectangle.right + HorizontalOffset, FPlacementRectangle.top + VerticalOffset);
        end;
      vgPlacementCenter:
        begin
          if FPlacementRectangle.empty then
            LocalPos := vgPoint((Target.Width - Width) / 2, (Target.Height - Height) / 2)
          else
            LocalPos := vgPoint(FPlacementRectangle.left + (FPlacementRectangle.right - FPlacementRectangle.left - Width) / 2,
              FPlacementRectangle.top + (FPlacementRectangle.bottom - FPlacementRectangle.top - Height) / 2);
          LocalPos.X := LocalPos.X + HorizontalOffset;
          LocalPos.Y := LocalPos.Y + VerticalOffset;
        end;
      vgPlacementAbsolute:
        begin
          {$IFNDEF NOVCL}
          if FPlacementScene = vgPlacementSceneNew then
          begin
            FPopupForm.Left := Round(FPlacementRectangle.Left);
            FPopupForm.Top := Round(FPlacementRectangle.Top);
          end;
          if FPlacementScene = vgPlacementSceneTarget then
          begin
          end;
          {$ENDIF}
          Exit;
        end;
      vgPlacementMouse:
        begin
          if IsOpen then
            Exit;
          {$IFNDEF NOVCL}
          GetCursorPos(Pos);
          if FPlacementScene = vgPlacementSceneNew then
          begin
            FPopupForm.Left := Pos.X;
            FPopupForm.Top := Pos.Y;
            if FPopupForm.Monitor <> nil then
            begin
              if FPopupForm.Left + FPopupForm.Width > FPopupForm.Monitor.Left + FPopupForm.Monitor.Width then
                FPopupForm.Left := FPopupForm.Monitor.Left + FPopupForm.Monitor.Width - FPopupForm.Width;
              if FPopupForm.Top + FPopupForm.Height > FPopupForm.Monitor.Top + FPopupForm.Monitor.Height then
                FPopupForm.Top := FPopupForm.Monitor.Top + FPopupForm.Monitor.Height - FPopupForm.Height;
            end;
          end;
          if FPlacementScene = vgPlacementSceneTarget then
          begin
          end;
          {$ENDIF}
          Exit;
        end;
      vgPlacementMouseCenter:
        begin
          if IsOpen then
            Exit;
          {$IFNDEF NOVCL}
          GetCursorPos(Pos);
          if FPlacementScene = vgPlacementSceneNew then
          begin
            FPopupForm.Left := Pos.X - round(Width / 2);
            FPopupForm.Top := Pos.Y;
            if FPopupForm.Monitor <> nil then
            begin
              if FPopupForm.Left + FPopupForm.Width > FPopupForm.Monitor.Left + FPopupForm.Monitor.Width then
                FPopupForm.Left := FPopupForm.Monitor.Left + FPopupForm.Monitor.Width - FPopupForm.Width;
              if FPopupForm.Top + FPopupForm.Height > FPopupForm.Monitor.Top + FPopupForm.Monitor.Height then
                FPopupForm.Top := FPopupForm.Monitor.Top + FPopupForm.Monitor.Height - FPopupForm.Height;
            end;
          end;
          if FPlacementScene = vgPlacementSceneTarget then
          begin
          end;
          {$ENDIF}
          Exit;
        end;
    end;
    AbsolutePos := Target.LocalToAbsolute(LocalPos);
    Pos := Point(Trunc(AbsolutePos.X), Trunc(AbsolutePos.Y));
    if FPlacementScene = vgPlacementSceneNew then
    begin
      if (Target.Scene <> nil) then
        Pos := Point(round(Target.Scene.LocalToScreen(vgPoint(Pos.X, Pos.Y)).x), round(Target.Scene.LocalToScreen(vgPoint(Pos.X, Pos.Y)).y))
      else
        if (Scene <> nil) then
        Pos := Point(round(Scene.LocalToScreen(vgPoint(Pos.X, Pos.Y)).x), round(Scene.LocalToScreen(vgPoint(Pos.X, Pos.Y)).y));
    end;
  end;

  if FPlacementScene = vgPlacementSceneNew then
  begin
    {$IFNDEF NOVCL}
    FPopupForm.Left := Pos.X;
    FPopupForm.Top := Pos.Y;
    if FPopupForm.Monitor <> nil then
    begin
      if FPopupForm.Left + FPopupForm.Width > FPopupForm.Monitor.Left + FPopupForm.Monitor.Width then
        FPopupForm.Left := FPopupForm.Monitor.Left + FPopupForm.Monitor.Width - FPopupForm.Width;
      if FPopupForm.Top + FPopupForm.Height > FPopupForm.Monitor.Top + FPopupForm.Monitor.Height then
        FPopupForm.Top := FPopupForm.Monitor.Top + FPopupForm.Monitor.Height - FPopupForm.Height;
    end;
    {$ELSE}
    TvxForm(FPopupScene).Left := Pos.X;
    TvxForm(FPopupScene).Top := Pos.Y;
    {$ENDIF}
  end;
  if FPlacementScene = vgPlacementSceneTarget then
  begin
    if (Parent <> nil) and (Parent.IsVisual) then
      AbsolutePos := Parent.Visual.AbsoluteToLocal(AbsolutePos);
    Position.Point := AbsolutePos;
  end;
end;

procedure TvxPopup.Popup;
begin
  if FAnimating then
  begin
    FIsOpen := false;
    Exit;
  end;
  {$IFNDEF NOVCL}
  if FPopupForm <> nil then
  begin
    ClosePopup;
    Exit;
  end;
  {$ENDIF}

  FSaveScale := Scale.Point;
  FSaveParent := Parent;
  case PlacementScene of
    vgPlacementSceneNew:
      begin
        {$IFNDEF NOVCL}
        FPopupForm := TvxPopupForm.Create(Application);
        if Owner is TCustomForm then
          TvxPopupForm(FPopupForm).FOwnerForm := TCustomForm(Owner);
        if (Scene <> nil) and (Scene.GetComponent <> nil) and (Scene.GetComponent.Owner is TCustomForm) then
          TvxPopupForm(FPopupForm).FOwnerForm := TCustomForm(Scene.GetComponent.Owner);
        FPopupForm.Width := Round(Width * AbsoluteMatrix.m11);
        FPopupForm.Height := Round(Height * AbsoluteMatrix.m22);
        Scale.X := AbsoluteMatrix.m11;
        Scale.Y := AbsoluteMatrix.m22;
        ApplyPlacement;
        TvxPopupForm(FPopupForm).FPopup := Self;
        TvxPopupForm(FPopupForm).FNoFree := false;
        FPopupScene := TDicomScene.Create(FPopupForm);
        with FPopupScene do
        begin
          Transparency := true;
          Parent := FPopupForm;
          Align := alClient;
          Style := Self.FStyle;
          if (FStyle = nil) and Assigned(FScene) then
            Style := FScene.GetStyle;
        end;
        FPopupScene.Width := Round(Width);
        FPopupScene.Height := Round(Height);
        { show }
        Visible := true;
        { add self}
        FPopupScene.AddObject(Self);
        SetNewScene(FPopupScene);
        FPopupScene.ActiveControl := Self;
        { apply resoruces }
        FNeedResource := true;
        ApplyResource;
        { show }
        FPopupForm.Show;
        FPopupScene.SetFocus;
        SetFocus;
        {$ELSE}
        FPopupScene := TvxForm.CreateNew(nil);
        TvxForm(FPopupScene).TopMost := true;
        //        TvxForm(FPopupScene).ShowActivated := false;
        TvxForm(FPopupScene).StaysOpen := StaysOpen;
        TvxForm(FPopupScene).BorderStyle := bsNone;
        TvxForm(FPopupScene).Transparency := true;
        TvxForm(FPopupScene).Width := Round(Width * AbsoluteMatrix.m11);
        TvxForm(FPopupScene).Height := Round(Height * AbsoluteMatrix.m22);
        TvxForm(FPopupScene).OnClose := DoFormClose;
        TvxForm(FPopupScene).Style := FStyle;
        if (FStyle = nil) and Assigned(FScene) then
          TvxForm(FPopupScene).Style := FScene.GetStyle;
        Scale.X := AbsoluteMatrix.m11;
        Scale.Y := AbsoluteMatrix.m22;
        ApplyPlacement;
        { show }
        Visible := true;
        { add self}
        FSaveParent := Parent;
        FPopupScene.AddObject(Self);
        SetNewScene(TvxForm(FPopupScene));
        { apply resoruces }
        FNeedResource := true;
        ApplyResource;
        { show }
        TvxForm(FPopupScene).Show;
        {$ENDIF}
      end;
    vgPlacementSceneTarget:
      begin
        FPopupLayout := TvxVisualObject.Create(Self);
        if (FPlacementTarget <> nil) and (FPlacementTarget.Scene <> nil) then
          FPopupLayout.Parent := TvxVisualObject(FPlacementTarget.Scene.GetRoot)
        else
          FPopupLayout.Parent := Scene.GetRoot;
        FPopupLayout.Align := vaContents;
        FPopupLayout.OnClick := DoPopupLayoutClick;
        FPopupLayout.HitTest := not FStaysOpen;
        { add self}
        if FScene <> nil then
          FSaveFocused := FScene.GetFocused;
        FSaveParent := Parent;
        Parent := FPopupLayout;
        SetNewScene(FPopupLayout.Scene);
        SetFocus;
        ApplyPlacement;
        { show }
        Visible := true;
        { apply resoruces }
        FNeedResource := true;
        ApplyResource;
        { show }
        BringToFront;
        CanFocused := true;
        SetFocus;
      end;
  end;
  if PopupList = nil then
    PopupList := TList.Create;
  if not StaysOpen then
    PopupList.Add(Self);
  { trigger }
  FIsOpen := true;
  ApplyTriggerEffect(Self, 'IsOpen');
  StartTriggerAnimation(Self, 'IsOpen');
  { drag timer }
  {$IFNDEF NOVCL}
  if (FPlacementScene = vgPlacementSceneNew) and FDragWithParent and FStaysOpen then
  begin
    FDragTimer := TvxTimer.Create(Self);
    FDragTimer.Interval := 10;
    FDragTimer.OnTimer := DoTimer;
    FDragTimer.Enabled := true;
  end;
  {$ENDIF}
end;

procedure TvxPopup.SetModalResult(const Value: TModalResult);
begin
  FModalResult := Value;
  {$IFNDEF NOVCL}
  if FPopupForm <> nil then
    FPopupForm.ModalResult := Value;
  {$ENDIF}
end;

function TvxPopup.PopupModal: TModalResult;
begin
  {$IFNDEF NOVCL}
  if FAnimating then
  begin
    FIsOpen := false;
    Exit;
  end;
  if FPopupForm <> nil then
  begin
    if FModal then
    begin
      FModalResult := mrCancel;
      FModal := false;
      Exit;
    end;
    ClosePopup;
    Exit;
  end;
  Popup;
  FModalResult := 0;
  FModal := true;
  repeat
    Application.HandleMessage;
    if Application.Terminated then
    begin
      FModalResult := mrCancel;
      if FPopupForm <> nil then
        FPopupForm.ModalResult := mrCancel;
    end;
    if FPopupForm <> nil then
    begin
      ApplyPlacement;
      FModalResult := FPopupForm.ModalResult;
    end;
  until not ((FModalResult = 0) and FModal);
  FModal := true;
  Result := FModalResult;
  ClosePopup;
  {$ENDIF}
end;

procedure TvxPopup.DialogKey(var Key: Word; Shift: TShiftState);
begin
  inherited DialogKey(Key, Shift);
  if (Key = VK_ESCAPE) and (IsOpen) and not (StaysOpen) then
  begin
    IsOpen := false;
    Key := 0;
  end;
end;

procedure TvxPopup.ClosePopup;
var
  Idx, i: integer;
begin
  if FAnimating then
    Exit;
  if (PlacementScene = vgPlacementSceneNew) and (FPopupScene = nil) then
    Exit;
  if FModal and (FModalResult = 0) then
  begin
    ModalResult := mrCancel;
    Exit;
  end;
  { drag timer }
  {$IFNDEF NOVCL}
  if (FDragTimer <> nil) then
    FreeAndNil(FDragTimer);
  {$ENDIF}
  { trigger }
  FAnimating := true;
  FIsOpen := false;
  if not (csDestroying in ComponentState) then
  begin
    ApplyTriggerEffect(Self, 'IsOpen');
    StartTriggerAnimationWait(Self, 'IsOpen');
  end;
  { hide }
  Visible := false;
  { remove self}
  if FPlacementScene = vgPlacementSceneNew then
  begin
    FPopupScene.RemoveObject(Self);
    SetNewScene(nil);
    { free}
    {$IFNDEF NOVCL}
    if not TvxPopupForm(FPopupForm).FNoFree then
    begin
      FPopupScene := nil; // Free called by PopupForm.Release
      TvxPopupForm(FPopupForm).FPopup := nil;
      FPopupForm.Release;
      FPopupForm := nil;
    end
    else
      FPopupForm := nil;
    {$ELSE}
    TvxForm(FPopupScene).Release;
    {$ENDIF}
    FPopupScene := nil;
    Scale.Point := FSaveScale;
    Parent := FSaveParent;
  end;
  if FPlacementScene = vgPlacementSceneTarget then
  begin
    SetNewScene(nil);
    Parent := FSaveParent;
    if FSaveFocused <> nil then
      FSaveFocused.SetFocus;
    FSaveFocused := nil;
    FPopupLayout.Free;
    FPopupLayout := nil;
  end;
  FAnimating := false;
  FSaveParent := nil;
  if Assigned(FOnClosePopup) then
    FOnClosePopup(Self);
  if (PopupList <> nil) then
    PopupList.Remove(Self);
end;

procedure TvxPopup.KillFocus;
begin
  inherited;
end;

procedure TvxPopup.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (AComponent = FPlacementTarget) and (Operation = opRemove) then
    FPlacementTarget := nil;
  if (AComponent = FSaveParent) and (Operation = opRemove) then
    FSaveParent := nil;
end;

procedure TvxPopup.SetIsOpen(const Value: boolean);
begin
  if FIsOpen <> Value then
  begin
    if Assigned(Scene) and Scene.GetDesignTime then
    begin
      FIsOpen := false;
      Exit;
    end;
    FIsOpen := Value;
    if FIsOpen then
      Popup
    else
      ClosePopup;
  end;
end;

procedure TvxPopup.DoFormClose(Sender: TObject; var Action: TCloseAction);
begin
  {$IFDEF NOVCL}
  if (FIsOpen) and (not StaysOpen) then
  begin
    if FModal then
      TvxForm(FPopupScene).ModalResult := mrCancel
    else
      ClosePopup;
    Action := caFree;
  end;
  {$ENDIF}
end;

procedure TvxPopup.DoPopupLayoutClick(Sender: TObject);
begin
  if (FIsOpen) and (not StaysOpen) then
    ClosePopup;
end;

procedure TvxPopup.Dotimer(Sender: TObject);
begin
  ApplyPlacement;
end;

procedure TvxPopup.SetPlacementRectangle(const Value: TvxBounds);
begin
end;

{ TvxPopupItem }

constructor TvxPopupItem.Create(AOwner: TComponent);
begin
  inherited;
  FPopup := TvxPopup.Create(Self);
  FPopup.PlacementTarget := Self;
  //  FPopup.PlacementScene := vgPlacementSceneTarget;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FPopup.OnClosePopup := DoClosePopup;
end;

destructor TvxPopupItem.Destroy;
begin
  inherited;
end;

procedure TvxPopupItem.AddObject(AObject: TvxObject);
begin
  if (FPopup <> nil) and (AObject <> FPopup) and (AObject <> FResourceLink) and not (AObject is TvxEffect) and not (AObject is TvxAnimation) then
  begin
    FPopup.AddObject(AObject);
  end
  else
    inherited;
end;

procedure TvxPopupItem.GetChildren(Proc: TGetChildProc; Root: TComponent);
var
  j: integer;
begin
  inherited;
  if (FPopup <> nil) then
    if (FPopup.ChildrenCount > 0) then
    begin
      for j := 0 to FPopup.ChildrenCount - 1 do
        if FPopup.Children[j].Stored then
          Proc(TComponent(FPopup.Children[j]));
    end;
end;

procedure TvxPopupItem.Realign;
begin
  inherited;
  ApplyPlacement;
end;

procedure TvxPopupItem.ApplyPlacement;
var
  SavePlacement: TvxPlacementScene;
begin
  FPopup.Placement := Placement;
  FPopup.VerticalOffset := VerticalOffset;
  FPopup.HorizontalOffset := HorizontalOffset;
  if (FScene <> nil) and (FScene.GetDesignTime) and not (FPopup.DesignHide) then
  begin
    SavePlacement := FPopup.PlacementScene;
    FPopup.PlacementScene := vgPlacementSceneTarget;
    FPopup.ApplyPlacement;
    FPopup.PlacementScene := SavePlacement;
  end;
end;

procedure TvxPopupItem.DesignClick;
begin
  inherited;
  FPopup.DesignHide := not FPopup.DesignHide;
  ApplyPlacement;
  FPopup.Locked := FPopup.DesignHide;
end;

procedure TvxPopupItem.DefineProperties(Filer: TFiler);
begin
  inherited;
  Filer.DefineProperty('PopupSize', ReadRect, WriteRect, true);
end;

procedure TvxPopupItem.ReadRect(Reader: TReader);
var
  R: TvxRect;
begin
  R := vgStringToRect(Reader.ReadString);
  FPopup.SetBounds(FPopup.Position.X, FPopup.Position.Y, vgRectWidth(R), vgRectHeight(R));
end;

procedure TvxPopupItem.WriteRect(Writer: TWriter);
begin
  Writer.WriteString(vgRectToString(FPopup.LocalRect));
end;

procedure TvxPopupItem.DoClosePopup(Sender: TObject);
var
  List: TList;
  i: integer;
begin
  // close all children
  List := TList.Create;
  AddControlsToList(List);
  for i := 0 to List.Count - 1 do
    if (TObject(List[i]) is TvxPopupItem) then
      TvxPopupItem(List[i]).MouseLeave;
  List.Free;
end;

procedure TvxPopupItem.MouseEnter;
begin
  inherited;
  if (FPopup <> nil) and not (FPopup.IsOpen) then
  begin
    ApplyPlacement;
    FPopup.IsOpen := true;
  end;
end;

procedure TvxPopupItem.MouseLeave;
var
  P: TPoint;
begin
  inherited;
  if (FPopup <> nil) and (FPopup.IsOpen) then
  begin
    {$IFNDEF NOVCL}
    if FPopup.FPopupScene <> nil then
    begin
      GetCursorPos(P);
      with FPopup.FPopupScene.ScreenToClient(P) do
      begin
        if FPopup.PointInObject(x, y) then
          Exit;
      end;
    end
    else
    begin
      GetCursorPos(P);
      with TDicomScene(FScene.GetComponent).ScreenToClient(P) do
      begin
        if FPopup.PointInObject(x, y) then
          Exit;
        if PointInObject(x, y) then
          Exit;
      end;
    end;
    FPopup.IsOpen := false;
    {$ENDIF}
  end;
end;

procedure TvxPopupItem.SetPlacement(Value: TvxPlacement);
begin
  if FPlacement <> Value then
  begin
    FPlacement := Value;
    ApplyPlacement;
  end;
end;

procedure TvxPopupItem.SetHorizontalOffset(Value: single);
begin
  if FHorizontalOffset <> Value then
  begin
    FHorizontalOffset := Value;
    ApplyPlacement;
  end;
end;

procedure TvxPopupItem.SetVerticalOffset(Value: single);
begin
  if FVerticalOffset <> Value then
  begin
    FVerticalOffset := Value;
    ApplyPlacement;
  end;
end;

{ TvxMessagePopup }

const

  ModalResults: array[TvxMessageButton] of Integer = (
    mrYes, mrNo, mrOk, mrCancel, mrAbort, mrRetry, mrIgnore, mrAll, mrNoToAll,
    mrYesToAll, 0);
  MessageButtonNames: array[TvxMessageButton] of WideString = (

    'Yes', 'No', 'OK', 'Cancel', 'Abort', 'Retry', 'Ignore', 'All', 'NoToAll',
    'YesToAll', 'Help');

constructor TvxMessagePopup.Create(AOwner: TComponent);
begin
  inherited;
  FDragWithParent := true;
  FStaysOpen := true;
  FDisableScene := true;
end;

destructor TvxMessagePopup.Destroy;
begin
  inherited;
end;

function TvxMessagePopup.PopupModal: TModalResult;
var
  SaveEnabled: boolean;
begin
  if (Scene <> nil) and (Scene.GetRoot <> nil) and FDisableScene then
  begin
    SaveEnabled := Scene.GetRoot.Visual.Enabled;
    Scene.GetRoot.Visual.Enabled := false;
  end;
  Result := inherited PopupModal;
  if (Scene <> nil) and (Scene.GetRoot <> nil) and FDisableScene then
  begin
    Scene.GetRoot.Visual.Enabled := SaveEnabled;
  end;
end;

procedure TvxMessagePopup.ApplyPlacement;
begin
  if PlacementTarget = nil then
  begin
    {$IFNDEF NOVCL}
    if (Owner <> nil) and (Owner is TCustomForm) then
    begin
      with TCustomForm(Owner).ClientToScreen(Point(0, 0)) do
        PlacementRectangle.Rect := vgRect(X, Y, X + Width, Y);
      HorizontalOffset := (TCustomForm(Owner).Width - Width) / 2;
    end;
    {$ENDIF}
  end
  else
  begin
    HorizontalOffset := (PlacementTarget.Width - Width) / 2;
  end;
  inherited;
end;

function MessagePopup(const ACaption, AMessage: WideString; AType: TvxMessageType;
  Buttons: TvxMessageButtons; const AOwner: IvgScene; const Target: TvxVisualObject = nil;
  const ADisableScene: boolean = true;
  const ABitmap: TvxBitmap = nil;
  const AStyle: TvxResources = nil): integer;
var
  B, DefaultButton, CancelButton: TvxMessageButton;
  PopupCtrl: TvxMessagePopup;
  C, M: TvxLabel;
  L: TvxLayout;
  I: TvxVisualObject;
  Btn: TvxButton;
  SaveEnabled: boolean;
begin
  if (AOwner <> nil) and (AOwner.GetRoot <> nil) and ADisableScene then
  begin
    SaveEnabled := AOwner.GetRoot.Visual.Enabled;
    AOwner.GetRoot.Visual.Enabled := false;
  end;
  try
    if (AOwner <> nil) and (AOwner.GetComponent <> nil) then
      PopupCtrl := TvxMessagePopup.Create(AOwner.GetComponent.Owner)
    else
      PopupCtrl := TvxMessagePopup.Create(AOwner.GetComponent);
    PopupCtrl.StaysOpen := true;
    PopupCtrl.DragWithParent := true;
    PopupCtrl.PlacementScene := vgPlacementSceneNew;
    PopupCtrl.Width := 500;
    PopupCtrl.Height := 150;
    PopupCtrl.Style := AStyle;
    PopupCtrl.PlacementTarget := Target;
    if Target <> nil then
    begin
      PopupCtrl.Scale.Point := vgPoint(Target.AbsoluteMatrix.m11, Target.AbsoluteMatrix.m22);
    end;
    if (AStyle = nil) and (AOwner <> nil) and (AOwner.GetStyle <> nil) then
      PopupCtrl.Style := AOwner.GetStyle;

    PopupCtrl.ApplyResource;

    if ABitmap <> nil then
    begin
      I := TvxImage.Create(PopupCtrl);
      with TvxImage(I) do
      begin
        Parent := PopupCtrl;
        SetBounds(30, 10, 64, 64);
        Bitmap.Assign(ABitmap);
      end;
    end
    else
    begin
      I := TvxControl.Create(PopupCtrl);
      with I do
      begin
        Parent := PopupCtrl;
        SetBounds(30, 10, 64, 64);
      end;
      case AType of
        vgMessageWarning: TvxControl(I).Resource := 'iconwarning';
        vgMessageError: TvxControl(I).Resource := 'iconerror';
        vgMessageInformation: TvxControl(I).Resource := 'iconinformation';
        vgMessageConfirmation: TvxControl(I).Resource := 'iconconfirmation';
      end;
    end;

    if vgButtonOk in Buttons then
      DefaultButton := vgButtonOk
    else
      if vgButtonYes in Buttons then
      DefaultButton := vgButtonYes
    else
      DefaultButton := vgButtonRetry;
    if vgButtonCancel in Buttons then
      CancelButton := vgButtonCancel
    else
      if vgButtonNo in Buttons then
      CancelButton := vgButtonNo
    else
      CancelButton := vgButtonOk;

    C := TvxLabel.Create(PopupCtrl);
    with C do
    begin
      Parent := PopupCtrl;
      Align := vaTop;
      Height := 30;
      Padding.Rect := vgRect(30, 10, 30, 0);
      if I <> nil then
        Padding.Left := Padding.Rect.Left + I.width + 10;
      Text := ACaption;
      TextAlign := vgTextAlignNear;
      Font.Size := Font.Size * 1.4;
    end;
    M := TvxLabel.Create(PopupCtrl);
    with M do
    begin
      Parent := PopupCtrl;
      Align := vaClient;
      Height := 50;
      Padding.Rect := vgRect(30, 0, 30, 0);
      if I <> nil then
        Padding.Left := Padding.Rect.Left + I.width + 10;
      Text := AMessage;
      TextAlign := vgTextAlignNear;
    end;
    L := TvxLayout.Create(PopupCtrl);
    with L do
    begin
      Parent := PopupCtrl;
      Align := vaBottom;
      Height := 20;
      Padding.Rect := vgRect(30, 0, 30, 30);
    end;
    for B := Low(TvxMessageButton) to High(TvxMessageButton) do
    begin
      if not (B in Buttons) then
        Continue;
      Btn := TvxButton.Create(PopupCtrl);
      with Btn do
      begin
        Parent := L;
        Align := vaRight;
        Position.X := 1000;
        Padding.Rect := vgRect(7, 0, 0, 0);
        Text := MessageButtonNames[B];
        ModalResult := ModalResults[B];
        if B = DefaultButton then
          Default := True;
        if B = CancelButton then
          Cancel := True;
      end;
    end;

    Result := PopupCtrl.PopupModal;
    PopupCtrl.Free;
  finally
    if (AOwner <> nil) and (AOwner.GetRoot <> nil) and ADisableScene then
      AOwner.GetRoot.Visual.Enabled := SaveEnabled;
  end;
end;

{ TvxTimer ====================================================================}

{$IFDEF NOVCL}

const
  cIdNoTimer = THandle(-1);

constructor TvxTimer.Create(AOwner: TComponent);
begin
  inherited Create(AOwner);
  FInterval := 1000;
  FTimerHandle := cIdNoTimer;
  FEnabled := true;
end;

destructor TvxTimer.Destroy;
begin
  FOnTimer := nil;
  FEnabled := false;
  KillTimer;
  inherited Destroy;
end;

procedure TvxTimer.KillTimer;
begin
  if FTimerHandle <> cIdNoTimer then
  begin
    Platform.DestroyTimer(FTimerHandle);
    FTimerHandle := cIdNoTimer;
  end;
end;

procedure TvxTimer.Loaded;
begin
  inherited Loaded;
  UpdateTimer;
end;

procedure TvxTimer.UpdateTimer;
begin
  KillTimer;
  if (FEnabled) and (FInterval > 0) and (([csDesigning, csLoading, csDestroying] * ComponentState = [])) and Assigned(FOnTimer) then
  begin
    FTimerHandle := Platform.CreateTimer(FInterval, Timer);
    if FTimerHandle = 0 then
    begin
      FTimerHandle := cIdNoTimer;
    end;
  end;
end;

procedure TvxTimer.Timer;
begin
  if (FEnabled) and (FInterval > 0) then
    DoOnTimer;
end;

procedure TvxTimer.SetOnTimer(Value: TNotifyEvent);
begin
  if @Value = @FOnTimer then
    Exit;
  FOnTimer := value;
  UpdateTimer;
end;

procedure TvxTimer.DoOnTimer;
begin
  if Assigned(FOnTimer) then
    FOnTimer(Self);
end;

procedure TvxTimer.SetEnabled(value: boolean);
begin
  if (Value <> FEnabled) then
  begin
    FEnabled := value;
    UpdateTimer;
  end;
end;

procedure TvxTimer.SetInterval(value: cardinal);
begin
  if (value <> FInterval) then
  begin
    FInterval := value;
    UpdateTimer;
  end;
end;
{$ENDIF}

type
  TvxHackTabItem = class(TvxTabItem);

  { TvxTabItem }

constructor TvxTabItem.Create(AOwner: TComponent);
begin
  inherited;
  FAutoTranslate := true;
  Height := 20;
  Width := 80;
  HitTest := true;
end;

procedure TvxTabItem.ApplyStyle;
begin
  inherited;
  if (Parent <> nil) and (Parent is TvxTabControl) and (TvxTabControl(Parent).ItemIndex = Index) then
    Select(true)
  else
    Select(false)
end;

destructor TvxTabItem.Destroy;
begin
  inherited;
end;

procedure TvxTabItem.DesignSelect;
begin
  inherited;
  if (Parent <> nil) and (Parent is TvxTabControl) then
    TvxTabControl(Parent).ItemIndex := Index;
end;

procedure TvxTabControl.AddObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxTabItem then
    Realign;
end;

procedure TvxTabItem.Realign;
begin
  inherited;
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  if (FLayout <> nil) and (Parent <> nil) and (Parent is TvxTabControl) then
  begin
    FLayout.Position.X := TvxTabControl(Parent).Margins.left + FLayout.Padding.left;
    FLayout.Position.Y := Self.Height + TvxTabControl(Parent).Margins.top + FLayout.Padding.bottom;
    FLayout.Width := TvxTabControl(Parent).Width - TvxTabControl(Parent).Margins.left - TvxTabControl(Parent).Margins.right -
      FLayout.Padding.left - FLayout.Padding.Right;
    FLayout.Height := TvxTabControl(Parent).Height - Self.Height - TvxTabControl(Parent).Margins.top - TvxTabControl(Parent).Margins.bottom -
      FLayout.Padding.top - FLayout.Padding.bottom;
  end;
  FDisableAlign := false;
end;

procedure TvxTabItem.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    if (Parent <> nil) and (Parent is TvxTabControl) then
    begin
      TvxTabControl(Parent).ItemIndex := Index;
    end;
  end;
end;

procedure TvxTabItem.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FLayout) then
    FLayout := nil;
end;

procedure TvxTabItem.Select(ASelected: boolean);
begin
  FIsSelected := ASelected;
  StartTriggerAnimation(Self, 'IsSelected');
  ApplyTriggerEffect(Self, 'IsSelected');
end;

procedure TvxTabItem.SetIndex(const Value: integer);
begin
  if FIndex <> Value then
  begin
    inherited Index := Value;
    Realign;
  end;
end;

procedure TvxTabItem.SetVisible(const Value: boolean);
var
  S: TvxTabItem;
begin
  if Value <> Visible then
  begin
    S := TvxTabControl(Parent).TabItem(TvxTabControl(Parent).ItemIndex);
    inherited;
    if not Visible and IsSelected then
    begin
      Select(false);
      TvxTabControl(Parent).FItemIndex := -1;
      if Index >= TvxTabControl(Parent).TabCount then
        TvxTabControl(Parent).ItemIndex := TvxTabControl(Parent).TabCount - 1
      else
        TvxTabControl(Parent).ItemIndex := Index;
    end
    else
    begin
      TvxTabControl(Parent).Realign;
      if S <> nil then
      begin
        TvxTabControl(Parent).FItemIndex := -1;
        TvxTabControl(Parent).ItemIndex := S.Index;
      end;
    end;
  end;
end;

{ TvxTab ==================================================================}

constructor TvxTabControl.Create(AOwner: TComponent);
begin
  inherited;
  FItemIndex := -1;
  AutoCapture := true;
  Width := 200;
  Height := 200;
end;

destructor TvxTabControl.Destroy;
begin
  inherited;
end;

procedure TvxTabControl.FreeStyle;
begin
  inherited;
  FBackground := nil;
end;

procedure TvxTabControl.ApplyStyle;
var
  B: TvxObject;
begin
  inherited;
  B := FindResource('background');
  if (B <> nil) and (B.IsVisual) then
  begin
    FBackground := B.Visual;
  end;
  Realign;
end;

procedure TvxTabControl.PaintChildren;
var
  Sel: TvxTabItem;
  SaveOp: single;
begin
  Sel := TabItem(ItemIndex);
  if (Sel <> nil) and (Sel.Visible) then
  begin
    SaveOp := Sel.Opacity;
    Sel.Opacity := 0;
    inherited;
    Sel.Opacity := SaveOp;

    Canvas.SetMatrix(Sel.AbsoluteMatrix);
    Sel.BeforePaint;
    Sel.Paint;
    Sel.PaintChildren;
  end
  else
    inherited;
end;

procedure TvxTabControl.Realign;
var
  Idx, i: integer;
  CurX, CurY: single;
  AutoWidth, MaxHeight: single;
  B: TvxObject;
begin
  inherited;
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  { move all non TabItem to end of list }
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if not (TvxObject(FChildren[i]) is TvxTabItem) then
        TvxObject(FChildren[i]).Index := FChildren.Count - 1;
  { calc max height }
  MaxHeight := 0;
  Idx := 0;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]) is TvxTabItem then
        with TvxTabItem(FChildren[i]) do
        begin
          if not Visible then
            Continue;
          FIndex := Idx;
          if Height + Padding.Top + Padding.Bottom > MaxHeight then
            MaxHeight := Height + Padding.Top + Padding.Bottom;
          Idx := Idx + 1;
        end;
  if Idx = 0 then
    MaxHeight := 0
  else
    if FItemHeight > 0 then
    MaxHeight := FItemHeight;
  { background }
  if FResourceLink <> nil then
  begin
    B := FResourceLink;
    if (B <> nil) and (B.IsVisual) then
      with TvxVisualObject(B) do
      begin
        Align := vaNone;
        Position.X := Padding.Left;
        Position.Y := MaxHeight + Padding.Top;
        Width := Self.Width - Padding.Left - Padding.Top;
        Height := Self.Height - MaxHeight - Padding.Top - Padding.Bottom;
        BringToFront;
      end;
  end;
  { align }
  CurX := 0;
  CurY := 0;
  { fullsize }
  AutoWidth := Width;
  if FBackground <> nil then
    AutoWidth := Width - FBackground.Margins.Left - FBackground.Margins.Right;
  if FFullSize and (Idx > 0) then
    AutoWidth := AutoWidth / Idx
  else
    AutoWidth := AutoWidth;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]) is TvxTabItem then
        with TvxTabItem(FChildren[i]) do
        begin
          if not Visible then
            Continue;
          Align := vaNone;
          if Layout <> nil then
          begin
            Layout.Align := vaNone;
            Layout.Visible := Index = ItemIndex;
            Layout.DesignHide := not (Index = ItemIndex);
            Layout.ClipChildren := true;
            if Layout.Visible then
              Layout.BringToFront;
          end;
          if FFullSize then
            SetBounds(CurX + Padding.Left, CurY + Padding.Top, AutoWidth, MaxHeight - Padding.Top - Padding.Bottom)
          else
            SetBounds(CurX + Padding.Left, CurY + Padding.Top, Width, MaxHeight - Padding.Top - Padding.Bottom);
          CurX := CurX + Padding.Left + Width + Padding.Right;
          Realign;
        end;
  FDisableAlign := false;
end;

function TvxTabControl.TabCount: integer;
var
  i: integer;
begin
  Result := 0;
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]) is TvxTabItem then
      begin
        if TvxTabItem(FChildren[i]).Visible then
        begin
          Inc(Result);
        end;
      end;
end;

function TvxTabControl.TabItem(AIndex: integer): TvxTabItem;
var
  i: integer;
begin
  { calc max height }
  if FChildren <> nil then
    for i := 0 to FChildren.Count - 1 do
      if TvxObject(FChildren[i]) is TvxTabItem then
      begin
        if TvxTabItem(FChildren[i]).Visible and (TvxTabItem(FChildren[i]).Index = AIndex) then
        begin
          Result := TvxTabItem(FChildren[i]);
          Exit;
        end;
      end;
  Result := nil;
end;

procedure TvxTabControl.KeyDown(var Key: Word; var KeyChar: WideChar;
  Shift: TShiftState);
begin
  //  inherited ;
end;

procedure TvxTabControl.KeyUp(var Key: Word; var KeyChar: WideChar;
  Shift: TShiftState);
begin
  //  inherited ;
end;

procedure TvxTabControl.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  Item: TvxTabItem;
begin
  inherited;
  Realign;
  {  if Button = mbLeft then
    begin
      Item := ItemByPoint(X, Y);
      if Item <> nil then
        ItemIndex := Item.Index;
      FMouseSelecting := true;
    end;}
end;

procedure TvxTabControl.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  Item: TvxTabItem;
begin
  inherited;
  {  if (ssLeft in Shift) and FMouseSelecting then
    begin
      Item := ItemByPoint(X, Y);
      if Item <> nil then
        ItemIndex := Item.Index;
    end;}
end;

procedure TvxTabControl.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  //  FMouseSelecting := false;
end;

procedure TvxTabControl.MouseWheel(Shift: TShiftState; WheelDelta: integer;
  var Handled: boolean);
begin
  inherited;
end;

procedure TvxTabControl.SetItemIndex(const Value: integer);
begin
  if FItemIndex <> Value then
  begin
    if TabItem(FItemIndex) <> nil then
      TabItem(FItemIndex).Select(false);
    FItemIndex := Value;
    Realign;
    if TabItem(FItemIndex) <> nil then
      TabItem(FItemIndex).Select(true);
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxTabItem.DesignInsert;
var
  L: TvxLayout;
begin
  inherited;
  if FLayout = nil then
  begin
    L := TvxLayout.Create(Owner);
    L.Parent := Parent;
    if vgDesigner <> nil then
      L.Name := vgDesigner.UniqueName(Owner, L.ClassName);
    Layout := L;
  end;
end;

function TvxTabControl.ItemClass: string;
begin
  Result := 'TvxTabItem';
end;

procedure TvxTabControl.SetItem(AItem: TvxTabItem);
begin
  ItemIndex := AItem.Index;
end;

procedure TvxTabControl.SetItemHeight(const Value: single);
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    Realign;
  end;
end;

procedure TvxTabControl.SetFullSize(const Value: boolean);
begin
  if FFullSize <> Value then
  begin
    FFullSize := Value;
    Realign;
  end;
end;

{ TvxHudTabControl }

function TvxHudTabControl.ItemClass: string;
begin
  Result := 'TvxHudTabItem';
end;

{ TvxCustomTextBox ==================================================================}

constructor TvxCustomTextBox.Create(AOwner: TComponent);
begin
  inherited;
  FShowCaret := true;
  FFont := TvxFont.Create;
  FFont.OnChanged := FontChanged;
  FFontFill := TvxBrush.Create(vgBrushSolid, $FF000000);
  FSelectionFill := TvxBrush.Create(vgBrushSolid, $802A8ADF);
  CanFocused := true;
  Cursor := crIBeam;
  TextAlign := vgTextAlignNear;
  AutoCapture := true;
  Width := 100;
  Height := 22;
  FCaretPosition := 0;
  FSelStart := 0;
  FSelLength := 0;
  FFirstVisibleChar := 1;
  CreatePopupMenu;
end;

destructor TvxCustomTextBox.Destroy;
begin
  FSelectionFill.Free;
  FFontFill.Free;
  FFont.Free;
  {$IFNDEF NOVCL}
  FPopupMenu.Free;
  {$ENDIF}
  inherited;
end;

procedure TvxCustomTextBox.CreatePopupMenu;
{$IFNDEF NOVCL}
var
  TmpItem: TMenuItem;
  {$ENDIF}
begin
  {$IFNDEF NOVCL}
  FPopupMenu := TPopupMenu.Create(Self);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Cut';
    OnClick := DoCut;
  end;
  FPopupMenu.Items.Add(TmpItem);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Copy';
    OnClick := DoCopy;
  end;
  FPopupMenu.Items.Add(TmpItem);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Paste';
    OnClick := DoPaste;
  end;
  FPopupMenu.Items.Add(TmpItem);

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Delete';
    OnClick := DoDelete;
  end;
  FPopupMenu.Items.Add(TmpItem);

  //  FPopupMenu.Items.NewBottomLine;

  TmpItem := TMenuItem.Create(FPopupMenu);
  with TmpItem do
  begin
    Caption := 'Select All';
    OnClick := DoSelectAll;
  end;
  FPopupMenu.Items.Add(TmpItem);
  {$ENDIF}
end;

procedure TvxCustomTextBox.DoSelectAll(Sender: TObject);
begin
  SelectAll;
end;

procedure TvxCustomTextBox.DoCut(Sender: TObject);
begin
  CutToClipboard;
end;

procedure TvxCustomTextBox.DoCopy(Sender: TObject);
begin
  CopyToClipboard;
end;

procedure TvxCustomTextBox.DoDelete(Sender: TObject);
begin
  ClearSelection;
end;

procedure TvxCustomTextBox.DoPaste(Sender: TObject);
begin
  PasteFromClipboard;
end;

procedure TvxCustomTextBox.UpdatePopupMenuItems;
var
  SelTextEmpty: boolean;
begin
  SelTextEmpty := SelText <> '';
  {$IFNDEF NOVCL}
  FPopupMenu.Items.Find('Cut').Enabled := SelTextEmpty and not ReadOnly;
  FPopupMenu.Items.Find('Copy').Enabled := SelTextEmpty;
  FPopupMenu.Items.Find('Paste').Enabled := (Clipboard.AsText <> '') and not ReadOnly;
  FPopupMenu.Items.Find('Delete').Enabled := SelTextEmpty and not ReadOnly;
  FPopupMenu.Items.Find('Select All').Enabled := SelText <> Text;
  {$ENDIF}
end;

function TvxCustomTextBox.GetData: Variant;
begin
  Result := FText;
end;

procedure TvxCustomTextBox.SetData(const Value: Variant);
begin
  if VarIsNull(Value) then
    Text := ''
  else
    if VarIsType(Value, varDate) then
    Text := DateTimeToStr(VarToDateTime(Value))
  else
    if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    Text := VarToWideStr(Value);
end;

procedure TvxCustomTextBox.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('content');
  if (T <> nil) and (T is TvxContent) then
  begin
    TvxContent(T).OnPaint := DoContentPaint;
  end;
  T := FindResource('selection');
  if (T <> nil) and (T is TvxBrushObject) then
  begin
    FSelectionFill.Assign(TvxBrushObject(T).Brush);
  end;
  { from style }
  T := FindResource('foreground');
  if (T <> nil) and (T is TvxBrushObject) then
    FFontFill.Assign(TvxBrushObject(T).Brush);
end;

function TvxCustomTextBox.ContentRect: TvxRect;
var
  T: TvxObject;
begin
  T := FindResource('content');
  if (T <> nil) and (T.IsVisual) then
  begin
    Result := TvxVisualObject(T).ParentedRect;
  end
  else
  begin
    Result := LocalRect;
  end;
end;

procedure TvxCustomTextBox.Paint;
begin
  inherited;
end;

procedure TvxCustomTextBox.DoContentPaint(Sender: TObject; const Canvas: TvxCanvas;
  const ARect: TvxRect);
var
  i: integer;
  R: TvxRect;
  SaveIdx: cardinal;
begin
  { draw text }
  if FText = '' then
    Exit;

  SaveIdx := Canvas.SaveCanvas;
  Canvas.IntersectClipRect(ARect);

  Canvas.Font.Assign(Font);
  Canvas.Fill.Assign(FFontFill);
  if FPassword then
  begin
    R := ARect;
    R.Right := R.Left + GetPasswordCharWidth - 1;
    R.Top := (vgRectHeight(ARect) - vgRectWidth(R)) / 2;
    R.Bottom := R.Top + vgRectWidth(R);
    for i := FFirstVisibleChar to Length(Text) do
    begin
      Canvas.FillEllipse(R, AbsoluteOpacity);
      vgOffsetRect(R, vgRectWidth(R) + 1, 0);
    end;
  end
  else
  begin
    R := ARect;
    if Textalign = vgTextAlignNear then
      R.Right := R.Right + (Font.Size / 2); // disable GDI+ clippping
    Canvas.FillText(R, R, Copy(Text, FFirstVisibleChar, Length(Text) - FFirstVisibleChar + 1),
      false, AbsoluteOpacity, TextAlign, vgTextAlignCenter);
  end;
  { carret }
  if IsFocused then
  begin
    { selection }
    if SelLength > 0 then
    begin
      Canvas.Fill.Assign(FSelectionFill);
      R := GetSelRect;
      with ContentRect do
        vgOffsetRect(R, -Left, -Top);
      Canvas.FillRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    end;
  end;

  Canvas.RestoreCanvas(SaveIdx);
end;

procedure TvxCustomTextBox.InsertText(const AText: WideString);
var
  TmpS: WideString;
begin
  if ReadOnly then
    Exit;

  TmpS := Text;
  //  FActionStack.FragmentDeleted(SelStart + 1, Copy(TmpS, SelStart+1, SelLength));
  Delete(TmpS, SelStart + 1, SelLength);
  //  FActionStack.FragmentInserted(SelStart + 1, Length(AText), SelLength <> 0);
  Insert(AText, TmpS, SelStart + 1);
  if (MaxLength <= 0) or (Length(TmpS) <= MaxLength) then
  begin
    Text := TmpS;
    CaretPosition := SelStart + Length(AText);
  end;
  SelLength := 0;
end;

procedure TvxCustomTextBox.UpdateFirstVisibleChar;
var
  LEditRect: TvxRect;
begin
  if FFirstVisibleChar >= (FCaretPosition + 1) then
  begin
    FFirstVisibleChar := FCaretPosition;
    if FFirstVisibleChar < 1 then
      FFirstVisibleChar := 1;
  end
  else
  begin
    LEditRect := ContentRect;

    if Password then
      while ((FCaretPosition - FFirstVisibleChar + 1) * GetPasswordCharWidth > LEditRect.Right - LEditRect.Left) and (FFirstVisibleChar < Length(Text)) do
        Inc(FFirstVisibleChar)
    else
    begin
      while (TextWidth(Copy(Text, FFirstVisibleChar, FCaretPosition - FFirstVisibleChar + 1)) > LEditRect.Right - LEditRect.Left) and (FFirstVisibleChar < Length(Text)) do
      begin
        if TextWidth(Copy(Text, FFirstVisibleChar + 500, (FCaretPosition - FFirstVisibleChar + 500) + 1)) > LEditRect.Right - LEditRect.Left then
          Inc(FFirstVisibleChar, 500)
        else
          if TextWidth(Copy(Text, FFirstVisibleChar + 100, (FCaretPosition - FFirstVisibleChar + 100) + 1)) > LEditRect.Right - LEditRect.Left then
          Inc(FFirstVisibleChar, 100)
        else
          if TextWidth(Copy(Text, FFirstVisibleChar + 50, (FCaretPosition - FFirstVisibleChar + 100) + 1)) > LEditRect.Right - LEditRect.Left then
          Inc(FFirstVisibleChar, 50)
        else
          if TextWidth(Copy(Text, FFirstVisibleChar + 10, (FCaretPosition - FFirstVisibleChar + 10) + 1)) > LEditRect.Right - LEditRect.Left then
          Inc(FFirstVisibleChar, 10)
        else
          Inc(FFirstVisibleChar);
      end;
    end;
  end;
  Repaint;
end;

procedure TvxCustomTextBox.UpdateCaretePosition;
begin
  SetCaretPosition(CaretPosition);
end;

function TvxCustomTextBox.GetPasswordCharWidth: single;
begin
  Result := Font.Size / 2;
end;

function TvxCustomTextBox.TextWidth(const Str: WideString): single;
var
  R: TvxRect;
begin
  R := ContentRect;
  R.Right := 10000;
  Canvas.Font.Assign(Font);
  if FPassword then
  begin
    R.Right := R.Left + GetPasswordCharWidth * Length(Str);
  end
  else
    Canvas.MeasureText(R, R, Str, false, vgTextAlignNear, vgTextAlignCenter);
  Result := vgRectWidth(R);
end;

function TvxCustomTextBox.GetCoordinatePosition(x: single): integer;
var
  CurX: double;
  TmpX,
    WholeTextWidth,
    EditRectWidth: single;
  Str, StrA: WideString;
begin
  Result := FFirstVisibleChar - 1;
  if Length(Text) = 0 then
    Exit;

  if FPassword then
    WholeTextWidth := Length(Text) * GetPasswordCharWidth
  else
    WholeTextWidth := TextWidth(Copy(Text, 1, Length(Text)));

  EditRectWidth := ContentRect.Right - ContentRect.Left;
  TmpX := x;
  if WholeTextWidth < EditRectWidth then
    case TextAlign of
      vgTextAlignFar: TmpX := x - (EditRectWidth - WholeTextWidth);
      vgTextAlignCenter: TmpX := x - ((EditRectWidth - WholeTextWidth) / 2);
    end;

  if FPassword then
  begin
    Result := Result + Trunc((TmpX - ContentRect.Left) / GetPasswordCharWidth);
    if Result < 0 then
      Result := 0
    else
      if Result > Length(Text) then
      Result := Length(Text);
  end
  else
  begin
    TmpX := TmpX - ContentRect.Left;
    StrA := System.Copy(Text, FFirstVisibleChar, Result - FFirstVisibleChar + 1);
    Str := System.Copy(Text, FFirstVisibleChar, Result - FFirstVisibleChar + 2);
    while (TextWidth(StrA) < TmpX) and (Result < Length(Text)) do
    begin
      if (TmpX > TextWidth(StrA) + ((TextWidth(Str) - TextWidth(StrA)) / 2)) and (TmpX < TextWidth(Str)) then
      begin
        Result := Result + 1;
        Break;
      end;
      if TmpX < TextWidth(Str) then
        Break;
      Result := Result + 1;
      StrA := Str;
      Str := Copy(Text, FFirstVisibleChar, Result - FFirstVisibleChar + 2);
    end;
  end;
end;

function TvxCustomTextBox.GetCharX(a: integer): single;
var
  WholeTextWidth: single;
  EditRectWidth: single;
  R: TvxRect;
  T: WideString;
begin
  if FPassword then
  begin
    WholeTextWidth := Length(Text) * GetPasswordCharWidth;
    Result := ContentRect.Left;
    if a > 0 then
    begin
      if FPassword then
      begin
        if a <= Length(Text) then
          Result := Result + (a - FFirstVisibleChar + 1) * GetPasswordCharWidth
        else
          Result := Result + (Length(Text) - FFirstVisibleChar + 1) * GetPasswordCharWidth;
      end
    end;
    EditRectWidth := ContentRect.Right - ContentRect.Left;
    if WholeTextWidth < EditRectWidth then
      case TextAlign of
        vgTextAlignFar: Result := Result + (EditRectWidth - WholeTextWidth);
        vgTextAlignCenter: Result := Result + ((EditRectWidth - WholeTextWidth) / 2);
      end;
    Exit;
  end;

  R := ContentRect;
  Canvas.Font.Assign(Font);
  T := Text;
  if Text = '' then
    T := 'a';
  Canvas.MeasureText(R, R, T, false, vgTextAlignNear, vgTextAlignCenter);
  WholeTextWidth := R.Right - ContentRect.Left;
  Result := ContentRect.Left;

  if a > 0 then
  begin
    if a <= Length(Text) then
    begin
      R := ContentRect;
      Canvas.MeasureText(R, R, Copy(Text, FFirstVisibleChar, a - FFirstVisibleChar + 1), false, vgTextAlignNear, vgTextAlignCenter);
      Result := R.Right;
    end
    else
    begin
      R := ContentRect;
    end;
  end;

  EditRectWidth := ContentRect.Right - ContentRect.Left;
  if WholeTextWidth < EditRectWidth then
    case TextAlign of
      vgTextAlignFar: Result := Result + (EditRectWidth - WholeTextWidth);
      vgTextAlignCenter: Result := Result + ((EditRectWidth - WholeTextWidth) / 2);
    end;
end;

function TvxCustomTextBox.GetNextWordBeging(StartPosition: integer): integer;
var
  SpaceFound, WordFound: boolean;
begin
  Result := StartPosition;
  SpaceFound := false;
  WordFound := false;
  while (Result + 2 <= Length(Text)) and
    ((not ((Text[Result + 1] <> vgWideSpace) and SpaceFound))
    or not WordFound) do
  begin
    if Text[Result + 1] = vgWideSpace then
      SpaceFound := true;
    if Text[Result + 1] <> vgWideSpace then
    begin
      WordFound := true;
      SpaceFound := false;
    end;

    Result := Result + 1;
  end;
  if not SpaceFound then
    Result := Result + 1;
end;

function TvxCustomTextBox.GetPrivWordBeging(StartPosition: integer): integer;
var
  WordFound: boolean;
begin
  Result := StartPosition;
  WordFound := false;
  while (Result > 0) and
    ((Text[Result] <> vgWideSpace) or not WordFound) do
  begin
    if Text[Result] <> vgWideSpace then
      WordFound := true;
    Result := Result - 1;
  end;
end;

function TvxCustomTextBox.GetSelStart: integer;
begin
  if FSelLength > 0 then
    Result := FSelStart
  else
    if FSelLength < 0 then
    Result := FSelStart + FSelLength
  else
    Result := CaretPosition;
end;

function TvxCustomTextBox.GetSelRect: TvxRect;
begin
  Result := ContentRect;
  Result.Left := GetCharX(SelStart);
  Result.Right := GetCharX(SelStart + SelLength) + 1;
end;

function TvxCustomTextBox.GetSelLength: integer;
begin
  Result := Abs(FSelLength);
end;

function TvxCustomTextBox.GetSelText: WideString;
begin
  Result := Copy(Text, SelStart + 1, SelLength);
end;

procedure TvxCustomTextBox.SetSelLength(const Value: integer);
begin
  if FSelLength <> Value then
  begin
    FSelLength := Value;
    Repaint;
  end;
end;

procedure TvxCustomTextBox.SetSelStart(const Value: integer);
begin
  if FSelStart <> Value then
  begin
    SelLength := 0;
    FSelStart := Value;
    CaretPosition := FSelStart;
    Repaint;
  end;
end;

procedure TvxCustomTextBox.SetCaretPosition(const Value: integer);
begin
  if Value < 0 then
    FCaretPosition := 0
  else
    if Value > Length(Text) then
    FCaretPosition := Length(Text)
  else
    FCaretPosition := Value;

  UpdateFirstVisibleChar;

  if SelLength <= 0 then
    FSelStart := Value;

  Repaint;
  if IsFocused and FShowCaret then
  begin
    SetCaretSize(vgPoint(2, (Font.Size * 1.25)));
    SetCaretPos(vgPoint(GetCharX(FCaretPosition) - 1, (ContentRect.Top + ContentRect.Bottom - (Font.Size * 1.25)) / 2));
    SetCaretColor(FFontFill.SolidColor);
  end;
end;

procedure TvxCustomTextBox.SetMaxLength(const Value: Integer);
begin
  if FMaxLength <> Value then
  begin
    FMaxLength := Value;
  end;
end;

procedure TvxCustomTextBox.CopyToClipboard;
var
  Data: THandle;
  DataPtr: Pointer;
  Size: Cardinal;
  S: WideString;
begin
  {$IFNDEF NOVCL}
  {$IFNDEF FPC}
  //  if PasswordKind = pkNone then
  if Length(SelText) > 0 then
  begin
    S := SelText;
    begin
      Size := Length(S);
      Data := GlobalAlloc(GMEM_MOVEABLE + GMEM_DDESHARE, 2 * Size + 2);
      try
        DataPtr := GlobalLock(Data);
        try
          Move(PWideChar(S)^, DataPtr^, 2 * Size + 2);
          Clipboard.SetAsHandle(CF_UNICODETEXT, Data);
        finally
          GlobalUnlock(Data);
        end;
      except
        GlobalFree(Data);
        raise;
      end;
    end;
  end;
  {$ELSE}
  if SelText <> '' then
    Clipbrd.Clipboard.AsText := UTF8Encode(SelText);
  {$ENDIF}
  {$ENDIF}
end;

procedure TvxCustomTextBox.PasteFromClipboard;
var
  Data: THandle;
  Insertion: WideString;
begin
  if ReadOnly then
    Exit;
  {$IFNDEF NOVCL}
  {$IFNDEF FPC}
  if Clipbrd.Clipboard.HasFormat(CF_UNICODETEXT) then
  begin
    Data := Clipbrd.Clipboard.GetAsHandle(CF_UNICODETEXT);
    try
      if Data <> 0 then
        Insertion := PWideChar(GlobalLock(Data));
    finally
      if Data <> 0 then
        GlobalUnlock(Data);
    end;
  end
  else
    Insertion := Clipbrd.Clipboard.AsText;

  InsertText(Insertion);
  {$ELSE}
  InsertText(UTF8Decode(Clipbrd.Clipboard.AsText));
  {$ENDIF}
  {$ENDIF}
end;

procedure TvxCustomTextBox.ClearSelection;
var
  TmpS: WideString;
begin
  if ReadOnly then
    Exit;

  TmpS := Text;
  //  FActionStack.FragmentDeleted(SelStart+1, Copy(TmpS,SelStart+1,SelLength));
  Delete(TmpS, SelStart + 1, SelLength);
  CaretPosition := SelStart;
  Text := TmpS;
  SelLength := 0;
end;

procedure TvxCustomTextBox.CutToClipboard;
begin
  //  if PasswordKind = pkNone then
  CopyToClipboard;
  ClearSelection;
end;

procedure TvxCustomTextBox.SelectAll;
begin
  SelStart := 0;
  SelLength := Length(Text);
  SetCaretPosition(Length(Text));
  Repaint;
end;

procedure TvxCustomTextBox.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
var
  S: wideString;
  TmpS: WideString;
  OldCaretPosition: integer;
begin
  inherited;
  OldCaretPosition := CaretPosition;
  FLastChar := KeyChar;
  FLastKey := Key;
  case Key of
    VK_RETURN: Change;
    VK_END: CaretPosition := Length(Text);
    VK_HOME: CaretPosition := 0;
    VK_LEFT:
      if ssCtrl in Shift then
        CaretPosition := GetPrivWordBeging(CaretPosition)
      else
        CaretPosition := CaretPosition - 1;
    VK_RIGHT:
      if ssCtrl in Shift then
        CaretPosition := GetNextWordBeging(CaretPosition)
      else
        CaretPosition := CaretPosition + 1;
    VK_DELETE, 8: {Delete or BackSpace key was pressed}
      if not ReadOnly then
      begin
        if SelLength <> 0 then
        begin
          if Shift = [ssShift] then
            CutToClipboard
          else
            ClearSelection;
        end
        else
        begin
          TmpS := Text;
          if TmpS <> '' then
            if Key = VK_DELETE then
            begin
              //              FActionStack.FragmentDeleted(CaretPosition + 1,TmpS[CaretPosition + 1]);
              Delete(TmpS, CaretPosition + 1, 1);
            end
            else
            begin {BackSpace key was pressed}
              {              if CaretPosition > 0 then
                              FActionStack.FragmentDeleted(CaretPosition,TmpS[CaretPosition]);}
              Delete(TmpS, CaretPosition, 1);
              CaretPosition := CaretPosition - 1;
            end;
          Text := TmpS;
          if Assigned(FOnTyping) then
            FOnTyping(Self);
        end;
      end;
    VK_INSERT:
      if Shift = [ssCtrl] then
      begin
        CopyToClipboard;
      end
      else
        if Shift = [ssShift] then
      begin
        PasteFromClipboard;
        if Assigned(FOnTyping) then
          FOnTyping(Self);
      end;
  end;

  if (KeyChar <> #0) and (FFilterChar <> '') and (Pos(KeyChar, FFilterChar) = 0) then
  begin
    KeyChar := #0;
  end;
  case KeyChar of
    'a', 'A':
      if Shift = [ssCtrl] then
      begin
        SelectAll;
        KeyChar := #0;
      end;
    'c', 'C':
      if Shift = [ssCtrl] then
      begin
        CopyToClipboard;
        KeyChar := #0;
      end;
    'v', 'V':
      if Shift = [ssCtrl] then
      begin
        PasteFromClipboard;
        if Assigned(FOnTyping) then
          FOnTyping(Self);
        KeyChar := #0;
      end;
    'x', 'X':
      if Shift = [ssCtrl] then
      begin
        CutToClipboard;
        KeyChar := #0;
      end;
    'z', 'Z':
      if Shift = [ssCtrl] then
      begin
        {UnDo};
        KeyChar := #0;
      end;
  end;

  if Key in [VK_END, VK_HOME, VK_LEFT, VK_RIGHT] then
  begin
    if ssShift in Shift then
    begin
      if SelLength = 0 then
        FSelStart := OldCaretPosition;
      FSelStart := CaretPosition;
      FSelLength := FSelLength - (CaretPosition - OldCaretPosition);
    end
    else
      FSelLength := 0;
    Repaint;
  end;

  if (Ord(KeyChar) >= 32) and not ReadOnly then
  begin
    S := KeyChar;
    InsertText(S);
    if Assigned(FOnTyping) then
      FOnTyping(Self);
  end;
  if FResourceLink <> nil then
    FResourceLink.Visual.UpdateEffects;
  UpdateCaretePosition;
end;

procedure TvxCustomTextBox.KeyUp(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
end;

procedure TvxCustomTextBox.DblClick;
begin
  inherited;
  SelectAll;
end;

procedure TvxCustomTextBox.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  OldFocused: boolean;
begin
  OldFocused := IsFocused;
  inherited;
  if Button = mbLeft then
    FLMouseSelecting := true;

  if (Button = mbLeft) and not (ssDouble in Shift) then
  begin
    if OldFocused then // clear only already focused
    begin
      CaretPosition := GetCoordinatePosition(x);
      SelLength := 0;
    end;
  end;
end;

procedure TvxCustomTextBox.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
var
  OldCaretPosition: integer;
  TmpNewPosition: integer;
begin
  inherited;
  if FLMouseSelecting then
  begin
    TmpNewPosition := GetCoordinatePosition(x);
    OldCaretPosition := CaretPosition;
    if (x > ContentRect.Right) then
      CaretPosition := TmpNewPosition + 1
    else
      CaretPosition := TmpNewPosition;
    if SelLength = 0 then
      FSelStart := OldCaretPosition;
    FSelStart := CaretPosition;
    FSelLength := FSelLength - (CaretPosition - OldCaretPosition);
  end;
end;

procedure TvxCustomTextBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  FLMouseSelecting := false;
end;

procedure TvxCustomTextBox.Change;
begin
  if FNeedChange then
  begin
    if Assigned(FBindingObjects) then
      ToBindingObjects;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxCustomTextBox.ContextMenu(const ScreenPosition: TvxPoint);
begin
  inherited;
  if csDesigning in ComponentState then
    Exit;
  if Popup <> nil then
    Exit;

  UpdatePopupMenuItems;
  {$IFNDEF NOVCL}
  FPopupMenu.PopupComponent := Self;
  FPopupMenu.Popup(round(ScreenPosition.X), round(ScreenPosition.Y));
  {$ENDIF}
end;

procedure TvxCustomTextBox.EnterFocus;
begin
  inherited;
  FNeedChange := false;
  if FShowCaret then
    ShowCaretProc;
  if FScene.ShowKeyboardForControl(Self) then
    CaretPosition := Length(Text)
  else
    SelectAll;
end;

procedure TvxCustomTextBox.KillFocus;
begin
  if not Assigned(FScene) then
  begin
    inherited;
    Exit;
  end;
  FScene.HideKeyboardForControl(Self);
  if FShowCaret then
    HideCaret;
  inherited;
  Change;
end;

procedure TvxCustomTextBox.SetText(const Value: WideString);
begin
  if FText <> Value then
  begin
    FText := Value;
    if FCaretPosition > Length(Text) then
      SetCaretPosition(Length(Text));
    if not (csLoading in ComponentState) and Assigned(OnChangeTracking) then
      OnChangeTracking(Self);
    FNeedChange := true;
    Repaint;
  end;
end;

procedure TvxCustomTextBox.SetPassword(const Value: boolean);
begin
  if FPassword <> Value then
  begin
    FPassword := Value;
    Repaint;
  end;
end;

procedure TvxCustomTextBox.SetFont(const Value: TvxFont);
begin
  FFont.Assign(Value);
end;

procedure TvxCustomTextBox.SetTextAlign(const Value: TvxTextAlign);
begin
  if FTextAlign <> Value then
  begin
    FTextAlign := Value;
    Repaint;
  end;
end;

procedure TvxCustomTextBox.FontChanged(Sender: TObject);
begin
  Repaint;
end;

{ TvxNumberBox ================================================================}

constructor TvxNumberBox.Create(AOwner: TComponent);
begin
  inherited;
  FDecimalDigits := 2;
  FFilterChar := '0123456789.,-+';
  Max := 10;
  VertIncrement := 5;
  HorzIncrement := 1;
  Text := '0';
  Value := 0;
  AutoCapture := true;
end;

destructor TvxNumberBox.Destroy;
begin
  inherited;
end;

function TvxNumberBox.GetData: Variant;
begin
  Result := Value;
end;

procedure TvxNumberBox.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    Self.Value := Value;
end;

procedure TvxNumberBox.Change;
begin
  try
    FValue := StrToFloat(Text);
    if FValue > FMax then
      FValue := FMax;
    if FValue < FMin then
      FValue := FMin;
    if (frac(FValue) = 0) or (FValueType = vgValueInteger) then
      FText := IntToStr(Trunc(FValue))
    else
      FText := FloattoStr(FValue);
  except
    if (frac(FValue) = 0) or (FValueType = vgValueInteger) then
      FText := IntToStr(Trunc(FValue))
    else
      FText := FloattoStr(FValue);
  end;
  Repaint;
  inherited;
end;

procedure TvxNumberBox.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  case Key of
    VK_UP: Value := Value + HorzIncrement;
    VK_DOWN: Value := Value - HorzIncrement;
  else
    inherited;
    Exit;
  end;
  Key := 0;
end;

procedure TvxNumberBox.MouseDown(Button: TMouseButton; Shift: TShiftState;
  X, Y: single);
begin
  inherited;
  if Button = mbLeft then
  begin
    FPressed := true;
    FPressedPos := vgPoint(X, Y);
    FPressedVert := false;
    FPressedInc := 0;
  end;
end;

procedure TvxNumberBox.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
  if FPressed then
  begin
    if Abs(X - FPressedPos.X) >= Abs(Y - FPressedPos.Y) then
    begin
      { horz }
      if X > FPressedPos.X then
        Value := Value + HorzIncrement
      else
        Value := Value - HorzIncrement;
      FPressedInc := X - FPressedPos.X;
      FPressedVert := false;
    end
    else
    begin
      { vert }
      if Y < FPressedPos.Y then
        Value := Value + VertIncrement
      else
        Value := Value - VertIncrement;
      FPressedInc := X - FPressedPos.X;
      FPressedVert := true;
    end;
    FNeedChange := true;
    FPressedPos := vgPoint(X, Y);
  end;
end;

procedure TvxNumberBox.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  if FPressed then
  begin
    FPressed := false;
    Change;
    Repaint;
  end;
end;

procedure TvxNumberBox.Paint;
begin
  inherited;
end;

procedure TvxNumberBox.PaintChildren;
var
  R: TvxRect;
begin
  if FPressed then
    FDisableCaret := true;
  inherited;
  if FPressed then
  begin
    Canvas.SetMatrix(AbsoluteMatrix);
    Canvas.Fill.Style := vgBrushSolid;
    Canvas.Fill.SolidColor := $AA505050;
    R := LocalRect;
    if FPressedVert then
    begin
      vgInflateRect(R, -1, -1);
      R.Left := R.Right - 5;
      Canvas.FillRect(R, 1, 1, AllCorners, AbsoluteOpacity);
      vgInflateRect(R, -1, -1);
      {      if FPressedInc > 0 then
            begin
              Canvas.Fill.SolidColor := $AA202020;
              R.Top := (vgRectHeight(R) / 2);
              R.Bottom := R.Top + (Height / 2.1);
              Canvas.FillRect(R, 1, 1, AbsoluteOpacity);
            end;
            if FPressedInc < 0 then
            begin
              Canvas.Fill.SolidColor := $AA202020;
              R.Bottom := (vgRectHeight(R) / 2);
              R.Top := R.Bottom - (Height / 2.1);
              Canvas.FillRect(R, 1, 1, AbsoluteOpacity);
            end;}
    end
    else
    begin
      vgInflateRect(R, -1, -1);
      R.Top := R.Bottom - 5;
      Canvas.FillRect(R, 1, 1, AllCorners, AbsoluteOpacity);
      vgInflateRect(R, -1, -1);
      {      if FPressedInc > 0 then
            begin
              Canvas.Fill.SolidColor := $AA202020;
              R.Left := (vgRectWidth(R) / 2);
              R.Right := R.Left + (Width / 2.1);
              Canvas.FillRect(R, 1, 1, AbsoluteOpacity);
            end;
            if FPressedInc < 0 then
            begin
              Canvas.Fill.SolidColor := $AA202020;
              R.Right := (vgRectWidth(R) / 2);
              R.Left := R.Right - (Width / 2.1);
              Canvas.FillRect(R, 1, 1, AbsoluteOpacity);
            end;}
    end;
  end;
  if FPressed then
    FDisableCaret := false;
end;

procedure TvxNumberBox.SetMax(const Value: single);
begin
  FMax := Value;
end;

procedure TvxNumberBox.SetMin(const Value: single);
begin
  FMin := Value;
end;

procedure TvxNumberBox.SetDecimalDigits(const Value: integer);
begin
  FDecimalDigits := Value;
end;

procedure TvxNumberBox.SetValue(const AValue: single);
begin
  if FValue <> AValue then
  begin
    FValue := AValue;
    if FValue > FMax then
      FValue := FMax;
    if FValue < FMin then
      FValue := FMin;
    if (frac(FValue) = 0) or (FValueType = vgValueInteger) then
      FText := IntToStr(Trunc(FValue))
    else
      FText := Format('%.' + IntToStr(FDecimalDigits) + 'f', [FValue]);
    SelLength := 0;
    Repaint;
  end;
end;

procedure TvxNumberBox.SetValueType(const Value: TvxValueType);
begin
  FValueType := Value;
end;

procedure TvxNumberBox.SetText(const Value: WideString);
begin
  inherited;
end;

{ TvxSpinBox ==================================================================}

constructor TvxSpinBox.Create(AOwner: TComponent);
begin
  inherited;
  FDecimalDigits := 2;
  FFilterChar := '0123456789.,-+';
  TextAlign := vgTextAlignCenter;
  Increment := 1;
  Max := 10;
  Text := '0';
  Value := 0;
end;

destructor TvxSpinBox.Destroy;
begin
  inherited;
end;

procedure TvxSpinBox.ApplyStyle;
var
  B: TvxObject;
begin
  inherited;
  B := FindResource('minusbutton');
  if (B <> nil) and (B is TvxCustomButton) then
  begin
    FMinus := TvxCustomButton(B);
    FMinus.OnClick := DoMinusClick;
  end;
  B := FindResource('plusbutton');
  if (B <> nil) and (B is TvxCustomButton) then
  begin
    FPlus := TvxCustomButton(B);
    FPlus.OnClick := DoPlusClick;
  end;
end;

procedure TvxSpinBox.FreeStyle;
begin
  inherited;
  FMinus := nil;
  FPlus := nil;
end;

procedure TvxSpinBox.DoMinusClick(Sender: TObject);
begin
  SetFocus;
  Value := Value - Increment;
  FNeedChange := true;
  Change;
end;

procedure TvxSpinBox.DoPlusClick(Sender: TObject);
begin
  SetFocus;
  Value := Value + Increment;
  FNeedChange := true;
  Change;
end;

function TvxSpinBox.GetData: Variant;
begin
  Result := Value;
end;

procedure TvxSpinBox.SetData(const Value: Variant);
begin
  if VarIsEvent(Value) then
    OnChange := VariantToEvent(Value)
  else
    Self.Value := Value;
end;

procedure TvxSpinBox.KeyDown(var Key: Word; var KeyChar: System.WideChar; Shift: TShiftState);
begin
  case Key of
    VK_UP: Value := Value + Increment;
    VK_DOWN: Value := Value - Increment;
  else
    inherited;
    Exit;
  end;
  Key := 0;
end;

procedure TvxSpinBox.Change;
begin
  try
    FValue := StrToFloat(Text);
    if FValue > FMax then
      FValue := FMax;
    if FValue < FMin then
      FValue := FMin;
    if (frac(FValue) = 0) or (FValueType = vgValueInteger) then
      FText := IntToStr(Trunc(FValue))
    else
      FText := FloattoStr(FValue);
  except
    if (frac(FValue) = 0) or (FValueType = vgValueInteger) then
      FText := IntToStr(Trunc(FValue))
    else
      FText := FloattoStr(FValue);
  end;
  Repaint;
  inherited;
end;

procedure TvxSpinBox.SetMax(const Value: single);
begin
  FMax := Value;
end;

procedure TvxSpinBox.SetMin(const Value: single);
begin
  FMin := Value;
end;

procedure TvxSpinBox.SetValue(const AValue: single);
begin
  if FValue <> AValue then
  begin
    FValue := AValue;
    if FValue > FMax then
      FValue := FMax;
    if FValue < FMin then
      FValue := FMin;
    if (frac(FValue) = 0) or (FValueType = vgValueInteger) then
      FText := IntToStr(Trunc(FValue))
    else
      FText := Format('%' + DecimalSeparator + IntToStr(FDecimalDigits) + 'f', [FValue]);
    SelLength := 0;
    Repaint;
  end;
end;

procedure TvxSpinBox.SetValueType(const Value: TvxValueType);
begin
  if FValueType <> Value then
  begin
    FValueType := Value;
    if (FValueType = vgValueInteger) and (Frac(Increment) <> 0) then
      Increment := 1;
  end;
end;

procedure TvxSpinBox.SetDecimalDigits(const Value: integer);
begin
  FDecimalDigits := Value;
end;

procedure TvxSpinBox.SetText(const Value: WideString);
begin
  inherited;
end;

{ TvxComboTextBox }

type
  TvxHackComboListBox = class(TvxComboListBox);

constructor TvxComboTextBox.Create(AOwner: TComponent);
begin
  inherited;
  DropDownCount := 8;
  Cursor := crDefault;
  FItemHeight := 19;
  FItems := TvxWideStringList.Create;
  TvxWideStringList(FItems).OnChange := DoItemsChanged;
  FPopup := TvxPopup.Create(Self);
  FPopup.PlacementTarget := Self;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FPopup.OnClosePopup := DoClosePopup;
  FListBox := TvxComboListBox.Create(Self);
  FListBox.Parent := FPopup;
  TvxHackComboListBox(FListBox).FComboBox := Self;
  FListBox.ItemHeight := ItemHeight;
  FListBox.Stored := false;
  FListBox.Align := vaClient;
  FListBox.ShowCheckboxes := false;
  FListBox.ItemIndex := -1;
  OnTyping := DoTyping;
end;

destructor TvxComboTextBox.Destroy;
begin
  FreeAndNil(FItems);
  inherited;
end;

procedure TvxComboTextBox.DoItemsChanged(Sender: TObject);
begin
  RebuildList;
end;

procedure TvxComboTextBox.RebuildList;
var
  SaveI, i: integer;
  Item: TvxListBoxItem;
begin
  if csDestroying in ComponentState then
    Exit;
  if Items = nil then
    Exit;
  BeginUpdate;
  SaveI := FListbox.ItemIndex;
  TvxHackComboListBox(FListBox).FItemIndex := -1;
  FListBox.Clear;
  for i := 0 to FItems.Count - 1 do
  begin
    Item := TvxListBoxItem.Create(Self);
    Item.AutoTranslate := FAutoTranslate;
    Item.Parent := FListBox;
    Item.Height := FItemHeight;
    Item.Stored := false;
    Item.Locked := true;
    Item.Text := FItems[i];
  end;
  EndUpdate;
  TvxHackComboListBox(FListbox).FItemIndex := SaveI;
  if TvxHackComboListBox(FListbox).FItemIndex >= FListbox.Count then
    TvxHackComboListBox(FListbox).FItemIndex := FListbox.Count - 1;
end;

procedure TvxComboTextBox.KeyDown(var Key: Word;
  var KeyChar: System.WideChar; Shift: TShiftState);
var
  i: integer;
begin
  inherited;
  if Count > 0 then
  begin
    if ReadOnly and (KeyChar <> #0) then
    begin
      for i := 0 to Count - 1 do
        if (FListBox.Items[i].Text <> '') and (WideLowerCase(FListBox.Items[i].Text[1]) = WideLowerCase(KeyChar)) then
        begin
          ItemIndex := i;
          Break;
        end;
      KeyChar := #0;
    end;
    case Key of
      VK_UP:
        if ItemIndex > 0 then
        begin
          ItemIndex := ItemIndex - 1;
          if ItemIndex < 0 then
            ItemIndex := 0;
        end;
      VK_DOWN:
        begin
          if ItemIndex < Count - 1 then
            ItemIndex := ItemIndex + 1;
          if ItemIndex > Count - 1 then
            ItemIndex := Count - 1;
        end;
    else
      Exit;
    end;
    Key := 0;
  end;
end;

procedure TvxComboTextBox.Realign;
begin
  inherited;
  if FDisableAlign then
    Exit;
  FDisableAlign := true;
  { FContent }
  if FPopup <> nil then
    FPopup.Width := Width;
  if FListBox <> nil then
    FListBox.Width := Width;
  FDisableAlign := false;
end;

procedure TvxComboTextBox.DoClosePopup(Sender: TObject);
begin
  if ShowCaret and IsFocused then
    ShowCaretProc;
end;

procedure TvxComboTextBox.DropDown;
var
  Count, i: integer;
begin
  if not FPopup.IsOpen then
  begin
    if ShowCaret then
      HideCaret;
    FPopup.Placement := FPlacement;
    FPopup.Width := Width;
    Count := DropDownCount;
    if FListBox.Count < Count then
      Count := FListBox.Count;
    if FListbox.ItemHeight > 0 then
      FPopup.Height := Count * (FListbox.ItemHeight) + 4
    else
      FPopup.Height := Count * (Height - 4);
    TvxHackComboListBox(FListBox).FNeedResource := true;
    FListBox.ApplyResource;
    FPopup.IsOpen := true;
    FListBox.SetFocus;
    TvxHackComboListBox(FListbox).UpdateSelection;
  end
  else
  begin
    FPopup.IsOpen := false;
  end;
end;

procedure TvxComboTextBox.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if (Button = mbLeft) and not vgPtInRect(vgPoint(X, Y), ContentRect) then
  begin
    DropDown;
  end;
end;

procedure TvxComboTextBox.SetItemHeight(const Value: single);
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    FListBox.ItemHeight := FItemHeight;
  end;
end;

procedure TvxComboTextBox.SetItems(const Value: TvxWideStrings);
begin
  FItems.Assign(Value);
end;

procedure TvxComboTextBox.ChangeParent;
begin
  inherited;
end;

function TvxComboTextBox.GetItemIndex: integer;
begin
  if FListBox <> nil then
    Result := FListBox.ItemIndex
  else
    Result := -1;
end;

procedure TvxComboTextBox.SetItemIndex(const Value: integer);
begin
  if FListBox <> nil then
  begin
    FListBox.ItemIndex := Value;
    if (ItemIndex >= 0) and (ItemIndex < Items.Count) then
    begin
      Text := Items[ItemIndex];
      FNeedChange := false;
      if not Scene.ShowKeyboardForControl(Self) then
        SelectAll;
      if Assigned(FBindingObjects) then
        ToBindingObjects;
      if Assigned(FOnChange) then
        FOnChange(Self);
      if (FResourceLink <> nil) then
        FResourceLink.Visual.UpdateEffects;
      Repaint;
    end;
  end;
end;

function TvxComboTextBox.GetCount: integer;
begin
  if FListBox <> nil then
    Result := FListBox.Count
  else
    Result := 0;
end;

procedure TvxComboTextBox.DoTyping(Sender: TObject);
var
  i, l: integer;
  UT: WideString;
begin
  if (FLastChar = #0) and ((FLastKey = VK_DELETE) or (FLastKey = 8)) then
    Exit;
  {$IFDEF NOVCL}
  {$IFDEF DARWIN}
  Exit;
  {$ENDIF}
  {$ENDIF}
  UT := WideUpperCase(Text);
  exit;
  for i := 0 to Items.Count - 1 do
    if pos(UT, WideUpperCase(Items.Strings[i])) = 1 then
    begin
      l := length(Text);
      Text := Items.Strings[i];
      SelStart := l;
      SelLength := length(Items.Strings[i]) - l;
      Exit;
    end;
end;

function TvxComboTextBox.GetListBoxResource: string;
begin
  Result := FListBox.Resource;
end;

procedure TvxComboTextBox.SetListBoxResource(const Value: string);
begin
  FListBox.Resource := Value;
end;

{ TvxComboTrackBar }

constructor TvxComboTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FFilterChar := '0123456789.,-+';
  Text := '0';
  Width := 100;
  Height := 22;
  FResource := 'combotextboxstyle';
  FPopup := TvxPopup.Create(Self);
  FPopup.FResource := 'combopopupstyle';
  FPopup.PlacementTarget := Self;
  FPopup.StaysOpen := false;
  FPopup.Stored := false;
  FPopup.Parent := Self;
  FPopup.Locked := true;
  FPopup.DesignHide := true;
  FPopup.Margins.Rect := vgRect(5, 2, 5, 2);
  FPopup.OnClosePopup := DoClosePopup;
  FTrackBar := TvxTrackBar.Create(Self);
  FTrackBar.Parent := FPopup;
  FTrackBar.Stored := false;
  FTrackBar.DisableFocusEffect := true;
  FTrackBar.Align := vaVertCenter;
  FTrackBar.OnChange := DoTrackChange;
end;

destructor TvxComboTrackBar.Destroy;
begin
  inherited;
end;

procedure TvxComboTrackBar.DoTrackChange(Sender: TObject);
begin
  Text := vgFloatToStr(FTrackBar.Value);
  SelectAll;
  if Assigned(FOnChange) then
    FOnChange(Self);
end;

procedure TvxComboTrackBar.KeyDown(var Key: Word;
  var KeyChar: System.WideChar; Shift: TShiftState);
begin
  inherited;
  {  if Count > 0 then
    begin
      case Key of
        VK_UP: If ItemIndex > 0 then
          begin
            ItemIndex := ItemIndex - 1;
            if ItemIndex < 0 then ItemIndex := 0;
          end;
        VK_DOWN:
          begin
            If ItemIndex < Count - 1 then ItemIndex := ItemIndex + 1;
            if ItemIndex > Count - 1 then ItemIndex := Count - 1;
          end;
      else
        Exit;
      end;
      Key := 0;
    end; }
end;

procedure TvxComboTrackBar.DoClosePopup(Sender: TObject);
begin
  if ShowCaret and IsFocused then
    ShowCaretProc;
end;

procedure TvxComboTrackBar.DropDown;
var
  i: integer;
begin
  if not FPopup.IsOpen then
  begin
    if ShowCaret then
      HideCaret;
    FPopup.Placement := FPlacement;
    if Width < 100 then
      FPopup.Width := 100
    else
      FPopup.Width := Width;
    FPopup.Height := 30;
    FTrackBar.ApplyResource;
    FPopup.IsOpen := true;
  end
  else
  begin
    FPopup.IsOpen := false;
  end;
end;

procedure TvxComboTrackBar.Change;
begin
  try
    Value := StrToFloat(Text);
  except
    FText := FloatToStr(Value);
  end;
  Repaint;
  inherited;
end;

procedure TvxComboTrackBar.MouseDown(Button: TMouseButton;
  Shift: TShiftState; X, Y: single);
begin
  inherited;
  if (Button = mbLeft) and not vgPtInRect(vgPoint(X, Y), ContentRect) then
  begin
    DropDown;
  end;
end;

procedure TvxComboTrackBar.ChangeParent;
begin
  inherited;
  FPopup.Parent := Parent;
end;

function TvxComboTrackBar.GetFrequency: single;
begin
  Result := FTrackBar.Frequency;
end;

function TvxComboTrackBar.GetMax: single;
begin
  Result := FTrackBar.Max;
end;

function TvxComboTrackBar.GetMin: single;
begin
  Result := FTrackBar.Min;
end;

procedure TvxComboTrackBar.SetFrequency(const Value: single);
begin
  FTrackBar.Frequency := Value;
end;

procedure TvxComboTrackBar.SetMax(const Value: single);
begin
  FTrackBar.Max := Value;
end;

procedure TvxComboTrackBar.SetMin(const Value: single);
begin
  FTrackBar.Min := Value;
end;

procedure TvxComboTrackBar.SetValue(const AValue: single);
begin
  FTrackBar.Value := AValue;
end;

function TvxComboTrackBar.GetValue: single;
begin
  Result := FTrackBar.Value;
end;

{ TvxTextBoxClearBtn }

constructor TvxTextBoxClearBtn.Create(AOwner: TComponent);
begin
  inherited;
end;

destructor TvxTextBoxClearBtn.Destroy;
begin
  inherited;
end;

procedure TvxTextBoxClearBtn.ApplyStyle;
var
  B: TvxObject;
begin
  inherited;
  B := FindResource('clearbutton');
  if (B <> nil) and (B is TvxCustomButton) then
  begin
    FClearBtn := TvxCustomButton(B);
    FClearBtn.OnClick := DoClearBtnClick;
  end;
end;

procedure TvxTextBoxClearBtn.DoClearBtnClick(Sender: TObject);
begin
  SetFocus;
  Text := '';
  Change;
end;

procedure TvxTextBoxClearBtn.FreeStyle;
begin
  FClearBtn := nil;
  inherited;
end;

{ TvxHudComboTextBox }

constructor TvxHudComboTextBox.Create(AOwner: TComponent);
begin
  inherited;
  FListBox.FResource := 'hudcombolistboxstyle';
  FResource := 'hudcombotextboxstyle';
end;

{ TvxHudComboTrackBar }

constructor TvxHudComboTrackBar.Create(AOwner: TComponent);
begin
  inherited;
  FResource := 'hudcombotextboxstyle';
  FPopup.FResource := 'hudcombopopupstyle';
  FTrackBar.FResource := 'hudtrackbarstyle';
end;

{ TvxTreeViewItem }

constructor TvxTreeViewItem.Create(AOwner: TComponent);
begin
  inherited;
  Position.Point := vgPoint(5000, 5000);
  FAutoTranslate := true;
  TextAlign := vgTextAlignNear;
  Height := 19;
  HitTest := false;
  CanFocused := false;
end;

procedure TvxTreeViewItem.Realign;
begin
  if (TreeView <> nil) and (TreeView.FUpdating > 0) then
    Exit;
  inherited;
end;

procedure TvxTreeViewItem.DragEnd;
begin
  inherited;
  DragLeave;
  if (TreeView <> nil) and (TreeView.FDragItem <> nil) then
  begin
    TreeView.FDragItem.RemoveFreeNotify(TreeView);
    TreeView.FDragItem := nil;
  end;
end;

function TvxTreeViewItem.GetCount: integer;
var
  i: integer;
begin
  Result := 0;
  if ChildrenCount > 0 then
    for i := 0 to ChildrenCount - 1 do
      if Children[i] is TvxTreeViewItem then
      begin
        Inc(Result);
      end;
end;

function TvxTreeViewItem.ItemByPoint(const X, Y: single): TvxTreeViewItem;
var
  i: integer;
  P, P1: TvxPoint;
begin
  P := LocaltoAbsolute(vgPoint(X, Y));
  for i := 0 to Count - 1 do
    with ItemByIndex(i) do
    begin
      if not Visible then
        Continue;
      if pointInObject(P.X, P.Y) then
      begin
        Result := Self.ItemByIndex(i);
        Exit;
      end
      else
        if (Count > 0) and (IsExpanded) then
      begin
        P1 := AbsoluteToLocal(P);
        Result := ItemByPoint(P1.X, P1.Y);
        if Result <> nil then
          Exit;
      end;
    end;
  Result := nil;
end;

function TvxTreeViewItem.ItemByIndex(const Idx: integer): TvxTreeViewItem;
var
  c, i: integer;
begin
  c := 0;
  if ChildrenCount > 0 then
    for i := 0 to ChildrenCount - 1 do
      if Children[i] is TvxTreeViewItem then
      begin
        if c = Idx then
        begin
          Result := TvxTreeViewItem(Children[i]);
          Exit;
        end;
        Inc(c);
      end;
  Result := nil;
end;

procedure TvxTreeViewItem.Paint;
var
  R: TvxRect;
begin
  inherited Paint;
  if Assigned(Scene) and Scene.GetDesignTime and not Locked and not FInPaintTo then
  begin
    R := LocalRect;
    vgInflateRect(R, -0.5, -0.5);
    Canvas.StrokeThickness := 1;
    Canvas.StrokeDash := vgDashDash;
    Canvas.Stroke.Style := vgBrushSolid;
    Canvas.Stroke.SolidColor := $A0909090;
    Canvas.DrawRect(R, 0, 0, AllCorners, AbsoluteOpacity);
    Canvas.StrokeDash := vgDashSolid;
  end;
end;

function TvxTreeViewItem.ItemClass: string;
begin
  Result := ClassName;
end;

procedure TvxTreeViewItem.DesignClick;
begin
  inherited;
  IsExpanded := not IsExpanded;
end;

function TvxTreeViewItem.EnterFocusChildren(AObject: TvxVisualObject): boolean;
begin
  Result := inherited EnterFocusChildren(AObject);
  if (TreeView <> nil) then
  begin
    TreeView.Selected := Self;
    Result := true;
  end;
end;

function TvxTreeViewItem.Level: integer;
var
  P: TvxObject;
begin
  Result := 0;
  P := Parent;
  while (P <> nil) and not (P is TvxTreeView) and not (P is TvxContent) do
  begin
    Result := Result + 1;
    P := P.Parent;
  end;
end;

function TvxTreeViewItem.TreeView: TvxTreeView;
var
  P: TvxObject;
begin
  P := Parent;
  while (P <> nil) do
  begin
    if P is TvxTreeView then
    begin
      Result := TvxTreeView(P);
      Exit;
    end;
    P := P.Parent;
  end;
  Result := nil;
end;

procedure TvxTreeViewItem.FreeStyle;
begin
  inherited;
  FButton := nil;
  FCheck := nil;
end;

procedure TvxTreeViewItem.ApplyStyle;
var
  B: TvxObject;
begin
  inherited;
  B := FindResource('button');
  if (B <> nil) and (B is TvxCustomButton) then
  begin
    FButton := TvxCustomButton(B);
    FButton.OnClick := DoButtonClick;
    FButton.Visible := Count > 0;
    if FButton.Visible then
    begin
      FButton.ApplyResource;
      FButton.StartTriggerAnimation(Self, 'IsExpanded');
    end;
  end;
  B := FindResource('check');
  if (B <> nil) and (B is TvxCheckBox) then
  begin
    FCheck := TvxCheckBox(B);
    FCheck.IsChecked := IsChecked;
    FCheck.OnChange := DoCheckClick;
    if TreeView <> nil then
      FCheck.Visible := TreeView.ShowCheckboxes;
  end;
  StartTriggerAnimation(Self, 'IsSelected');
end;

procedure TvxTreeViewItem.DoCheckClick(Sender: TObject);
begin
  if FCheck <> nil then
    FIsChecked := FCheck.IsChecked;
  if TreeView <> nil then
  begin
    TreeView.SetFocus;
    TreeView.Selected := Self;
    if Assigned(TreeView.OnChangeCheck) then
      TreeView.OnChangeCheck(Self);
  end;
end;

procedure TvxTreeViewItem.UpdateCheck;
var
  i: integer;
begin
  if (TreeView <> nil) and (FCheck <> nil) then
    FCheck.Visible := TreeView.ShowCheckboxes;
  if ChildrenCount > 0 then
    for i := 0 to ChildrenCount - 1 do
      if Children[i] is TvxTreeViewItem then
        TvxTreeViewItem(Children[i]).UpdateCheck;
end;

procedure TvxTreeViewItem.SetIsChecked(const Value: boolean);
begin
  if FIsChecked <> Value then
  begin
    FIsChecked := Value;
    if FCheck <> nil then
      FCheck.IsChecked := FIsChecked;
  end;
end;

procedure TvxTreeViewItem.SetIsSelected(const Value: boolean);
begin
  if FIsSelected <> Value then
  begin
    FIsSelected := Value;
    StartTriggerAnimation(Self, 'IsSelected');
    if Treeview <> nil then
      Treeview.UpdateSelection;
  end;
end;

procedure TvxTreeViewItem.DoButtonClick(Sender: TObject);
begin
  IsExpanded := not IsExpanded;
end;

procedure TvxTreeViewItem.SetIsExpanded(const Value: boolean);
begin
  if FIsExpanded <> Value then
  begin
    FIsExpanded := Value;
    if (FButton <> nil) and not (csLoading in ComponentState) then
    begin
      FButton.Visible := Count > 0;
      if FButton.Visible then
        FButton.StartTriggerAnimation(Self, 'IsExpanded');
    end;
    if TreeView <> nil then
      TreeView.Realign;
  end;
end;

function TvxTreeViewItem.GetItem(Index: integer): TvxTreeViewItem;
begin
  Result := ItemByIndex(Index);
end;

{ TvxTreeView ==================================================================}

constructor TvxTreeView.Create(AOwner: TComponent);
begin
  inherited;
  FGlobalList := TList.Create;
  FGlobalList.Capacity := 100;
  CanFocused := true;
  AutoCapture := true;
  HideSelectionUnfocused := true;
  Width := 100;
  Height := 100;
  FItemHeight := 0;
end;

destructor TvxTreeView.Destroy;
begin
  if FSelections <> nil then
    FreeAndNil(FSelections);
  FreeAndNil(FGlobalList);
  inherited;
end;

procedure TvxTreeView.ApplyStyle;
var
  T: TvxObject;
begin
  inherited;
  T := FindResource('selection');
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    FSelection := TvxVisualObject(T);
    FSelection.Visible := false;
  end;
  if (T <> nil) and (T is TvxVisualObject) then
  begin
    TvxVisualObject(T).Visible := false;
  end;
  UpdateSelection;
end;

procedure TvxTreeView.FreeStyle;
begin
  inherited;
  FSelection := nil;
  if FSelections <> nil then
    FSelections.Clear;
end;

procedure TvxTreeView.UpdateGlobalIndexes;
var
  GlobalIdx: integer;

  procedure AlignItem(AItem: TvxTreeViewItem);
  var
    i: integer;
    P: TvxPoint;
  begin
    AItem.GlobalIndex := GlobalIdx;
    GlobalIdx := GlobalIdx + 1;
    FGlobalList.Add(AItem);
    if AItem.Count > 0 then
    begin
      if AItem.IsExpanded then
        for i := 0 to AItem.Count - 1 do
          AlignItem(AItem.ItemByIndex(i));
    end;
  end;
var
  i: integer;
begin
  FGlobalList.Clear;
  GlobalIdx := 0;
  for i := 0 to Count - 1 do
    AlignItem(ItemByIndex(i));
  FGlobalCount := GlobalIdx;
end;

function CompareTreeItem(item1, item2: TvxObject): integer;
begin
  if (item1 is TvxTreeViewItem) and (item2 is TvxTreeViewItem) then
  begin
    if (TvxTreeViewItem(item1).TreeView <> nil) and Assigned(TvxTreeViewItem(item1).TreeView.OnCompare) then
      Result := TvxTreeViewItem(item1).TreeView.OnCompare(TvxTreeViewItem(item1), TvxTreeViewItem(item2))
    else
      {$IFDEF KS_COMPILER5}
      Result := CompareText(TvxTreeViewItem(item1).Text, TvxTreeViewItem(item2).Text);
    {$ELSE}
      Result := WideCompareText(TvxTreeViewItem(item1).Text, TvxTreeViewItem(item2).Text);
    {$ENDIF}
  end
  else
    Result := 0;
end;

procedure TvxTreeView.SortItems;
begin
  if not FSorted then
    Exit;
  FContent.Sort(CompareTreeItem);
end;

function TvxTreeView.GetItemRect(Item: TvxTreeViewItem): TvxRect;
var
  P: TvxPoint;
begin
  if Item <> nil then
  begin
    P := Item.LocalToAbsolute(vgPoint(0, 0));
    P := FContent.AbsoluteToLocal(P);
    Result := vgRect(0, 0, Item.Width, Item.Height);
    vgOffsetRect(Result, P.X, P.Y);
  end
  else
    Result := vgRect(0, 0, 0, 0);
end;

procedure TvxTreeView.UpdateSelection;
var
  i: integer;
  P: TvxPoint;
  R: TvxRect;
  Sel: boolean;
  SelRects: array of TvxRect;
  Clone: TvxVisualObject;
  Vis: boolean;
begin
  if FSelection = nil then
    Exit;
  // calc rects
  Vis := true;
  Sel := false;
  SetLength(SelRects, 0);
  for i := 0 to GlobalCount - 1 do
  begin
    if (ItemByGlobalIndex(i).IsSelected) then
    begin
      P := ItemByGlobalIndex(i).LocalToAbsolute(vgPoint(0, 0));
      if (FSelection.Parent <> nil) and (FSelection.Parent.IsVisual) then
        P := FSelection.Parent.Visual.AbsoluteToLocal(P);
      R := vgRect(P.X, P.Y, P.X + ItemByGlobalIndex(i).Width, P.Y + ItemByGlobalIndex(i).Height);
      if (Length(SelRects) > 0) and (i > 0) and (ItemByGlobalIndex(i - 1).IsSelected) then
        SelRects[High(SelRects)] := vgUnionRect(R, SelRects[High(SelRects)])
      else
      begin
        SetLength(SelRects, Length(SelRects) + 1);
        SelRects[High(SelRects)] := R;
      end;
      Sel := true;
    end;
  end;
  // Create selection list
  if FSelections = nil then
    FSelections := TList.Create;
  // create selections
  if FSelections.Count < Length(SelRects) then
    for i := FSelections.Count to Length(SelRects) - 1 do
    begin
      Clone := TvxVisualObject(FSelection.Clone(Self));
      FSelections.Add(Clone);
      Clone.Parent := FSelection.Parent;
    end;
  // hide if not need
  if Length(SelRects) < FSelections.Count then
    for i := Length(SelRects) to FSelections.Count - 1 do
    begin
      TvxVisualObject(FSelections[i]).Visible := false;
    end;
  // Check visible
  if HideSelectionUnfocused and not IsFocused then
    Vis := false;
  // align selections
  for i := 0 to High(SelRects) do
  begin
    TvxVisualObject(FSelections[i]).Visible := Vis;
    if Vis then
    begin
      with SelRects[i] do
        TvxVisualObject(FSelections[i]).SetBounds(Left, Top, Right - Left, Bottom - Top);
    end;
  end;
end;

function TvxTreeView.GetContentBounds: TvxRect;
const
  StepX = 19;
var
  CurY, CurX: single;
  R: TvxRect;

  procedure HideItem(AItem: TvxTreeViewItem);
  var
    i: integer;
  begin
    AItem.Visible := false;
    AItem.Opacity := 0;
    if AItem.Count > 0 then
      for i := 0 to AItem.Count - 1 do
        HideItem(AItem.ItemByIndex(i));
  end;

  procedure AlignItem(AItem: TvxTreeViewItem);
  var
    i: integer;
    P: TvxPoint;
  begin
    P := vgPoint(CurX, CurY);
    P := FContent.LocalToAbsolute(P);
    P := AItem.Parent.Visual.AbsoluteToLocal(P);
    if FItemHeight <> 0 then
      AItem.SetBounds(P.X + AItem.Padding.Left, P.Y + AItem.Padding.Top,
        R.Right - R.Left - AItem.Padding.Left - AItem.Padding.Right - (AItem.Level * StepX), FItemHeight)
    else
      AItem.SetBounds(P.X + AItem.Padding.Left, P.Y + AItem.Padding.Top,
        R.Right - R.Left - AItem.Padding.Left - AItem.Padding.Right - (AItem.Level * StepX), AItem.Height);

    if AItem.FButton <> nil then
      AItem.FButton.Visible := AItem.Count > 0;

    CurY := CurY + AItem.Height + AItem.Padding.Top + AItem.Padding.Bottom;

    if AItem.Count > 0 then
    begin
      if AItem.IsExpanded then
      begin
        CurX := CurX + StepX;
        for i := 0 to AItem.Count - 1 do
        begin
          with AItem.ItemByIndex(i) do
          begin
            Visible := true;
            Opacity := 1;
          end;
          AlignItem(AItem.ItemByIndex(i));
        end;
        CurX := CurX - StepX;
      end
      else
      begin
        for i := 0 to AItem.Count - 1 do
          HideItem(AItem.ItemByIndex(i));
      end;
    end;
  end;
var
  i: integer;
  C: integer;
  P: TvxPoint;
  Sel: TvxTreeViewItem;
begin
  Result := LocalRect;
  UpdateGlobalIndexes;
  if FUpdating > 0 then
    Exit;
  if ContentLayout = nil then
    Exit;
  R := ContentLayout.LocalRect;
  { content }
  FCountExpanded := 0;
  if FContent <> nil then
  begin
    { Sort if need }
    SortItems;
    { align }
    CurY := 0;
    CurX := 0;
    for i := 0 to Count - 1 do
      AlignItem(ItemByIndex(i));
    R.Bottom := R.Top + CurY;
  end;
  if R.Bottom = R.Top then
    R.Bottom := R.Top + 1;
  Result := R;
  UpdateSelection;
end;

procedure TvxTreeView.HScrollChange(Sender: TObject);
begin
  inherited;
  UpdateSelection;
end;

procedure TvxTreeView.VScrollChange(Sender: TObject);
begin
  inherited;
  UpdateSelection;
end;

function TvxTreeView.ItemByIndex(const Idx: integer): TvxTreeViewItem;
begin
  if (FContent <> nil) and (FContent.ChildrenCount > 0) and (Idx >= 0) and (Idx < FContent.ChildrenCount) then
    Result := TvxTreeViewItem(FContent.Children[Idx])
  else
    Result := nil;
end;

function TvxTreeView.ItemByGlobalIndex(const Idx: integer): TvxTreeViewItem;
begin
  Result := TvxTreeViewItem(FGlobalList[Idx]);
end;

function TvxTreeView.ItemByPoint(const X, Y: single): TvxTreeViewItem;
var
  i: integer;
  P, P1: TvxPoint;
begin
  P := LocalToAbsolute(vgPoint(X, Y));
  if (FContent <> nil) and (FContent.ChildrenCount > 0) then
    for i := 0 to FContent.ChildrenCount - 1 do
      if FContent.Children[i] is TvxTreeViewItem then
      begin
        if not TvxTreeViewItem(FContent.Children[i]).Visible then
          Continue;
        if not vgIntersectRect(TvxTreeViewItem(FContent.Children[i]).UpdateRect, UpdateRect) then
          Continue;
        if TvxTreeViewItem(FContent.Children[i]).pointInObject(P.X, P.Y) then
        begin
          Result := TvxTreeViewItem(FContent.Children[i]);
          Exit;
        end
        else
          if (TvxTreeViewItem(FContent.Children[i]).IsExpanded) and (TvxTreeViewItem(FContent.Children[i]).Count > 0) then
        begin
          P1 := TvxTreeViewItem(FContent.Children[i]).AbsoluteToLocal(P);
          Result := TvxTreeViewItem(FContent.Children[i]).ItemByPoint(P1.X, P1.Y);
          if Result <> nil then
            Exit;
        end;
      end;
  Result := nil;
end;

procedure TvxTreeView.KeyDown(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
  if (Count > 0) and (Selected <> nil) then
  begin
    case Key of
      VK_ADD: Selected.IsExpanded := true;
      VK_SUBTRACT: Selected.IsExpanded := false;
      VK_HOME: Selected := ItemByGlobalIndex(0);
      VK_END: Selected := ItemByGlobalIndex(GlobalCount - 1);
      VK_UP:
        if Selected.GlobalIndex > 0 then
          Selected := ItemByGlobalIndex(Selected.GlobalIndex - 1);
      VK_DOWN:
        if Selected.GlobalIndex < GlobalCount - 1 then
          Selected := ItemByGlobalIndex(Selected.GlobalIndex + 1);
    else
      Exit;
    end;
    Key := 0;
  end;
end;

procedure TvxTreeView.KeyUp(var Key: Word; var KeyChar: System.WideChar;
  Shift: TShiftState);
begin
  inherited;
end;

procedure TvxTreeView.DragOver(const Data: TvxDragObject;
  const Point: TvxPoint; var Accept: Boolean);
var
  Obj: TvxTreeViewItem;
begin
  inherited;
  with AbsoluteToLocal(Point) do
    Obj := ItemByPoint(X, Y);
  if (Obj <> FDragItem) then
  begin
    if FDragItem <> nil then
    begin
      FDragItem.DragLeave;
      FDragItem.RemoveFreeNotify(Self);
    end;
    FDragItem := Obj;
    if FDragItem <> nil then
    begin
      FDragItem.AddFreeNotify(Self);
      FDragItem.DragEnter(Data, Point);
      Accept := true;
    end
    else
      Accept := false;
  end
  else
    Accept := true;

  if FDragItem = Selected then
    Accept := false;
end;

procedure TvxTreeView.DragDrop(const Data: TvxDragObject;
  const Point: TvxPoint);
var
  Obj: TvxTreeViewItem;
  Allow: boolean;
begin
  inherited;
  if FDragItem <> nil then
  begin
    FDragItem.DragLeave;
    FDragItem.RemoveFreeNotify(Self);
    FDragItem := nil;
  end;
  with AbsoluteToLocal(Point) do
    Obj := ItemByPoint(X, Y);
  if Obj = nil then
  begin
    // to root
    Allow := true;
    if Assigned(OnDragChange) then
      OnDragChange(TvxTreeViewItem(Data.Source), nil, Allow);
    if Allow then
    begin
      TvxTreeViewItem(Data.Source).Parent := Self;
      Realign;
    end;
  end
  else
  begin
    Allow := true;
    if Assigned(OnDragChange) then
      OnDragChange(TvxTreeViewItem(Data.Source), Obj, Allow);
    if Allow then
    begin
      if not Obj.IsExpanded then
        Obj.IsExpanded := true;
      TvxTreeViewItem(Data.Source).Parent := Obj;
      Realign;
    end;
  end;
end;

procedure TvxTreeView.MouseDown(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
var
  Item: TvxTreeViewItem;
begin
  inherited;
  if Button = mbLeft then
  begin
    Item := ItemByPoint(X, Y);
    if Item <> nil then
    begin
      if Multiselect then
      begin
        if ssCtrl in Shift then
          Item.IsSelected := not Item.IsSelected
        else
          if ssShift in Shift then
        begin
          SelectRange(Selected, Item);
          Selected := Item;
        end
        else
        begin
          SelectRange(Item, Item);
          Selected := Item;
        end;
        FFirstSelect := Item;
      end
      else
      begin
        if Selected <> Item then
          Selected := Item
        else
          if AllowDrag then
          Scene.BeginVCLDrag(Selected, MakeScreenshot);
      end;
    end;
    FMouseSelecting := true;
  end;
end;

procedure TvxTreeView.MouseMove(Shift: TShiftState; X, Y, Dx, Dy: single);
begin
  inherited;
end;

procedure TvxTreeView.MouseUp(Button: TMouseButton; Shift: TShiftState; X,
  Y: single);
begin
  inherited;
  FFirstSelect := nil;
  FMouseSelecting := false;
end;

procedure TvxTreeView.Clear;
var
  i: integer;
begin
  BeginUpdate;
  if FContent <> nil then
    if FContent.ChildrenCount > 0 then
      for i := FContent.ChildrenCount - 1 downto 0 do
        if FContent.Children[i] is TvxTreeViewItem then
          TvxObject(FContent.Children[i]).Free;
  FScrollDesign.Y := 0;
  FScrollDesign.X := 0;
  FSelected := nil;
  UpdateGlobalIndexes;
  UpdateSelection;
  EndUpdate;
end;

procedure TvxTreeView.SelectRange(Item1, Item2: TvxTreeViewItem);
var
  i: integer;
begin
  if Item1 = nil then
    Exit;
  if Item2 = nil then
    Exit;
  for i := 0 to Min(Item1.GlobalIndex, Item2.GlobalIndex) - 1 do
    ItemByGlobalIndex(i).IsSelected := false;
  for i := Max(Item1.GlobalIndex, Item2.GlobalIndex) + 1 to GlobalCount - 1 do
    ItemByGlobalIndex(i).IsSelected := false;
  for i := Min(Item1.GlobalIndex, Item2.GlobalIndex) to Max(Item1.GlobalIndex, Item2.GlobalIndex) do
    ItemByGlobalIndex(i).IsSelected := true;
end;

procedure TvxTreeView.ClearSelection;
var
  i: integer;
begin
  for i := 0 to GlobalCount - 1 do
    ItemByGlobalIndex(i).IsSelected := false;
end;

procedure TvxTreeView.SelectAll;
var
  i: integer;
begin
  for i := 0 to GlobalCount - 1 do
    ItemByGlobalIndex(i).IsSelected := true;
end;

procedure TvxTreeView.EnterFocus;
begin
  inherited;
  if HideSelectionUnfocused and (Selected <> nil) then
    UpdateSelection;
end;

procedure TvxTreeView.KillFocus;
begin
  inherited;
  if HideSelectionUnfocused and (Selected <> nil) then
    UpdateSelection;
end;

procedure TvxTreeView.AddObject(AObject: TvxObject);
begin
  if (FContent <> nil) and ((AObject is TvxTreeViewItem) or (AObject is TvxSelectionItem)) then
  begin
    FContent.AddObject(AObject);
  end
  else
    inherited;
end;

procedure TvxTreeViewItem.AddObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxTreeViewItem then
    if FUpdating = 0 then
    begin
      TreeView.UpdateGlobalIndexes;
      TreeView.Realign;
    end;
end;

procedure TvxTreeViewItem.RemoveObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxTreeViewItem then
  begin
    TvxTreeViewItem(AObject).IsSelected := false;
    if FUpdating = 0 then
    begin
      TreeView.UpdateGlobalIndexes;
      TreeView.Realign;
    end;
  end;
end;

procedure TvxTreeView.ContentAddObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxTreeViewItem then
    if FUpdating = 0 then
    begin
      UpdateGlobalIndexes;
      Realign;
    end;
end;

procedure TvxTreeView.ContentRemoveObject(AObject: TvxObject);
begin
  inherited;
  if AObject is TvxTreeViewItem then
  begin
    TvxTreeViewItem(AObject).IsSelected := false;
    if FUpdating = 0 then
    begin
      UpdateGlobalIndexes;
      Realign;
    end;
  end;
end;

procedure TvxTreeView.SetSelected(const Value: TvxTreeViewItem);
var
  i: TvxObject;
  P: TvxPoint;
begin
  if FSelected <> Value then
  begin
    if (FSelected <> nil) and not MultiSelect then
      FSelected.IsSelected := false;

    FSelected := Value;
    if (FSelected <> nil) and (FContent <> nil) then
    begin
      i := FSelected.Parent;
      while ((i <> nil) and not (i is TvxTreeView)) do
      begin
        if (i is TvxTreeViewItem) then
          TvxTreeViewItem(i).IsExpanded := true;
        i := i.Parent;
      end;
      if (FContent <> nil) and (ContentLayout <> nil) and (VScrollBar <> nil) then
      begin
        P := ContentLayout.AbsoluteToLocal(FSelected.LocalToAbsolute(vgPoint(0, 0)));
        if P.Y < 0 then
          VScrollBar.Value := VScrollBar.Value + P.Y;
        if P.Y + FSelected.Padding.Top + FSelected.Padding.Bottom + FSelected.Height > ContentLayout.Height then
          VScrollBar.Value := VScrollBar.Value + (P.Y + FSelected.Padding.Top + FSelected.Padding.Bottom + FSelected.Height - ContentLayout.Height);
      end;
      FSelected.IsSelected := true;
    end;
    if Assigned(FOnChange) then
      FOnChange(Self);
  end;
end;

procedure TvxTreeView.Notification(AComponent: TComponent;
  Operation: TOperation);
begin
  inherited;
  if (Operation = opRemove) and (AComponent = FSelected) then
    FSelected := nil;
  if (Operation = opRemove) and (AComponent = FDragItem) then
    FDragItem := nil;
end;

function TvxTreeView.ItemClass: string;
begin
  Result := 'TvxTreeViewItem';
end;

procedure TvxTreeView.SetItemHeight(const Value: single);
begin
  if FItemHeight <> Value then
  begin
    FItemHeight := Value;
    Realign;
  end;
end;

procedure TvxTreeView.CollapseAll;
var
  i: integer;
  item: TvxTreeViewItem;
begin
  BeginUpdate;
  for i := 0 to Count - 1 do
  begin
    item := ItemByIndex(i);
    if item <> nil then
      item.IsExpanded := false;
  end;
  EndUpdate;
end;

procedure TvxTreeView.ExpandAll;
var
  i: integer;
  item: TvxTreeViewItem;
begin
  BeginUpdate;
  for i := 0 to Count - 1 do
  begin
    item := ItemByIndex(i);
    if item <> nil then
      item.IsExpanded := true;
  end;
  EndUpdate;
end;

function TvxTreeView.GetSelection: TvxSelectionItem;
var
  B: TvxObject;
begin
  B := FindResource('selection');
  if (B <> nil) and (B is TvxSelectionItem) then
    Result := TvxSelectionItem(B)
  else
    Result := nil;
end;

procedure TvxTreeView.SetShowCheckboxes(const Value: boolean);
var
  i: integer;
begin
  if FShowCheckboxes <> Value then
  begin
    FShowCheckboxes := Value;
    for i := 0 to Count - 1 do
      if ItemByIndex(i) <> nil then
        ItemByIndex(i).UpdateCheck;
  end;
end;

function TvxTreeView.GetItem(Index: integer): TvxTreeViewItem;
begin
  Result := ItemByIndex(Index);
end;

procedure TvxTreeView.SetSorted(const Value: boolean);
begin
  if FSorted <> Value then
  begin
    FSorted := Value;
    Realign;
  end;
end;

procedure TvxTreeView.SetAllowDrag(const Value: boolean);
begin
  if FAllowDrag <> Value then
  begin
    FAllowDrag := Value;
    if FAllowDrag then
      DragDisableHighlight := true;
  end;
end;

procedure TvxTreeView.EndUpdate;
begin
  inherited;
end;

function TvxTreeView.GetCount: integer;
begin
  Result := 0;
  if (FContent <> nil) then
    Result := FContent.ChildrenCount;
end;

initialization
  {$IFDEF DARWIN}
  SetExceptionMask([exInvalidOp, exDenormalized, exZeroDivide, exOverflow, exUnderflow, exPrecision]);
  {$ENDIF}
  RegisterClasses([TvxBitmap, TvxPathData, TvxBrush, TvxBounds, TvxPosition, TvxGradient, TvxGradientPoints, TvxGradientPoint, TvxVisual]);
  RegisterClasses([TvxResources, TvxObject, TvxContent, TvxControl]);
  RegisterClasses([TvxWideStrings, TvxWideStringList]);
  RegisterVGObjects('Resources', [TvxBrushObject, TvxPathObject, TvxBitmapObject]);
  {$IFDEF VgSceneTrial}
  ShowVersion2;
  {$ENDIF}

  {$IFNDEF NOVCL}
  {$IFDEF WINDOWS}
  User32Lib := LoadLibrary(User32);
  if User32Lib <> 0 then
  begin
    @SetLayeredWindowAttributes := GetProcAddress(User32Lib, 'SetLayeredWindowAttributes');
    @UpdateLayeredWindow := GetProcAddress(User32Lib, 'UpdateLayeredWindow');
    @PrintWindow := GetProcAddress(User32Lib, 'PrintWindow');
  end;
  OleInitialize(nil);
  {$ENDIF}
  RegisterClasses([TvxCustomScene]);
  RegisterVGObjects('Layout', [TvxFrame]);
  {$ENDIF}
  RegisterVGObjects('Popup', [TvxPopup, {TvxPopupItem, } TvxMessagePopup]);

  RegisterVGObjects('Animations', [TvxColorAnimation, TvxGradientAnimation, TvxFloatAnimation, TvxRectAnimation, TvxBitmapAnimation, TvxBitmapListAnimation,
    TvxColorKeyAnimation, TvxFloatKeyAnimation, TvxPathAnimation, TvxPathSwitcher]);

  RegisterVGObjects('Effects', [TvxShadowEffect, TvxBlurEffect, TvxGlowEffect, TvxInnerGlowEffect,
    TvxBevelEffect, TvxReflectionEffect]);

  RegisterVGObjects('Shapes', [TvxLine, TvxRectangle, TvxSidesRectangle, TvxBlurRectangle, TvxRoundRect, TvxBlurRoundRect, TvxEllipse, TvxCircle, TvxArc, TvxPie, TvxText, TvxPath, TvxImage, TvxPaintBox]);
  RegisterVGObjects('Shapes', [TvxScrollArrowLeft, TvxScrollArrowRight]);
  RegisterVGObjects('Shapes', [TvxCalloutRectangle]);
  RegisterVGObjects('Design', [TvxSelection, TvxSelectionPoint, TvxDesignFrame]);

  RegisterClasses([TvxSelectionItem, TvxThumb, TvxExpanderButton]);
  RegisterVGObjects('Windows', [TvxBackground, TvxSizeGrip, TvxCloseButton]);
  RegisterVGObjects('Boxes', [TvxCheckBox, TvxPathCheckBox, TvxRadioButton, TvxGroupBox,
    TvxPopupBox]);
  RegisterVGObjects('Controls', [TvxPanel, TvxCalloutPanel, TvxLabel, TvxValueLabel,
    TvxImageControl, TvxProgressBar, TvxTrack, TvxScrollBar, TvxSmallScrollBar, TvxAniIndicator,
      TvxExpander, TvxTrackBar, TvxSplitter]);
  RegisterVGObjects('Tool and Status', [TvxStatusBar, TvxToolBar, TvxToolButton, TvxToolPathButton]);
  RegisterVGObjects('Buttons', [TvxButton, TvxRoundButton, TvxCircleButton, TvxBitmapButton, TvxPathButton, TvxSpeedButton, TvxCornerButton,
    TvxColorButton, TvxAngleButton, TvxBitmapStateButton, TvxPopupButton]);
  RegisterVGObjects('HUD', [TvxHudPanel, TvxHudWindow, TvxHudButton, TvxHudSpeedButton, TvxHudAngleButton, TvxHudTrack, TvxHudTrackBar,
    TvxHudScrollBar, TvxHudPopupBox, TvxHudLabel, TvxHudCheckBox, TvxHudRadioButton, TvxHudGroupBox, TvxHudCloseButton,
      TvxHudStatusBar, TvxHudSizeGrip, TvxHudRoundButton, TvxHudCornerButton, TvxHudCircleButton]);

  RegisterVGObjects('Layout', [TvxLayout, TvxScaledLayout, TvxGridLayout, TvxSplitLayout]);
  {$IFNDEF NOVCL}
  RegisterVGObjects('Layout', [TvxNonVGLayout]);
  {$ENDIF}
  RegisterVGObjects('Controls', [TvxScrollBox, TvxVertScrollBox, TvxFramedScrollBox, TvxFramedVertScrollBox]);

  RegisterVGObjects('Lists', [TvxListBox, TvxComboBox, TvxStringListBox, TvxStringComboBox, TvxHorzListBox]);
  RegisterVGObjects('Lists', [TvxImageListBox, TvxHorzImageListBox]);
  RegisterVGObjects('Items', [TvxListBoxItem]);
  RegisterVGObjects('Items', [TvxImageListBoxItem]);
  RegisterVGObjects('HUD', [TvxHudListBox, TvxHudHorzListBox, TvxHudComboBox, TvxHudStringListBox, TvxHudStringComboBox]);
  RegisterVGObjects('HUD', [TvxHudImageListBox, TvxHudHorzImageListBox]);

  RegisterVGObjects('Trees', [TvxTreeView]);
  RegisterVGObjects('Items', [TvxTreeViewItem]);

  RegisterVGObjects('Text Edits', [TvxTextBox, TvxRoundTextBox, TvxNumberBox, TvxSpinBox, TvxComboTextBox, TvxComboTrackBar, TvxTextBoxClearBtn]);
  RegisterVGObjects('HUD', [TvxHudTextBox, TvxHudNumberBox, TvxHudRoundTextBox, TvxHudSpinBox, TvxHudComboTextBox, TvxHudComboTrackBar]);

  RegisterVGObjects('Text Edits', [TvxMemo]);
  RegisterVGObjects('HUD', [TvxHudMemo]);

  RegisterVGObjects('Colors', [TvxHueTrackBar, TvxAlphaTrackBar, TvxBWTrackBar, TvxColorQuad, TvxColorPicker, TvxGradientEdit, TvxColorBox, TvxColorPanel, TvxComboColorBox]);
  RegisterVGObjects('HUD', [TvxHudHueTrackBar, TvxHudAlphaTrackBar, TvxHudBWTrackBar, TvxHudComboColorBox]);

  RegisterVGObjects('Controls', [TvxTabControl]);
  RegisterVGObjects('HUD', [TvxHudTabControl]);
  RegisterVGObjects('Items', [TvxTabItem, TvxHudTabItem]);

  RegisterVGObjects('Ext. Controls', [TvxIPhoneButton, {TvxDockBar, } TvxDropTarget, TvxImageViewer, TvxDicomView, TvxDicomToolBar]);
  RegisterVGObjects('Math', [TvxPlotGrid]);
  RegisterVGObjects('Compound', [TvxCompoundTrackBar, TvxCompoundAngleBar, TvxCompoundTextBox,
    TvxCompoundMemo, TvxCompoundNumberBox, TvxCompoundPopupBox, TvxCompoundColorButton,
      TvxCompoundImage, TvxCalendar]);
  RegisterVGObjects('Boxes', [TvxCalendarBox]);
  RegisterVGObjects('Text Edits', [TvxCalendarTextBox]);

  //RegisterVGObjects('Design', [TvxInspector]);

  {$IFDEF LINUX}
  DefaultCanvasClass := TvxCanvasCairo;
  DefaultFilterClass := TvxFilterGtk;
  {$ENDIF}

  {$IFDEF WINDOWS}
  LoadD2D;
  {$ENDIF}

  {$IFDEF WINDOWS}
  DefaultFilterClass := TvxFilterGdiPlus;
  if DefaultCanvasClass = nil then
    DefaultCanvasClass := TvxCanvasGdiPlus;
  DefaultPrinterCanvasClass := TvxCanvasGdiPlus;
  {$IFNDEF vg_no_init_gdip}
  InitGDIP;
  {$ENDIF}
  {$ENDIF}

  {$IFDEF DARWIN}
  DefaultCanvasClass := TvxCanvasQuartz;
  DefaultFilterClass := TvxFilterQuartz;
  {$ENDIF}

  RegisterClasses([TvxTextCell, TvxCheckCell, TvxProgressCell, TvxPopupCell, TvxStringColumn]);
  RegisterVGObjects('Grid', [TvxGrid, TvxStringGrid, TvxHeader]);
  RegisterVGObjects('Grid Columns', [TvxColumn, TvxCheckColumn, TvxProgressColumn, TvxPopupColumn, TvxImageColumn]);
  RegisterVGObjects('Items', [TvxHeaderItem]);

finalization
  {$IFDEF WINDOWS}
  FreeD2D;
  {$ENDIF}

  {$IFDEF WINDOWS}
  {$IFNDEF vg_no_free_gdip}
  FreeGDIP;
  {$ENDIF}
  {$ENDIF}

  {$IFNDEF NOVCL}
  {$IFDEF WINDOWS}
  if User32Lib <> 0 then
    FreeLibrary(User32Lib);
  {$ENDIF}
  {$ENDIF}
  if PopupList <> nil then
    FreeAndNil(PopupList);
  if aniThread <> nil then
    FreeAndNil(aniThread);
  if DefaultStyles <> nil then
    FreeAndNil(DefaultStyles);
  if ObjectList <> nil then
    FreeAndNil(ObjectList);
  if ResourceList <> nil then
    FreeAndNil(ResourceList);
  if CollectLang <> nil then
    FreeAndNil(CollectLang);
  if Lang <> nil then
    FreeAndNil(Lang);
  if SceneList <> nil then
    FreeAndNil(SceneList);

end.

